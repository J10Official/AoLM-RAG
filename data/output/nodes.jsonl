{"id": "stream_economics_mathematicsstatistics_management_sciences", "type": "V_stream", "name": "Economics, Mathematics/Statistics, Management Sciences", "properties": {"slug": "economics_mathematicsstatistics_management_sciences"}}
{"id": "stream_computer_science_and_engineering", "type": "V_stream", "name": "Computer Science and Engineering", "properties": {"slug": "computer_science_and_engineering"}}
{"id": "course_106108840", "type": "V_course", "name": "Foundations of Deep Learning: Concepts and Applications", "properties": {"course_id": "noc26-cs01", "nptel_url": "https://nptel.ac.in/courses/106108840", "nptel_id": "106108840", "abstract": "NOC: Foundations of Deep Learning: Concepts and Applications, IISc Bangalore RV University\nProf. Sriram Ganapathy Prof. Ashwini Kodipalli Prof. Baishali Garai Course Duration :\nJan-Apr 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-04-25\nCourse Abstract\n\n1.Deep Learning is a core pillar of modern Artificial Intelligence, powering applications in computer vision, natural language processing, healthcare, and robotics.\n\n2.With the rapid expansion of AI-related programs in AICTE-affiliated institutions, it's essential for students to build a strong foundation in this field.\n\n3.This course is designed to guide learners step-by-step\u2014from the basics of neural networks to advanced architectures like CNNs, RNNs, and Autoencoders.\n\n4.Emphasis is placed on both conceptual clarity and practical implementation using Python and Google Colab.\n\n5.By the end of the course, students will be able to apply deep learning algorithms on real-world data to develop intelligent solutions. Course Duration :\nJan-Apr 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-04-25", "professor": "Prof. Sriram Ganapathy\nProf. Ashwini Kodipalli\nProf. Baishali Garai", "institute": "IISc Bangalore\nRV University", "duration": "12 Weeks", "stream_id": "stream_computer_science_and_engineering"}}
{"id": "lecture_106108840_w1_l1", "type": "V_lecture", "name": "Overview of Machine Learning and Deep Learning", "properties": {"week": 1, "lecture_num": 1, "youtube_url": "https://www.youtube.com/watch?v=SThBzCPRmYg", "course_id": "course_106108840"}}
{"id": "lecture_106108840_w1_l2", "type": "V_lecture", "name": "Single Layer Perceptron", "properties": {"week": 1, "lecture_num": 2, "youtube_url": "https://www.youtube.com/watch?v=jc4RlxP_NXI", "course_id": "course_106108840"}}
{"id": "lecture_106108840_w1_l3", "type": "V_lecture", "name": "Hands-on on Single Layer Perceptron", "properties": {"week": 1, "lecture_num": 3, "youtube_url": "https://www.youtube.com/watch?v=EflKDIKydOo", "course_id": "course_106108840"}}
{"id": "lecture_106108840_w1_l4", "type": "V_lecture", "name": "Multi-Layer Perceptron", "properties": {"week": 1, "lecture_num": 4, "youtube_url": "https://www.youtube.com/watch?v=GPf6W8LqmIg", "course_id": "course_106108840"}}
{"id": "lecture_106108840_w1_l5", "type": "V_lecture", "name": "Activation and Loss Functions", "properties": {"week": 1, "lecture_num": 5, "youtube_url": "https://www.youtube.com/watch?v=O17GdLARCDs", "course_id": "course_106108840"}}
{"id": "lecture_106108840_w1_l6", "type": "V_lecture", "name": "Gradient descent algorithm", "properties": {"week": 1, "lecture_num": 6, "youtube_url": "https://www.youtube.com/watch?v=_U8p3wNRXpE", "course_id": "course_106108840"}}
{"id": "lecture_106108840_w1_l7", "type": "V_lecture", "name": "Backpropagation in Neural Network", "properties": {"week": 1, "lecture_num": 7, "youtube_url": "https://www.youtube.com/watch?v=7Bxdusdst64", "course_id": "course_106108840"}}
{"id": "lecture_106108840_w2_l8", "type": "V_lecture", "name": "Varients of Gradient descent and Momentum based techniques", "properties": {"week": 2, "lecture_num": 8, "youtube_url": "https://www.youtube.com/watch?v=0_gkxWxOZX0", "course_id": "course_106108840"}}
{"id": "lecture_106108840_w2_l9", "type": "V_lecture", "name": "Regularization techniques in Neural Networks", "properties": {"week": 2, "lecture_num": 9, "youtube_url": "https://www.youtube.com/watch?v=94KhsJW8Ck8", "course_id": "course_106108840"}}
{"id": "lecture_106108840_w2_l10", "type": "V_lecture", "name": "Hands-on on MLP for classification problem", "properties": {"week": 2, "lecture_num": 10, "youtube_url": "https://www.youtube.com/watch?v=ULmTPyWJXbc", "course_id": "course_106108840"}}
{"id": "lecture_106108840_w2_l11", "type": "V_lecture", "name": "Fundamentals of Image representation and Image preprocessing and Data augmentation", "properties": {"week": 2, "lecture_num": 11, "youtube_url": "https://www.youtube.com/watch?v=tKifuG-N0iA", "course_id": "course_106108840"}}
{"id": "lecture_106108840_w2_l12", "type": "V_lecture", "name": "Introduction to Convolutional Neural Networks, Inspiration behind CNN, Key Components of CNN", "properties": {"week": 2, "lecture_num": 12, "youtube_url": "https://www.youtube.com/watch?v=lFAuMdxuD2E", "course_id": "course_106108840"}}
{"id": "lecture_106108840_w2_l13", "type": "V_lecture", "name": "Convolution for RGB, Pooling Layer and Flatten Layer", "properties": {"week": 2, "lecture_num": 13, "youtube_url": "https://www.youtube.com/watch?v=86qAMgY95_Q", "course_id": "course_106108840"}}
{"id": "lecture_106108840_w2_l14", "type": "V_lecture", "name": "Batch Normalization", "properties": {"week": 2, "lecture_num": 14, "youtube_url": "https://www.youtube.com/watch?v=Eme6OxdaRiY", "course_id": "course_106108840"}}
{"id": "lecture_106108840_w3_l15", "type": "V_lecture", "name": "Hands-on session on building simple CNN model", "properties": {"week": 3, "lecture_num": 15, "youtube_url": "https://www.youtube.com/watch?v=FDb3SWMGkow", "course_id": "course_106108840"}}
{"id": "lecture_106108840_w3_l16", "type": "V_lecture", "name": "Architecture and Implementation of AlexNet", "properties": {"week": 3, "lecture_num": 16, "youtube_url": "https://www.youtube.com/watch?v=eYM2IpGTp8k", "course_id": "course_106108840"}}
{"id": "lecture_106108840_w3_l17", "type": "V_lecture", "name": "VGGNet (VGG16 and VGG19) and GoogleNet", "properties": {"week": 3, "lecture_num": 17, "youtube_url": "https://www.youtube.com/watch?v=MK_Ufs6PpOg", "course_id": "course_106108840"}}
{"id": "lecture_106108840_w3_l18", "type": "V_lecture", "name": "Introduction to ResNet (ResNet 34 and ResNet50)", "properties": {"week": 3, "lecture_num": 18, "youtube_url": "https://www.youtube.com/watch?v=dKNTvLwxVUQ", "course_id": "course_106108840"}}
{"id": "lecture_106108840_w3_l19", "type": "V_lecture", "name": "Introduction to Transfer Learning", "properties": {"week": 3, "lecture_num": 19, "youtube_url": "https://www.youtube.com/watch?v=fYweCC7tf3o", "course_id": "course_106108840"}}
{"id": "lecture_106108840_w3_l20", "type": "V_lecture", "name": "Hands-on on standard CNN architectures and transfer learning", "properties": {"week": 3, "lecture_num": 20, "youtube_url": "https://www.youtube.com/watch?v=0Ruv8MGZsOQ", "course_id": "course_106108840"}}
{"id": "lecture_106108840_w3_l21", "type": "V_lecture", "name": "Hands-on on building and deep CNN ensemble model.", "properties": {"week": 3, "lecture_num": 21, "youtube_url": "https://www.youtube.com/watch?v=61wMNx8OJns", "course_id": "course_106108840"}}
{"id": "course_106108841", "type": "V_course", "name": "Mathematical Foundations of Machine Learning", "properties": {"course_id": "noc26-cs02", "nptel_url": "https://nptel.ac.in/courses/106108841", "nptel_id": "106108841", "abstract": "NOC: Mathematical Foundations of Machine Learning, IISc Bangalore\nProf. Prathosh A P Course Duration :\nJan-Apr 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-04-25\nCourse Abstract\n\nThis course introduces the mathematical foundations of machine learning, covering risk minimization, density estimation, regularization, and generalization. Students learn classical methods such as linear models, kernel machines, SVMs, decision trees, and ensemble techniques, as well as modern deep learning approaches including MLPs, CNNs, RNNs, and Transformers. Probabilistic models, clustering, PCA, and the EM algorithm are presented to build a solid grounding in unsupervised learning. The course concludes with an introduction to generative models (GANs, VAEs) as a bridge to advanced topics. Emphasis is placed on both theory and practice, with coding assignments connecting math to real-world ML applications. Course Duration :\nJan-Apr 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-04-25", "professor": "Prof. Prathosh A P", "institute": "IISc Bangalore", "duration": "12 weeks", "stream_id": "stream_computer_science_and_engineering"}}
{"id": "lecture_106108841_w1_l1", "type": "V_lecture", "name": "Overview of Function Approximation", "properties": {"week": 1, "lecture_num": 1, "youtube_url": "https://www.youtube.com/watch?v=G2h7nD_Stxg", "course_id": "course_106108841"}}
{"id": "lecture_106108841_w1_l2", "type": "V_lecture", "name": "Recap of Probability Theory - 1, Part 1", "properties": {"week": 1, "lecture_num": 2, "youtube_url": "https://www.youtube.com/watch?v=YLx3hBqt28k", "course_id": "course_106108841"}}
{"id": "lecture_106108841_w1_l3", "type": "V_lecture", "name": "Recap of Probability Theory - 1, Part 2", "properties": {"week": 1, "lecture_num": 3, "youtube_url": "https://www.youtube.com/watch?v=DaBw9qBpt2s", "course_id": "course_106108841"}}
{"id": "lecture_106108841_w1_l4", "type": "V_lecture", "name": "Recap of Probability Theory - 1, Part 3", "properties": {"week": 1, "lecture_num": 4, "youtube_url": "https://www.youtube.com/watch?v=0R6Agp4tqSU", "course_id": "course_106108841"}}
{"id": "lecture_106108841_w1_l5", "type": "V_lecture", "name": "Recap of Probability Theory Part 2", "properties": {"week": 1, "lecture_num": 5, "youtube_url": "https://www.youtube.com/watch?v=R69wew8RrPo", "course_id": "course_106108841"}}
{"id": "lecture_106108841_w1_l6", "type": "V_lecture", "name": "Understanding a Chest X-Ray  as Sample from Distribution", "properties": {"week": 1, "lecture_num": 6, "youtube_url": "https://www.youtube.com/watch?v=bdcvsSNAHIk", "course_id": "course_106108841"}}
{"id": "lecture_106108841_w1_l7", "type": "V_lecture", "name": "IID Assumption", "properties": {"week": 1, "lecture_num": 7, "youtube_url": "https://www.youtube.com/watch?v=C83xmx80tMo", "course_id": "course_106108841"}}
{"id": "lecture_106108841_w2_l8", "type": "V_lecture", "name": "Distribution Estimation", "properties": {"week": 2, "lecture_num": 8, "youtube_url": "https://www.youtube.com/watch?v=aYb8KG9JYsg", "course_id": "course_106108841"}}
{"id": "lecture_106108841_w2_l9", "type": "V_lecture", "name": "Density Function", "properties": {"week": 2, "lecture_num": 9, "youtube_url": "https://www.youtube.com/watch?v=_QrezNPmxDk", "course_id": "course_106108841"}}
{"id": "lecture_106108841_w2_l10", "type": "V_lecture", "name": "Challenge With ML", "properties": {"week": 2, "lecture_num": 10, "youtube_url": "https://www.youtube.com/watch?v=767MLwniPKE", "course_id": "course_106108841"}}
{"id": "lecture_106108841_w2_l11", "type": "V_lecture", "name": "Tutorial 1 : Introduction to Python Basics", "properties": {"week": 2, "lecture_num": 11, "youtube_url": "https://www.youtube.com/watch?v=cF025BechXo", "course_id": "course_106108841"}}
{"id": "lecture_106108841_w2_l12", "type": "V_lecture", "name": "Tutorial 2 : Simple Problem solving in Probability Theory", "properties": {"week": 2, "lecture_num": 12, "youtube_url": "https://www.youtube.com/watch?v=nGwjqvLHguA", "course_id": "course_106108841"}}
{"id": "lecture_106108841_w2_l13", "type": "V_lecture", "name": "Entropy", "properties": {"week": 2, "lecture_num": 13, "youtube_url": "https://www.youtube.com/watch?v=P6wjLz4dRTs", "course_id": "course_106108841"}}
{"id": "lecture_106108841_w2_l14", "type": "V_lecture", "name": "Kullback-Leibler (KL) Divergence", "properties": {"week": 2, "lecture_num": 14, "youtube_url": "https://www.youtube.com/watch?v=ihkGbIdbbxc", "course_id": "course_106108841"}}
{"id": "lecture_106108841_w3_l15", "type": "V_lecture", "name": "Minimization of KL Divergence", "properties": {"week": 3, "lecture_num": 15, "youtube_url": "https://www.youtube.com/watch?v=Ij4p5hLbfo4", "course_id": "course_106108841"}}
{"id": "lecture_106108841_w3_l16", "type": "V_lecture", "name": "Example of ML Estimate", "properties": {"week": 3, "lecture_num": 16, "youtube_url": "https://www.youtube.com/watch?v=mEpXOyLwbxA", "course_id": "course_106108841"}}
{"id": "lecture_106108841_w3_l17", "type": "V_lecture", "name": "Risk Minimization Framework", "properties": {"week": 3, "lecture_num": 17, "youtube_url": "https://www.youtube.com/watch?v=jXCqrFVGwoU", "course_id": "course_106108841"}}
{"id": "lecture_106108841_w3_l18", "type": "V_lecture", "name": "Bayes Classifier", "properties": {"week": 3, "lecture_num": 18, "youtube_url": "https://www.youtube.com/watch?v=-y3SSAIhD4Y", "course_id": "course_106108841"}}
{"id": "lecture_106108841_w3_l19", "type": "V_lecture", "name": "Tutorial 3 : Risk Minimization Framework", "properties": {"week": 3, "lecture_num": 19, "youtube_url": "https://www.youtube.com/watch?v=AQ3einJJrr0", "course_id": "course_106108841"}}
{"id": "lecture_106108841_w3_l20", "type": "V_lecture", "name": "MLE for Gaussian Distribution", "properties": {"week": 3, "lecture_num": 20, "youtube_url": "https://www.youtube.com/watch?v=tF-RrzUnnYA", "course_id": "course_106108841"}}
{"id": "lecture_106108841_w3_l21", "type": "V_lecture", "name": "MLE for Generalized Discrete Random Variable", "properties": {"week": 3, "lecture_num": 21, "youtube_url": "https://www.youtube.com/watch?v=j7jbpicYdik", "course_id": "course_106108841"}}
{"id": "lecture_106108841_w4_l22", "type": "V_lecture", "name": "Density Estimation for Mixed Distribution", "properties": {"week": 4, "lecture_num": 22, "youtube_url": "https://www.youtube.com/watch?v=3UmgTSDgG5Q", "course_id": "course_106108841"}}
{"id": "lecture_106108841_w4_l23", "type": "V_lecture", "name": "Latent Variable Models", "properties": {"week": 4, "lecture_num": 23, "youtube_url": "https://www.youtube.com/watch?v=J9QNr4UrB2c", "course_id": "course_106108841"}}
{"id": "lecture_106108841_w4_l24", "type": "V_lecture", "name": "MLE for Latent Variable Models", "properties": {"week": 4, "lecture_num": 24, "youtube_url": "https://www.youtube.com/watch?v=BMj-TWtK83A", "course_id": "course_106108841"}}
{"id": "lecture_106108841_w4_l25", "type": "V_lecture", "name": "Expectation Maximization Algorithm", "properties": {"week": 4, "lecture_num": 25, "youtube_url": "https://www.youtube.com/watch?v=ejma0iH1pXE", "course_id": "course_106108841"}}
{"id": "lecture_106108841_w4_l26", "type": "V_lecture", "name": "Tutorial 4 : Minmax Classifier", "properties": {"week": 4, "lecture_num": 26, "youtube_url": "https://www.youtube.com/watch?v=ENpzs2ycXJE", "course_id": "course_106108841"}}
{"id": "lecture_106108841_w4_l27", "type": "V_lecture", "name": "Tutorial 5 :  Neyman Pearson Classifier", "properties": {"week": 4, "lecture_num": 27, "youtube_url": "https://www.youtube.com/watch?v=8esVIly2TZY", "course_id": "course_106108841"}}
{"id": "lecture_106108841_w4_l28", "type": "V_lecture", "name": "Tutorial 6 : Example of NP Classifier, ROC Curve", "properties": {"week": 4, "lecture_num": 28, "youtube_url": "https://www.youtube.com/watch?v=JwQEaTqyBDw", "course_id": "course_106108841"}}
{"id": "lecture_106108841_w5_l29", "type": "V_lecture", "name": "Tutorial 7A : MLE for Gaussian Distribution", "properties": {"week": 5, "lecture_num": 29, "youtube_url": "https://www.youtube.com/watch?v=XA3UiD8zEF8", "course_id": "course_106108841"}}
{"id": "lecture_106108841_w5_l30", "type": "V_lecture", "name": "Tutorial 7B : MLE for Generalized Discrete Distribution", "properties": {"week": 5, "lecture_num": 30, "youtube_url": "https://www.youtube.com/watch?v=o5697P6KZoc", "course_id": "course_106108841"}}
{"id": "course_106103842", "type": "V_course", "name": "Foundation for Virtual and Augmented Reality Systems", "properties": {"course_id": "noc26-cs03", "nptel_url": "https://nptel.ac.in/courses/106103842", "nptel_id": "106103842", "abstract": "NOC: Foundation for Virtual and Augmented Reality Systems, IIT Guwahati\nProf Samit Bhattacharya Course Duration :\nJan-Apr 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-04-24\nCourse Abstract\n\nExtended Reality (XR), covering the areas of Virtual, Augmented and Mixed Reality technologies, has become quite popular nowadays. The reason is primarily the advancements in relevant hardware, which made such technologies affordable. As a result, there is huge interest in building applications of such technologies in various domains, the most notable example being the idea of Metaverse. This course is focused on explaining the foundational aspects of the technology in a lucid manner, through a practical case study. The topics include the basic concepts of XR, the hardware and software used, the issues (both psycho-physiological and technological) and how to address those from the user\u2019s and developer\u2019s perspective, stages of system development and finally, optimization issues and approaches to resolve. Each concept is explained in details, with the help of the use case, whenever appropriate. The overall aim of the course is to impart foundational knowledge to the learner to understand and implement an XR system with confidence. Course Duration :\nJan-Apr 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-04-24", "professor": "Prof Samit Bhattacharya", "institute": "IIT Guwahati", "duration": "12 Weeks", "stream_id": "stream_computer_science_and_engineering"}}
{"id": "lecture_106103842_w1_l1", "type": "V_lecture", "name": "Lec 1: General Intro to XR", "properties": {"week": 1, "lecture_num": 1, "youtube_url": "https://www.youtube.com/watch?v=_wnXXuAfFac", "course_id": "course_106103842"}}
{"id": "lecture_106103842_w1_l2", "type": "V_lecture", "name": "Lec 2: Application Domains and System Categories", "properties": {"week": 1, "lecture_num": 2, "youtube_url": "https://www.youtube.com/watch?v=6oEA3HswKhc", "course_id": "course_106103842"}}
{"id": "lecture_106103842_w1_l3", "type": "V_lecture", "name": "Lec 3: Application Domains and System Categories", "properties": {"week": 1, "lecture_num": 3, "youtube_url": "https://www.youtube.com/watch?v=Fi6z0F03L8c", "course_id": "course_106103842"}}
{"id": "lecture_106103842_w1_l4", "type": "V_lecture", "name": "Lec 4: Definitions", "properties": {"week": 1, "lecture_num": 4, "youtube_url": "https://www.youtube.com/watch?v=uI4TZJnzCNI", "course_id": "course_106103842"}}
{"id": "lecture_106103842_w1_l5", "type": "V_lecture", "name": "Lec 5: Definitions", "properties": {"week": 1, "lecture_num": 5, "youtube_url": "https://www.youtube.com/watch?v=3bUERKXyKNs", "course_id": "course_106103842"}}
{"id": "lecture_106103842_w1_l6", "type": "V_lecture", "name": "Lec 6: Historical Evolution", "properties": {"week": 1, "lecture_num": 6, "youtube_url": "https://www.youtube.com/watch?v=GlUP4u8ZsEQ", "course_id": "course_106103842"}}
{"id": "lecture_106103842_w1_l7", "type": "V_lecture", "name": "Lec 1: Historial Evolution", "properties": {"week": 1, "lecture_num": 7, "youtube_url": "https://www.youtube.com/watch?v=3ZMXFg32Ilw", "course_id": "course_106103842"}}
{"id": "lecture_106103842_w2_l8", "type": "V_lecture", "name": "Lec 2: Issues & Challenges", "properties": {"week": 2, "lecture_num": 8, "youtube_url": "https://www.youtube.com/watch?v=ED731ZFakiI", "course_id": "course_106103842"}}
{"id": "lecture_106103842_w2_l9", "type": "V_lecture", "name": "Lec 3: Issues & Challenges", "properties": {"week": 2, "lecture_num": 9, "youtube_url": "https://www.youtube.com/watch?v=m-YSjCqNAfM", "course_id": "course_106103842"}}
{"id": "lecture_106103842_w2_l10", "type": "V_lecture", "name": "Lec 4: Cybersickness", "properties": {"week": 2, "lecture_num": 10, "youtube_url": "https://www.youtube.com/watch?v=Tx68HbDBLgc", "course_id": "course_106103842"}}
{"id": "lecture_106103842_w2_l11", "type": "V_lecture", "name": "Lec 5: Cybersickness", "properties": {"week": 2, "lecture_num": 11, "youtube_url": "https://www.youtube.com/watch?v=D4X1yLcXPvM", "course_id": "course_106103842"}}
{"id": "lecture_106103842_w2_l12", "type": "V_lecture", "name": "Lec 1: Cybersickness", "properties": {"week": 2, "lecture_num": 12, "youtube_url": "https://www.youtube.com/watch?v=UE6yqAlTHZ8", "course_id": "course_106103842"}}
{"id": "lecture_106103842_w2_l13", "type": "V_lecture", "name": "Lec 2: VR Hardware", "properties": {"week": 2, "lecture_num": 13, "youtube_url": "https://www.youtube.com/watch?v=oGpBcw9MHsU", "course_id": "course_106103842"}}
{"id": "lecture_106103842_w2_l14", "type": "V_lecture", "name": "Lec 3: VR Hardware", "properties": {"week": 2, "lecture_num": 14, "youtube_url": "https://www.youtube.com/watch?v=V2EMVpnyAn4", "course_id": "course_106103842"}}
{"id": "lecture_106103842_w3_l15", "type": "V_lecture", "name": "Lec 4: AR Hardware", "properties": {"week": 3, "lecture_num": 15, "youtube_url": "https://www.youtube.com/watch?v=OCf-kNBk1LQ", "course_id": "course_106103842"}}
{"id": "lecture_106103842_w3_l16", "type": "V_lecture", "name": "Lec 5: Understanding Tracking I", "properties": {"week": 3, "lecture_num": 16, "youtube_url": "https://www.youtube.com/watch?v=wm65mdXjPx8", "course_id": "course_106103842"}}
{"id": "lecture_106103842_w3_l17", "type": "V_lecture", "name": "Lec 1: Understanding Tracking II", "properties": {"week": 3, "lecture_num": 17, "youtube_url": "https://www.youtube.com/watch?v=GAxynQg8exg", "course_id": "course_106103842"}}
{"id": "lecture_106103842_w3_l18", "type": "V_lecture", "name": "Lec 2: Understanding Tracking III", "properties": {"week": 3, "lecture_num": 18, "youtube_url": "https://www.youtube.com/watch?v=fwaYn6ZlDbU", "course_id": "course_106103842"}}
{"id": "lecture_106103842_w3_l19", "type": "V_lecture", "name": "Lec 3: VR Software", "properties": {"week": 3, "lecture_num": 19, "youtube_url": "https://www.youtube.com/watch?v=FktO8DU1NBQ", "course_id": "course_106103842"}}
{"id": "lecture_106103842_w3_l20", "type": "V_lecture", "name": "Lec 4: VR Software", "properties": {"week": 3, "lecture_num": 20, "youtube_url": "https://www.youtube.com/watch?v=rdBonoyBPSU", "course_id": "course_106103842"}}
{"id": "lecture_106103842_w3_l21", "type": "V_lecture", "name": "Lec 5 : AR Software", "properties": {"week": 3, "lecture_num": 21, "youtube_url": "https://www.youtube.com/watch?v=OE_X-qvXbws", "course_id": "course_106103842"}}
{"id": "course_106103843", "type": "V_course", "name": "Neural Networks for Computer Vision and Natural Language Processing", "properties": {"course_id": "noc26-cs04", "nptel_url": "https://nptel.ac.in/courses/106103843", "nptel_id": "106103843", "abstract": "NOC: Neural Networks for Computer Vision and Natural Language Processing, IIT Guwahati\nProf Arijit Sur Course Duration :\nJan-Apr 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-04-25\nCourse Abstract\n\nNatural language processing (NLP) and computer vision (CV) have become increasingly significant due to their wide-ranging applications, such as language translation, speech recognition, image analysis, and automation in the healthcare, education, and transportation sectors. For under graduate and postgraduate college students, this course will offer a strong foundation in the concepts and techniques of deep learning, preparing them for advanced research and enhancing their employability in emerging technologies. Beginners in the industry will also benefit from practical insights into bridging theoretical knowledge with real-world applications, enabling them to contribute effectively to projects involving language and vision-based solutions. Faculty members will gain exposure to the latest developments and tools in the field, supporting their efforts to integrate cutting-edge topics into their teaching and research.\nThis course starts with fundamental machine learning concepts and will cover advanced deep learning techniques for modeling primary computer vision and NLP tasks. The course module design helps beginners understand the underlying neural network concepts and how to apply these networks to model different important NLP and vision tasks. Simple diagrammatic illustrations help students from various backgrounds understand complex learning models. The course contents are in massive demand in AI/ML-based IT industries. Course Duration :\nJan-Apr 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-04-25", "professor": "Prof Arijit Sur", "institute": "IIT Guwahati", "duration": "12 Weeks", "stream_id": "stream_computer_science_and_engineering"}}
{"id": "lecture_106103843_w1_l1", "type": "V_lecture", "name": "Introduction to Learning", "properties": {"week": 1, "lecture_num": 1, "youtube_url": "https://www.youtube.com/watch?v=meEm5r4Tsys", "course_id": "course_106103843"}}
{"id": "lecture_106103843_w1_l2", "type": "V_lecture", "name": "Supervised Learning (Regression)", "properties": {"week": 1, "lecture_num": 2, "youtube_url": "https://www.youtube.com/watch?v=THIEmfsTMIw", "course_id": "course_106103843"}}
{"id": "lecture_106103843_w1_l3", "type": "V_lecture", "name": "Gradient Descent", "properties": {"week": 1, "lecture_num": 3, "youtube_url": "https://www.youtube.com/watch?v=xEsXi1RciN8", "course_id": "course_106103843"}}
{"id": "lecture_106103843_w1_l4", "type": "V_lecture", "name": "Logistics Regression", "properties": {"week": 1, "lecture_num": 4, "youtube_url": "https://www.youtube.com/watch?v=vhGGzt20WbM", "course_id": "course_106103843"}}
{"id": "lecture_106103843_w1_l5", "type": "V_lecture", "name": "Optimization for supervised models", "properties": {"week": 1, "lecture_num": 5, "youtube_url": "https://www.youtube.com/watch?v=Z-ANBc5OjCU", "course_id": "course_106103843"}}
{"id": "lecture_106103843_w1_l6", "type": "V_lecture", "name": "Neural Network - I (Single Layer Perceptron)", "properties": {"week": 1, "lecture_num": 6, "youtube_url": "https://www.youtube.com/watch?v=eR0EnlvXF6A", "course_id": "course_106103843"}}
{"id": "lecture_106103843_w1_l7", "type": "V_lecture", "name": "Neural Network - II (Multi Layer Perceptron)", "properties": {"week": 1, "lecture_num": 7, "youtube_url": "https://www.youtube.com/watch?v=zvdkk-yz5NA", "course_id": "course_106103843"}}
{"id": "lecture_106103843_w2_l8", "type": "V_lecture", "name": "Neural Network \u2013 III (Training of the Multi Layer Perceptron)", "properties": {"week": 2, "lecture_num": 8, "youtube_url": "https://www.youtube.com/watch?v=2otF4tF2nWI", "course_id": "course_106103843"}}
{"id": "lecture_106103843_w2_l9", "type": "V_lecture", "name": "Introduction to Deep Learning - I", "properties": {"week": 2, "lecture_num": 9, "youtube_url": "https://www.youtube.com/watch?v=i8SxZniobQw", "course_id": "course_106103843"}}
{"id": "lecture_106103843_w2_l10", "type": "V_lecture", "name": "Introduction to Deep Learning - II", "properties": {"week": 2, "lecture_num": 10, "youtube_url": "https://www.youtube.com/watch?v=Fx2mGGHwJWY", "course_id": "course_106103843"}}
{"id": "lecture_106103843_w2_l11", "type": "V_lecture", "name": "Introduction to Deep Learning - III", "properties": {"week": 2, "lecture_num": 11, "youtube_url": "https://www.youtube.com/watch?v=0M3ekpfvpyo", "course_id": "course_106103843"}}
{"id": "lecture_106103843_w2_l12", "type": "V_lecture", "name": "Computer Vision Through Machine Learning", "properties": {"week": 2, "lecture_num": 12, "youtube_url": "https://www.youtube.com/watch?v=6eON0Sbit6Q", "course_id": "course_106103843"}}
{"id": "lecture_106103843_w2_l13", "type": "V_lecture", "name": "Natural Language Processing Through Machine Learning", "properties": {"week": 2, "lecture_num": 13, "youtube_url": "https://www.youtube.com/watch?v=oY-Y76pW5O8", "course_id": "course_106103843"}}
{"id": "lecture_106103843_w2_l14", "type": "V_lecture", "name": "Convolutional Neural Network - I", "properties": {"week": 2, "lecture_num": 14, "youtube_url": "https://www.youtube.com/watch?v=Pu2LaEH8oi8", "course_id": "course_106103843"}}
{"id": "lecture_106103843_w3_l15", "type": "V_lecture", "name": "Convolutional Neural Network - II (Model Architecture)", "properties": {"week": 3, "lecture_num": 15, "youtube_url": "https://www.youtube.com/watch?v=_tK2HcJsAHk", "course_id": "course_106103843"}}
{"id": "lecture_106103843_w3_l16", "type": "V_lecture", "name": "Optimizing Convolutional Neural Network", "properties": {"week": 3, "lecture_num": 16, "youtube_url": "https://www.youtube.com/watch?v=jk1H3bSupuo", "course_id": "course_106103843"}}
{"id": "course_106105847", "type": "V_course", "name": "Algorithmic Graph Theory and Data Structures", "properties": {"course_id": "noc26-cs08", "nptel_url": "https://nptel.ac.in/courses/106105847", "nptel_id": "106105847", "abstract": "NOC: Algorithmic Graph Theory and Data Structures, IIT Kharagpur\nProf. Sourav Mukhopadhyay Course Duration :\nJan-Apr 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-04-19\nCourse Abstract\n\nThis course offers a comprehensive introduction to the mathematical modeling and algorithmic analysis of graph-based problems. Students will gain a solid foundation in core graph algorithms and the efficient data structures that power them. Through a theoretical concept, the course emphasizes key algorithmic paradigms such as greedy methods, dynamic programming, and augmented data structures in the context of solving real-world problems. A strong focus will be placed on analyzing algorithm performance using time and space complexity, enabling students to assess efficiency and scalability. This course is designed to strengthen problem\ufffesolving skills and bridge the gap between theory and implementation, the course also serves as a stepping stone for advanced studies and research in algorithmic graph theory, network science, and computational complexity. Course Duration :\nJan-Apr 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-04-19", "professor": "Prof. Sourav Mukhopadhyay", "institute": "IIT Kharagpur", "duration": "12 Weeks", "stream_id": "stream_computer_science_and_engineering"}}
{"id": "lecture_106105847_w1_l1", "type": "V_lecture", "name": "Lecture No - 01 : Introduction", "properties": {"week": 1, "lecture_num": 1, "youtube_url": "https://www.youtube.com/watch?v=bfLfbi7L9Ro", "course_id": "course_106105847"}}
{"id": "lecture_106105847_w1_l2", "type": "V_lecture", "name": "Lecture No - 02 : Analysis of Algorithm", "properties": {"week": 1, "lecture_num": 2, "youtube_url": "https://www.youtube.com/watch?v=bdC7-68QGyo", "course_id": "course_106105847"}}
{"id": "lecture_106105847_w1_l3", "type": "V_lecture", "name": "Lecture No - 03 : Time Complexity", "properties": {"week": 1, "lecture_num": 3, "youtube_url": "https://www.youtube.com/watch?v=wM3LZunspa0", "course_id": "course_106105847"}}
{"id": "lecture_106105847_w1_l4", "type": "V_lecture", "name": "Lecture No - 04 : Merge Sort", "properties": {"week": 1, "lecture_num": 4, "youtube_url": "https://www.youtube.com/watch?v=CX24tq7EaTE", "course_id": "course_106105847"}}
{"id": "lecture_106105847_w1_l5", "type": "V_lecture", "name": "Lecture No - 05 : Solving the recurrences", "properties": {"week": 1, "lecture_num": 5, "youtube_url": "https://www.youtube.com/watch?v=f0qkgPEnlPg", "course_id": "course_106105847"}}
{"id": "lecture_106105847_w1_l6", "type": "V_lecture", "name": "Lecture No - 06 : Solving the recurrences (Cont\u2026)", "properties": {"week": 1, "lecture_num": 6, "youtube_url": "https://www.youtube.com/watch?v=j-ALF30toNQ", "course_id": "course_106105847"}}
{"id": "lecture_106105847_w1_l7", "type": "V_lecture", "name": "Lecture No - 07 : Divide and Conquer Algorithms", "properties": {"week": 1, "lecture_num": 7, "youtube_url": "https://www.youtube.com/watch?v=Xpww5c403_s", "course_id": "course_106105847"}}
{"id": "lecture_106105847_w2_l8", "type": "V_lecture", "name": "Lecture No - 08 : Fibonacci numbers and Matrix multiplication", "properties": {"week": 2, "lecture_num": 8, "youtube_url": "https://www.youtube.com/watch?v=23UmMmJHov0", "course_id": "course_106105847"}}
{"id": "lecture_106105847_w2_l9", "type": "V_lecture", "name": "Lecture No - 09 : Quicksort", "properties": {"week": 2, "lecture_num": 9, "youtube_url": "https://www.youtube.com/watch?v=kSg9uuE2UG8", "course_id": "course_106105847"}}
{"id": "lecture_106105847_w2_l10", "type": "V_lecture", "name": "Lecture No - 10 : Randomized Quicksort", "properties": {"week": 2, "lecture_num": 10, "youtube_url": "https://www.youtube.com/watch?v=b4dVSF81Mzk", "course_id": "course_106105847"}}
{"id": "lecture_106105847_w2_l11", "type": "V_lecture", "name": "Lecture No - 11 : Heapsort", "properties": {"week": 2, "lecture_num": 11, "youtube_url": "https://www.youtube.com/watch?v=KbKfulzFbhw", "course_id": "course_106105847"}}
{"id": "lecture_106105847_w2_l12", "type": "V_lecture", "name": "Lecture No - 12 : Linear time sorting", "properties": {"week": 2, "lecture_num": 12, "youtube_url": "https://www.youtube.com/watch?v=l9ZOVtX0Teg", "course_id": "course_106105847"}}
{"id": "lecture_106105847_w2_l13", "type": "V_lecture", "name": "Lecture No - 13 : Linear time sorting (Cont\u2026)", "properties": {"week": 2, "lecture_num": 13, "youtube_url": "https://www.youtube.com/watch?v=pt1Sy799PfA", "course_id": "course_106105847"}}
{"id": "lecture_106105847_w2_l14", "type": "V_lecture", "name": "Lecture No - 14 : Order Statistics", "properties": {"week": 2, "lecture_num": 14, "youtube_url": "https://www.youtube.com/watch?v=o4ca6JunphI", "course_id": "course_106105847"}}
{"id": "lecture_106105847_w3_l15", "type": "V_lecture", "name": "Lecture No - 15 : Order Statistics (Cont\u2026)", "properties": {"week": 3, "lecture_num": 15, "youtube_url": "https://www.youtube.com/watch?v=RyUN5ouKD1Q", "course_id": "course_106105847"}}
{"id": "lecture_106105847_w3_l16", "type": "V_lecture", "name": "Lecture No - 16 : Hash Function", "properties": {"week": 3, "lecture_num": 16, "youtube_url": "https://www.youtube.com/watch?v=mqwxS5OaEjs", "course_id": "course_106105847"}}
{"id": "lecture_106105847_w3_l17", "type": "V_lecture", "name": "Lecture No - 17 : Open Addressing Hashing", "properties": {"week": 3, "lecture_num": 17, "youtube_url": "https://www.youtube.com/watch?v=Jw2Az1TkIqI", "course_id": "course_106105847"}}
{"id": "lecture_106105847_w3_l18", "type": "V_lecture", "name": "Lecture No - 18 : Universal Hash Functions", "properties": {"week": 3, "lecture_num": 18, "youtube_url": "https://www.youtube.com/watch?v=0AfKTbcY3Ao", "course_id": "course_106105847"}}
{"id": "lecture_106105847_w3_l19", "type": "V_lecture", "name": "Lecture No - 19 : Perfect Hashing", "properties": {"week": 3, "lecture_num": 19, "youtube_url": "https://www.youtube.com/watch?v=zuzzD11iXS0", "course_id": "course_106105847"}}
{"id": "lecture_106105847_w3_l20", "type": "V_lecture", "name": "Lecture No - 20 : Heap", "properties": {"week": 3, "lecture_num": 20, "youtube_url": "https://www.youtube.com/watch?v=MYxXRJe4REk", "course_id": "course_106105847"}}
{"id": "course_106106931", "type": "V_course", "name": "Introduction to Haskell Programming", "properties": {"course_id": "noc26-cs12", "nptel_url": "https://nptel.ac.in/courses/106106931", "nptel_id": "106106931", "abstract": "NOC: Introduction To Haskell Programming, Chennai Mathematical Institute\nProf. S. P Suresh Course Duration :\nJan-Apr 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-04-24\nCourse Abstract\n\nFunctional programming is an elegant, concise and powerful programming paradigm. This style encourages breaking up programming tasks into logical units that can be easily translated into provably correct code. Haskell brings together the best features of functional programming and is increasingly being used in the industry, both for building rapid prototypes and for actual deployment. Course Duration :\nJan-Apr 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-04-24", "professor": "Prof. S. P Suresh", "institute": "Chennai Mathematical Institute", "duration": "8 Weeks + 4 Weeks (New)", "stream_id": "stream_computer_science_and_engineering"}}
{"id": "lecture_106106931_w1_l1", "type": "V_lecture", "name": "Functions and types: 1", "properties": {"week": 1, "lecture_num": 1, "youtube_url": "https://www.youtube.com/watch?v=c6YbECRIa_4", "course_id": "course_106106931"}}
{"id": "lecture_106106931_w1_l2", "type": "V_lecture", "name": "Functions and types: 2", "properties": {"week": 1, "lecture_num": 2, "youtube_url": "https://www.youtube.com/watch?v=AJmmdinjb70", "course_id": "course_106106931"}}
{"id": "lecture_106106931_w1_l3", "type": "V_lecture", "name": "Functions and types: 3", "properties": {"week": 1, "lecture_num": 3, "youtube_url": "https://www.youtube.com/watch?v=rj5Mk1oA87Y", "course_id": "course_106106931"}}
{"id": "lecture_106106931_w1_l4", "type": "V_lecture", "name": "Haskell demo", "properties": {"week": 1, "lecture_num": 4, "youtube_url": "https://www.youtube.com/watch?v=eHuh_RvicxM", "course_id": "course_106106931"}}
{"id": "lecture_106106931_w1_l5", "type": "V_lecture", "name": "Recursive functions: 1", "properties": {"week": 1, "lecture_num": 5, "youtube_url": "https://www.youtube.com/watch?v=rugQUfPQg3c", "course_id": "course_106106931"}}
{"id": "lecture_106106931_w1_l6", "type": "V_lecture", "name": "Recursive functions: 2", "properties": {"week": 1, "lecture_num": 6, "youtube_url": "https://www.youtube.com/watch?v=YikcBEVdRQU", "course_id": "course_106106931"}}
{"id": "lecture_106106931_w1_l7", "type": "V_lecture", "name": "Lists: 1", "properties": {"week": 1, "lecture_num": 7, "youtube_url": "https://www.youtube.com/watch?v=rnLxpe5Caf8", "course_id": "course_106106931"}}
{"id": "lecture_106106931_w2_l8", "type": "V_lecture", "name": "Lists: 2", "properties": {"week": 2, "lecture_num": 8, "youtube_url": "https://www.youtube.com/watch?v=Q13HW5L8NfI", "course_id": "course_106106931"}}
{"id": "lecture_106106931_w2_l9", "type": "V_lecture", "name": "Lists demo", "properties": {"week": 2, "lecture_num": 9, "youtube_url": "https://www.youtube.com/watch?v=iw4S2h3-2xw", "course_id": "course_106106931"}}
{"id": "lecture_106106931_w2_l10", "type": "V_lecture", "name": "Built-in functions on lists, list notations: 1", "properties": {"week": 2, "lecture_num": 10, "youtube_url": "https://www.youtube.com/watch?v=ogd1fFmheao", "course_id": "course_106106931"}}
{"id": "lecture_106106931_w2_l11", "type": "V_lecture", "name": "Built-in functions on lists, list notations: 2", "properties": {"week": 2, "lecture_num": 11, "youtube_url": "https://www.youtube.com/watch?v=hAPO5yPySwo", "course_id": "course_106106931"}}
{"id": "lecture_106106931_w2_l12", "type": "V_lecture", "name": "Char, String, tuples, etc", "properties": {"week": 2, "lecture_num": 12, "youtube_url": "https://www.youtube.com/watch?v=fx6AvjRzexI", "course_id": "course_106106931"}}
{"id": "lecture_106106931_w2_l13", "type": "V_lecture", "name": "Haskell demo", "properties": {"week": 2, "lecture_num": 13, "youtube_url": "https://www.youtube.com/watch?v=Ok_VgEl-1rA", "course_id": "course_106106931"}}
{"id": "lecture_106106931_w2_l14", "type": "V_lecture", "name": "Higher-order functions", "properties": {"week": 2, "lecture_num": 14, "youtube_url": "https://www.youtube.com/watch?v=ndfIacbkp1Y", "course_id": "course_106106931"}}
{"id": "lecture_106106931_w3_l15", "type": "V_lecture", "name": "Folds", "properties": {"week": 3, "lecture_num": 15, "youtube_url": "https://www.youtube.com/watch?v=D9RuJQNciLI", "course_id": "course_106106931"}}
{"id": "lecture_106106931_w3_l16", "type": "V_lecture", "name": "More folds", "properties": {"week": 3, "lecture_num": 16, "youtube_url": "https://www.youtube.com/watch?v=mVgn0fi0lMQ", "course_id": "course_106106931"}}
{"id": "lecture_106106931_w3_l17", "type": "V_lecture", "name": "Higher-order functions: demo", "properties": {"week": 3, "lecture_num": 17, "youtube_url": "https://www.youtube.com/watch?v=Vn7b1Uv8euY", "course_id": "course_106106931"}}
{"id": "course_106106852", "type": "V_course", "name": "Introduction to Information Retrieval", "properties": {"course_id": "noc26-cs13", "nptel_url": "https://nptel.ac.in/courses/106106852", "nptel_id": "106106852", "abstract": "NOC: Introduction to Information Retrieval, IISER Kolkata\nProf. Dwaipayan Roy Course Duration :\nJan-Apr 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-04-25\nCourse Abstract\n\nThis course offers a comprehensive introduction to Information Retrieval (IR), the \u2018science behind search engines\u2019 and document retrieval systems. It covers fundamental concepts such as indexing, ranking, retrieval models, evaluation metrics, and relevance feedback. Learners will also be briefly introduce modern IR applications, including web search, recommender systems, and semantic retrieval techniques. The course balances theory with hands-on components to prepare students for both academic research and industry roles Course Duration :\nJan-Apr 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-04-25", "professor": "Prof. Dwaipayan Roy", "institute": "IISER Kolkata", "duration": "12 Weeks", "stream_id": "stream_computer_science_and_engineering"}}
{"id": "lecture_106106852_w1_l1", "type": "V_lecture", "name": "Introduction to the course", "properties": {"week": 1, "lecture_num": 1, "youtube_url": "https://www.youtube.com/watch?v=8Mf_Ko2zAns", "course_id": "course_106106852"}}
{"id": "lecture_106106852_w1_l2", "type": "V_lecture", "name": "Introduction to Information Retrieval", "properties": {"week": 1, "lecture_num": 2, "youtube_url": "https://www.youtube.com/watch?v=kKGLFUcV-ZI", "course_id": "course_106106852"}}
{"id": "lecture_106106852_w1_l3", "type": "V_lecture", "name": "Text Processing: Term Selection", "properties": {"week": 1, "lecture_num": 3, "youtube_url": "https://www.youtube.com/watch?v=JhxCPYSfKh4", "course_id": "course_106106852"}}
{"id": "lecture_106106852_w1_l4", "type": "V_lecture", "name": "Text Processing: Term Filtering and Linguistic Processing", "properties": {"week": 1, "lecture_num": 4, "youtube_url": "https://www.youtube.com/watch?v=jAzeZP7Xfjk", "course_id": "course_106106852"}}
{"id": "lecture_106106852_w1_l5", "type": "V_lecture", "name": "Indexing", "properties": {"week": 1, "lecture_num": 5, "youtube_url": "https://www.youtube.com/watch?v=ID_YWiYBfAE", "course_id": "course_106106852"}}
{"id": "lecture_106106852_w1_l6", "type": "V_lecture", "name": "Inverted Index", "properties": {"week": 1, "lecture_num": 6, "youtube_url": "https://www.youtube.com/watch?v=Ww9oYc_-QAk", "course_id": "course_106106852"}}
{"id": "lecture_106106852_w1_l7", "type": "V_lecture", "name": "Making of the Inverted Index", "properties": {"week": 1, "lecture_num": 7, "youtube_url": "https://www.youtube.com/watch?v=jQ5zbOhewz4", "course_id": "course_106106852"}}
{"id": "lecture_106106852_w2_l8", "type": "V_lecture", "name": "Storing Inverted Index", "properties": {"week": 2, "lecture_num": 8, "youtube_url": "https://www.youtube.com/watch?v=aC1WNYbDzt8", "course_id": "course_106106852"}}
{"id": "lecture_106106852_w2_l9", "type": "V_lecture", "name": "Inverted Index Summary", "properties": {"week": 2, "lecture_num": 9, "youtube_url": "https://www.youtube.com/watch?v=mbIgidzcrxg", "course_id": "course_106106852"}}
{"id": "lecture_106106852_w2_l10", "type": "V_lecture", "name": "Statistical Properties of Text - Zipf's Law", "properties": {"week": 2, "lecture_num": 10, "youtube_url": "https://www.youtube.com/watch?v=OdOgOi6zcrM", "course_id": "course_106106852"}}
{"id": "lecture_106106852_w2_l11", "type": "V_lecture", "name": "Statistical Properties of Text - Heap's Law", "properties": {"week": 2, "lecture_num": 11, "youtube_url": "https://www.youtube.com/watch?v=3pmyZz6ueZE", "course_id": "course_106106852"}}
{"id": "lecture_106106852_w2_l12", "type": "V_lecture", "name": "Index Compression", "properties": {"week": 2, "lecture_num": 12, "youtube_url": "https://www.youtube.com/watch?v=qQQ1i5LDIuQ", "course_id": "course_106106852"}}
{"id": "lecture_106106852_w2_l13", "type": "V_lecture", "name": "Getting started with PyLucene", "properties": {"week": 2, "lecture_num": 13, "youtube_url": "https://www.youtube.com/watch?v=BbDlBAvh94I", "course_id": "course_106106852"}}
{"id": "lecture_106106852_w2_l14", "type": "V_lecture", "name": "Installing Docker and PyLucene", "properties": {"week": 2, "lecture_num": 14, "youtube_url": "https://www.youtube.com/watch?v=grhPr2BQ924", "course_id": "course_106106852"}}
{"id": "lecture_106106852_w3_l15", "type": "V_lecture", "name": "Understanding Different Fields in PyLucene - 1", "properties": {"week": 3, "lecture_num": 15, "youtube_url": "https://www.youtube.com/watch?v=ihh82T1Ijsc", "course_id": "course_106106852"}}
{"id": "lecture_106106852_w3_l16", "type": "V_lecture", "name": "Understanding Different Fields in PyLucene - 2", "properties": {"week": 3, "lecture_num": 16, "youtube_url": "https://www.youtube.com/watch?v=Uxy_ZiWpC_4", "course_id": "course_106106852"}}
{"id": "lecture_106106852_w3_l17", "type": "V_lecture", "name": "Reading a Small Toy Dataset for Indexing using PyLucene", "properties": {"week": 3, "lecture_num": 17, "youtube_url": "https://www.youtube.com/watch?v=R9mwUFALgnE", "course_id": "course_106106852"}}
{"id": "lecture_106106852_w3_l18", "type": "V_lecture", "name": "Different Analyzers in PyLucene", "properties": {"week": 3, "lecture_num": 18, "youtube_url": "https://www.youtube.com/watch?v=wtqU-H4GXQM", "course_id": "course_106106852"}}
{"id": "lecture_106106852_w3_l19", "type": "V_lecture", "name": "Indexing using PyLucene - Setting the Parameters", "properties": {"week": 3, "lecture_num": 19, "youtube_url": "https://www.youtube.com/watch?v=9d37S8eJy3c", "course_id": "course_106106852"}}
{"id": "lecture_106106852_w3_l20", "type": "V_lecture", "name": "Indexing using PyLucene - 2", "properties": {"week": 3, "lecture_num": 20, "youtube_url": "https://www.youtube.com/watch?v=-NAUlEnC-UA", "course_id": "course_106106852"}}
{"id": "lecture_106106852_w3_l21", "type": "V_lecture", "name": "Non-English Text Analysis using PyLucene", "properties": {"week": 3, "lecture_num": 21, "youtube_url": "https://www.youtube.com/watch?v=Ea-hCYFNLmY", "course_id": "course_106106852"}}
{"id": "lecture_106106852_w4_l22", "type": "V_lecture", "name": "Exploring Luke: The Lucene Index Viewer", "properties": {"week": 4, "lecture_num": 22, "youtube_url": "https://www.youtube.com/watch?v=OhE1GFN0wt0", "course_id": "course_106106852"}}
{"id": "lecture_106106852_w4_l23", "type": "V_lecture", "name": "Experimenting with Different Options in Indexing", "properties": {"week": 4, "lecture_num": 23, "youtube_url": "https://www.youtube.com/watch?v=XQrBpYqgaxA", "course_id": "course_106106852"}}
{"id": "lecture_106106852_w4_l24", "type": "V_lecture", "name": "PyLucene Practice Programs - 1", "properties": {"week": 4, "lecture_num": 24, "youtube_url": "https://www.youtube.com/watch?v=VZIJvgHU6X8", "course_id": "course_106106852"}}
{"id": "lecture_106106852_w4_l25", "type": "V_lecture", "name": "PyLucene Practice Programs - 2", "properties": {"week": 4, "lecture_num": 25, "youtube_url": "https://www.youtube.com/watch?v=G32Jefx96HA", "course_id": "course_106106852"}}
{"id": "lecture_106106852_w4_l26", "type": "V_lecture", "name": "Query Processing", "properties": {"week": 4, "lecture_num": 26, "youtube_url": "https://www.youtube.com/watch?v=mQ9pME0PGeY", "course_id": "course_106106852"}}
{"id": "course_106108229", "type": "V_course", "name": "Secure Computation: Part I", "properties": {"course_id": "noc26-cs17", "nptel_url": "https://nptel.ac.in/courses/106108229", "nptel_id": "106108229", "abstract": "NOC: Secure Computation: Part I, IIITB\nProf. Ashish Choudhury Course Duration :\nJan-Apr 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-04-17\nCourse Abstract\n\nThis course will discuss about how using various cryptographic primitives, one can do computation on distributed and sensitive data, also known as secure multi-party computation (MPC), which arguably is one of the most fundamental problems in cryptography as well as distributed computing. Course Duration :\nJan-Apr 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-04-17", "professor": "Prof. Ashish Choudhury", "institute": "IISc Bangalore", "duration": "12 Weeks", "stream_id": "stream_computer_science_and_engineering"}}
{"id": "lecture_106108229_w1_l1", "type": "V_lecture", "name": "What is Secure MPC", "properties": {"week": 1, "lecture_num": 1, "youtube_url": "https://www.youtube.com/watch?v=wOO-7YKiMP8", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w1_l2", "type": "V_lecture", "name": "Real-World Examples of Secure MPC", "properties": {"week": 1, "lecture_num": 2, "youtube_url": "https://www.youtube.com/watch?v=CSzb5tPdMPI", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w1_l3", "type": "V_lecture", "name": "Various Dimensions to Study Secure MPC", "properties": {"week": 1, "lecture_num": 3, "youtube_url": "https://www.youtube.com/watch?v=6ne_3w89j6M", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w1_l4", "type": "V_lecture", "name": "Recap of Basic Concepts from Abstract Algebra", "properties": {"week": 1, "lecture_num": 4, "youtube_url": "https://www.youtube.com/watch?v=dwYzh4dXWq4", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w1_l5", "type": "V_lecture", "name": "Recap of Basic Concepts from Abstract Algebra Contd.", "properties": {"week": 1, "lecture_num": 5, "youtube_url": "https://www.youtube.com/watch?v=6A8xhUs0lLI", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w1_l6", "type": "V_lecture", "name": "Recap of Basic Concepts from Cryptography", "properties": {"week": 1, "lecture_num": 6, "youtube_url": "https://www.youtube.com/watch?v=zWDzPuNMo4A", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w1_l7", "type": "V_lecture", "name": "Secret sharing", "properties": {"week": 1, "lecture_num": 7, "youtube_url": "https://www.youtube.com/watch?v=-86lvXoe7Qw", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w2_l8", "type": "V_lecture", "name": "Additive Secret Sharing", "properties": {"week": 2, "lecture_num": 8, "youtube_url": "https://www.youtube.com/watch?v=TBgxlXHzxxc", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w2_l9", "type": "V_lecture", "name": "Inefficient Threshold Secret Sharing", "properties": {"week": 2, "lecture_num": 9, "youtube_url": "https://www.youtube.com/watch?v=sQkcwGde5dc", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w2_l10", "type": "V_lecture", "name": "Polynomials Over Fields", "properties": {"week": 2, "lecture_num": 10, "youtube_url": "https://www.youtube.com/watch?v=5VIp8nrUoA4", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w2_l11", "type": "V_lecture", "name": "Shamir Secret-Sharing", "properties": {"week": 2, "lecture_num": 11, "youtube_url": "https://www.youtube.com/watch?v=EwazKH7X0FI", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w2_l12", "type": "V_lecture", "name": "Linear secret-sharing", "properties": {"week": 2, "lecture_num": 12, "youtube_url": "https://www.youtube.com/watch?v=y8eVltFf5-Y", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w2_l13", "type": "V_lecture", "name": "Linear Secret Sharing Contd.", "properties": {"week": 2, "lecture_num": 13, "youtube_url": "https://www.youtube.com/watch?v=La3ifySRp6A", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w2_l14", "type": "V_lecture", "name": "General Secret Sharing", "properties": {"week": 2, "lecture_num": 14, "youtube_url": "https://www.youtube.com/watch?v=-D4OHFpdcEk", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w3_l15", "type": "V_lecture", "name": "Perfectly-Secure Message Transmission", "properties": {"week": 3, "lecture_num": 15, "youtube_url": "https://www.youtube.com/watch?v=G13P-zvQtcw", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w3_l16", "type": "V_lecture", "name": "A Toy MPC Protocol", "properties": {"week": 3, "lecture_num": 16, "youtube_url": "https://www.youtube.com/watch?v=69ccFQZodPM", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w3_l17", "type": "V_lecture", "name": "A Toy MPC Protocol Contd.", "properties": {"week": 3, "lecture_num": 17, "youtube_url": "https://www.youtube.com/watch?v=fEIyLLsnZYI", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w3_l18", "type": "V_lecture", "name": "The BGW MPC Protocol", "properties": {"week": 3, "lecture_num": 18, "youtube_url": "https://www.youtube.com/watch?v=VYCiutSFLb8", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w3_l19", "type": "V_lecture", "name": "The BGW MPC Protocol for Linear Functions", "properties": {"week": 3, "lecture_num": 19, "youtube_url": "https://www.youtube.com/watch?v=t8JnV1pixTw", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w3_l20", "type": "V_lecture", "name": "The BGW MPC Protocol for Linear Functions: Security Analysis", "properties": {"week": 3, "lecture_num": 20, "youtube_url": "https://www.youtube.com/watch?v=2IcEFm6T-zo", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w3_l21", "type": "V_lecture", "name": "The BGW MPC Protocol: The Case of Non-Linear Gates", "properties": {"week": 3, "lecture_num": 21, "youtube_url": "https://www.youtube.com/watch?v=rc9p4YjaCz0", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w4_l22", "type": "V_lecture", "name": "The Degree-Reduction Problem", "properties": {"week": 4, "lecture_num": 22, "youtube_url": "https://www.youtube.com/watch?v=PVCXg5aad-Q", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w4_l23", "type": "V_lecture", "name": "The Gennaro-Rabin-Rabin (GRR) Degree-Reduction Method", "properties": {"week": 4, "lecture_num": 23, "youtube_url": "https://www.youtube.com/watch?v=mae0O89ctlQ", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w4_l24", "type": "V_lecture", "name": "Analysis of the GRR, Degree-Reduction Method", "properties": {"week": 4, "lecture_num": 24, "youtube_url": "https://www.youtube.com/watch?v=q688ADK7QpI", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w4_l25", "type": "V_lecture", "name": "Shared Circuit-Evaluation via  GRR Degree-Reduction Method", "properties": {"week": 4, "lecture_num": 25, "youtube_url": "https://www.youtube.com/watch?v=ov1Q0rWpbfA", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w4_l26", "type": "V_lecture", "name": "Shared Circuit-Evaluation in the Pre-processing Model", "properties": {"week": 4, "lecture_num": 26, "youtube_url": "https://www.youtube.com/watch?v=FDq7N8wOhyU", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w4_l27", "type": "V_lecture", "name": "Optimality of Corruption Bound for Perfectly-Secure MPC", "properties": {"week": 4, "lecture_num": 27, "youtube_url": "https://www.youtube.com/watch?v=Fo0ocyChlgU", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w4_l28", "type": "V_lecture", "name": "Perfectly-Secure MPC Tolerating General (Non-Threshold) Adversaries", "properties": {"week": 4, "lecture_num": 28, "youtube_url": "https://www.youtube.com/watch?v=ZA3h5rKttfE", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w5_l29", "type": "V_lecture", "name": "Perfectly-Secure MPC Tolerating General (Non-Threshold) Adversaries with Q^((2)) Condition", "properties": {"week": 5, "lecture_num": 29, "youtube_url": "https://www.youtube.com/watch?v=MoC1AV7fj9w", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w5_l30", "type": "V_lecture", "name": "Perfectly-Secure MPC for Small Number of Parties", "properties": {"week": 5, "lecture_num": 30, "youtube_url": "https://www.youtube.com/watch?v=ZFuLweCcmcA", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w5_l31", "type": "V_lecture", "name": "Perfectly-Secure 3PC Contd.", "properties": {"week": 5, "lecture_num": 31, "youtube_url": "https://www.youtube.com/watch?v=-jAT7nciyYY", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w5_l32", "type": "V_lecture", "name": "More Efficient Perfectly-Secure 3PC", "properties": {"week": 5, "lecture_num": 32, "youtube_url": "https://www.youtube.com/watch?v=4RdKRU_JGF8", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w5_l33", "type": "V_lecture", "name": "More Efficient Perfectly-Secure 3PC Contd.", "properties": {"week": 5, "lecture_num": 33, "youtube_url": "https://www.youtube.com/watch?v=q6gMJfxOXLI", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w5_l34", "type": "V_lecture", "name": "Towards Cryptographically-Secure MPC", "properties": {"week": 5, "lecture_num": 34, "youtube_url": "https://www.youtube.com/watch?v=aAz9c0pzFPc", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w5_l35", "type": "V_lecture", "name": "GMW MPC protocol", "properties": {"week": 5, "lecture_num": 35, "youtube_url": "https://www.youtube.com/watch?v=YiwTVQFkAQQ", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w6_l36", "type": "V_lecture", "name": "Oblivious Transfer (OT)", "properties": {"week": 6, "lecture_num": 36, "youtube_url": "https://www.youtube.com/watch?v=1s-bKKdElAU", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w6_l37", "type": "V_lecture", "name": "RSA Assumption and RSA Hard-Core Predicate", "properties": {"week": 6, "lecture_num": 37, "youtube_url": "https://www.youtube.com/watch?v=ZO00TA8kJg8", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w6_l38", "type": "V_lecture", "name": "Bit OT Based on RSA Assumption and  Hard-Core Predicate", "properties": {"week": 6, "lecture_num": 38, "youtube_url": "https://www.youtube.com/watch?v=hL71qaFvlqY", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w6_l39", "type": "V_lecture", "name": "Discrete Logarithm and DDH Assumption", "properties": {"week": 6, "lecture_num": 39, "youtube_url": "https://www.youtube.com/watch?v=kz6BD1Dj_ms", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w6_l40", "type": "V_lecture", "name": "OT Based on the DDH Assumption", "properties": {"week": 6, "lecture_num": 40, "youtube_url": "https://www.youtube.com/watch?v=ahA6nklRWgY", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w6_l41", "type": "V_lecture", "name": "Pre-Processing Phase for the GMW Protocol", "properties": {"week": 6, "lecture_num": 41, "youtube_url": "https://www.youtube.com/watch?v=siPrjQEjrX4", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w6_l42", "type": "V_lecture", "name": "Pre-Processing Phase for the GMW Protocol: The n-Party Case", "properties": {"week": 6, "lecture_num": 42, "youtube_url": "https://www.youtube.com/watch?v=3gMh7tpELNQ", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w7_l43", "type": "V_lecture", "name": "Pre-Processing Phase for the GMW Protocol Contd.", "properties": {"week": 7, "lecture_num": 43, "youtube_url": "https://www.youtube.com/watch?v=OgF4-uzB4qY", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w7_l44", "type": "V_lecture", "name": "Pre-Processing of OT", "properties": {"week": 7, "lecture_num": 44, "youtube_url": "https://www.youtube.com/watch?v=8LjFySb-UFY", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w7_l45", "type": "V_lecture", "name": "OT Extension", "properties": {"week": 7, "lecture_num": 45, "youtube_url": "https://www.youtube.com/watch?v=-CTEA6VG79g", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w7_l46", "type": "V_lecture", "name": "Analysis of IKNP OT Extension", "properties": {"week": 7, "lecture_num": 46, "youtube_url": "https://www.youtube.com/watch?v=VY3HlyCucPI", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w7_l47", "type": "V_lecture", "name": "Yao\u2019s Protocol for Secure 2PC", "properties": {"week": 7, "lecture_num": 47, "youtube_url": "https://www.youtube.com/watch?v=idxotQw27RU", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w7_l48", "type": "V_lecture", "name": "Yao\u2019s Garbling Scheme", "properties": {"week": 7, "lecture_num": 48, "youtube_url": "https://www.youtube.com/watch?v=OflsREK77EE", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w7_l49", "type": "V_lecture", "name": "Yao\u2019s Protocol for Secure 2PC", "properties": {"week": 7, "lecture_num": 49, "youtube_url": "https://www.youtube.com/watch?v=fKLflqqeuAE", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w8_l50", "type": "V_lecture", "name": "Optimizations for Yao\u2019s Garbling", "properties": {"week": 8, "lecture_num": 50, "youtube_url": "https://www.youtube.com/watch?v=CsprOy0EW78", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w8_l51", "type": "V_lecture", "name": "Interpreting Yao\u2019s Secure 2PC Protocol as a Secret-Sharing Based Protocol", "properties": {"week": 8, "lecture_num": 51, "youtube_url": "https://www.youtube.com/watch?v=aiKXtvR8P04", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w8_l52", "type": "V_lecture", "name": "Mixed Protocols for Secure 2PC", "properties": {"week": 8, "lecture_num": 52, "youtube_url": "https://www.youtube.com/watch?v=mhEz8DoueXg", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w8_l53", "type": "V_lecture", "name": "The Arithmetic, Boolean and Yao Sharing for Secure 2PC", "properties": {"week": 8, "lecture_num": 53, "youtube_url": "https://www.youtube.com/watch?v=ChoL9saTIFI", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w8_l54", "type": "V_lecture", "name": "The ABY Conversions", "properties": {"week": 8, "lecture_num": 54, "youtube_url": "https://www.youtube.com/watch?v=RCI76Ye1m_U", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w8_l55", "type": "V_lecture", "name": "The ABY Conversions Contd.", "properties": {"week": 8, "lecture_num": 55, "youtube_url": "https://www.youtube.com/watch?v=jqeZGO6YUtI", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w8_l56", "type": "V_lecture", "name": "The ABY Conversions Contd.", "properties": {"week": 8, "lecture_num": 56, "youtube_url": "https://www.youtube.com/watch?v=pr857pGN680", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w9_l57", "type": "V_lecture", "name": "ABY Computations : Example", "properties": {"week": 9, "lecture_num": 57, "youtube_url": "https://www.youtube.com/watch?v=spXXRX7Bw30", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w9_l58", "type": "V_lecture", "name": "Goodbye and Farewell", "properties": {"week": 9, "lecture_num": 58, "youtube_url": "https://www.youtube.com/watch?v=M4slsY7nt0k", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w9_l59", "type": "V_lecture", "name": "Live Session 16-09-2021", "properties": {"week": 9, "lecture_num": 59, "youtube_url": "https://www.youtube.com/watch?v=ScoYmXvRSEw", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w9_l60", "type": "V_lecture", "name": "Live Session 06-03-2024", "properties": {"week": 9, "lecture_num": 60, "youtube_url": "https://www.youtube.com/watch?v=cznLuRJH43Q", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w9_l61", "type": "V_lecture", "name": "Live Session 10-02-2025", "properties": {"week": 9, "lecture_num": 61, "youtube_url": "https://www.youtube.com/watch?v=MW2CPalnlIQ", "course_id": "course_106108229"}}
{"id": "lecture_106108229_w9_l62", "type": "V_lecture", "name": "Live Session 24-03-2025", "properties": {"week": 9, "lecture_num": 62, "youtube_url": "https://www.youtube.com/watch?v=INi6NUpEOy0", "course_id": "course_106108229"}}
{"id": "course_106106221", "type": "V_course", "name": "Foundations of Cryptography, IIIT Bangalore", "properties": {"course_id": "noc26-cs18", "nptel_url": "https://nptel.ac.in/courses/106106221", "nptel_id": "106106221", "abstract": "NOC: Foundations of Cryptography, IIIT Bangalore, IIIT Bangalore\nProf. Ashish Choudhury Course Duration :\nJan-Apr 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-04-18\nCourse Abstract\n\nThe course provides the basic paradigm and principles of modern cryptography. The focus of this course will be on definitions and constructions of various cryptographic objects. We will try to understand what security properties are desirable in such objects, how to formally define these properties, and how to design objects that satisfy the definitions. The aim is that at the end of this course, the students are able to understand a significant portion of current cryptography research papers and standards. Course Duration :\nJan-Apr 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-04-18", "professor": "Prof. Ashish Choudhury", "institute": "IISc Bangalore", "duration": "12 Weeks", "stream_id": "stream_computer_science_and_engineering"}}
{"id": "lecture_106106221_w1_l1", "type": "V_lecture", "name": "Introduction", "properties": {"week": 1, "lecture_num": 1, "youtube_url": "https://www.youtube.com/watch?v=iTVyKbDCJrA", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w1_l2", "type": "V_lecture", "name": "Symmetric-key Encryption", "properties": {"week": 1, "lecture_num": 2, "youtube_url": "https://www.youtube.com/watch?v=eIJzIUhks6E", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w1_l3", "type": "V_lecture", "name": "Historical Ciphers and their Cryptanalysis", "properties": {"week": 1, "lecture_num": 3, "youtube_url": "https://www.youtube.com/watch?v=NrRJInkFsyQ", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w1_l4", "type": "V_lecture", "name": "Perfect Security", "properties": {"week": 1, "lecture_num": 4, "youtube_url": "https://www.youtube.com/watch?v=DOMayh6QnTE", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w1_l5", "type": "V_lecture", "name": "Limitations of Perfect Security", "properties": {"week": 1, "lecture_num": 5, "youtube_url": "https://www.youtube.com/watch?v=lDCD2AVis3Q", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w1_l6", "type": "V_lecture", "name": "Introduction to Computational Security", "properties": {"week": 1, "lecture_num": 6, "youtube_url": "https://www.youtube.com/watch?v=N6YzR_8zdE0", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w1_l7", "type": "V_lecture", "name": "Semantic Security", "properties": {"week": 1, "lecture_num": 7, "youtube_url": "https://www.youtube.com/watch?v=UVPNA8so2lg", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w2_l8", "type": "V_lecture", "name": "Pseudo-random Generators (PRGs)", "properties": {"week": 2, "lecture_num": 8, "youtube_url": "https://www.youtube.com/watch?v=00_xpi3zTkU", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w2_l9", "type": "V_lecture", "name": "Operations on Pseudorandom Generators", "properties": {"week": 2, "lecture_num": 9, "youtube_url": "https://www.youtube.com/watch?v=XrHrmus5pAo", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w2_l10", "type": "V_lecture", "name": "Stream Ciphers", "properties": {"week": 2, "lecture_num": 10, "youtube_url": "https://www.youtube.com/watch?v=pBELpoglnvQ", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w2_l11", "type": "V_lecture", "name": "Provably-secure Instantiation of PRG", "properties": {"week": 2, "lecture_num": 11, "youtube_url": "https://www.youtube.com/watch?v=YgB_ae1UjMI", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w2_l12", "type": "V_lecture", "name": "Practical Instantiations of PRG", "properties": {"week": 2, "lecture_num": 12, "youtube_url": "https://www.youtube.com/watch?v=JUYdd4FHC78", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w2_l13", "type": "V_lecture", "name": "CPA-security", "properties": {"week": 2, "lecture_num": 13, "youtube_url": "https://www.youtube.com/watch?v=wXI4cjZzB3A", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w2_l14", "type": "V_lecture", "name": "Pseudo-random Functions (PRFs)", "properties": {"week": 2, "lecture_num": 14, "youtube_url": "https://www.youtube.com/watch?v=_iPVd87B_zc", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w3_l15", "type": "V_lecture", "name": "CPA-secure Encryption from PRF", "properties": {"week": 3, "lecture_num": 15, "youtube_url": "https://www.youtube.com/watch?v=QRquzIsPPJk", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w3_l16", "type": "V_lecture", "name": "Modes of Operations of Block Ciphers Part I", "properties": {"week": 3, "lecture_num": 16, "youtube_url": "https://www.youtube.com/watch?v=3ujQWgW41-M", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w3_l17", "type": "V_lecture", "name": "Modes of Operations of Block Ciphers Part II", "properties": {"week": 3, "lecture_num": 17, "youtube_url": "https://www.youtube.com/watch?v=RKd8I5R_bM8", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w3_l18", "type": "V_lecture", "name": "Theoretical Constructions of Block Ciphers", "properties": {"week": 3, "lecture_num": 18, "youtube_url": "https://www.youtube.com/watch?v=-Oza6jm56eE", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w3_l19", "type": "V_lecture", "name": "Practical Constructions of Block Ciphers: Part I", "properties": {"week": 3, "lecture_num": 19, "youtube_url": "https://www.youtube.com/watch?v=q9CgbEC3qbg", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w3_l20", "type": "V_lecture", "name": "Practical Constructions of Block Ciphers: Part II", "properties": {"week": 3, "lecture_num": 20, "youtube_url": "https://www.youtube.com/watch?v=UxtR-CB69Rw", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w3_l21", "type": "V_lecture", "name": "From Passive to Active Adversary", "properties": {"week": 3, "lecture_num": 21, "youtube_url": "https://www.youtube.com/watch?v=-lYoMYslB10", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w4_l22", "type": "V_lecture", "name": "Message Integrity and Authentication", "properties": {"week": 4, "lecture_num": 22, "youtube_url": "https://www.youtube.com/watch?v=D7law6sIL9Q", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w4_l23", "type": "V_lecture", "name": "Message Authentication for Long Messages : Part I", "properties": {"week": 4, "lecture_num": 23, "youtube_url": "https://www.youtube.com/watch?v=4AKQiWGuQGk", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w4_l24", "type": "V_lecture", "name": "Message Authentication for Long Messages : Part II", "properties": {"week": 4, "lecture_num": 24, "youtube_url": "https://www.youtube.com/watch?v=GRU_AcMX6cU", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w4_l25", "type": "V_lecture", "name": "Information-theoretic MACs : Part I", "properties": {"week": 4, "lecture_num": 25, "youtube_url": "https://www.youtube.com/watch?v=SZHqphyYBQg", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w4_l26", "type": "V_lecture", "name": "Information-theoretic MACs : Part II", "properties": {"week": 4, "lecture_num": 26, "youtube_url": "https://www.youtube.com/watch?v=IAEiNJkz6PI", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w4_l27", "type": "V_lecture", "name": "Cryptographic Hash Functions:  Part I", "properties": {"week": 4, "lecture_num": 27, "youtube_url": "https://www.youtube.com/watch?v=FOk8TN7HQLo", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w4_l28", "type": "V_lecture", "name": "Cryptographic Hash Functions: Part II", "properties": {"week": 4, "lecture_num": 28, "youtube_url": "https://www.youtube.com/watch?v=S5CjxbRDj-s", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w5_l29", "type": "V_lecture", "name": "Message Authentication Using Hash Functions", "properties": {"week": 5, "lecture_num": 29, "youtube_url": "https://www.youtube.com/watch?v=b6cZMalRs84", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w5_l30", "type": "V_lecture", "name": "Generic Attacks on Hash Functions and Additional Applications of Hash Functions", "properties": {"week": 5, "lecture_num": 30, "youtube_url": "https://www.youtube.com/watch?v=l5aQJJpI1kE", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w5_l31", "type": "V_lecture", "name": "Random Oracle Model: Part I", "properties": {"week": 5, "lecture_num": 31, "youtube_url": "https://www.youtube.com/watch?v=lN_5J0IRvAg", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w5_l32", "type": "V_lecture", "name": "Random Oracle Model: Part II", "properties": {"week": 5, "lecture_num": 32, "youtube_url": "https://www.youtube.com/watch?v=STKDTs4gd10", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w5_l33", "type": "V_lecture", "name": "Authenticated Encryption", "properties": {"week": 5, "lecture_num": 33, "youtube_url": "https://www.youtube.com/watch?v=Ez5feo06wy4", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w5_l34", "type": "V_lecture", "name": "Composing CPA-secure Cipher with a Secure MAC:  Part I", "properties": {"week": 5, "lecture_num": 34, "youtube_url": "https://www.youtube.com/watch?v=t-OQFQLEWqw", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w5_l35", "type": "V_lecture", "name": "Composing CPA-secure Cipher with a Secure MAC: Part II", "properties": {"week": 5, "lecture_num": 35, "youtube_url": "https://www.youtube.com/watch?v=h8N3ExKSQSg", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w6_l36", "type": "V_lecture", "name": "Key-Exchange Protocols:  Part I", "properties": {"week": 6, "lecture_num": 36, "youtube_url": "https://www.youtube.com/watch?v=m3BJbPGlTEQ", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w6_l37", "type": "V_lecture", "name": "Key-Exchange Protocols:  Part II", "properties": {"week": 6, "lecture_num": 37, "youtube_url": "https://www.youtube.com/watch?v=lAOeNquHhnM", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w6_l38", "type": "V_lecture", "name": "Cyclic groups", "properties": {"week": 6, "lecture_num": 38, "youtube_url": "https://www.youtube.com/watch?v=0c-0oMjuUv4", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w6_l39", "type": "V_lecture", "name": "Cryptographic Hardness Assumptions in the Cyclic Groups", "properties": {"week": 6, "lecture_num": 39, "youtube_url": "https://www.youtube.com/watch?v=LF9GnfnShUs", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w6_l40", "type": "V_lecture", "name": "Candidate Cyclic Groups for Cryptographic Purposes:  Part I", "properties": {"week": 6, "lecture_num": 40, "youtube_url": "https://www.youtube.com/watch?v=Fs-mNyay6Uc", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w6_l41", "type": "V_lecture", "name": "Candidate Cyclic Groups for Cryptographic Purposes:  Part II", "properties": {"week": 6, "lecture_num": 41, "youtube_url": "https://www.youtube.com/watch?v=debalr6sjMM", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w6_l42", "type": "V_lecture", "name": "Cryptographic Applications of the Discrete Log Assumption", "properties": {"week": 6, "lecture_num": 42, "youtube_url": "https://www.youtube.com/watch?v=19tskoxC7qw", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w7_l43", "type": "V_lecture", "name": "Public-key Encryption", "properties": {"week": 7, "lecture_num": 43, "youtube_url": "https://www.youtube.com/watch?v=tBRP0aSeHyE", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w7_l44", "type": "V_lecture", "name": "El Gamal Public-key Encryption Scheme", "properties": {"week": 7, "lecture_num": 44, "youtube_url": "https://www.youtube.com/watch?v=D7qYmC-PoBI", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w7_l45", "type": "V_lecture", "name": "RSA Assumption", "properties": {"week": 7, "lecture_num": 45, "youtube_url": "https://www.youtube.com/watch?v=sb-0W2EMvMY", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w7_l46", "type": "V_lecture", "name": "RSA Public-key Cryptosystem", "properties": {"week": 7, "lecture_num": 46, "youtube_url": "https://www.youtube.com/watch?v=gVPyTRbBc70", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w7_l47", "type": "V_lecture", "name": "Hybrid Public-key Cryptosystem", "properties": {"week": 7, "lecture_num": 47, "youtube_url": "https://www.youtube.com/watch?v=rQrVuH5HFIk", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w7_l48", "type": "V_lecture", "name": "CCA-Secure Public-key Ciphers", "properties": {"week": 7, "lecture_num": 48, "youtube_url": "https://www.youtube.com/watch?v=UGqHs7MmCBQ", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w7_l49", "type": "V_lecture", "name": "CCA-Secure Public-key Ciphers Based on Diffie-Hellman Problems", "properties": {"week": 7, "lecture_num": 49, "youtube_url": "https://www.youtube.com/watch?v=KBhcg9jnU3Q", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w8_l50", "type": "V_lecture", "name": "CCA-Secure Public-key Ciphers Based on RSA Assumption", "properties": {"week": 8, "lecture_num": 50, "youtube_url": "https://www.youtube.com/watch?v=71YY4Pf6FtU", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w8_l51", "type": "V_lecture", "name": "Digital Signatures", "properties": {"week": 8, "lecture_num": 51, "youtube_url": "https://www.youtube.com/watch?v=JMq2RaFYWXI", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w8_l52", "type": "V_lecture", "name": "RSA Signatures", "properties": {"week": 8, "lecture_num": 52, "youtube_url": "https://www.youtube.com/watch?v=ML5ncYzTks4", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w8_l53", "type": "V_lecture", "name": "Identification Schemes", "properties": {"week": 8, "lecture_num": 53, "youtube_url": "https://www.youtube.com/watch?v=vANEg9zVPxM", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w8_l54", "type": "V_lecture", "name": "Schnorr Signature Scheme and TLS/SSL", "properties": {"week": 8, "lecture_num": 54, "youtube_url": "https://www.youtube.com/watch?v=y5vBnyPpkWI", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w8_l55", "type": "V_lecture", "name": "Number Theory", "properties": {"week": 8, "lecture_num": 55, "youtube_url": "https://www.youtube.com/watch?v=H4j-NU011Dc", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w8_l56", "type": "V_lecture", "name": "Secret Sharing", "properties": {"week": 8, "lecture_num": 56, "youtube_url": "https://www.youtube.com/watch?v=Rsn8HjNiQpA", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w9_l57", "type": "V_lecture", "name": "Zero-Knowledge Protocols:  Part I", "properties": {"week": 9, "lecture_num": 57, "youtube_url": "https://www.youtube.com/watch?v=Ntt7CLHaepU", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w9_l58", "type": "V_lecture", "name": "Zero-Knowledge Protocols:  Part II", "properties": {"week": 9, "lecture_num": 58, "youtube_url": "https://www.youtube.com/watch?v=AsIAQhG5_hA", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w9_l59", "type": "V_lecture", "name": "Good Bye for Now", "properties": {"week": 9, "lecture_num": 59, "youtube_url": "https://www.youtube.com/watch?v=-Wja13AA2DA", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w9_l60", "type": "V_lecture", "name": "Live Session 18-02-2021", "properties": {"week": 9, "lecture_num": 60, "youtube_url": "https://www.youtube.com/watch?v=LmY8X_VtuCY", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w9_l61", "type": "V_lecture", "name": "Live Session 10-03-2020", "properties": {"week": 9, "lecture_num": 61, "youtube_url": "https://www.youtube.com/watch?v=3eeqecuG2h8", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w9_l62", "type": "V_lecture", "name": "Live Session 14-02-2022", "properties": {"week": 9, "lecture_num": 62, "youtube_url": "https://www.youtube.com/watch?v=HfL-J1qpACg", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w9_l63", "type": "V_lecture", "name": "Live Session 19-04-2022", "properties": {"week": 9, "lecture_num": 63, "youtube_url": "https://www.youtube.com/watch?v=6_cp4JZNKDA", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w10_l64", "type": "V_lecture", "name": "Live Session 06-03-2024", "properties": {"week": 10, "lecture_num": 64, "youtube_url": "https://www.youtube.com/watch?v=ez0LXL0O9mk", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w10_l65", "type": "V_lecture", "name": "Live Session 10-02-2025", "properties": {"week": 10, "lecture_num": 65, "youtube_url": "https://www.youtube.com/watch?v=-QxG9KmFFVU", "course_id": "course_106106221"}}
{"id": "lecture_106106221_w10_l66", "type": "V_lecture", "name": "Live Session 24-03-2025", "properties": {"week": 10, "lecture_num": 66, "youtube_url": "https://www.youtube.com/watch?v=3EgIJIqlACg", "course_id": "course_106106221"}}
{"id": "course_106101360", "type": "V_course", "name": "Games and Information", "properties": {"course_id": "noc26-cs21", "nptel_url": "https://nptel.ac.in/courses/106101360", "nptel_id": "106101360", "abstract": "NOC: Games and Information, IIT Bombay\nProf. Ankur A. Kulkarni Course Duration :\nJan-Apr 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-04-18\nCourse Abstract\n\nThis is an advanced course in game theory, with a particular emphasis on the role of information. We begin with static games and cover the basic notations there. About 65% of the course concerns dynamic games where we introduce information structures, role of information structure on equilibria, Bayesian games and information asymmetry. We then cover the basic concepts of mechanism design. We do a quick overview of signaling and screening, and introduce information design. As a final topic we do a study of pre-play communication \u00e2\u20ac\u201c achievable payoffs and correlated equilibria. We finally end with a few applications of game theory in finance.\n\nINTENDED AUDIENCE: Graduate students in engineering and economics.\n\nPREREQUISITES: No prerequisites.\n\nINDUSTRY SUPPORT: Stock and commodity exchanges, platforms like Ola, Uber, Amazon. Course Duration :\nJan-Apr 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-04-18", "professor": "Prof. Ankur A. Kulkarni", "institute": "IIT Bombay", "duration": "12 Weeks", "stream_id": "stream_computer_science_and_engineering"}}
{"id": "lecture_106101360_w1_l1", "type": "V_lecture", "name": "Week 1: Lecture 1: Introduction, why do delays happen, contention for resources", "properties": {"week": 1, "lecture_num": 1, "youtube_url": "https://www.youtube.com/watch?v=yXlNtu7PkTI", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w1_l2", "type": "V_lecture", "name": "Week 1: Lecture 2: Performance metrics and parameters", "properties": {"week": 1, "lecture_num": 2, "youtube_url": "https://www.youtube.com/watch?v=HyhScBeEMCc", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w1_l3", "type": "V_lecture", "name": "Week 1: Lecture 3: Introducing Queuing Systems", "properties": {"week": 1, "lecture_num": 3, "youtube_url": "https://www.youtube.com/watch?v=g5ON0ij5DM0", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w1_l4", "type": "V_lecture", "name": "Week 1: Lecture 4: Memoryless Distributions", "properties": {"week": 1, "lecture_num": 4, "youtube_url": "https://www.youtube.com/watch?v=CuA6mwTcB64", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w1_l5", "type": "V_lecture", "name": "Week 1: Lecture 5: Operational Laws", "properties": {"week": 1, "lecture_num": 5, "youtube_url": "https://www.youtube.com/watch?v=TFOH0GSsiZc", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w2_l6", "type": "V_lecture", "name": "Week 2: Lecture 6: Aumann model of incomplete information: Definition and Examples", "properties": {"week": 2, "lecture_num": 6, "youtube_url": "https://www.youtube.com/watch?v=34x7MXdxVHI", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w2_l7", "type": "V_lecture", "name": "Week 2: Lecture 7: Knowledge operator: Definition and Examples", "properties": {"week": 2, "lecture_num": 7, "youtube_url": "https://www.youtube.com/watch?v=QHNIcGQWt3M", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w2_l8", "type": "V_lecture", "name": "Week 2: Lecture 8: Common knowledge: Definition and Examples", "properties": {"week": 2, "lecture_num": 8, "youtube_url": "https://www.youtube.com/watch?v=C9Fh4U8xsZ8", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w2_l9", "type": "V_lecture", "name": "Week 2: Lecture 9: The structural theorem of common knowledge", "properties": {"week": 2, "lecture_num": 9, "youtube_url": "https://www.youtube.com/watch?v=CLt_tkFPs9s", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w2_l10", "type": "V_lecture", "name": "Week 2: Lecture 10: Proof of the structural theorem (forward direction)", "properties": {"week": 2, "lecture_num": 10, "youtube_url": "https://www.youtube.com/watch?v=mXuNp0ycMcs", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w2_l11", "type": "V_lecture", "name": "Week 2: Lecture 11: Proof of the structural theorem (backward direction)", "properties": {"week": 2, "lecture_num": 11, "youtube_url": "https://www.youtube.com/watch?v=tbIDprzGjro", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w2_l12", "type": "V_lecture", "name": "Week 2: Lecture 12: Aumann model of incomplete information with belief: Definition and Examples", "properties": {"week": 2, "lecture_num": 12, "youtube_url": "https://www.youtube.com/watch?v=pDP3dF_Mb_Q", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w2_l13", "type": "V_lecture", "name": "Week 2: Lecture 13: Aumann's agreement theorem", "properties": {"week": 2, "lecture_num": 13, "youtube_url": "https://www.youtube.com/watch?v=iz3y9anHRwY", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w3_l14", "type": "V_lecture", "name": "Week 3: Lecture 14: Zero-sum game definition and Security strategies", "properties": {"week": 3, "lecture_num": 14, "youtube_url": "https://www.youtube.com/watch?v=Bd2sJjQJlGU", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w3_l15", "type": "V_lecture", "name": "Week 3: Lecture 15: Saddle point strategies", "properties": {"week": 3, "lecture_num": 15, "youtube_url": "https://www.youtube.com/watch?v=1q4iSseIuvE", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w3_l16", "type": "V_lecture", "name": "Week 3: Lecture 16: Further properties of saddle point strategies", "properties": {"week": 3, "lecture_num": 16, "youtube_url": "https://www.youtube.com/watch?v=WjLmH-91M00", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w3_l17", "type": "V_lecture", "name": "Week 3: Lecture 17: Mixed strategies", "properties": {"week": 3, "lecture_num": 17, "youtube_url": "https://www.youtube.com/watch?v=c4HTBQmknMM", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w4_l18", "type": "V_lecture", "name": "Week 4: Lecture 18: Weirstrass lemma and existence of a mixed saddle point strategy", "properties": {"week": 4, "lecture_num": 18, "youtube_url": "https://www.youtube.com/watch?v=dmuhyoXsqEo", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w4_l19", "type": "V_lecture", "name": "Week 4: Lecture 19: Von Nuenmann minmax theorem", "properties": {"week": 4, "lecture_num": 19, "youtube_url": "https://www.youtube.com/watch?v=tQ-x_xfUyhc", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w4_l20", "type": "V_lecture", "name": "Week 4: Lecture 20: Computing mixed saddle point startegy: Holmes and Moriarty", "properties": {"week": 4, "lecture_num": 20, "youtube_url": "https://www.youtube.com/watch?v=3r5WHXdNRto", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w4_l21", "type": "V_lecture", "name": "Week 4: Lecture 21: Computing mixed strategy saddle point: 2X2 matrix game", "properties": {"week": 4, "lecture_num": 21, "youtube_url": "https://www.youtube.com/watch?v=_jJUXY1DU8M", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w4_l22", "type": "V_lecture", "name": "Week 4: Lecture 22: Computing mixed strategy saddle point: 2X3 matrix game", "properties": {"week": 4, "lecture_num": 22, "youtube_url": "https://www.youtube.com/watch?v=QOnl_E66drA", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w5_l23", "type": "V_lecture", "name": "Week 5: Lecture 23: Nash equilibrium of a non zero-sum game and its relation with Kakutani fixed...", "properties": {"week": 5, "lecture_num": 23, "youtube_url": "https://www.youtube.com/watch?v=pk2BwEtPPnE", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w5_l24", "type": "V_lecture", "name": "Week 5: Lecture 24: Proof: Existence of Nash equilibrium (Condition 1 of Kakutani fixed point...)", "properties": {"week": 5, "lecture_num": 24, "youtube_url": "https://www.youtube.com/watch?v=L9OJc_fsM0s", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w5_l25", "type": "V_lecture", "name": "Week 5: Lecture 25: Proof: Existence of Nash equilibrium (Condition 2 of Kakutani fixed...)", "properties": {"week": 5, "lecture_num": 25, "youtube_url": "https://www.youtube.com/watch?v=BPC0Hw1jhEc", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w5_l26", "type": "V_lecture", "name": "Week 5: Lecture 26: Existence of Nash equilibrium for infinite strategy space (Using Brower's ...)", "properties": {"week": 5, "lecture_num": 26, "youtube_url": "https://www.youtube.com/watch?v=_A8pckIq-No", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w5_l27", "type": "V_lecture", "name": "Week 5: Lecture 27: Quantal Response: Motivation", "properties": {"week": 5, "lecture_num": 27, "youtube_url": "https://www.youtube.com/watch?v=8JA7_DkWT20", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w5_l28", "type": "V_lecture", "name": "Week 5: Lecture 28: Quantal Response: Formal model", "properties": {"week": 5, "lecture_num": 28, "youtube_url": "https://www.youtube.com/watch?v=27IAqhPnFX8", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w6_l29", "type": "V_lecture", "name": "Week 6: Lecture 29: Dynamic games definiton", "properties": {"week": 6, "lecture_num": 29, "youtube_url": "https://www.youtube.com/watch?v=wv_QaGzNiHY", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w6_l30", "type": "V_lecture", "name": "Week 6: Lecture 30: Solution concept in dynamic games", "properties": {"week": 6, "lecture_num": 30, "youtube_url": "https://www.youtube.com/watch?v=Iobvcwjg4Ew", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w6_l31", "type": "V_lecture", "name": "Week 6: Lecture 31: Relation of the heuristic solution with the Nash equilibrium of the standard ...", "properties": {"week": 6, "lecture_num": 31, "youtube_url": "https://www.youtube.com/watch?v=ZE1ZrLs_UEQ", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w6_l32", "type": "V_lecture", "name": "Week 6: Lecture 32: Example of a Threat equilibrium", "properties": {"week": 6, "lecture_num": 32, "youtube_url": "https://www.youtube.com/watch?v=NJyOomRaU9w", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w6_l33", "type": "V_lecture", "name": "Week 6: Lecture 33: Interpreting the threat equilibrium in standard normal form of the dynamic game", "properties": {"week": 6, "lecture_num": 33, "youtube_url": "https://www.youtube.com/watch?v=kFDzlGFjOtA", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w7_l34", "type": "V_lecture", "name": "Week 7: Lecture 34: Extensive form games I", "properties": {"week": 7, "lecture_num": 34, "youtube_url": "https://www.youtube.com/watch?v=b8knJDikL4s", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w7_l35", "type": "V_lecture", "name": "Week 7: Lecture 35: Extensive form games II", "properties": {"week": 7, "lecture_num": 35, "youtube_url": "https://www.youtube.com/watch?v=PgA8atHuO0M", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w7_l36", "type": "V_lecture", "name": "Week 7: Lecture 36: Single Act Games", "properties": {"week": 7, "lecture_num": 36, "youtube_url": "https://www.youtube.com/watch?v=hIQ1iz_25XA", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w7_l37", "type": "V_lecture", "name": "Week 7: Lecture 37: Informationally inferior games", "properties": {"week": 7, "lecture_num": 37, "youtube_url": "https://www.youtube.com/watch?v=UPftdT5yp4c", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w8_l38", "type": "V_lecture", "name": "Week 8: Lecture 38: Information Structure in Single Act Games", "properties": {"week": 8, "lecture_num": 38, "youtube_url": "https://www.youtube.com/watch?v=fDGkMmORlAk", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w8_l39", "type": "V_lecture", "name": "Week 8: Lecture 39: Nested and Ladder Nested Extensive form games", "properties": {"week": 8, "lecture_num": 39, "youtube_url": "https://www.youtube.com/watch?v=gBviiWlw_1o", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w8_l40", "type": "V_lecture", "name": "Week 8: Lecture 40: Equilibrium Algorithm", "properties": {"week": 8, "lecture_num": 40, "youtube_url": "https://www.youtube.com/watch?v=sPv4J2JO07U", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w8_l41", "type": "V_lecture", "name": "Week 8: Lecture 41: Stage-wise multi act games", "properties": {"week": 8, "lecture_num": 41, "youtube_url": "https://www.youtube.com/watch?v=IgHoxULgSDs", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w8_l42", "type": "V_lecture", "name": "Week 8: Lecture 42: Feedback equilibrium", "properties": {"week": 8, "lecture_num": 42, "youtube_url": "https://www.youtube.com/watch?v=JRVkzBTJ96E", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w9_l43", "type": "V_lecture", "name": "Week 9: Lecture 43: Mixed and Behavioral Strategies", "properties": {"week": 9, "lecture_num": 43, "youtube_url": "https://www.youtube.com/watch?v=X1Av1f36YFM", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w9_l44", "type": "V_lecture", "name": "Week 9: Lecture 44: Conditions for equivalence for mixed and behavioral strategies", "properties": {"week": 9, "lecture_num": 44, "youtube_url": "https://www.youtube.com/watch?v=psf-AKiTHp0", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w9_l45", "type": "V_lecture", "name": "Week 9: Lecture 45: Kuhn's Theorem I", "properties": {"week": 9, "lecture_num": 45, "youtube_url": "https://www.youtube.com/watch?v=N6kfggbPlxg", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w9_l46", "type": "V_lecture", "name": "Week 9: Lecture 46: Kuhn's Theorem II", "properties": {"week": 9, "lecture_num": 46, "youtube_url": "https://www.youtube.com/watch?v=Bw0L385INFc", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w9_l47", "type": "V_lecture", "name": "Week 9: Lecture 47: Kuhn's Theorem III", "properties": {"week": 9, "lecture_num": 47, "youtube_url": "https://www.youtube.com/watch?v=LO-kBjXvL2w", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w10_l48", "type": "V_lecture", "name": "Week 10: Lecture 48: Games of incomplete information", "properties": {"week": 10, "lecture_num": 48, "youtube_url": "https://www.youtube.com/watch?v=UA6HDBww4hw", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w10_l49", "type": "V_lecture", "name": "Week 10: Lecture 49: Bayesian Nash equilibrium I", "properties": {"week": 10, "lecture_num": 49, "youtube_url": "https://www.youtube.com/watch?v=vKrenRjf6HY", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w10_l50", "type": "V_lecture", "name": "Week 10: Lecture 50: Bayesian Nash equilibrium II", "properties": {"week": 10, "lecture_num": 50, "youtube_url": "https://www.youtube.com/watch?v=e0TAAhNJ6Mo", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w10_l51", "type": "V_lecture", "name": "Week 10: Lecture 51: Self-enforcement of Nash equilibrium", "properties": {"week": 10, "lecture_num": 51, "youtube_url": "https://www.youtube.com/watch?v=GFz_nm-8n54", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w10_l52", "type": "V_lecture", "name": "Week 10: Lecture 52: Stackelberg game", "properties": {"week": 10, "lecture_num": 52, "youtube_url": "https://www.youtube.com/watch?v=zmNoq0m2Nss", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w11_l53", "type": "V_lecture", "name": "Week 11: Lecture 53: Principal-Agent Models I", "properties": {"week": 11, "lecture_num": 53, "youtube_url": "https://www.youtube.com/watch?v=LxMjR4iC3TU", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w11_l54", "type": "V_lecture", "name": "Week 11: Lecture 54: Principal-Agent Models II", "properties": {"week": 11, "lecture_num": 54, "youtube_url": "https://www.youtube.com/watch?v=mCj6lXyqDO4", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w11_l55", "type": "V_lecture", "name": "Week 11: Lecture 55: Moral Hazard and Adverse selection", "properties": {"week": 11, "lecture_num": 55, "youtube_url": "https://www.youtube.com/watch?v=MyWCHFA1BqY", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w11_l56", "type": "V_lecture", "name": "Week 11: Lecture 56: Games with contracts", "properties": {"week": 11, "lecture_num": 56, "youtube_url": "https://www.youtube.com/watch?v=Ga-d7x8raZ0", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w12_l57", "type": "V_lecture", "name": "Week 12: Lecture 57: Correlated Equilibrium I", "properties": {"week": 12, "lecture_num": 57, "youtube_url": "https://www.youtube.com/watch?v=rc9khLyPDgo", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w12_l58", "type": "V_lecture", "name": "Week 12: Lecture 58: Correlated Equilibrium II", "properties": {"week": 12, "lecture_num": 58, "youtube_url": "https://www.youtube.com/watch?v=YNiYo4aceDM", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w12_l59", "type": "V_lecture", "name": "Week 12: Lecture 59: Correlated Equilibrium III", "properties": {"week": 12, "lecture_num": 59, "youtube_url": "https://www.youtube.com/watch?v=qjrJH0M6tYw", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w12_l60", "type": "V_lecture", "name": "Week 12: Lecture 60: Bayesian Game with mediated communication", "properties": {"week": 12, "lecture_num": 60, "youtube_url": "https://www.youtube.com/watch?v=jlwGr5Ik5nM", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w12_l61", "type": "V_lecture", "name": "Week 12: Lecture 61: Revelation Principle", "properties": {"week": 12, "lecture_num": 61, "youtube_url": "https://www.youtube.com/watch?v=RkCgknUKi-E", "course_id": "course_106101360"}}
{"id": "lecture_106101360_w9_l62", "type": "V_lecture", "name": "Live Session 17-04-2024", "properties": {"week": 9, "lecture_num": 62, "youtube_url": "https://www.youtube.com/watch?v=gIF1jDmWL6I", "course_id": "course_106101360"}}
{"id": "course_108102169", "type": "V_course", "name": "Introduction to Embedded System Design", "properties": {"course_id": "noc26-cs22", "nptel_url": "https://nptel.ac.in/courses/108102169", "nptel_id": "108102169", "abstract": "NOC: Introduction to Embedded System Design, Netaji Subhas University of Technology and IIT Jammu\nProf. Dhananjay V. Gadre Prof. Badri N Subudhi Course Duration :\nJan-Apr 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-04-19\nCourse Abstract\n\nEmbedded Systems surround us in the form of gadgets and devices that we use. There is no aspect of human lives, which is untouched by such devices at home or for health diagnostics, transportation, entertainment. Learning out Embedded Systems will give the skills to design and manufacture embedded system products of the future which will help participants towards better employability. This course teaches embedded system design using a building block approach, which allows one to visualize the requirement of an embedded system and then to design it efficiently. The course will teach embedded system design using a microcontroller, namely Texas Instruments MSP430 low power microcontroller. The course will introduce various interfacing techniques for popular input devices including sensors, output devices and communication protocols. It will teach power supply design for embedded applications. It will also teach effective embedded programming techniques in C and how to maintain code using GIT. It will have a significant practical component, which will be achieved through a MSP430 microcontroller kit, to be distributed for free, to selected participants. Course Duration :\nJan-Apr 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-04-19", "professor": "Prof. Dhananjay V. Gadre\nProf. Badri N Subudhi", "institute": "Netaji Subhas University of Technology\nIIT Jammu", "duration": "12 Weeks", "stream_id": "stream_computer_science_and_engineering"}}
{"id": "lecture_108102169_w1_l1", "type": "V_lecture", "name": "Introduction", "properties": {"week": 1, "lecture_num": 1, "youtube_url": "https://www.youtube.com/watch?v=MkXydhCPnYM", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w1_l2", "type": "V_lecture", "name": "Introduction continued with Project demos", "properties": {"week": 1, "lecture_num": 2, "youtube_url": "https://www.youtube.com/watch?v=gyCDK4pNFS0", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w1_l3", "type": "V_lecture", "name": "Modular Approach to ESD", "properties": {"week": 1, "lecture_num": 3, "youtube_url": "https://www.youtube.com/watch?v=I3XuxQurw1U", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w1_l4", "type": "V_lecture", "name": "Modular Approach to ESD Continued", "properties": {"week": 1, "lecture_num": 4, "youtube_url": "https://www.youtube.com/watch?v=H9-bzaB6Xm8", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w1_l5", "type": "V_lecture", "name": "Salient Features of Modern Microcontrollers", "properties": {"week": 1, "lecture_num": 5, "youtube_url": "https://www.youtube.com/watch?v=EK0qxY7JsAo", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w1_l6", "type": "V_lecture", "name": "Salient Features of Modern Microcontrollers Continued", "properties": {"week": 1, "lecture_num": 6, "youtube_url": "https://www.youtube.com/watch?v=Agrmtc2yTzQ", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w1_l7", "type": "V_lecture", "name": "Elements of Microcontroller Ecosystem", "properties": {"week": 1, "lecture_num": 7, "youtube_url": "https://www.youtube.com/watch?v=c9-LGOXpnZc", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w2_l8", "type": "V_lecture", "name": "Elements of Microcontroller Ecosystem Continued", "properties": {"week": 2, "lecture_num": 8, "youtube_url": "https://www.youtube.com/watch?v=zVxBEkaeHQc", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w2_l9", "type": "V_lecture", "name": "Power Supply for Embedded Systems", "properties": {"week": 2, "lecture_num": 9, "youtube_url": "https://www.youtube.com/watch?v=iRwk7K8Lgvo", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w2_l10", "type": "V_lecture", "name": "Power Supply for Embedded Systems Continued", "properties": {"week": 2, "lecture_num": 10, "youtube_url": "https://www.youtube.com/watch?v=U7jAXAP00nk", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w2_l11", "type": "V_lecture", "name": "Introduction to MSP430", "properties": {"week": 2, "lecture_num": 11, "youtube_url": "https://www.youtube.com/watch?v=hMTgssIfb7U", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w2_l12", "type": "V_lecture", "name": "MSP430 Architecture", "properties": {"week": 2, "lecture_num": 12, "youtube_url": "https://www.youtube.com/watch?v=dXFcmVpkf1Y", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w2_l13", "type": "V_lecture", "name": "MSP430 Architecture- Continued. And Introduction to Lunchbox", "properties": {"week": 2, "lecture_num": 13, "youtube_url": "https://www.youtube.com/watch?v=wtuI4oLDvuE", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w2_l14", "type": "V_lecture", "name": "Programming Methods for MSP430", "properties": {"week": 2, "lecture_num": 14, "youtube_url": "https://www.youtube.com/watch?v=cHnKDTF4oXo", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w3_l15", "type": "V_lecture", "name": "Physical Interfacing -1", "properties": {"week": 3, "lecture_num": 15, "youtube_url": "https://www.youtube.com/watch?v=VnszKjDsUWk", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w3_l16", "type": "V_lecture", "name": "Physical Interfacing -2", "properties": {"week": 3, "lecture_num": 16, "youtube_url": "https://www.youtube.com/watch?v=Kp8AXob1Nag", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w3_l17", "type": "V_lecture", "name": "Physical Interfacing -3", "properties": {"week": 3, "lecture_num": 17, "youtube_url": "https://www.youtube.com/watch?v=IVmJ6aTf3jE", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w3_l18", "type": "V_lecture", "name": "Physical Interfacing -4", "properties": {"week": 3, "lecture_num": 18, "youtube_url": "https://www.youtube.com/watch?v=CL8VputrIU8", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w3_l19", "type": "V_lecture", "name": "Physical Interfacing -5", "properties": {"week": 3, "lecture_num": 19, "youtube_url": "https://www.youtube.com/watch?v=gnk94kO1PHw", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w3_l20", "type": "V_lecture", "name": "Physical Interfacing -6", "properties": {"week": 3, "lecture_num": 20, "youtube_url": "https://www.youtube.com/watch?v=zhdwN7OKYN4", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w3_l21", "type": "V_lecture", "name": "GIT, CCS Installation and Embedded C", "properties": {"week": 3, "lecture_num": 21, "youtube_url": "https://www.youtube.com/watch?v=ZsL-hF2mrA8", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w4_l22", "type": "V_lecture", "name": "MSP430 Digital I/O", "properties": {"week": 4, "lecture_num": 22, "youtube_url": "https://www.youtube.com/watch?v=fiaCA8VQLNg", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w4_l23", "type": "V_lecture", "name": "MSP430 Digital I/O: Switch Interfacing", "properties": {"week": 4, "lecture_num": 23, "youtube_url": "https://www.youtube.com/watch?v=mMzXhfPb_w4", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w4_l24", "type": "V_lecture", "name": "MSP430 Clock System and Reset", "properties": {"week": 4, "lecture_num": 24, "youtube_url": "https://www.youtube.com/watch?v=5yJcYlfq8rQ", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w4_l25", "type": "V_lecture", "name": "Interrupts in MSP430", "properties": {"week": 4, "lecture_num": 25, "youtube_url": "https://www.youtube.com/watch?v=9ztkdsftkow", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w4_l26", "type": "V_lecture", "name": "Interrupts in MSP430- Continued", "properties": {"week": 4, "lecture_num": 26, "youtube_url": "https://www.youtube.com/watch?v=oiCMlloWTQ0", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w4_l27", "type": "V_lecture", "name": "Interfacing Seven Segment Displays with MSP430; Low Power Modes in MSP430", "properties": {"week": 4, "lecture_num": 27, "youtube_url": "https://www.youtube.com/watch?v=gyOnGEZzXaY", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w4_l28", "type": "V_lecture", "name": "Interfacing Liquid Crystal Displays(LCD)", "properties": {"week": 4, "lecture_num": 28, "youtube_url": "https://www.youtube.com/watch?v=nLkxUn6tLhA", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w5_l29", "type": "V_lecture", "name": "MSP430 Timer Module: Introduction and Timer Capture", "properties": {"week": 5, "lecture_num": 29, "youtube_url": "https://www.youtube.com/watch?v=sVXmEYEMH3A", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w5_l30", "type": "V_lecture", "name": "Pulse Width Modulation, PWM using Timer Capture", "properties": {"week": 5, "lecture_num": 30, "youtube_url": "https://www.youtube.com/watch?v=o_oWKJx4Xvw", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w5_l31", "type": "V_lecture", "name": "Analog to Digital Converter in the MSP430", "properties": {"week": 5, "lecture_num": 31, "youtube_url": "https://www.youtube.com/watch?v=4DrOn_waYMk", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w5_l32", "type": "V_lecture", "name": "ADC and DAC using R2R Ladder and Random number generation using LFSR", "properties": {"week": 5, "lecture_num": 32, "youtube_url": "https://www.youtube.com/watch?v=jQv33cafmpM", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w5_l33", "type": "V_lecture", "name": "Serial Communication Protocols, USCI Module in MSP430", "properties": {"week": 5, "lecture_num": 33, "youtube_url": "https://www.youtube.com/watch?v=nLLcoGVcbJQ", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w5_l34", "type": "V_lecture", "name": "MSP430 Timer in Capture Mode", "properties": {"week": 5, "lecture_num": 34, "youtube_url": "https://www.youtube.com/watch?v=WX4rmuywpSo", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w5_l35", "type": "V_lecture", "name": "Coding Ninja", "properties": {"week": 5, "lecture_num": 35, "youtube_url": "https://www.youtube.com/watch?v=jCrt8RdO9qI", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w6_l36", "type": "V_lecture", "name": "Building an Electronics Project", "properties": {"week": 6, "lecture_num": 36, "youtube_url": "https://www.youtube.com/watch?v=6dmFuQtG0Eo", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w6_l37", "type": "V_lecture", "name": "Circuit Prototyping Techniques", "properties": {"week": 6, "lecture_num": 37, "youtube_url": "https://www.youtube.com/watch?v=70LG9yuO6PA", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w6_l38", "type": "V_lecture", "name": "Single Purpose Computers", "properties": {"week": 6, "lecture_num": 38, "youtube_url": "https://www.youtube.com/watch?v=bB9bWQJPHdM", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w6_l39", "type": "V_lecture", "name": "Single Purpose Computers - Continued", "properties": {"week": 6, "lecture_num": 39, "youtube_url": "https://www.youtube.com/watch?v=P6n3dLzD_Ko", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w6_l40", "type": "V_lecture", "name": "Recap of Course Coverage and Project Demonstration from Concept to Final", "properties": {"week": 6, "lecture_num": 40, "youtube_url": "https://www.youtube.com/watch?v=JE6_zAT0puA", "course_id": "course_108102169"}}
{"id": "lecture_108102169_w6_l41", "type": "V_lecture", "name": "Live Session 14-10-2020", "properties": {"week": 6, "lecture_num": 41, "youtube_url": "https://www.youtube.com/watch?v=4g-RH0aZaFQ", "course_id": "course_108102169"}}
{"id": "course_106102229", "type": "V_course", "name": "Advanced Computer Architecture", "properties": {"course_id": "noc26-cs23", "nptel_url": "https://nptel.ac.in/courses/106102229", "nptel_id": "106102229", "abstract": "NOC: Advanced Computer Architecture, IIT Delhi\nProf. Smruti R.Sarangi Course Duration :\nJan-Apr 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-04-18\nCourse Abstract\n\nThis course is on Advanced Computer Architecture. It will introduce students to advanced aspects of processor design and will specifically focus on out-of-order pipelines, GPUs, and compiler techniques for enhancing ILP. The course will subsequently move on to cache design and main memory technologies such as DDR-4. A substantial portion of the course will be devoted to the theory of on-chip networks and memory models. The last part of the course will cover aspects of low-power design, hardware security, and reliability. Course Duration :\nJan-Apr 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-04-18", "professor": "Prof. Smruti R.Sarangi", "institute": "IIT Delhi", "duration": "12 Weeks", "stream_id": "stream_computer_science_and_engineering"}}
{"id": "lecture_106102229_w1_l1", "type": "V_lecture", "name": "Introduction", "properties": {"week": 1, "lecture_num": 1, "youtube_url": "https://www.youtube.com/watch?v=b_6eJykAlQ4", "course_id": "course_106102229"}}
{"id": "lecture_106102229_w1_l2", "type": "V_lecture", "name": "Out-of-Order Pipelines (Part - I)", "properties": {"week": 1, "lecture_num": 2, "youtube_url": "https://www.youtube.com/watch?v=kAPiIp-pIDA", "course_id": "course_106102229"}}
{"id": "lecture_106102229_w1_l3", "type": "V_lecture", "name": "Out-of-Order Pipelines (Part - II)", "properties": {"week": 1, "lecture_num": 3, "youtube_url": "https://www.youtube.com/watch?v=gpBoJGCBfQQ", "course_id": "course_106102229"}}
{"id": "lecture_106102229_w1_l4", "type": "V_lecture", "name": "Out-of-Order Pipelines (Part - III)", "properties": {"week": 1, "lecture_num": 4, "youtube_url": "https://www.youtube.com/watch?v=R5yjBpOaKb4", "course_id": "course_106102229"}}
{"id": "lecture_106102229_w1_l5", "type": "V_lecture", "name": "The Fetch and Decode Stages (Part - I)", "properties": {"week": 1, "lecture_num": 5, "youtube_url": "https://www.youtube.com/watch?v=pqDRgYqC_Lk", "course_id": "course_106102229"}}
{"id": "lecture_106102229_w1_l6", "type": "V_lecture", "name": "The Fetch and Decode Stages (Part - II)", "properties": {"week": 1, "lecture_num": 6, "youtube_url": "https://www.youtube.com/watch?v=e0tbfINKPNE", "course_id": "course_106102229"}}
{"id": "lecture_106102229_w1_l7", "type": "V_lecture", "name": "The Fetch and Decode Stages (Part - III)", "properties": {"week": 1, "lecture_num": 7, "youtube_url": "https://www.youtube.com/watch?v=dSvCbiS9AUo", "course_id": "course_106102229"}}
{"id": "lecture_106102229_w2_l8", "type": "V_lecture", "name": "The Issue, Execute and Commit Stages (Part - I)", "properties": {"week": 2, "lecture_num": 8, "youtube_url": "https://www.youtube.com/watch?v=r9Mbrnomy1g", "course_id": "course_106102229"}}
{"id": "lecture_106102229_w2_l9", "type": "V_lecture", "name": "The Issue, Execute and Commit Stages (Part - II)", "properties": {"week": 2, "lecture_num": 9, "youtube_url": "https://www.youtube.com/watch?v=eiJ9t__tSiY", "course_id": "course_106102229"}}
{"id": "lecture_106102229_w2_l10", "type": "V_lecture", "name": "The Issue, Execute and Commit Stages (Part - III)", "properties": {"week": 2, "lecture_num": 10, "youtube_url": "https://www.youtube.com/watch?v=AqacdvOHh6Y", "course_id": "course_106102229"}}
{"id": "lecture_106102229_w2_l11", "type": "V_lecture", "name": "The Issue, Execute and Commit Stages (Part - IV)", "properties": {"week": 2, "lecture_num": 11, "youtube_url": "https://www.youtube.com/watch?v=6jkAfPFxXXI", "course_id": "course_106102229"}}
{"id": "lecture_106102229_w2_l12", "type": "V_lecture", "name": "Alternative Approaches to Issue and Commit (Part - I)", "properties": {"week": 2, "lecture_num": 12, "youtube_url": "https://www.youtube.com/watch?v=0VLOUQBZM7k", "course_id": "course_106102229"}}
{"id": "lecture_106102229_w2_l13", "type": "V_lecture", "name": "Alternative Approaches to Issue and Commit (Part - II)", "properties": {"week": 2, "lecture_num": 13, "youtube_url": "https://www.youtube.com/watch?v=Mq1iHjfoXx0", "course_id": "course_106102229"}}
{"id": "lecture_106102229_w2_l14", "type": "V_lecture", "name": "Alternative Approaches to Issue and Commit (Part - III)", "properties": {"week": 2, "lecture_num": 14, "youtube_url": "https://www.youtube.com/watch?v=2nvQ4-rf2qg", "course_id": "course_106102229"}}
{"id": "lecture_106102229_w3_l15", "type": "V_lecture", "name": "Alternative Approaches to Issue and Commit (Part - IV)", "properties": {"week": 3, "lecture_num": 15, "youtube_url": "https://www.youtube.com/watch?v=OyUnATuqmZY", "course_id": "course_106102229"}}
{"id": "lecture_106102229_w3_l16", "type": "V_lecture", "name": "Graphics Processors (Part - I)", "properties": {"week": 3, "lecture_num": 16, "youtube_url": "https://www.youtube.com/watch?v=xzpZmru_0GE", "course_id": "course_106102229"}}
{"id": "lecture_106102229_w3_l17", "type": "V_lecture", "name": "Graphics Processors (Part - II)", "properties": {"week": 3, "lecture_num": 17, "youtube_url": "https://www.youtube.com/watch?v=RaGXThtEtgY", "course_id": "course_106102229"}}
{"id": "lecture_106102229_w3_l18", "type": "V_lecture", "name": "Graphics Processors (Part -III)", "properties": {"week": 3, "lecture_num": 18, "youtube_url": "https://www.youtube.com/watch?v=RuB0N-AtNeI", "course_id": "course_106102229"}}
{"id": "lecture_106102229_w3_l19", "type": "V_lecture", "name": "Caches (Part -I)", "properties": {"week": 3, "lecture_num": 19, "youtube_url": "https://www.youtube.com/watch?v=OwYyLhZWcgs", "course_id": "course_106102229"}}
{"id": "lecture_106102229_w3_l20", "type": "V_lecture", "name": "Caches (Part -II)", "properties": {"week": 3, "lecture_num": 20, "youtube_url": "https://www.youtube.com/watch?v=kZlsZoQG_eM", "course_id": "course_106102229"}}
{"id": "lecture_106102229_w3_l21", "type": "V_lecture", "name": "Caches (Part -III)", "properties": {"week": 3, "lecture_num": 21, "youtube_url": "https://www.youtube.com/watch?v=qO7-z6KfFBc", "course_id": "course_106102229"}}
{"id": "lecture_106102229_w4_l22", "type": "V_lecture", "name": "Caches (Part -IV)", "properties": {"week": 4, "lecture_num": 22, "youtube_url": "https://www.youtube.com/watch?v=rAIsSRD9jdk", "course_id": "course_106102229"}}
{"id": "lecture_106102229_w4_l23", "type": "V_lecture", "name": "Caches (Part -V)", "properties": {"week": 4, "lecture_num": 23, "youtube_url": "https://www.youtube.com/watch?v=c0rGme8AoXY", "course_id": "course_106102229"}}
{"id": "lecture_106102229_w4_l24", "type": "V_lecture", "name": "Caches (Part -VI)", "properties": {"week": 4, "lecture_num": 24, "youtube_url": "https://www.youtube.com/watch?v=rQ6jlIcZOZQ", "course_id": "course_106102229"}}
{"id": "lecture_106102229_w4_l25", "type": "V_lecture", "name": "mod09lec25", "properties": {"week": 4, "lecture_num": 25, "youtube_url": "https://www.youtube.com/watch?v=-9Nc44lhRE8", "course_id": "course_106102229"}}
{"id": "lecture_106102229_w4_l26", "type": "V_lecture", "name": "Multicore Systems (Part - II)", "properties": {"week": 4, "lecture_num": 26, "youtube_url": "https://www.youtube.com/watch?v=MJkJamh5w1Q", "course_id": "course_106102229"}}
{"id": "lecture_106102229_w4_l27", "type": "V_lecture", "name": "Multicore Systems (Part - III)", "properties": {"week": 4, "lecture_num": 27, "youtube_url": "https://www.youtube.com/watch?v=GUXsontx1RU", "course_id": "course_106102229"}}
{"id": "lecture_106102229_w4_l28", "type": "V_lecture", "name": "Multicore Systems (Part - IV)", "properties": {"week": 4, "lecture_num": 28, "youtube_url": "https://www.youtube.com/watch?v=1ayOD21GlYg", "course_id": "course_106102229"}}
{"id": "lecture_106102229_w5_l29", "type": "V_lecture", "name": "Multicore Systems (Part - V)", "properties": {"week": 5, "lecture_num": 29, "youtube_url": "https://www.youtube.com/watch?v=oU0jepFOb88", "course_id": "course_106102229"}}
{"id": "lecture_106102229_w5_l30", "type": "V_lecture", "name": "Multicore Systems (Part - VI)", "properties": {"week": 5, "lecture_num": 30, "youtube_url": "https://www.youtube.com/watch?v=mibSxHZ6zB0", "course_id": "course_106102229"}}
{"id": "lecture_106102229_w5_l31", "type": "V_lecture", "name": "Multicore Systems (Part - VII)", "properties": {"week": 5, "lecture_num": 31, "youtube_url": "https://www.youtube.com/watch?v=41OQctpUk8w", "course_id": "course_106102229"}}
{"id": "lecture_106102229_w5_l32", "type": "V_lecture", "name": "Multicore Systems (Part - VIII)", "properties": {"week": 5, "lecture_num": 32, "youtube_url": "https://www.youtube.com/watch?v=dnNiuNDvhdM", "course_id": "course_106102229"}}
{"id": "lecture_106102229_w5_l33", "type": "V_lecture", "name": "Multicore Systems (Part - IX)", "properties": {"week": 5, "lecture_num": 33, "youtube_url": "https://www.youtube.com/watch?v=sRVQ2JXrcKA", "course_id": "course_106102229"}}
{"id": "course_106103359", "type": "V_course", "name": "Parallel Computer Architecture", "properties": {"course_id": "noc26-cs25", "nptel_url": "https://nptel.ac.in/courses/106103359", "nptel_id": "106103359", "abstract": "NOC: Parallel Computer Architecture, IIT Guwahati\nProf. Hemangee K. Kapoor Course Duration :\nJan-Apr 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-04-26\nCourse Abstract\n\nWith the emergence of application domains requiring large data processing as well as faster compute performance, parallel computing has become a critical component. This involves the use of multi-core processors as well as tightly integrated clusters of PCs and workstations. The most exciting development is the convergence of traditionally disparate approaches of shared memory, message passing and data driven computing onto the same platform\n\nAs the parallel applications communicate with each other using sharing data; it is important to correctly manage the shared data within the memory hierarchy to avoid inconsistency. Here, we need to understand the mechanisms used for data access, communication and coordination of work and its correct implementation.\n\nThis course will introduce the eld of parallel architectures and discuss in-depth shared memory management for parallel architectures. We will also learn about the interconnection topologies and routing methods which are important for connection and communication of the multiple cores executing the parallel applications. The course will conclude with overview of various parallel architectures and on-going research directions.\n\nINTENDED AUDIENCE: Final year UG as well as PG\n\nPREREQUISITES: Final year undergraduate as well as post-graduate students in the disciplines of CSE, IT, CS, ECE, EEE, etc. Can benet from this course. A basic knowledge in Computer Organisation is sucient to take this subject.\n\nINDUSTRY SUPPORT: Intel, Micron, AMD, IBM, NVIDIA, HP, Samsung, etc. Course Duration :\nJan-Apr 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-04-26", "professor": "Prof. Hemangee K. Kapoor", "institute": "IIT Guwahati", "duration": "12 Weeks", "stream_id": "stream_computer_science_and_engineering"}}
{"id": "lecture_106103359_w1_l1", "type": "V_lecture", "name": "Lec 1: Why do we need parallel architecture ?", "properties": {"week": 1, "lecture_num": 1, "youtube_url": "https://www.youtube.com/watch?v=U7VV4FZjz4s", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w1_l2", "type": "V_lecture", "name": "Lec 2: Multicore Revolution", "properties": {"week": 1, "lecture_num": 2, "youtube_url": "https://www.youtube.com/watch?v=bw-Q2-rdF8s", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w1_l3", "type": "V_lecture", "name": "Lec 3: What is Parallel Architecture?", "properties": {"week": 1, "lecture_num": 3, "youtube_url": "https://www.youtube.com/watch?v=na8yxOZ-8dw", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w1_l4", "type": "V_lecture", "name": "Lec 4: Performance and Benchmarking", "properties": {"week": 1, "lecture_num": 4, "youtube_url": "https://www.youtube.com/watch?v=XCMbuz2OBso", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w1_l5", "type": "V_lecture", "name": "Lec 5: Reporting Results", "properties": {"week": 1, "lecture_num": 5, "youtube_url": "https://www.youtube.com/watch?v=OiEXB8FE-6o", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w1_l6", "type": "V_lecture", "name": "Lec 6: Some Laws", "properties": {"week": 1, "lecture_num": 6, "youtube_url": "https://www.youtube.com/watch?v=WWhcVwFxJZM", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w1_l7", "type": "V_lecture", "name": "Lec 7: A shift from sequential to parallel", "properties": {"week": 1, "lecture_num": 7, "youtube_url": "https://www.youtube.com/watch?v=mmOrdTqjAuI", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w2_l8", "type": "V_lecture", "name": "Lec 8: Programming Models", "properties": {"week": 2, "lecture_num": 8, "youtube_url": "https://www.youtube.com/watch?v=0wuuVliPqqk", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w2_l9", "type": "V_lecture", "name": "Lec 9: Shared Memory Paradigm", "properties": {"week": 2, "lecture_num": 9, "youtube_url": "https://www.youtube.com/watch?v=g-b1dsPwaIk", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w2_l10", "type": "V_lecture", "name": "Lec 10: Message Passing Paradigm", "properties": {"week": 2, "lecture_num": 10, "youtube_url": "https://www.youtube.com/watch?v=T_A4LgEJaIo", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w2_l11", "type": "V_lecture", "name": "Lec 11: Examples", "properties": {"week": 2, "lecture_num": 11, "youtube_url": "https://www.youtube.com/watch?v=P2ZEyFY8jhI", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w2_l12", "type": "V_lecture", "name": "Lec 12: Cache Basics", "properties": {"week": 2, "lecture_num": 12, "youtube_url": "https://www.youtube.com/watch?v=mdl1hazrIyc", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w2_l13", "type": "V_lecture", "name": "Lec 13: Memory hierarchy questions (1)", "properties": {"week": 2, "lecture_num": 13, "youtube_url": "https://www.youtube.com/watch?v=94NNuSlsuas", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w2_l14", "type": "V_lecture", "name": "Lec 14: Memory hierarchy questions (2)", "properties": {"week": 2, "lecture_num": 14, "youtube_url": "https://www.youtube.com/watch?v=n2brFhaB-bA", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w3_l15", "type": "V_lecture", "name": "Lec 15: Six basic cache optimisations (1)", "properties": {"week": 3, "lecture_num": 15, "youtube_url": "https://www.youtube.com/watch?v=MLgvseKh6M4", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w3_l16", "type": "V_lecture", "name": "Lec 16: Six basic cache optimisations (2)", "properties": {"week": 3, "lecture_num": 16, "youtube_url": "https://www.youtube.com/watch?v=3oUPRUXRNJA", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w3_l17", "type": "V_lecture", "name": "Lec 17: Virtual Memory (1)", "properties": {"week": 3, "lecture_num": 17, "youtube_url": "https://www.youtube.com/watch?v=Ev4BET3i5R0", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w3_l18", "type": "V_lecture", "name": "Lec 18: Virtual Memory (2)", "properties": {"week": 3, "lecture_num": 18, "youtube_url": "https://www.youtube.com/watch?v=hY-R_OLgrNs", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w3_l19", "type": "V_lecture", "name": "Lec 19: Cache Coherence Problem", "properties": {"week": 3, "lecture_num": 19, "youtube_url": "https://www.youtube.com/watch?v=fAKaidkI4Mw", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w3_l20", "type": "V_lecture", "name": "Lec 20: Concept of Serialisation", "properties": {"week": 3, "lecture_num": 20, "youtube_url": "https://www.youtube.com/watch?v=GfjIYLhUekE", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w3_l21", "type": "V_lecture", "name": "Lec 21: Coherence related Conditions", "properties": {"week": 3, "lecture_num": 21, "youtube_url": "https://www.youtube.com/watch?v=xwBIXjk_uKY", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w4_l22", "type": "V_lecture", "name": "Lec 22: Types of Coherence Protocols (1)", "properties": {"week": 4, "lecture_num": 22, "youtube_url": "https://www.youtube.com/watch?v=9vNB0FoAY2U", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w4_l23", "type": "V_lecture", "name": "Lec 23: Types of Coherence Protocols (2)", "properties": {"week": 4, "lecture_num": 23, "youtube_url": "https://www.youtube.com/watch?v=zCrgew21Rjw", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w4_l24", "type": "V_lecture", "name": "Lec 24: VI Protocol", "properties": {"week": 4, "lecture_num": 24, "youtube_url": "https://www.youtube.com/watch?v=CxSalKixZJQ", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w4_l25", "type": "V_lecture", "name": "Lec 25: 3 state: MSI Protocol", "properties": {"week": 4, "lecture_num": 25, "youtube_url": "https://www.youtube.com/watch?v=MVkQrif0qS0", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w4_l26", "type": "V_lecture", "name": "Lec 26: MESI Protocol", "properties": {"week": 4, "lecture_num": 26, "youtube_url": "https://www.youtube.com/watch?v=bBSmcFoFRYw", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w4_l27", "type": "V_lecture", "name": "Lec 27: Dragon Protocol", "properties": {"week": 4, "lecture_num": 27, "youtube_url": "https://www.youtube.com/watch?v=oA31-k9qLag", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w4_l28", "type": "V_lecture", "name": "Lec 28: Coherence misses", "properties": {"week": 4, "lecture_num": 28, "youtube_url": "https://www.youtube.com/watch?v=S_dDh7jZGzA", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w5_l29", "type": "V_lecture", "name": "Lec 29: Coherence misses example", "properties": {"week": 5, "lecture_num": 29, "youtube_url": "https://www.youtube.com/watch?v=dC2mWYl2UMc", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w5_l30", "type": "V_lecture", "name": "Lec 30: Correctness Requirements", "properties": {"week": 5, "lecture_num": 30, "youtube_url": "https://www.youtube.com/watch?v=48rTP_EcvxQ", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w5_l31", "type": "V_lecture", "name": "Lec 31: Single-Level caches with an Atomic Bus (1)", "properties": {"week": 5, "lecture_num": 31, "youtube_url": "https://www.youtube.com/watch?v=9vG01AZrEKQ", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w5_l32", "type": "V_lecture", "name": "Lec 32: Single-Level caches with an Atomic Bus (2)", "properties": {"week": 5, "lecture_num": 32, "youtube_url": "https://www.youtube.com/watch?v=88B0vyWS9YE", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w5_l33", "type": "V_lecture", "name": "Lec 33: Multi-Level caches with an Atomic Bus (1)", "properties": {"week": 5, "lecture_num": 33, "youtube_url": "https://www.youtube.com/watch?v=x3EaoUQuvkM", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w5_l34", "type": "V_lecture", "name": "Lec 34: Multi-Level caches with an Atomic Bus (2)", "properties": {"week": 5, "lecture_num": 34, "youtube_url": "https://www.youtube.com/watch?v=Go_zOO13ex8", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w5_l35", "type": "V_lecture", "name": "Lec 35: Split transaction Bus", "properties": {"week": 5, "lecture_num": 35, "youtube_url": "https://www.youtube.com/watch?v=YXdwWvASZAI", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w6_l36", "type": "V_lecture", "name": "Lec 36: Phases in Split Transaction Bus", "properties": {"week": 6, "lecture_num": 36, "youtube_url": "https://www.youtube.com/watch?v=VBOcFykFngo", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w6_l37", "type": "V_lecture", "name": "Lec 37: Request table and Organization", "properties": {"week": 6, "lecture_num": 37, "youtube_url": "https://www.youtube.com/watch?v=wrrhwIbFYmQ", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w6_l38", "type": "V_lecture", "name": "Lec 38: Path of a Cache Miss", "properties": {"week": 6, "lecture_num": 38, "youtube_url": "https://www.youtube.com/watch?v=NDifrwPRbSM", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w6_l39", "type": "V_lecture", "name": "Lec 39: Multi-Level cache + Split transaction Bus", "properties": {"week": 6, "lecture_num": 39, "youtube_url": "https://www.youtube.com/watch?v=dkquNQNaXxg", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w6_l40", "type": "V_lecture", "name": "Lec 40: Introduction to Directory Cache Coherence", "properties": {"week": 6, "lecture_num": 40, "youtube_url": "https://www.youtube.com/watch?v=f6MeX6P5sLU", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w6_l41", "type": "V_lecture", "name": "Lec 41: Basic Operation of a Directory", "properties": {"week": 6, "lecture_num": 41, "youtube_url": "https://www.youtube.com/watch?v=jAwJRA-Le6k", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w6_l42", "type": "V_lecture", "name": "Lec 42: Directory Organisations", "properties": {"week": 6, "lecture_num": 42, "youtube_url": "https://www.youtube.com/watch?v=dNKUOP9eRLg", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w7_l43", "type": "V_lecture", "name": "Lec 43: Directory Overhead Optimisations", "properties": {"week": 7, "lecture_num": 43, "youtube_url": "https://www.youtube.com/watch?v=srB8IwTb2rA", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w7_l44", "type": "V_lecture", "name": "Lec 44: Directory Protocol optimisations", "properties": {"week": 7, "lecture_num": 44, "youtube_url": "https://www.youtube.com/watch?v=v2GKqLKBizo", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w7_l45", "type": "V_lecture", "name": "Lec 45:Proving Correctness (1)", "properties": {"week": 7, "lecture_num": 45, "youtube_url": "https://www.youtube.com/watch?v=-E-C7nin910", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w7_l46", "type": "V_lecture", "name": "Lec 46: Proving Correctness (2)", "properties": {"week": 7, "lecture_num": 46, "youtube_url": "https://www.youtube.com/watch?v=-u4T8ydxZcI", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w7_l47", "type": "V_lecture", "name": "Lec 47: SGI Origin Architecture", "properties": {"week": 7, "lecture_num": 47, "youtube_url": "https://www.youtube.com/watch?v=3-zhu9bg510", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w7_l48", "type": "V_lecture", "name": "Lec 48: Working of protocol", "properties": {"week": 7, "lecture_num": 48, "youtube_url": "https://www.youtube.com/watch?v=qkkM0W-BTc8", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w7_l49", "type": "V_lecture", "name": "Lec 49: Correctness Issues", "properties": {"week": 7, "lecture_num": 49, "youtube_url": "https://www.youtube.com/watch?v=AstI7ewFlQM", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w8_l50", "type": "V_lecture", "name": "Lec 50: Sequent NUMA-Q Architecture", "properties": {"week": 8, "lecture_num": 50, "youtube_url": "https://www.youtube.com/watch?v=4FaqjsfMFRQ", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w8_l51", "type": "V_lecture", "name": "Lec 51: Working of protocol(1)", "properties": {"week": 8, "lecture_num": 51, "youtube_url": "https://www.youtube.com/watch?v=xev2R-utApE", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w8_l52", "type": "V_lecture", "name": "Lec 52: Working of protocol (2)", "properties": {"week": 8, "lecture_num": 52, "youtube_url": "https://www.youtube.com/watch?v=bzNu_-VVye4", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w8_l53", "type": "V_lecture", "name": "Lec 53: Correctness and Protocol Interaction", "properties": {"week": 8, "lecture_num": 53, "youtube_url": "https://www.youtube.com/watch?v=OhwnunaMj7M", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w8_l54", "type": "V_lecture", "name": "Lec 54: Sequential Consistency", "properties": {"week": 8, "lecture_num": 54, "youtube_url": "https://www.youtube.com/watch?v=fHCVPd74WK0", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w8_l55", "type": "V_lecture", "name": "Lec 55: Implications of Sequential Consistency", "properties": {"week": 8, "lecture_num": 55, "youtube_url": "https://www.youtube.com/watch?v=imKvIyrxAiI", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w8_l56", "type": "V_lecture", "name": "Lec 56: Relaxed Consistency Models (1)", "properties": {"week": 8, "lecture_num": 56, "youtube_url": "https://www.youtube.com/watch?v=Hrs351nEe6A", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w9_l57", "type": "V_lecture", "name": "Lec 57: Relaxed Consistency Models (2)", "properties": {"week": 9, "lecture_num": 57, "youtube_url": "https://www.youtube.com/watch?v=SxzCMxK0F80", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w9_l58", "type": "V_lecture", "name": "Lec 58: Relaxing all Orders", "properties": {"week": 9, "lecture_num": 58, "youtube_url": "https://www.youtube.com/watch?v=53qJAfciRfU", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w9_l59", "type": "V_lecture", "name": "Lec 59: Uninterruptible Instructions", "properties": {"week": 9, "lecture_num": 59, "youtube_url": "https://www.youtube.com/watch?v=Ab2UyrKIK5M", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w9_l60", "type": "V_lecture", "name": "Lec 60: Implementation of atomic instructions", "properties": {"week": 9, "lecture_num": 60, "youtube_url": "https://www.youtube.com/watch?v=spSrWIcc7T8", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w9_l61", "type": "V_lecture", "name": "Lec70: Other synchronisation options", "properties": {"week": 9, "lecture_num": 61, "youtube_url": "https://www.youtube.com/watch?v=CceA5q48YKQ", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w9_l62", "type": "V_lecture", "name": "Lec 71: Interconnect Overview", "properties": {"week": 9, "lecture_num": 62, "youtube_url": "https://www.youtube.com/watch?v=xp1-BRHI3cs", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w9_l63", "type": "V_lecture", "name": "Lec 72: Topologies", "properties": {"week": 9, "lecture_num": 63, "youtube_url": "https://www.youtube.com/watch?v=NE38shcrpJA", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w10_l64", "type": "V_lecture", "name": "Lec 73: Routing", "properties": {"week": 10, "lecture_num": 64, "youtube_url": "https://www.youtube.com/watch?v=_i4E3YA1GaE", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w10_l65", "type": "V_lecture", "name": "Lec 74: Flow Control", "properties": {"week": 10, "lecture_num": 65, "youtube_url": "https://www.youtube.com/watch?v=1cjBmQotDvk", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w10_l66", "type": "V_lecture", "name": "Live Session 15-02-2024", "properties": {"week": 10, "lecture_num": 66, "youtube_url": "https://www.youtube.com/watch?v=j5Rm6vGSYsY", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w10_l67", "type": "V_lecture", "name": "Live Session 14-03-2024", "properties": {"week": 10, "lecture_num": 67, "youtube_url": "https://www.youtube.com/watch?v=pXQXTWfMf4Y", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w10_l68", "type": "V_lecture", "name": "Live Session 01-04-2024", "properties": {"week": 10, "lecture_num": 68, "youtube_url": "https://www.youtube.com/watch?v=lM3ZSoWdb78", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w10_l69", "type": "V_lecture", "name": "Live Session 13-02-2025", "properties": {"week": 10, "lecture_num": 69, "youtube_url": "https://www.youtube.com/watch?v=pTmNOlCoCas", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w10_l70", "type": "V_lecture", "name": "Live Session 06-03-2025", "properties": {"week": 10, "lecture_num": 70, "youtube_url": "https://www.youtube.com/watch?v=WhpxlAG-QoI", "course_id": "course_106103359"}}
{"id": "lecture_106103359_w11_l71", "type": "V_lecture", "name": "Live Session 03-04-2025", "properties": {"week": 11, "lecture_num": 71, "youtube_url": "https://www.youtube.com/watch?v=XfPCJfNnL9o", "course_id": "course_106103359"}}
{"id": "course_106103220", "type": "V_course", "name": "User-centric Computing For Human-Computer Interaction", "properties": {"course_id": "noc26-cs26", "nptel_url": "https://nptel.ac.in/courses/106103220", "nptel_id": "106103220", "abstract": "NOC: User-centric Computing For Human-Computer Interaction, IIT Guwahati\nProf. Samit Bhattacharya\nSelf-Paced Certificate Course Duration :\nJan-Mar 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-03-29\nCourse Abstract\n\nHuman-computer interaction is an emerging field of study at present, due to the proliferation of large number of consumer electronic products. The key issue in this field is to make the products usable to lay-persons. In order to do that, we need to take care of the (creative) design aspects (the look-and-feel of the interface) and also the system design aspect (both software and hardware). The field is interdisciplinary with inputs required from various other fields. However, the computer science and engineering plays the central role in the design of such systems (as per SIGCHI of ACM). In this course, we will introduce the engineering and computational issues in the design of human-computer interfaces for laypersons. The topics covered in the course includes the engineering life cycles for design of interactive systems, computational design framework (as part of the life cycle), components of the framework including the computational models of users and systems, and evaluation of such systems (with or without users). Course Duration :\nJan-Mar 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-03-29", "professor": "Prof. Samit Bhattacharya", "institute": "IIT Guwahati", "duration": "8 Weeks", "stream_id": "stream_computer_science_and_engineering"}}
{"id": "lecture_106103220_w1_l1", "type": "V_lecture", "name": "Introduction to UCC and history", "properties": {"week": 1, "lecture_num": 1, "youtube_url": "https://www.youtube.com/watch?v=azk99gD_2Io", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w1_l2", "type": "V_lecture", "name": "Issues and challenges", "properties": {"week": 1, "lecture_num": 2, "youtube_url": "https://www.youtube.com/watch?v=Bxt8oD0_YSg", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w1_l3", "type": "V_lecture", "name": "Latest research trends", "properties": {"week": 1, "lecture_num": 3, "youtube_url": "https://www.youtube.com/watch?v=LykpvLfQQ_s", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w1_l4", "type": "V_lecture", "name": "User-Centric Design and Software Engineering", "properties": {"week": 1, "lecture_num": 4, "youtube_url": "https://www.youtube.com/watch?v=XTMWDIekFi8", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w1_l5", "type": "V_lecture", "name": "Components of SDLC - Contextual Inquiry", "properties": {"week": 1, "lecture_num": 5, "youtube_url": "https://www.youtube.com/watch?v=UFcusfzTUMc", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w1_l6", "type": "V_lecture", "name": "Components of SDLC - Design Guidelines", "properties": {"week": 1, "lecture_num": 6, "youtube_url": "https://www.youtube.com/watch?v=rzCDxecGCco", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w1_l7", "type": "V_lecture", "name": "Components of SDLC - Prototyping", "properties": {"week": 1, "lecture_num": 7, "youtube_url": "https://www.youtube.com/watch?v=EkMP3u0so0k", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w2_l8", "type": "V_lecture", "name": "Case study (web site design)", "properties": {"week": 2, "lecture_num": 8, "youtube_url": "https://www.youtube.com/watch?v=SUvxkbtE9dA", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w2_l9", "type": "V_lecture", "name": "Introduction to User-Centric Computing", "properties": {"week": 2, "lecture_num": 9, "youtube_url": "https://www.youtube.com/watch?v=bbwamw_Osf4", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w2_l10", "type": "V_lecture", "name": "The UCC framework with illustrative case study", "properties": {"week": 2, "lecture_num": 10, "youtube_url": "https://www.youtube.com/watch?v=VwZmbTN4Res", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w2_l11", "type": "V_lecture", "name": "User-centric models - introduction and descriptive models", "properties": {"week": 2, "lecture_num": 11, "youtube_url": "https://www.youtube.com/watch?v=ow10wwfoAfQ", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w2_l12", "type": "V_lecture", "name": "User-centric models - predictive models and taxonomy", "properties": {"week": 2, "lecture_num": 12, "youtube_url": "https://www.youtube.com/watch?v=7LjUFpWxUf8", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w2_l13", "type": "V_lecture", "name": "Introduction to GOMS family of models", "properties": {"week": 2, "lecture_num": 13, "youtube_url": "https://www.youtube.com/watch?v=EtKhjhHVLRw", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w2_l14", "type": "V_lecture", "name": "Keystroke-Level Model (KLM)", "properties": {"week": 2, "lecture_num": 14, "youtube_url": "https://www.youtube.com/watch?v=VpX5VzQMBzU", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w3_l15", "type": "V_lecture", "name": "(CMN)GOMS Model", "properties": {"week": 3, "lecture_num": 15, "youtube_url": "https://www.youtube.com/watch?v=5moMYeGjNKU", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w3_l16", "type": "V_lecture", "name": "The Fitts' Law", "properties": {"week": 3, "lecture_num": 16, "youtube_url": "https://www.youtube.com/watch?v=rb9jro2qpCA", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w3_l17", "type": "V_lecture", "name": "The Hick-Hyman Law", "properties": {"week": 3, "lecture_num": 17, "youtube_url": "https://www.youtube.com/watch?v=J974s6hr_xM", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w3_l18", "type": "V_lecture", "name": "2D and 3D pointing models", "properties": {"week": 3, "lecture_num": 18, "youtube_url": "https://www.youtube.com/watch?v=7F01OFheosg", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w3_l19", "type": "V_lecture", "name": "The Steering Law for constrained navigation", "properties": {"week": 3, "lecture_num": 19, "youtube_url": "https://www.youtube.com/watch?v=m4r7X076dXs", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w3_l20", "type": "V_lecture", "name": "Model for hierarchical menu selection", "properties": {"week": 3, "lecture_num": 20, "youtube_url": "https://www.youtube.com/watch?v=wsa-qqnJhlM", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w3_l21", "type": "V_lecture", "name": "Mobile typing models (single finger and two thumb typing)", "properties": {"week": 3, "lecture_num": 21, "youtube_url": "https://www.youtube.com/watch?v=7lNjTvvLuCk", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w4_l22", "type": "V_lecture", "name": "Model for touch performance (FFitts' law)", "properties": {"week": 4, "lecture_num": 22, "youtube_url": "https://www.youtube.com/watch?v=g-OMAQ110Ho", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w4_l23", "type": "V_lecture", "name": "Lec 23: Introduction to formal models in UCD", "properties": {"week": 4, "lecture_num": 23, "youtube_url": "https://www.youtube.com/watch?v=RORm8jJQXuQ", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w4_l24", "type": "V_lecture", "name": "Lec 24: Formal modeling of user-computer dialogue", "properties": {"week": 4, "lecture_num": 24, "youtube_url": "https://www.youtube.com/watch?v=znABIrsOuEs", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w4_l25", "type": "V_lecture", "name": "Lec 25: Case studies on the use of models", "properties": {"week": 4, "lecture_num": 25, "youtube_url": "https://www.youtube.com/watch?v=6P6ykbJg6cM", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w4_l26", "type": "V_lecture", "name": "Lec 26: Introduction and research question formulation", "properties": {"week": 4, "lecture_num": 26, "youtube_url": "https://www.youtube.com/watch?v=ep64qdISQAU", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w4_l27", "type": "V_lecture", "name": "Lec 27: Variables determination and experiment design", "properties": {"week": 4, "lecture_num": 27, "youtube_url": "https://www.youtube.com/watch?v=fD-wAmhhd6A", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w4_l28", "type": "V_lecture", "name": "Lec 28: Data analysis including model building", "properties": {"week": 4, "lecture_num": 28, "youtube_url": "https://www.youtube.com/watch?v=v-zB0XPv76I", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w5_l29", "type": "V_lecture", "name": "Lec 29: Introduction to user-centric design evaluation and expert evaluation technique", "properties": {"week": 5, "lecture_num": 29, "youtube_url": "https://www.youtube.com/watch?v=quT9YpfGcyk", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w5_l30", "type": "V_lecture", "name": "Lec 30: User evaluation, empirical and model-based evaluation", "properties": {"week": 5, "lecture_num": 30, "youtube_url": "https://www.youtube.com/watch?v=Dhjqy5-1Yr0", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w5_l31", "type": "V_lecture", "name": "Lec 31: Concluding remarks", "properties": {"week": 5, "lecture_num": 31, "youtube_url": "https://www.youtube.com/watch?v=pzkyjgFsbys", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w5_l32", "type": "V_lecture", "name": "Live Session 15-02-2021", "properties": {"week": 5, "lecture_num": 32, "youtube_url": "https://www.youtube.com/watch?v=LJ1EEWZE1V0", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w5_l33", "type": "V_lecture", "name": "Live Session 15-03-2021", "properties": {"week": 5, "lecture_num": 33, "youtube_url": "https://www.youtube.com/watch?v=JC1X83sHqzs", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w5_l34", "type": "V_lecture", "name": "Live Session 26-02-2020", "properties": {"week": 5, "lecture_num": 34, "youtube_url": "https://www.youtube.com/watch?v=y_FYb64R9O8", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w5_l35", "type": "V_lecture", "name": "Live Session 18-03-2020", "properties": {"week": 5, "lecture_num": 35, "youtube_url": "https://www.youtube.com/watch?v=EVOBLcoMWsk", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w6_l36", "type": "V_lecture", "name": "Live Session 21-02-2022", "properties": {"week": 6, "lecture_num": 36, "youtube_url": "https://www.youtube.com/watch?v=hair8Kx_KiQ", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w6_l37", "type": "V_lecture", "name": "Live Session 15-03-2022", "properties": {"week": 6, "lecture_num": 37, "youtube_url": "https://www.youtube.com/watch?v=_YCq-I4wfEk", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w6_l38", "type": "V_lecture", "name": "Live Session 14-02-2024", "properties": {"week": 6, "lecture_num": 38, "youtube_url": "https://www.youtube.com/watch?v=oo6Fx5Ey5kU", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w6_l39", "type": "V_lecture", "name": "Live Session 13-03-2024", "properties": {"week": 6, "lecture_num": 39, "youtube_url": "https://www.youtube.com/watch?v=3vJ63oQb2VY", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w6_l40", "type": "V_lecture", "name": "Live Session 13-02-2025", "properties": {"week": 6, "lecture_num": 40, "youtube_url": "https://www.youtube.com/watch?v=OlRTaJtmWH0", "course_id": "course_106103220"}}
{"id": "lecture_106103220_w6_l41", "type": "V_lecture", "name": "Live Session 12-03-2025", "properties": {"week": 6, "lecture_num": 41, "youtube_url": "https://www.youtube.com/watch?v=97fGjxBKujI", "course_id": "course_106103220"}}
{"id": "course_106104357", "type": "V_course", "name": "Basics of Computational Complexity", "properties": {"course_id": "noc26-cs27", "nptel_url": "https://nptel.ac.in/courses/106104357", "nptel_id": "106104357", "abstract": "NOC: Basics of Computational Complexity, IIT Kanpur\nProf. Nitin Saxena Course Duration :\nJan-Apr 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-04-19\nCourse Abstract\n\nWe will start this course by mathematically formalizing computation and algorithms. Our approach in the course would be to look at famous concrete problems and prove theorems about their uncomputability, or, if computable, then how fast can they be computationally solved. The problems we will cover in this course are: the halting problem, boolean formula satisfiability (the P!=NP question), quantified boolean formula, formula minimization, polynomial identity testing, undirected graph reachability, permanent and graph isomorphism. While studying these computational problems we will define various complexity classes and develop various tools used in modern complexity theory.\n\nINTENDED AUDIENCE: Computer Science & Engineering, Mathematics, Electronics, Physics, & similar disciplines.\n\nPREREQUISITES: Preferable (but not necessary)-- Theory of Computation, or Algorithms, or Discrete Mathematics.\n\nINDUSTRY SUPPORT: Discrete Optimization, Cryptography/ Cyber Security, Coding theory, Computer Algebra, Symbolic Computing Software, , Learning Software. Course Duration :\nJan-Apr 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-04-19", "professor": "Prof. Nitin Saxena", "institute": "IIT Kanpur", "duration": "12 Weeks", "stream_id": "stream_computer_science_and_engineering"}}
{"id": "lecture_106104357_w1_l1", "type": "V_lecture", "name": "Lecture 1(a): Introduction", "properties": {"week": 1, "lecture_num": 1, "youtube_url": "https://www.youtube.com/watch?v=JY4Rd2laGgM", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w1_l2", "type": "V_lecture", "name": "Lecture 1(b): Outline", "properties": {"week": 1, "lecture_num": 2, "youtube_url": "https://www.youtube.com/watch?v=NHZ1SzavK9o", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w1_l3", "type": "V_lecture", "name": "Lecture 2(a): Formalize problems and machine", "properties": {"week": 1, "lecture_num": 3, "youtube_url": "https://www.youtube.com/watch?v=RTJk1naWJ9w", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w1_l4", "type": "V_lecture", "name": "Lecture 2(b): Turing Machine", "properties": {"week": 1, "lecture_num": 4, "youtube_url": "https://www.youtube.com/watch?v=WxZsUZoX4-w", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w1_l5", "type": "V_lecture", "name": "Lecture 3(a): Asymptotics, Church-Turing thesis, and UTM", "properties": {"week": 1, "lecture_num": 5, "youtube_url": "https://www.youtube.com/watch?v=ErYnXGdGOLA", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w1_l6", "type": "V_lecture", "name": "Lecture 3(b): Halting problem and Diagonalization", "properties": {"week": 1, "lecture_num": 6, "youtube_url": "https://www.youtube.com/watch?v=fgog_dRwAys", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w1_l7", "type": "V_lecture", "name": "Lecture 4(a); Classes P, NP, EXP", "properties": {"week": 1, "lecture_num": 7, "youtube_url": "https://www.youtube.com/watch?v=kM2MusVdLOI", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w2_l8", "type": "V_lecture", "name": "Lecture 4(b): Comparison of classes and Non-determinism", "properties": {"week": 2, "lecture_num": 8, "youtube_url": "https://www.youtube.com/watch?v=YoZyhNEaohg", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w2_l9", "type": "V_lecture", "name": "Lecture 5(a): NP vs Ntime", "properties": {"week": 2, "lecture_num": 9, "youtube_url": "https://www.youtube.com/watch?v=p4gG6I-5cls", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w2_l10", "type": "V_lecture", "name": "Lecture 5(b): SAT is NP-hard.", "properties": {"week": 2, "lecture_num": 10, "youtube_url": "https://www.youtube.com/watch?v=x8txbrDvR_4", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w2_l11", "type": "V_lecture", "name": "Lecture 6(a): Cook-Levin Theorem.", "properties": {"week": 2, "lecture_num": 11, "youtube_url": "https://www.youtube.com/watch?v=_t7LfZbqAQs", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w2_l12", "type": "V_lecture", "name": "Lecture 6(b): NP-hardness and Co-Classes", "properties": {"week": 2, "lecture_num": 12, "youtube_url": "https://www.youtube.com/watch?v=T84AJq32HM0", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w2_l13", "type": "V_lecture", "name": "Lecture 7(a): NEXP and G\u00f6del's computation question", "properties": {"week": 2, "lecture_num": 13, "youtube_url": "https://www.youtube.com/watch?v=Sj-6yZ0NjIE", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w2_l14", "type": "V_lecture", "name": "Lecture 7(b): Time, Space hierarchy", "properties": {"week": 2, "lecture_num": 14, "youtube_url": "https://www.youtube.com/watch?v=Z3YX-9hL3Dk", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w3_l15", "type": "V_lecture", "name": "Lecture 8(a): NDTM hierarchy", "properties": {"week": 3, "lecture_num": 15, "youtube_url": "https://www.youtube.com/watch?v=86Hdt-AzvLo", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w3_l16", "type": "V_lecture", "name": "Lecture 8(b): Ladner's Theorem and Introduction to Oracles", "properties": {"week": 3, "lecture_num": 16, "youtube_url": "https://www.youtube.com/watch?v=CLxztVNNRIg", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w3_l17", "type": "V_lecture", "name": "Lecture 9(a): Oracle and Relativizing proofs.", "properties": {"week": 3, "lecture_num": 17, "youtube_url": "https://www.youtube.com/watch?v=bTSJd31-cbI", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w3_l18", "type": "V_lecture", "name": "Lecture 9(b): Non-relativizing P\u2260NP and Introduction to Space complexity", "properties": {"week": 3, "lecture_num": 18, "youtube_url": "https://www.youtube.com/watch?v=eKBhEHm4PCc", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w3_l19", "type": "V_lecture", "name": "Lecture 10(a): PSPACE completeness", "properties": {"week": 3, "lecture_num": 19, "youtube_url": "https://www.youtube.com/watch?v=vm6gdALH3sk", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w3_l20", "type": "V_lecture", "name": "Lecture 10(b): QBF game and NSpace", "properties": {"week": 3, "lecture_num": 20, "youtube_url": "https://www.youtube.com/watch?v=R4ovpFoHO4U", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w3_l21", "type": "V_lecture", "name": "Lecture 11(a): NL complete", "properties": {"week": 3, "lecture_num": 21, "youtube_url": "https://www.youtube.com/watch?v=7LzhEYOI_5w", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w4_l22", "type": "V_lecture", "name": "Lecture 11(b): NL=coNL", "properties": {"week": 4, "lecture_num": 22, "youtube_url": "https://www.youtube.com/watch?v=e2HlPKJ4rM4", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w4_l23", "type": "V_lecture", "name": "Lecture 12(a): Polynomial Hierarchy", "properties": {"week": 4, "lecture_num": 23, "youtube_url": "https://www.youtube.com/watch?v=U-DULXCsems", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w4_l24", "type": "V_lecture", "name": "Lecture 12(b): PH Conjecture", "properties": {"week": 4, "lecture_num": 24, "youtube_url": "https://www.youtube.com/watch?v=WFIaac0SgUE", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w4_l25", "type": "V_lecture", "name": "Lecture 13(a): PH-complete and Oracle TM", "properties": {"week": 4, "lecture_num": 25, "youtube_url": "https://www.youtube.com/watch?v=WMEgfKoZaCQ", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w4_l26", "type": "V_lecture", "name": "Lecture 13(b): NP^NP and #SAT", "properties": {"week": 4, "lecture_num": 26, "youtube_url": "https://www.youtube.com/watch?v=erKj1g6Zw7o", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w4_l27", "type": "V_lecture", "name": "Lecture 14(a): Counting classes #P and PP", "properties": {"week": 4, "lecture_num": 27, "youtube_url": "https://www.youtube.com/watch?v=ft1hOSkAA8U", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w4_l28", "type": "V_lecture", "name": "Lecture 14(b): Permanent and its connection to the cycle cover of a Graph", "properties": {"week": 4, "lecture_num": 28, "youtube_url": "https://www.youtube.com/watch?v=mFw_-gW4_L4", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w5_l29", "type": "V_lecture", "name": "Lecture 15(a): #P-complete: Graph gadgets", "properties": {"week": 5, "lecture_num": 29, "youtube_url": "https://www.youtube.com/watch?v=MB8lTQXaOMk", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w5_l30", "type": "V_lecture", "name": "Lecture 15(b): #P-hard: Analyse XOR", "properties": {"week": 5, "lecture_num": 30, "youtube_url": "https://www.youtube.com/watch?v=Nr-013rrJNo", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w5_l31", "type": "V_lecture", "name": "Lecture 16(a): Valiant-Vazirani Lemma and Hashing", "properties": {"week": 5, "lecture_num": 31, "youtube_url": "https://www.youtube.com/watch?v=RIKFLQpK4Uo", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w5_l32", "type": "V_lecture", "name": "Lecture 16(b): SAT to Parity-SAT", "properties": {"week": 5, "lecture_num": 32, "youtube_url": "https://www.youtube.com/watch?v=Vh31AgPhkVY", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w5_l33", "type": "V_lecture", "name": "Lecture 17(a): Parity Quantification", "properties": {"week": 5, "lecture_num": 33, "youtube_url": "https://www.youtube.com/watch?v=c9M6tzyqmXo", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w5_l34", "type": "V_lecture", "name": "Lecture 17(b): Randomized reduction of PH to Parity-P", "properties": {"week": 5, "lecture_num": 34, "youtube_url": "https://www.youtube.com/watch?v=oXGr3kxkm1E", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w5_l35", "type": "V_lecture", "name": "Lecture 18(a): PH to #P", "properties": {"week": 5, "lecture_num": 35, "youtube_url": "https://www.youtube.com/watch?v=Cu_9pI16EuY", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w6_l36", "type": "V_lecture", "name": "Lecture 18(b): Probabilistic TM", "properties": {"week": 6, "lecture_num": 36, "youtube_url": "https://www.youtube.com/watch?v=ZlFFxEaAVtk", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w6_l37", "type": "V_lecture", "name": "Lecture 19(a): Example of PTM and Introduction to RP and ZPP", "properties": {"week": 6, "lecture_num": 37, "youtube_url": "https://www.youtube.com/watch?v=IvzuomwfNZw", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w6_l38", "type": "V_lecture", "name": "Lecture 19(b): ZPP = RP & coRP", "properties": {"week": 6, "lecture_num": 38, "youtube_url": "https://www.youtube.com/watch?v=9Libzt71JzA", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w6_l39", "type": "V_lecture", "name": "Lecture 20(a): Probability Amplification", "properties": {"week": 6, "lecture_num": 39, "youtube_url": "https://www.youtube.com/watch?v=lDFamKSStN0", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w6_l40", "type": "V_lecture", "name": "Lecture 20(b): BPP in PH", "properties": {"week": 6, "lecture_num": 40, "youtube_url": "https://www.youtube.com/watch?v=68HyU29zTuU", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w6_l41", "type": "V_lecture", "name": "Lecture 21(a): GNI is in BP.NP", "properties": {"week": 6, "lecture_num": 41, "youtube_url": "https://www.youtube.com/watch?v=XmjcDfCSVRw", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w6_l42", "type": "V_lecture", "name": "Lecture 21(b): GI is NP-hard.", "properties": {"week": 6, "lecture_num": 42, "youtube_url": "https://www.youtube.com/watch?v=Xl5ave6Ct4M", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w7_l43", "type": "V_lecture", "name": "Lecture 22(a): GI is NP-hard continued. Going Beyond TMs", "properties": {"week": 7, "lecture_num": 43, "youtube_url": "https://www.youtube.com/watch?v=8IfWHh2ZLDk", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w7_l44", "type": "V_lecture", "name": "Lecture 22(b): Circuit Complexity", "properties": {"week": 7, "lecture_num": 44, "youtube_url": "https://www.youtube.com/watch?v=Wu9dwXFLwKg", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w7_l45", "type": "V_lecture", "name": "Lecture 23(a): TM with Advice - P/poly.", "properties": {"week": 7, "lecture_num": 45, "youtube_url": "https://www.youtube.com/watch?v=4A5SpjeURNU", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w7_l46", "type": "V_lecture", "name": "Lecture 23(b): Circuits for NP and EXP", "properties": {"week": 7, "lecture_num": 46, "youtube_url": "https://www.youtube.com/watch?v=VzDvv1y09bo", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w7_l47", "type": "V_lecture", "name": "Lecture 24(a): Parallel Computation.", "properties": {"week": 7, "lecture_num": 47, "youtube_url": "https://www.youtube.com/watch?v=llm3UgFaZbk", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w7_l48", "type": "V_lecture", "name": "Lecture 24(b): P-completeness and NEXP-completeness", "properties": {"week": 7, "lecture_num": 48, "youtube_url": "https://www.youtube.com/watch?v=Yioq_WPULyY", "course_id": "course_106104357"}}
{"id": "lecture_106104357_w7_l49", "type": "V_lecture", "name": "Live Session 13-02-2024", "properties": {"week": 7, "lecture_num": 49, "youtube_url": "https://www.youtube.com/watch?v=-83cYkKZtwU", "course_id": "course_106104357"}}
{"id": "course_106104233", "type": "V_course", "name": "Probability for Computer Science", "properties": {"course_id": "noc26-cs28", "nptel_url": "https://nptel.ac.in/courses/106104233", "nptel_id": "106104233", "abstract": "NOC: Probability for Computer Science, IIT Kanpur\nProf. Nitin Saxena\nSwayam Certification Course Duration :\nFeb-Apr 2026\nEnrollment :\n2025-11-17 to 2026-02-16\nExam Registration :\n2025-12-13 to 2026-02-27\nExam Date :\n2026-04-19\nCourse Abstract\n\nProbability is one of the most important ideas in human knowledge. This is a crash course to introduce the concept of probability formally; and exhibit its applications in computer science, combinatorics, and algorithms. The course will be different from a typical mathematics course in the coverage and focus of examples. After finishing this course a student will have a good understanding of both theory and practice of probability in diverse areas. Course Duration :\nFeb-Apr 2026\nEnrollment :\n2025-11-17 to 2026-02-16\nExam Registration :\n2025-12-13 to 2026-02-27\nExam Date :\n2026-04-19", "professor": "Prof. Nitin Saxena", "institute": "IIT Kanpur", "duration": "8 Weeks", "stream_id": "stream_computer_science_and_engineering"}}
{"id": "lecture_106104233_w1_l1", "type": "V_lecture", "name": "Lecture 01 :  Introductory examples", "properties": {"week": 1, "lecture_num": 1, "youtube_url": "https://www.youtube.com/watch?v=CVvCvYFoCmM", "course_id": "course_106104233"}}
{"id": "lecture_106104233_w1_l2", "type": "V_lecture", "name": "Lecture 02 :  Examples and Course outline", "properties": {"week": 1, "lecture_num": 2, "youtube_url": "https://www.youtube.com/watch?v=hhaNcPNF6Yw", "course_id": "course_106104233"}}
{"id": "lecture_106104233_w1_l3", "type": "V_lecture", "name": "Lecture 03 :  Probability over discrete space", "properties": {"week": 1, "lecture_num": 3, "youtube_url": "https://www.youtube.com/watch?v=lik-huYpYxc", "course_id": "course_106104233"}}
{"id": "lecture_106104233_w1_l4", "type": "V_lecture", "name": "Lecture 04 :  Inclusion-Exclusion principle", "properties": {"week": 1, "lecture_num": 4, "youtube_url": "https://www.youtube.com/watch?v=osMbLWrx0ME", "course_id": "course_106104233"}}
{"id": "lecture_106104233_w1_l5", "type": "V_lecture", "name": "Lecture 05 : Probability over infinite space", "properties": {"week": 1, "lecture_num": 5, "youtube_url": "https://www.youtube.com/watch?v=bz9YpLjdfVM", "course_id": "course_106104233"}}
{"id": "lecture_106104233_w1_l6", "type": "V_lecture", "name": "Lecture 06 : Conditional probability, Partition formula", "properties": {"week": 1, "lecture_num": 6, "youtube_url": "https://www.youtube.com/watch?v=8oLZqkwmqGM", "course_id": "course_106104233"}}
{"id": "lecture_106104233_w1_l7", "type": "V_lecture", "name": "Lecture 07 : Independent events, Bayes theorem", "properties": {"week": 1, "lecture_num": 7, "youtube_url": "https://www.youtube.com/watch?v=I7PAXeAwX0I", "course_id": "course_106104233"}}
{"id": "lecture_106104233_w2_l8", "type": "V_lecture", "name": "Lecture 08 : Fallacies, Random variables", "properties": {"week": 2, "lecture_num": 8, "youtube_url": "https://www.youtube.com/watch?v=5dIMNBBKYaA", "course_id": "course_106104233"}}
{"id": "lecture_106104233_w2_l9", "type": "V_lecture", "name": "noc21-cs104-lec09", "properties": {"week": 2, "lecture_num": 9, "youtube_url": "https://www.youtube.com/watch?v=DbAJF9sDxhE", "course_id": "course_106104233"}}
{"id": "lecture_106104233_w2_l10", "type": "V_lecture", "name": "noc21-cs104-lec10", "properties": {"week": 2, "lecture_num": 10, "youtube_url": "https://www.youtube.com/watch?v=JEa2audI6mY", "course_id": "course_106104233"}}
{"id": "lecture_106104233_w2_l11", "type": "V_lecture", "name": "noc21-cs104-lec11", "properties": {"week": 2, "lecture_num": 11, "youtube_url": "https://www.youtube.com/watch?v=BBlCa5XMCm4", "course_id": "course_106104233"}}
{"id": "lecture_106104233_w2_l12", "type": "V_lecture", "name": "noc21-cs104-lec12", "properties": {"week": 2, "lecture_num": 12, "youtube_url": "https://www.youtube.com/watch?v=xl50kk0eFnM", "course_id": "course_106104233"}}
{"id": "lecture_106104233_w2_l13", "type": "V_lecture", "name": "noc21-cs104-lec13", "properties": {"week": 2, "lecture_num": 13, "youtube_url": "https://www.youtube.com/watch?v=nn7dbKJuaNM", "course_id": "course_106104233"}}
{"id": "lecture_106104233_w2_l14", "type": "V_lecture", "name": "noc21-cs104-lec14", "properties": {"week": 2, "lecture_num": 14, "youtube_url": "https://www.youtube.com/watch?v=zGz04lZk8i8", "course_id": "course_106104233"}}
{"id": "lecture_106104233_w3_l15", "type": "V_lecture", "name": "noc21-cs104-lec15", "properties": {"week": 3, "lecture_num": 15, "youtube_url": "https://www.youtube.com/watch?v=mdjoVYvC3nc", "course_id": "course_106104233"}}
{"id": "lecture_106104233_w3_l16", "type": "V_lecture", "name": "noc21-cs104-lec16", "properties": {"week": 3, "lecture_num": 16, "youtube_url": "https://www.youtube.com/watch?v=du99oYgQcDI", "course_id": "course_106104233"}}
{"id": "lecture_106104233_w3_l17", "type": "V_lecture", "name": "noc21-cs104-lec17", "properties": {"week": 3, "lecture_num": 17, "youtube_url": "https://www.youtube.com/watch?v=0QVJI2Eq678", "course_id": "course_106104233"}}
{"id": "lecture_106104233_w3_l18", "type": "V_lecture", "name": "noc21-cs104-lec18", "properties": {"week": 3, "lecture_num": 18, "youtube_url": "https://www.youtube.com/watch?v=yYOLUJ0A3Js", "course_id": "course_106104233"}}
{"id": "lecture_106104233_w3_l19", "type": "V_lecture", "name": "noc21-cs104-lec19", "properties": {"week": 3, "lecture_num": 19, "youtube_url": "https://www.youtube.com/watch?v=n68tMoARqfo", "course_id": "course_106104233"}}
{"id": "lecture_106104233_w3_l20", "type": "V_lecture", "name": "noc21-cs104-lec20", "properties": {"week": 3, "lecture_num": 20, "youtube_url": "https://www.youtube.com/watch?v=7XWm_vFxTBY", "course_id": "course_106104233"}}
{"id": "lecture_106104233_w3_l21", "type": "V_lecture", "name": "noc21-cs104-lec21", "properties": {"week": 3, "lecture_num": 21, "youtube_url": "https://www.youtube.com/watch?v=XvXe-t1ZHmM", "course_id": "course_106104233"}}
{"id": "lecture_106104233_w4_l22", "type": "V_lecture", "name": "noc21-cs104-lec22", "properties": {"week": 4, "lecture_num": 22, "youtube_url": "https://www.youtube.com/watch?v=xbdLhYOmag8", "course_id": "course_106104233"}}
{"id": "lecture_106104233_w4_l23", "type": "V_lecture", "name": "noc21-cs104-lec23", "properties": {"week": 4, "lecture_num": 23, "youtube_url": "https://www.youtube.com/watch?v=z1YfSvLlZx8", "course_id": "course_106104233"}}
{"id": "lecture_106104233_w4_l24", "type": "V_lecture", "name": "noc21-cs104-lec24", "properties": {"week": 4, "lecture_num": 24, "youtube_url": "https://www.youtube.com/watch?v=Fd6vX9ZCdvI", "course_id": "course_106104233"}}
{"id": "lecture_106104233_w4_l25", "type": "V_lecture", "name": "noc21-cs104-lec25", "properties": {"week": 4, "lecture_num": 25, "youtube_url": "https://www.youtube.com/watch?v=AOBEjCo2A1s", "course_id": "course_106104233"}}
{"id": "lecture_106104233_w4_l26", "type": "V_lecture", "name": "noc21-cs104-lec26", "properties": {"week": 4, "lecture_num": 26, "youtube_url": "https://www.youtube.com/watch?v=nrSOVTxjEm0", "course_id": "course_106104233"}}
{"id": "lecture_106104233_w4_l27", "type": "V_lecture", "name": "noc21-cs104-lec27", "properties": {"week": 4, "lecture_num": 27, "youtube_url": "https://www.youtube.com/watch?v=TwCDTFd1ojI", "course_id": "course_106104233"}}
{"id": "lecture_106104233_w4_l28", "type": "V_lecture", "name": "noc21-cs104-lec28", "properties": {"week": 4, "lecture_num": 28, "youtube_url": "https://www.youtube.com/watch?v=3nnCag9U1jc", "course_id": "course_106104233"}}
{"id": "lecture_106104233_w5_l29", "type": "V_lecture", "name": "noc21-cs104-lec29", "properties": {"week": 5, "lecture_num": 29, "youtube_url": "https://www.youtube.com/watch?v=4yxqreM_jdg", "course_id": "course_106104233"}}
{"id": "lecture_106104233_w5_l30", "type": "V_lecture", "name": "noc21-cs104-lec30", "properties": {"week": 5, "lecture_num": 30, "youtube_url": "https://www.youtube.com/watch?v=xmy8U3NuCoc", "course_id": "course_106104233"}}
{"id": "lecture_106104233_w5_l31", "type": "V_lecture", "name": "noc21-cs104-lec31", "properties": {"week": 5, "lecture_num": 31, "youtube_url": "https://www.youtube.com/watch?v=LqFoU9yRgUY", "course_id": "course_106104233"}}
{"id": "lecture_106104233_w5_l32", "type": "V_lecture", "name": "noc21-cs104-lec32", "properties": {"week": 5, "lecture_num": 32, "youtube_url": "https://www.youtube.com/watch?v=9QdnrNFYFCI", "course_id": "course_106104233"}}
{"id": "course_106104182", "type": "V_course", "name": "Cloud Computing and Distributed Systems", "properties": {"course_id": "noc26-cs29", "nptel_url": "https://nptel.ac.in/courses/106104182", "nptel_id": "106104182", "abstract": "NOC: Cloud Computing and Distributed Systems, IIT Patna\nProf. Rajiv Misra\nSelf-Paced Certificate Course Duration :\nJan-Mar 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-03-29\nCourse Abstract\n\nCloud computing is the on-demand delivery of computations, storage, applications, and other IT resources through a cloud services platform over the internet with pay-as-you-go business model. Today's Cloud computing systems are built using fundamental principles and models of distributed systems. This course provides an in-depth understanding of distributed computing \u00c3\u00a2\u00e2\u201a\u00ac\u00c5\u201cconcepts\u00c3\u00a2\u00e2\u201a\u00ac\u00c2\u009d, distributed algorithms, and the techniques, that underlie today's cloud computing technologies. The cloud computing and distributed systems concepts and models covered in course includes: virtualization, cloud storage: key-value/NoSQL stores, cloud networking,fault-tolerance cloud using PAXOS, peer-to-peer systems, classical distributed algorithms such as leader election, time, ordering in distributed systems, distributed mutual exclusion, distributed algorithms for failures and recovery approaches, emerging areas of big data and many more. And while discussing the concepts and techniques, we will also look at aspects of industry systems such as Apache Spark, Google\u00c3\u00a2\u00e2\u201a\u00ac\u00e2\u201e\u00a2s Chubby, Apache Zookeeper, HBase, MapReduce, Apache Cassandra, Google\u00c3\u00a2\u00e2\u201a\u00ac\u00e2\u201e\u00a2s B4, Microsoft\u00c3\u00a2\u00e2\u201a\u00ac\u00e2\u201e\u00a2s Swan and many others. Upon completing this course, students will have intimate knowledge about the internals of cloud computing and how the distributed systems concepts work inside clouds. Course Duration :\nJan-Mar 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-03-29", "professor": "Prof. Rajiv Misra", "institute": "IIT Patna", "duration": "8 Weeks", "stream_id": "stream_computer_science_and_engineering"}}
{"id": "lecture_106104182_w1_l1", "type": "V_lecture", "name": "Introduction to Cloud Computing", "properties": {"week": 1, "lecture_num": 1, "youtube_url": "https://www.youtube.com/watch?v=A3FPxuKlnkU", "course_id": "course_106104182"}}
{"id": "lecture_106104182_w1_l2", "type": "V_lecture", "name": "Virtualization", "properties": {"week": 1, "lecture_num": 2, "youtube_url": "https://www.youtube.com/watch?v=AkST9AO01x0", "course_id": "course_106104182"}}
{"id": "lecture_106104182_w1_l3", "type": "V_lecture", "name": "Hotspot Mitigation for Virtual Machine Migration", "properties": {"week": 1, "lecture_num": 3, "youtube_url": "https://www.youtube.com/watch?v=-gcROeHOH9s", "course_id": "course_106104182"}}
{"id": "lecture_106104182_w1_l4", "type": "V_lecture", "name": "Server Virtualization", "properties": {"week": 1, "lecture_num": 4, "youtube_url": "https://www.youtube.com/watch?v=SCszWWMEIio", "course_id": "course_106104182"}}
{"id": "lecture_106104182_w1_l5", "type": "V_lecture", "name": "Software Defined Network", "properties": {"week": 1, "lecture_num": 5, "youtube_url": "https://www.youtube.com/watch?v=FnbK7OaB7rw", "course_id": "course_106104182"}}
{"id": "lecture_106104182_w1_l6", "type": "V_lecture", "name": "Geo-distributed Cloud Data Centers", "properties": {"week": 1, "lecture_num": 6, "youtube_url": "https://www.youtube.com/watch?v=dKUXo6z6Q88", "course_id": "course_106104182"}}
{"id": "lecture_106104182_w1_l7", "type": "V_lecture", "name": "Leader Election in Rings (Classical Distributed Algorithms)", "properties": {"week": 1, "lecture_num": 7, "youtube_url": "https://www.youtube.com/watch?v=gXOaUP73aG0", "course_id": "course_106104182"}}
{"id": "lecture_106104182_w2_l8", "type": "V_lecture", "name": "Leader Election (Ring LE & Bully LE Algorithm)", "properties": {"week": 2, "lecture_num": 8, "youtube_url": "https://www.youtube.com/watch?v=aIFkEBRlCo4", "course_id": "course_106104182"}}
{"id": "lecture_106104182_w2_l9", "type": "V_lecture", "name": "Design of Zookeeper", "properties": {"week": 2, "lecture_num": 9, "youtube_url": "https://www.youtube.com/watch?v=iNBCqxnX2m4", "course_id": "course_106104182"}}
{"id": "lecture_106104182_w2_l10", "type": "V_lecture", "name": "Time and Clock Synchronization in Cloud Data Centers", "properties": {"week": 2, "lecture_num": 10, "youtube_url": "https://www.youtube.com/watch?v=6rtGYTuJn9k", "course_id": "course_106104182"}}
{"id": "lecture_106104182_w2_l11", "type": "V_lecture", "name": "Global State and Snapshot Recording Algorithms", "properties": {"week": 2, "lecture_num": 11, "youtube_url": "https://www.youtube.com/watch?v=nercwhDex3M", "course_id": "course_106104182"}}
{"id": "lecture_106104182_w2_l12", "type": "V_lecture", "name": "Distributed Mutual Exclusion", "properties": {"week": 2, "lecture_num": 12, "youtube_url": "https://www.youtube.com/watch?v=FUhLyoCNJ80", "course_id": "course_106104182"}}
{"id": "lecture_106104182_w2_l13", "type": "V_lecture", "name": "Consensus in Cloud Computing and Paxos", "properties": {"week": 2, "lecture_num": 13, "youtube_url": "https://www.youtube.com/watch?v=GQSiCjXL81g", "course_id": "course_106104182"}}
{"id": "lecture_106104182_w2_l14", "type": "V_lecture", "name": "Byzantine Agreement", "properties": {"week": 2, "lecture_num": 14, "youtube_url": "https://www.youtube.com/watch?v=iMOQWyWQaiY", "course_id": "course_106104182"}}
{"id": "lecture_106104182_w3_l15", "type": "V_lecture", "name": "Failures & Recovery Approaches in Distributed Systems", "properties": {"week": 3, "lecture_num": 15, "youtube_url": "https://www.youtube.com/watch?v=obIH0MTx1tU", "course_id": "course_106104182"}}
{"id": "lecture_106104182_w3_l16", "type": "V_lecture", "name": "Design of Key-Value Stores", "properties": {"week": 3, "lecture_num": 16, "youtube_url": "https://www.youtube.com/watch?v=q3unMI34KXM", "course_id": "course_106104182"}}
{"id": "lecture_106104182_w3_l17", "type": "V_lecture", "name": "Design of HBase", "properties": {"week": 3, "lecture_num": 17, "youtube_url": "https://www.youtube.com/watch?v=d12punvPmt0", "course_id": "course_106104182"}}
{"id": "lecture_106104182_w3_l18", "type": "V_lecture", "name": "Peer to Peer Systems in Cloud Computing", "properties": {"week": 3, "lecture_num": 18, "youtube_url": "https://www.youtube.com/watch?v=_-pB_YwwkMA", "course_id": "course_106104182"}}
{"id": "lecture_106104182_w3_l19", "type": "V_lecture", "name": "MapReduce", "properties": {"week": 3, "lecture_num": 19, "youtube_url": "https://www.youtube.com/watch?v=czSnUmc_RJk", "course_id": "course_106104182"}}
{"id": "lecture_106104182_w3_l20", "type": "V_lecture", "name": "Introduction to Spark", "properties": {"week": 3, "lecture_num": 20, "youtube_url": "https://www.youtube.com/watch?v=CRjfv-VzdWU", "course_id": "course_106104182"}}
{"id": "lecture_106104182_w3_l21", "type": "V_lecture", "name": "Introduction to Kafka", "properties": {"week": 3, "lecture_num": 21, "youtube_url": "https://www.youtube.com/watch?v=TD8KzxGdkGI", "course_id": "course_106104182"}}
{"id": "lecture_106104182_w4_l22", "type": "V_lecture", "name": "Live Session 10-03-2021", "properties": {"week": 4, "lecture_num": 22, "youtube_url": "https://www.youtube.com/watch?v=vQo-mjaUqGw", "course_id": "course_106104182"}}
{"id": "lecture_106104182_w4_l23", "type": "V_lecture", "name": "Live Session 04-03-2020", "properties": {"week": 4, "lecture_num": 23, "youtube_url": "https://www.youtube.com/watch?v=aXOfVSl2SQ4", "course_id": "course_106104182"}}
{"id": "course_106104449", "type": "V_course", "name": "Edge Computing", "properties": {"course_id": "noc26-cs30", "nptel_url": "https://nptel.ac.in/courses/106104449", "nptel_id": "106104449", "abstract": "Course Duration :\nJan-Mar 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-03-29\nCourse Abstract\n\nThis course we will cover fundamentals of Edge computing and its applications in low latency and critical real-time computing scenarios. The course brings in theory of Edge computing, focusing on it as a complementary approach that addresses some of the limitations of cloud computing. The course will cover applications where edge computing is a necessity, such as real-time applications that require low latency and high bandwidth. For example, autonomous vehicles require real-time processing of data from sensors, which cannot be done in a centralized data center due to latency issues.\n\nThis course covers various innovations of waves from cloud computing to edge computing. This course provides an in-depth understanding of edge computing principles with different use case of edge computing. In this course we will explore different frameworks for computing over edge devices and cloud. We will cover different techniques for distributed data analytics over edge devices like edge data center. Different edge computing fundamentals will be covered, such as RTT, Docker containers, Kubernetes, MQTT, Kafka, time and clock synchronization and key-value stores at edge. We will also cover various cloud platforms that provide edge services.\n\nThis course also covers recent advances of machine learning, deep learning and artificial intelligence with appropriate use cases in edge computing such as predictive maintenance, self driving cars and deep reinforcement learning for edge applications.\n\nINTENDED AUDIENCE: CSE, ECE, EE\n\nPREREQUISITES: Networking\n\nINDUSTRY SUPPORT: IT industries Course Duration :\nJan-Mar 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExam Date :\n2026-03-29 Course Duration :\nJan-Mar 2026\nEnrollment :\n2025-11-17 to 2026-01-26\nExam Registration :\n2025-12-13 to 2026-02-13\nExa", "professor": "Prof. Rajiv Misra", "institute": "IIT Patna", "duration": "8 Weeks", "stream_id": "stream_computer_science_and_engineering"}}
{"id": "lecture_106104449_w1_l1", "type": "V_lecture", "name": "Lecture 1 - Overview of Cloud Computing", "properties": {"week": 1, "lecture_num": 1, "youtube_url": "https://www.youtube.com/watch?v=w2caA8ty36s", "course_id": "course_106104449"}}
{"id": "lecture_106104449_w1_l2", "type": "V_lecture", "name": "Lecture 2 - Cloud Computing and its Limitation to Support Low Latency and RTT", "properties": {"week": 1, "lecture_num": 2, "youtube_url": "https://www.youtube.com/watch?v=Ph3j_dNvAlA", "course_id": "course_106104449"}}
{"id": "lecture_106104449_w1_l3", "type": "V_lecture", "name": "Lecture 3 - Introduction to Edge Computing", "properties": {"week": 1, "lecture_num": 3, "youtube_url": "https://www.youtube.com/watch?v=mfIedOuZYY4", "course_id": "course_106104449"}}
{"id": "lecture_106104449_w1_l4", "type": "V_lecture", "name": "Lecture 4 - Edge Computing Paradigms - 004", "properties": {"week": 1, "lecture_num": 4, "youtube_url": "https://www.youtube.com/watch?v=1_k0PoMv0ts", "course_id": "course_106104449"}}
{"id": "lecture_106104449_w1_l5", "type": "V_lecture", "name": "Lecture 05 : Overview of Virtualization", "properties": {"week": 1, "lecture_num": 5, "youtube_url": "https://www.youtube.com/watch?v=EoE7MOGB5Ik", "course_id": "course_106104449"}}
{"id": "lecture_106104449_w1_l6", "type": "V_lecture", "name": "Lecture 06 : Docker Containers", "properties": {"week": 1, "lecture_num": 6, "youtube_url": "https://www.youtube.com/watch?v=KoPUmPdYAPc", "course_id": "course_106104449"}}
{"id": "lecture_106104449_w1_l7", "type": "V_lecture", "name": "Lecture 07:  Kubernetes", "properties": {"week": 1, "lecture_num": 7, "youtube_url": "https://www.youtube.com/watch?v=ramTsf8sYqY", "course_id": "course_106104449"}}
{"id": "lecture_106104449_w2_l8", "type": "V_lecture", "name": "Lecture 08: NoSQL Databases and Key Value Stores", "properties": {"week": 2, "lecture_num": 8, "youtube_url": "https://www.youtube.com/watch?v=-s29jUAkg70", "course_id": "course_106104449"}}
{"id": "lecture_106104449_w2_l9", "type": "V_lecture", "name": "Lecture 09:  Edge AI Intelligence at the Edge", "properties": {"week": 2, "lecture_num": 9, "youtube_url": "https://www.youtube.com/watch?v=ON_ndZNDjok", "course_id": "course_106104449"}}
{"id": "lecture_106104449_w2_l10", "type": "V_lecture", "name": "Lecture 10 - Edge AI Intelligence at the Edge", "properties": {"week": 2, "lecture_num": 10, "youtube_url": "https://www.youtube.com/watch?v=_X6p-p6VOb4", "course_id": "course_106104449"}}
{"id": "lecture_106104449_w2_l11", "type": "V_lecture", "name": "Lecture 11 - Mobile Edge Computing", "properties": {"week": 2, "lecture_num": 11, "youtube_url": "https://www.youtube.com/watch?v=EbvrAwoB9u4", "course_id": "course_106104449"}}
{"id": "lecture_106104449_w2_l12", "type": "V_lecture", "name": "Lecture 12 - Geo-distributed Data Centers", "properties": {"week": 2, "lecture_num": 12, "youtube_url": "https://www.youtube.com/watch?v=nIljfZJ_M9Q", "course_id": "course_106104449"}}
{"id": "lecture_106104449_w2_l13", "type": "V_lecture", "name": "Lecture 13 - Time and Clock Synchronization", "properties": {"week": 2, "lecture_num": 13, "youtube_url": "https://www.youtube.com/watch?v=vJHvK57PDZE", "course_id": "course_106104449"}}
{"id": "lecture_106104449_w2_l14", "type": "V_lecture", "name": "Lecture 14 - Edge Computing Security and Privacy", "properties": {"week": 2, "lecture_num": 14, "youtube_url": "https://www.youtube.com/watch?v=IgXbwDNsBUk", "course_id": "course_106104449"}}
{"id": "concept_artificial_intelligence", "type": "V_concept", "name": "Artificial Intelligence", "properties": {"description": "A field of study focused on creating intelligent machines that can think and learn like humans.", "keywords": ["science", "artificial intelligence", "ai", "machine learning", "learning", "computer", "intelligence", "artificial", "machine"], "source_lectures": ["lecture_106108840_w1_l1", "lecture_106104449_w2_l10", "lecture_106103220_w6_l40", "lecture_106104182_w4_l22"]}}
{"id": "concept_machine_learning", "type": "V_concept", "name": "Machine Learning", "properties": {"description": "A subset of artificial intelligence that enables systems to learn from data without being explicitly programmed.", "keywords": ["models", "statistical", "prediction", "programming", "ai", "data", "machine learning", "learning", "algorithm", "artificial", "experience", "intelligence", "algorithms", "machine"], "source_lectures": ["lecture_106108840_w1_l1", "lecture_106103843_w2_l12", "lecture_106104449_w1_l3", "lecture_106104449_w2_l10", "lecture_106108841_w2_l10", "lecture_106103843_w1_l1", "lecture_106108229_w1_l2"]}}
{"id": "concept_deep_learning", "type": "V_concept", "name": "Deep Learning", "properties": {"description": "A subset of machine learning based on artificial neural networks that can handle large and complex data sets.", "keywords": ["networks", "complexity", "network", "deep", "learning", "neural", "complex", "machine"], "source_lectures": ["lecture_106108840_w1_l1", "lecture_106103843_w2_l12", "lecture_106104449_w2_l10", "lecture_106103843_w2_l9", "lecture_106103843_w2_l10", "lecture_106103220_w6_l40"]}}
{"id": "concept_supervised_learning", "type": "V_concept", "name": "Supervised Learning", "properties": {"description": "A type of machine learning where the model is trained on labeled data to make predictions.", "keywords": ["model", "mapping", "labeled data", "supervised", "machine learning", "learning", "training", "labeled", "data", "supervised learning", "machine"], "source_lectures": ["lecture_106108840_w1_l1", "lecture_106108841_w2_l8", "lecture_106103843_w1_l1", "lecture_106103843_w1_l2", "lecture_106103843_w1_l6", "lecture_106103843_w2_l9", "lecture_106103220_w4_l28"]}}
{"id": "concept_unsupervised_learning", "type": "V_concept", "name": "Unsupervised Learning", "properties": {"description": "A type of machine learning where the model is trained on unlabeled data to discover patterns.", "keywords": ["unlabeled", "unlabeled data", "unsupervised learning", "machine learning", "learning", "patterns", "clustering", "data", "unsupervised"], "source_lectures": ["lecture_106108840_w1_l1", "lecture_106108841_w2_l8", "lecture_106103843_w1_l1"]}}
{"id": "concept_reinforcement_learning", "type": "V_concept", "name": "Reinforcement Learning", "properties": {"description": "A type of machine learning where the model learns from feedback from the environment to make decisions.", "keywords": ["reward", "environment", "learning", "reinforcement", "agent", "reinforcement learning", "feedback"], "source_lectures": ["lecture_106108840_w1_l1", "lecture_106103843_w1_l1"]}}
{"id": "concept_artificial_neural_network", "type": "V_concept", "name": "Artificial Neural Network", "properties": {"description": "A mathematical model of the neurons or network of neurons that are present in the human brain.", "keywords": ["artificial", "neural", "network", "brain"], "source_lectures": ["lecture_106108840_w1_l1"]}}
{"id": "concept_convolutional_neural_network", "type": "V_concept", "name": "Convolutional Neural Network", "properties": {"description": "A type of artificial neural network that is trained directly on raw images to detect features.", "keywords": ["deep learning", "image processing", "feature extraction", "image", "convolutional", "images", "computer vision", "network", "cnn", "deep", "spatial", "convolution", "neural", "processing", "neural network"], "source_lectures": ["lecture_106108840_w1_l1", "lecture_106108840_w2_l12", "lecture_106108840_w3_l15", "lecture_106108840_w3_l19", "lecture_106108840_w3_l20", "lecture_106103843_w2_l11", "lecture_106103843_w3_l15", "lecture_106108840_w2_l11", "lecture_106108840_w3_l21", "lecture_106103843_w2_l10", "lecture_106103843_w2_l14"]}}
{"id": "concept_classification", "type": "V_concept", "name": "Classification", "properties": {"description": "A type of supervised learning algorithm that predicts a categorical label.", "keywords": ["classification", "discrete", "categorization", "discrete output", "supervised", "categories", "learning", "algorithm"], "source_lectures": ["lecture_106108840_w1_l1", "lecture_106103843_w1_l1", "lecture_106103843_w1_l2"]}}
{"id": "concept_regression", "type": "V_concept", "name": "Regression", "properties": {"description": "A type of supervised learning algorithm that predicts a continuous value.", "keywords": ["prediction", "continuous output", "supervised", "learning", "regression", "algorithm", "continuous"], "source_lectures": ["lecture_106108840_w1_l1", "lecture_106103843_w1_l1", "lecture_106103843_w1_l2"]}}
{"id": "concept_clustering", "type": "V_concept", "name": "Clustering", "properties": {"description": "A type of unsupervised learning algorithm that groups similar data points into clusters.", "keywords": ["structure", "learning", "clustering", "grouping", "algorithm", "unsupervised"], "source_lectures": ["lecture_106108840_w1_l1", "lecture_106103843_w1_l1"]}}
{"id": "concept_backpropagation", "type": "V_concept", "name": "Backpropagation", "properties": {"description": "An algorithm used to train artificial neural networks by minimizing the error between predicted and actual outputs.", "keywords": ["loss", "networks", "algorithm", "neural", "function", "backpropagation", "training"], "source_lectures": ["lecture_106108840_w1_l1", "lecture_106108840_w2_l14"]}}
{"id": "concept_self_driving_cars", "type": "V_concept", "name": "Self-Driving Cars", "properties": {"description": "A application of deep learning that enables cars to navigate and make decisions without human input.", "keywords": ["self-driving", "cars", "deep", "learning"], "source_lectures": ["lecture_106108840_w1_l1"]}}
{"id": "concept_language_translation", "type": "V_concept", "name": "Language Translation", "properties": {"description": "A application of deep learning that enables computers to translate text from one language to another.", "keywords": ["language", "translation", "deep", "learning"], "source_lectures": ["lecture_106108840_w1_l1"]}}
{"id": "concept_facial_recognition", "type": "V_concept", "name": "Facial Recognition", "properties": {"description": "A application of deep learning that enables computers to identify and recognize individual faces.", "keywords": ["facial", "recognition", "deep", "learning"], "source_lectures": ["lecture_106108840_w1_l1"]}}
{"id": "concept_biological_neuron", "type": "V_concept", "name": "Biological Neuron", "properties": {"description": "A specialized cell that processes and transmits information through electrical and chemical signals.", "keywords": ["electrochemical", "nerve cell", "signal", "biological", "cell", "neuron", "signals"], "source_lectures": ["lecture_106108840_w1_l2", "lecture_106103843_w1_l6"]}}
{"id": "concept_artificial_neuron", "type": "V_concept", "name": "Artificial Neuron", "properties": {"description": "A mathematical model that mimics the behavior of a biological neuron, used in artificial neural networks.", "keywords": ["model", "network", "neuron", "building block", "mathematical", "artificial"], "source_lectures": ["lecture_106108840_w1_l2", "lecture_106103843_w1_l6"]}}
{"id": "concept_dendrites", "type": "V_concept", "name": "Dendrites", "properties": {"description": "The branching extensions of a neuron that receive signals from other neurons.", "keywords": ["dendrites", "neuron", "branching", "extensions", "signals"], "source_lectures": ["lecture_106108840_w1_l2"]}}
{"id": "concept_axon", "type": "V_concept", "name": "Axon", "properties": {"description": "A long, thin extension of a neuron that carries signals away from the cell body.", "keywords": ["axon", "neuron", "extension", "signals", "cell body"], "source_lectures": ["lecture_106108840_w1_l2"]}}
{"id": "concept_synapse", "type": "V_concept", "name": "Synapse", "properties": {"description": "The gap between two neurons where chemical signals are transmitted from one neuron to another.", "keywords": ["synapse", "neuron", "gap", "chemical", "signals"], "source_lectures": ["lecture_106108840_w1_l2"]}}
{"id": "concept_neurotransmitters", "type": "V_concept", "name": "Neurotransmitters", "properties": {"description": "Chemical messengers that transmit signals from one neuron to another across the synapse.", "keywords": ["neurotransmitters", "chemical", "messengers", "signals", "synapse"], "source_lectures": ["lecture_106108840_w1_l2"]}}
{"id": "concept_activation_function", "type": "V_concept", "name": "Activation Function", "properties": {"description": "A mathematical function that determines the output of an artificial neuron based on its input.", "keywords": ["networks", "nonlinearity", "non-linearity", "activation", "relu", "network", "complex relationships", "function", "neuron", "activation function", "mathematical", "neural", "artificial", "neural network"], "source_lectures": ["lecture_106108840_w1_l2", "lecture_106108840_w1_l4", "lecture_106108840_w1_l5", "lecture_106108840_w2_l10", "lecture_106108840_w2_l12", "lecture_106108840_w2_l14", "lecture_106103843_w1_l7", "lecture_106103843_w2_l8", "lecture_106103843_w1_l6", "lecture_106103843_w2_l9", "lecture_106103843_w2_l14"]}}
{"id": "concept_perceptron", "type": "V_concept", "name": "Perceptron", "properties": {"description": "A type of artificial neural network that can be trained to perform binary classification tasks.", "keywords": ["perceptron", "artificial", "neural", "network", "binary"], "source_lectures": ["lecture_106108840_w1_l2"]}}
{"id": "concept_perceptron_learning_algorithm", "type": "V_concept", "name": "Perceptron Learning Algorithm", "properties": {"description": "An algorithm used to train a perceptron to perform binary classification tasks.", "keywords": ["perceptron", "learning", "algorithm", "binary", "classification"], "source_lectures": ["lecture_106108840_w1_l2"]}}
{"id": "concept_single_layer_perceptron", "type": "V_concept", "name": "Single Layer Perceptron", "properties": {"description": "A type of perceptron that consists of only one layer of artificial neurons.", "keywords": ["perceptron", "single", "neural network", "neuron", "linearly separable", "neural", "single layer", "artificial", "layer"], "source_lectures": ["lecture_106108840_w1_l2", "lecture_106108840_w1_l3", "lecture_106108840_w1_l4", "lecture_106103843_w1_l6"]}}
{"id": "concept_weight_update_formula", "type": "V_concept", "name": "Weight Update Formula", "properties": {"description": "A formula used to update the weights of an artificial neuron during the training process.", "keywords": ["weight", "update", "formula", "artificial", "neuron"], "source_lectures": ["lecture_106108840_w1_l2"]}}
{"id": "concept_bias_term", "type": "V_concept", "name": "Bias Term", "properties": {"description": "A constant value added to the output of an artificial neuron to shift the decision boundary.", "keywords": ["constant", "weighted sum", "term", "neuron", "bias term", "threshold", "bias", "artificial"], "source_lectures": ["lecture_106108840_w1_l2", "lecture_106103843_w1_l6"]}}
{"id": "concept_decision_boundary", "type": "V_concept", "name": "Decision Boundary", "properties": {"description": "The boundary that separates the classes in a binary classification problem.", "keywords": ["boundary", "classification", "decision boundary", "hyperplane", "separator", "problem", "binary", "decision"], "source_lectures": ["lecture_106108840_w1_l2", "lecture_106103843_w1_l4", "lecture_106103843_w1_l1"]}}
{"id": "concept_multi_layer_perceptron", "type": "V_concept", "name": "Multi-Layer Perceptron", "properties": {"description": "A type of artificial neural network with multiple layers of neurons, used for both linearly and nonlinearly separable problems.", "keywords": ["perceptron", "classification", "nonlinearly separable", "multi-layer", "network", "layer", "regression", "multi", "mlp", "neural", "neural network"], "source_lectures": ["lecture_106108840_w1_l3", "lecture_106108840_w1_l4", "lecture_106108840_w2_l10", "lecture_106103843_w1_l7", "lecture_106108840_w2_l11", "lecture_106108840_w3_l21", "lecture_106103843_w2_l9"]}}
{"id": "concept_linearly_separable_problem", "type": "V_concept", "name": "Linearly Separable Problem", "properties": {"description": "A problem where the data can be separated into different classes using a straight line or hyperplane.", "keywords": ["linearly separable", "problem", "data", "classification"], "source_lectures": ["lecture_106108840_w1_l3"]}}
{"id": "concept_nonlinearly_separable_problem", "type": "V_concept", "name": "Nonlinearly Separable Problem", "properties": {"description": "A problem where the data cannot be separated into different classes using a straight line or hyperplane.", "keywords": ["nonlinearly separable", "problem", "data", "classification"], "source_lectures": ["lecture_106108840_w1_l3"]}}
{"id": "concept_perceptron_learning_rule", "type": "V_concept", "name": "Perceptron Learning Rule", "properties": {"description": "An algorithm used to update the weights of a perceptron, based on the error between the predicted and actual outputs.", "keywords": ["perceptron learning rule", "algorithm", "weights", "error"], "source_lectures": ["lecture_106108840_w1_l3"]}}
{"id": "concept_back_propagation_algorithm", "type": "V_concept", "name": "Back Propagation Algorithm", "properties": {"description": "An algorithm used to update the weights of a multi-layer perceptron, based on the error between the predicted and actual outputs.", "keywords": ["propagation", "back propagation", "neural", "algorithm", "weights", "back", "training", "error"], "source_lectures": ["lecture_106108840_w1_l3", "lecture_106108840_w1_l4"]}}
{"id": "concept_threshold_activation_function", "type": "V_concept", "name": "Threshold Activation Function", "properties": {"description": "A type of activation function that outputs 1 if the input is greater than a certain threshold, and 0 otherwise.", "keywords": ["threshold activation function", "activation function", "neural network"], "source_lectures": ["lecture_106108840_w1_l3"]}}
{"id": "concept_step_activation_function", "type": "V_concept", "name": "Step Activation Function", "properties": {"description": "A type of activation function that outputs 1 if the input is greater than a certain threshold, and 0 otherwise, similar to the threshold activation function.", "keywords": ["step activation function", "activation function", "neural network"], "source_lectures": ["lecture_106108840_w1_l3"]}}
{"id": "concept_google_collab", "type": "V_concept", "name": "Google Collab", "properties": {"description": "A free cloud-based platform for data science and machine learning, providing a Jupyter notebook environment.", "keywords": ["cloud", "collab", "python", "data science", "cloud-based", "google collab", "jupyter notebook", "google"], "source_lectures": ["lecture_106108840_w1_l3", "lecture_106108841_w2_l11"]}}
{"id": "concept_binary_classification", "type": "V_concept", "name": "Binary Classification", "properties": {"description": "A type of classification problem where the data is divided into two classes or categories.", "keywords": ["target", "binary classification", "two-class", "classification", "classes", "variable", "problem", "outcomes", "binary", "data"], "source_lectures": ["lecture_106108840_w1_l3", "lecture_106108840_w2_l10", "lecture_106103843_w1_l4"]}}
{"id": "concept_feed_forward_neural_network", "type": "V_concept", "name": "Feed Forward Neural Network", "properties": {"description": "A type of neural network where the information flows only in one direction, from input layer to output layer, without any feedback loops.", "keywords": ["direction", "forward", "network", "neural", "feed"], "source_lectures": ["lecture_106108840_w1_l4", "lecture_106103843_w1_l7", "lecture_106103843_w2_l8"]}}
{"id": "concept_sigmoid_activation_function", "type": "V_concept", "name": "Sigmoid Activation Function", "properties": {"description": "A specific type of activation function that maps any real-valued number to a value between 0 and 1, often used in neural networks.", "keywords": ["networks", "activation", "non-linearity", "sigmoid", "nonlinear", "function", "output", "neural", "real-valued"], "source_lectures": ["lecture_106108840_w1_l4", "lecture_106108840_w1_l5", "lecture_106108840_w1_l7", "lecture_106108840_w2_l10", "lecture_106108840_w3_l18", "lecture_106103843_w3_l16"]}}
{"id": "concept_shallow_neural_network", "type": "V_concept", "name": "Shallow Neural Network", "properties": {"description": "A type of neural network with only one hidden layer, often used for simple problems and linearly separable data.", "keywords": ["shallow", "neural", "network", "simple"], "source_lectures": ["lecture_106108840_w1_l4"]}}
{"id": "concept_deep_neural_network", "type": "V_concept", "name": "Deep Neural Network", "properties": {"description": "A type of neural network with multiple hidden layers, often used for complex problems and non-linearly separable data.", "keywords": ["tasks", "network", "deep", "neural", "complex"], "source_lectures": ["lecture_106108840_w1_l4", "lecture_106103843_w2_l10"]}}
{"id": "concept_weighted_sum", "type": "V_concept", "name": "Weighted Sum", "properties": {"description": "A calculation used in neural networks to combine the inputs to a neuron, where each input is multiplied by a weight and the results are summed.", "keywords": ["weights", "sum", "inputs", "weighted", "network", "weighted sum", "neuron", "neural"], "source_lectures": ["lecture_106108840_w1_l4", "lecture_106103843_w1_l6"]}}
{"id": "concept_loss_function", "type": "V_concept", "name": "Loss Function", "properties": {"description": "A mathematical function that measures the difference between the predicted and actual outputs of a neural network, used to train the network.", "keywords": ["loss", "model", "prediction", "hypothesis", "error", "network", "function", "machine learning", "learning", "training", "optimization", "mathematical", "neural", "difference", "machine"], "source_lectures": ["lecture_106108840_w1_l4", "lecture_106108840_w1_l5", "lecture_106108840_w1_l6", "lecture_106108840_w1_l7", "lecture_106103843_w1_l4", "lecture_106108841_w3_l16", "lecture_106108841_w3_l17", "lecture_106108841_w3_l19"]}}
{"id": "concept_linear_activation_function", "type": "V_concept", "name": "Linear Activation Function", "properties": {"description": "An activation function where the output is the same as the input, also known as the identity function.", "keywords": ["linear", "activation", "function", "identity"], "source_lectures": ["lecture_106108840_w1_l5"]}}
{"id": "concept_tanh_activation_function", "type": "V_concept", "name": "Tanh Activation Function", "properties": {"description": "A nonlinear activation function that maps any real-valued number to a value between -1 and 1.", "keywords": ["nonlinear", "networks", "tanh", "neural", "function", "activation"], "source_lectures": ["lecture_106108840_w1_l5", "lecture_106108840_w3_l18"]}}
{"id": "concept_softmax_activation_function", "type": "V_concept", "name": "Softmax Activation Function", "properties": {"description": "A nonlinear activation function that maps a vector of real-valued numbers to a vector of values between 0 and 1, where the sum of the values is 1.", "keywords": ["distribution", "softmax", "activation", "network", "function", "nonlinear", "probability", "neural"], "source_lectures": ["lecture_106108840_w1_l5", "lecture_106108840_w3_l17", "lecture_106108840_w3_l21"]}}
{"id": "concept_relu_activation_function", "type": "V_concept", "name": "ReLU Activation Function", "properties": {"description": "A nonlinear activation function that maps all negative values to 0 and all positive values to the same value.", "keywords": ["nonlinear", "negative", "networks", "positive", "non-linearity", "network", "relu", "neural", "function", "activation"], "source_lectures": ["lecture_106108840_w1_l5", "lecture_106108840_w2_l10", "lecture_106108840_w2_l13", "lecture_106108840_w2_l14", "lecture_106108840_w3_l15", "lecture_106108840_w3_l16", "lecture_106108840_w3_l17", "lecture_106108840_w3_l18"]}}
{"id": "concept_leaky_relu_activation_function", "type": "V_concept", "name": "Leaky ReLU Activation Function", "properties": {"description": "A variation of the ReLU activation function that maps all negative values to a small non-zero value instead of 0.", "keywords": ["leaky", "relu", "activation", "function"], "source_lectures": ["lecture_106108840_w1_l5"]}}
{"id": "concept_mean_squared_error", "type": "V_concept", "name": "Mean Squared Error", "properties": {"description": "A loss function that measures the average squared difference between the model's predictions and the actual true values.", "keywords": ["mse", "loss", "squared", "error", "squared error", "function", "mean", "mean squared error", "cost"], "source_lectures": ["lecture_106108840_w1_l5", "lecture_106108840_w1_l7", "lecture_106103843_w1_l2"]}}
{"id": "concept_mean_absolute_error", "type": "V_concept", "name": "Mean Absolute Error", "properties": {"description": "A loss function that measures the average absolute difference between the model's predictions and the actual true values.", "keywords": ["mean", "absolute", "error", "loss"], "source_lectures": ["lecture_106108840_w1_l5"]}}
{"id": "concept_binary_cross_entropy_loss", "type": "V_concept", "name": "Binary Cross Entropy Loss", "properties": {"description": "A loss function that measures the difference between the model's predictions and the actual true values for binary classification problems.", "keywords": ["cross", "entropy", "classification", "function", "binary", "loss", "cross-entropy"], "source_lectures": ["lecture_106108840_w1_l5", "lecture_106108840_w2_l10"]}}
{"id": "concept_categorical_cross_entropy_loss", "type": "V_concept", "name": "Categorical Cross Entropy Loss", "properties": {"description": "A loss function that measures the difference between the model's predictions and the actual true values for multi-class classification problems.", "keywords": ["categorical", "cross", "entropy", "loss"], "source_lectures": ["lecture_106108840_w1_l5"]}}
{"id": "concept_kl_divergence_loss", "type": "V_concept", "name": "KL Divergence Loss", "properties": {"description": "A loss function that measures the difference between two probability distributions.", "keywords": ["kl", "divergence", "loss", "probability"], "source_lectures": ["lecture_106108840_w1_l5"]}}
{"id": "concept_neural_network_architecture", "type": "V_concept", "name": "Neural Network Architecture", "properties": {"description": "The design of a neural network, including the number of layers, the number of neurons in each layer, and the connections between them.", "keywords": ["architecture", "network", "structure", "design", "neural"], "source_lectures": ["lecture_106108840_w1_l5", "lecture_106103843_w2_l10"]}}
{"id": "concept_gradient_descent_algorithm", "type": "V_concept", "name": "Gradient Descent Algorithm", "properties": {"description": "A first-order iterative optimization algorithm used to minimize the loss function in machine learning models.", "keywords": ["gradient", "descent", "optimization", "machine learning"], "source_lectures": ["lecture_106108840_w1_l6"]}}
{"id": "concept_optimization_algorithm", "type": "V_concept", "name": "Optimization Algorithm", "properties": {"description": "A method used to adjust model parameters to minimize errors and improve accuracy.", "keywords": ["optimization", "algorithm", "machine learning", "model"], "source_lectures": ["lecture_106108840_w1_l6"]}}
{"id": "concept_partial_derivative", "type": "V_concept", "name": "Partial Derivative", "properties": {"description": "A derivative of a function with respect to one of its variables, while keeping the other variables constant.", "keywords": ["change", "calculus", "partial", "derivative", "function", "rate", "optimization", "mathematical", "mathematics", "concept"], "source_lectures": ["lecture_106108840_w1_l6", "lecture_106108840_w1_l7", "lecture_106108841_w5_l29", "lecture_106108841_w5_l30"]}}
{"id": "concept_gradient", "type": "V_concept", "name": "Gradient", "properties": {"description": "A vector of partial derivatives of a function with respect to its parameters.", "keywords": ["gradient", "vector", "partial", "derivative"], "source_lectures": ["lecture_106108840_w1_l6"]}}
{"id": "concept_learning_rate", "type": "V_concept", "name": "Learning Rate", "properties": {"description": "A hyperparameter that controls how quickly a model learns during training.", "keywords": ["descent", "rate", "hyperparameter", "gradient", "learning", "machine learning"], "source_lectures": ["lecture_106108840_w1_l6", "lecture_106108840_w1_l7", "lecture_106103843_w1_l3"]}}
{"id": "concept_convex_function", "type": "V_concept", "name": "Convex Function", "properties": {"description": "A mathematical function whose graph is curved upward, with a single minimum point.", "keywords": ["global minimum", "convex", "function", "optimization", "mathematics"], "source_lectures": ["lecture_106108840_w1_l6", "lecture_106103843_w1_l3", "lecture_106103843_w1_l2"]}}
{"id": "concept_non_convex_function", "type": "V_concept", "name": "Non-Convex Function", "properties": {"description": "A mathematical function whose graph is not curved upward, with multiple minimum points.", "keywords": ["non-convex", "function", "mathematics", "optimization"], "source_lectures": ["lecture_106108840_w1_l6"]}}
{"id": "concept_global_minima", "type": "V_concept", "name": "Global Minima", "properties": {"description": "The minimum point of a function that is the lowest among all possible points.", "keywords": ["mathematics", "minima", "global", "optimization"], "source_lectures": ["lecture_106108840_w1_l6", "lecture_106103843_w1_l3"]}}
{"id": "concept_local_minima", "type": "V_concept", "name": "Local Minima", "properties": {"description": "A minimum point of a function that is the lowest among nearby points, but not necessarily the global minimum.", "keywords": ["mathematics", "minima", "local", "optimization"], "source_lectures": ["lecture_106108840_w1_l6", "lecture_106103843_w1_l3"]}}
{"id": "concept_saddle_point", "type": "V_concept", "name": "Saddle Point", "properties": {"description": "A point on a function's graph where the gradient is zero, but it is not a local minimum.", "keywords": ["game", "optimization", "payoff", "mathematics", "strategy", "player", "point", "optimal", "saddle point", "saddle", "theory", "equilibrium", "nash equilibrium", "game theory"], "source_lectures": ["lecture_106108840_w1_l6", "lecture_106101360_w3_l15", "lecture_106101360_w3_l16", "lecture_106101360_w3_l17", "lecture_106101360_w4_l18", "lecture_106101360_w4_l19", "lecture_106101360_w4_l22"]}}
{"id": "concept_back_propagation", "type": "V_concept", "name": "Back Propagation", "properties": {"description": "An algorithm used to compute the partial derivatives of a loss function with respect to model parameters.", "keywords": ["networks", "back", "network", "machine learning", "training", "algorithm", "neural", "propagation"], "source_lectures": ["lecture_106108840_w1_l6", "lecture_106103843_w2_l8", "lecture_106103843_w2_l9", "lecture_106103843_w2_l10", "lecture_106103843_w3_l16"]}}
{"id": "concept_backpropagation_algorithm", "type": "V_concept", "name": "Backpropagation Algorithm", "properties": {"description": "A method for training artificial neural networks by minimizing the loss function using gradient descent.", "keywords": ["descent", "networks", "gradient", "network", "algorithm", "neural", "backpropagation", "training"], "source_lectures": ["lecture_106108840_w1_l7", "lecture_106103843_w1_l7", "lecture_106103843_w2_l11"]}}
{"id": "concept_gradient_descent", "type": "V_concept", "name": "Gradient Descent", "properties": {"description": "An optimization algorithm used to minimize the loss function in machine learning models.", "keywords": ["descent", "loss", "gradient", "error minimization", "function", "optimization", "algorithm", "gradient descent", "minimization", "machine"], "source_lectures": ["lecture_106108840_w1_l7", "lecture_106103843_w1_l3", "lecture_106103843_w1_l4", "lecture_106104449_w2_l10", "lecture_106108841_w2_l10", "lecture_106103843_w1_l6"]}}
{"id": "concept_neural_network", "type": "V_concept", "name": "Neural Network", "properties": {"description": "A machine learning model composed of layers of interconnected nodes (neurons) that process and transmit information.", "keywords": ["model", "computational", "network", "learning", "layers", "neural", "machine"], "source_lectures": ["lecture_106108840_w1_l7", "lecture_106108841_w2_l10", "lecture_106103843_w2_l9"]}}
{"id": "concept_weight_updation", "type": "V_concept", "name": "Weight Updation", "properties": {"description": "The process of adjusting the weights of a neural network during training to minimize the loss function.", "keywords": ["weight", "updation", "neural", "network", "training"], "source_lectures": ["lecture_106108840_w1_l7"]}}
{"id": "concept_chain_rule", "type": "V_concept", "name": "Chain Rule", "properties": {"description": "A mathematical rule used to calculate the derivative of a composite function, often used in backpropagation.", "keywords": ["chain", "derivative", "composite", "mathematical", "function", "rule", "calculus"], "source_lectures": ["lecture_106108840_w1_l7", "lecture_106103843_w2_l8"]}}
{"id": "concept_batch_gradient_descent", "type": "V_concept", "name": "Batch Gradient Descent", "properties": {"description": "A variant of gradient descent that uses all data points in each iteration to update the weights and biases.", "keywords": ["batch", "gradient", "descent", "optimization"], "source_lectures": ["lecture_106108840_w2_l8"]}}
{"id": "concept_stochastic_gradient_descent", "type": "V_concept", "name": "Stochastic Gradient Descent", "properties": {"description": "A variant of gradient descent that uses a single data point in each iteration to update the weights and biases.", "keywords": ["descent", "optimization", "stochastic", "sgd", "gradient"], "source_lectures": ["lecture_106108840_w2_l8", "lecture_106108840_w3_l16", "lecture_106103843_w1_l3"]}}
{"id": "concept_mini_batch_gradient_descent", "type": "V_concept", "name": "Mini-Batch Gradient Descent", "properties": {"description": "A variant of gradient descent that uses a small subset of data points in each iteration to update the weights and biases.", "keywords": ["descent", "optimization", "batch", "mini", "mini-batch", "gradient"], "source_lectures": ["lecture_106108840_w2_l8", "lecture_106103843_w1_l3"]}}
{"id": "concept_momentum_based_optimizers", "type": "V_concept", "name": "Momentum-Based Optimizers", "properties": {"description": "A type of optimizer that uses momentum to overcome local minima and oscillations in the optimization process.", "keywords": ["momentum", "optimizer", "local", "minima"], "source_lectures": ["lecture_106108840_w2_l8"]}}
{"id": "concept_nesterov_accelerated_gradient", "type": "V_concept", "name": "Nesterov Accelerated Gradient", "properties": {"description": "A variant of gradient descent that uses a look-ahead mechanism to reduce oscillations and improve convergence.", "keywords": ["nesterov", "accelerated", "gradient", "optimization"], "source_lectures": ["lecture_106108840_w2_l8"]}}
{"id": "concept_adagrad_optimizer", "type": "V_concept", "name": "Adagrad Optimizer", "properties": {"description": "An optimizer that adapts the learning rate based on the previous updates, suitable for sparse data sets.", "keywords": ["adagrad", "optimizer", "learning", "rate"], "source_lectures": ["lecture_106108840_w2_l8"]}}
{"id": "concept_rmsprop_optimizer", "type": "V_concept", "name": "RMSProp Optimizer", "properties": {"description": "An optimizer that uses an exponentially decaying average of squared gradients to adapt the learning rate.", "keywords": ["rmsprop", "optimizer", "learning", "rate"], "source_lectures": ["lecture_106108840_w2_l8"]}}
{"id": "concept_adam_optimizer", "type": "V_concept", "name": "Adam Optimizer", "properties": {"description": "A popular optimizer that combines the advantages of momentum and RMSProp to adapt the learning rate.", "keywords": ["rate", "adam", "gradient", "learning", "optimizer"], "source_lectures": ["lecture_106108840_w2_l8", "lecture_106108840_w3_l15"]}}
{"id": "concept_adder_delta_optimizer", "type": "V_concept", "name": "Adder Delta Optimizer", "properties": {"description": "An optimizer that dynamically tunes the effective learning rate without requiring an initial learning rate.", "keywords": ["adder", "delta", "optimizer", "learning", "rate"], "source_lectures": ["lecture_106108840_w2_l8"]}}
{"id": "concept_sparse_data_set", "type": "V_concept", "name": "Sparse Data Set", "properties": {"description": "A data set where most of the features have zero values, making the gradient updates small.", "keywords": ["sparse", "data", "set", "features"], "source_lectures": ["lecture_106108840_w2_l8"]}}
{"id": "concept_dense_data_set", "type": "V_concept", "name": "Dense Data Set", "properties": {"description": "A data set where most of the features have non-zero values, making the gradient updates large.", "keywords": ["dense", "data", "set", "features"], "source_lectures": ["lecture_106108840_w2_l8"]}}
{"id": "concept_learning_rate_decay", "type": "V_concept", "name": "Learning Rate Decay", "properties": {"description": "A technique to reduce the learning rate over time to improve convergence.", "keywords": ["learning", "rate", "decay", "convergence"], "source_lectures": ["lecture_106108840_w2_l8"]}}
{"id": "concept_time_based_decay", "type": "V_concept", "name": "Time-Based Decay", "properties": {"description": "A type of learning rate decay that reduces the learning rate based on the current time step.", "keywords": ["time-based", "decay", "learning", "rate"], "source_lectures": ["lecture_106108840_w2_l8"]}}
{"id": "concept_exponential_decay", "type": "V_concept", "name": "Exponential Decay", "properties": {"description": "A type of learning rate decay that reduces the learning rate exponentially based on the current time step.", "keywords": ["exponential", "decay", "learning", "rate"], "source_lectures": ["lecture_106108840_w2_l8"]}}
{"id": "concept_regularization_techniques", "type": "V_concept", "name": "Regularization Techniques", "properties": {"description": "Methods used to reduce overfitting in machine learning models", "keywords": ["regularization", "overfitting", "machine learning"], "source_lectures": ["lecture_106108840_w2_l9"]}}
{"id": "concept_overfitting", "type": "V_concept", "name": "Overfitting", "properties": {"description": "When a model learns the noise and random variations in the training data, resulting in poor generalization to new data", "keywords": ["model", "dataset", "networks", "complexity", "generalization", "noise", "machine learning", "training", "training data", "overfitting", "learning", "neural", "model complexity", "data", "random variations", "machine"], "source_lectures": ["lecture_106108840_w2_l9", "lecture_106108840_w2_l14", "lecture_106108840_w3_l19", "lecture_106108841_w1_l1", "lecture_106108841_w3_l17", "lecture_106103843_w1_l5", "lecture_106103843_w2_l9", "lecture_106103843_w3_l16"]}}
{"id": "concept_l1_regularization", "type": "V_concept", "name": "L1 Regularization", "properties": {"description": "A regularization technique that adds a penalty term proportional to the absolute value of the model's coefficients", "keywords": ["regularization", "weights", "loss", "penalty term", "lasso regression", "l1", "penalty", "function", "machine learning", "term", "l1 regularization", "lasso"], "source_lectures": ["lecture_106108840_w2_l9", "lecture_106108840_w2_l10", "lecture_106108840_w3_l15", "lecture_106103843_w1_l5"]}}
{"id": "concept_l2_regularization", "type": "V_concept", "name": "L2 Regularization", "properties": {"description": "A regularization technique that adds a penalty term proportional to the square of the model's coefficients", "keywords": ["regularization", "weights", "penalty term", "loss", "l2", "penalty", "function", "ridge regression", "term", "machine learning", "ridge", "l2 regularization"], "source_lectures": ["lecture_106108840_w2_l9", "lecture_106108840_w2_l10", "lecture_106108840_w3_l15", "lecture_106103843_w1_l5"]}}
{"id": "concept_feature_selection", "type": "V_concept", "name": "Feature Selection", "properties": {"description": "The process of selecting a subset of relevant features to use in a model", "keywords": ["feature selection", "relevant features", "model"], "source_lectures": ["lecture_106108840_w2_l9"]}}
{"id": "concept_data_augmentation", "type": "V_concept", "name": "Data Augmentation", "properties": {"description": "A technique used to increase the size of a training dataset by applying random transformations to the existing data", "keywords": ["transformation", "size", "dataset", "transformations", "technique", "data augmentation", "augmentation", "training", "data", "training dataset"], "source_lectures": ["lecture_106108840_w2_l9", "lecture_106108840_w3_l15", "lecture_106108840_w3_l16", "lecture_106108840_w2_l11", "lecture_106108840_w3_l21"]}}
{"id": "concept_early_stopping", "type": "V_concept", "name": "Early Stopping", "properties": {"description": "A technique used to prevent overfitting by stopping the training process when the model's performance on the validation set starts to degrade", "keywords": ["regularization", "validation set", "early stopping", "stopping", "validation", "machine learning", "training", "overfitting", "early"], "source_lectures": ["lecture_106108840_w2_l9", "lecture_106108840_w2_l10", "lecture_106103843_w1_l5"]}}
{"id": "concept_dropout_regularization", "type": "V_concept", "name": "Dropout Regularization", "properties": {"description": "A technique used to prevent overfitting by randomly dropping out units during training", "keywords": ["dropout regularization", "overfitting", "network", "neural", "units", "regularization", "dropout"], "source_lectures": ["lecture_106108840_w2_l9", "lecture_106108840_w3_l15"]}}
{"id": "concept_l1_norm", "type": "V_concept", "name": "L1 Norm", "properties": {"description": "A measure of the magnitude of a vector, calculated as the sum of the absolute values of its components", "keywords": ["l1 norm", "magnitude", "vector"], "source_lectures": ["lecture_106108840_w2_l9"]}}
{"id": "concept_l2_norm", "type": "V_concept", "name": "L2 Norm", "properties": {"description": "A measure of the magnitude of a vector, calculated as the square root of the sum of the squares of its components", "keywords": ["l2 norm", "magnitude", "vector"], "source_lectures": ["lecture_106108840_w2_l9"]}}
{"id": "concept_hyperparameter", "type": "V_concept", "name": "Hyperparameter", "properties": {"description": "A parameter that is set before training a model, such as the learning rate or regularization strength", "keywords": ["configuration", "model selection", "learning rate", "hyperparameter", "optimization", "regularization strength"], "source_lectures": ["lecture_106108840_w2_l9", "lecture_106108841_w4_l22"]}}
{"id": "concept_outlier", "type": "V_concept", "name": "Outlier", "properties": {"description": "A data point that is significantly different from the other data points in a dataset", "keywords": ["outlier", "data point", "dataset"], "source_lectures": ["lecture_106108840_w2_l9"]}}
{"id": "concept_min_max_scaler", "type": "V_concept", "name": "Min-Max Scaler", "properties": {"description": "A technique used to normalize data by scaling it to a common range, usually between 0 and 1.", "keywords": ["min-max", "scaler", "normalization", "data", "range"], "source_lectures": ["lecture_106108840_w2_l10"]}}
{"id": "concept_train_test_split", "type": "V_concept", "name": "Train-Test Split", "properties": {"description": "A technique used to split a dataset into training and testing sets.", "keywords": ["train", "test", "split", "dataset", "evaluation"], "source_lectures": ["lecture_106108840_w2_l10"]}}
{"id": "concept_epoch", "type": "V_concept", "name": "Epoch", "properties": {"description": "A single pass through the entire training dataset.", "keywords": ["epoch", "training", "dataset", "pass"], "source_lectures": ["lecture_106108840_w2_l10"]}}
{"id": "concept_batch_size", "type": "V_concept", "name": "Batch Size", "properties": {"description": "The number of samples that are processed together as a single unit before the model is updated.", "keywords": ["batch", "size", "samples", "update", "model"], "source_lectures": ["lecture_106108840_w2_l10"]}}
{"id": "concept_optimizer", "type": "V_concept", "name": "Optimizer", "properties": {"description": "An algorithm used to update the model's parameters to minimize the loss function.", "keywords": ["optimizer", "algorithm", "parameters", "loss", "function"], "source_lectures": ["lecture_106108840_w2_l10"]}}
{"id": "concept_regularization", "type": "V_concept", "name": "Regularization", "properties": {"description": "A technique used to prevent overfitting by adding a penalty term to the loss function.", "keywords": ["regularization", "loss", "penalty term", "penalty", "machine learning", "term", "overfitting"], "source_lectures": ["lecture_106108840_w2_l10", "lecture_106103843_w1_l5"]}}
{"id": "concept_dropout", "type": "V_concept", "name": "Dropout", "properties": {"description": "A regularization technique that randomly sets a fraction of the neurons to zero during training.", "keywords": ["dropout", "overfitting", "network", "neural", "fraction", "neurons", "regularization", "training", "technique"], "source_lectures": ["lecture_106108840_w2_l10", "lecture_106108840_w3_l16", "lecture_106108840_w3_l20"]}}
{"id": "concept_human_visual_system", "type": "V_concept", "name": "Human Visual System", "properties": {"description": "The biological system responsible for processing visual information in humans.", "keywords": ["human visual system", "biology", "vision", "brain"], "source_lectures": ["lecture_106108840_w2_l12"]}}
{"id": "concept_convolutional_layer", "type": "V_concept", "name": "Convolutional Layer", "properties": {"description": "The fundamental building block of a convolutional neural network, responsible for extracting features from input images.", "keywords": ["image processing", "feature extraction", "convolutional layer", "filters", "convolutional", "feature detection", "cnn", "local patterns", "filter", "convolution", "neural", "layer"], "source_lectures": ["lecture_106108840_w2_l12", "lecture_106103843_w3_l15", "lecture_106103843_w2_l14"]}}
{"id": "concept_kernel", "type": "V_concept", "name": "Kernel", "properties": {"description": "A small matrix used to scan an image and extract features during the convolution operation.", "keywords": ["kernel", "convolution", "image processing", "feature extraction"], "source_lectures": ["lecture_106108840_w2_l12"]}}
{"id": "concept_stride", "type": "V_concept", "name": "Stride", "properties": {"description": "The number of pixels by which the kernel moves over the input image during the convolution operation.", "keywords": ["image processing", "pixels", "stride", "convolution step", "convolution", "kernel", "sliding window"], "source_lectures": ["lecture_106108840_w2_l12", "lecture_106108840_w2_l13", "lecture_106103843_w2_l14"]}}
{"id": "concept_padding", "type": "V_concept", "name": "Padding", "properties": {"description": "The process of adding zeros to the border of an image to preserve its size during the convolution operation.", "keywords": ["border preservation", "padding", "input", "zeros", "convolution", "image processing"], "source_lectures": ["lecture_106108840_w2_l12", "lecture_106108840_w2_l13"]}}
{"id": "concept_feature_map", "type": "V_concept", "name": "Feature Map", "properties": {"description": "The output of a convolutional layer, representing the features extracted from the input image.", "keywords": ["feature map", "convolutional layer", "image processing", "feature extraction"], "source_lectures": ["lecture_106108840_w2_l12"]}}
{"id": "concept_pooling_layer", "type": "V_concept", "name": "Pooling Layer", "properties": {"description": "A layer in a convolutional neural network that reduces the spatial dimensions of the feature maps, helping to downsample the data.", "keywords": ["feature maps", "downsampling", "feature aggregation", "features", "cnn", "pooling layer", "pooling", "layer"], "source_lectures": ["lecture_106108840_w2_l12", "lecture_106108840_w2_l13", "lecture_106103843_w2_l14"]}}
{"id": "concept_fully_connected_layer", "type": "V_concept", "name": "Fully Connected Layer", "properties": {"description": "A layer in a neural network where every neuron is connected to every neuron in the previous layer, used for classification and regression tasks.", "keywords": ["classification", "fully connected layer", "neural network", "network", "decision layer", "fully connected", "regression", "fully", "connected", "neural", "layer"], "source_lectures": ["lecture_106108840_w2_l12", "lecture_106108840_w3_l15", "lecture_106108840_w3_l16", "lecture_106108840_w3_l17", "lecture_106108840_w2_l11", "lecture_106103843_w2_l14"]}}
{"id": "concept_convolution_operation", "type": "V_concept", "name": "Convolution Operation", "properties": {"description": "A mathematical operation that combines an image with a kernel to produce a feature map.", "keywords": ["convolution", "image", "kernel", "feature map"], "source_lectures": ["lecture_106108840_w2_l13"]}}
{"id": "concept_max_pooling", "type": "V_concept", "name": "Max Pooling", "properties": {"description": "A type of pooling that selects the maximum value from a region of an input.", "keywords": ["max pooling", "image", "max", "downsampling", "region", "maximum", "pooling", "feature selection", "processing", "layer"], "source_lectures": ["lecture_106108840_w2_l13", "lecture_106108840_w3_l15", "lecture_106103843_w2_l14"]}}
{"id": "concept_average_pooling", "type": "V_concept", "name": "Average Pooling", "properties": {"description": "A type of pooling that calculates the average value from a region of an input.", "keywords": ["downsampling", "feature preservation", "region", "pooling", "average", "average pooling"], "source_lectures": ["lecture_106108840_w2_l13", "lecture_106103843_w2_l14"]}}
{"id": "concept_flatten_layer", "type": "V_concept", "name": "Flatten Layer", "properties": {"description": "A layer that transforms a multi-dimensional input into a one-dimensional input.", "keywords": ["array", "multi-dimensional", "network", "neural", "layer", "flatten", "one-dimensional"], "source_lectures": ["lecture_106108840_w2_l13", "lecture_106108840_w3_l15", "lecture_106108840_w3_l20"]}}
{"id": "concept_global_max_pooling", "type": "V_concept", "name": "Global Max Pooling", "properties": {"description": "A type of pooling that selects the maximum value from an entire input.", "keywords": ["global", "max", "pooling", "maximum"], "source_lectures": ["lecture_106108840_w2_l13"]}}
{"id": "concept_global_average_pooling", "type": "V_concept", "name": "Global Average Pooling", "properties": {"description": "A type of pooling that calculates the average value from an entire input.", "keywords": ["global", "pooling", "map", "average", "feature"], "source_lectures": ["lecture_106108840_w2_l13", "lecture_106108840_w3_l20"]}}
{"id": "concept_batch_normalization", "type": "V_concept", "name": "Batch Normalization", "properties": {"description": "A regularization technique used in neural networks to normalize the input data for each layer, reducing overfitting and improving stability.", "keywords": ["regularization", "batch", "networks", "network", "layer", "training", "neural", "normalization"], "source_lectures": ["lecture_106108840_w2_l14", "lecture_106108840_w3_l15", "lecture_106108840_w3_l17", "lecture_106108840_w3_l20", "lecture_106103843_w3_l16"]}}
{"id": "concept_mini_batch", "type": "V_concept", "name": "Mini-Batch", "properties": {"description": "A small subset of the training data used to update the model's parameters during training, reducing computational cost and improving stability.", "keywords": ["mini-batch", "training", "data", "model", "parameters"], "source_lectures": ["lecture_106108840_w2_l14"]}}
{"id": "concept_mean_and_standard_deviation", "type": "V_concept", "name": "Mean and Standard Deviation", "properties": {"description": "Statistical measures used to describe the central tendency and variability of a dataset, used in batch normalization to normalize the input data.", "keywords": ["mean", "standard", "deviation", "statistics", "normalization"], "source_lectures": ["lecture_106108840_w2_l14"]}}
{"id": "concept_gamma_and_beta_parameters", "type": "V_concept", "name": "Gamma and Beta Parameters", "properties": {"description": "Learnable parameters used in batch normalization to scale and shift the normalized input data, introducing flexibility into the model.", "keywords": ["gamma", "beta", "parameters", "batch", "normalization"], "source_lectures": ["lecture_106108840_w2_l14"]}}
{"id": "concept_moving_mean_and_variance", "type": "V_concept", "name": "Moving Mean and Variance", "properties": {"description": "Non-learnable parameters used in batch normalization to store the mean and variance of the input data during training, used for inference and testing.", "keywords": ["moving", "mean", "variance", "batch", "normalization"], "source_lectures": ["lecture_106108840_w2_l14"]}}
{"id": "concept_convolutional_neural_network_cnn", "type": "V_concept", "name": "Convolutional Neural Network (CNN)", "properties": {"description": "A type of neural network designed to process data with grid-like topology, commonly used for image and video processing tasks.", "keywords": ["cnn", "convolutional", "neural", "network", "image"], "source_lectures": ["lecture_106108840_w2_l14"]}}
{"id": "concept_image_data_generator", "type": "V_concept", "name": "Image Data Generator", "properties": {"description": "A function that generates batches of image data for training a neural network", "keywords": ["image", "generator", "network", "data", "augmentation", "neural"], "source_lectures": ["lecture_106108840_w3_l15", "lecture_106108840_w2_l11"]}}
{"id": "concept_conv2d_layer", "type": "V_concept", "name": "Conv2D Layer", "properties": {"description": "A type of layer that applies a convolutional filter to an image", "keywords": ["conv2d", "layer", "image", "processing", "neural"], "source_lectures": ["lecture_106108840_w3_l15"]}}
{"id": "concept_convolution_neural_network", "type": "V_concept", "name": "Convolution Neural Network", "properties": {"description": "A type of neural network designed to process data with grid-like topology, such as images.", "keywords": ["cnn", "neural", "network", "image", "processing"], "source_lectures": ["lecture_106108840_w3_l16"]}}
{"id": "concept_alexnet", "type": "V_concept", "name": "AlexNet", "properties": {"description": "A deep convolutional neural network designed for image classification tasks.", "keywords": ["alexnet", "deep", "learning", "image", "classification"], "source_lectures": ["lecture_106108840_w3_l16"]}}
{"id": "concept_vanishing_gradient_problem", "type": "V_concept", "name": "Vanishing Gradient Problem", "properties": {"description": "A problem that occurs during backpropagation in neural networks, where gradients become smaller and smaller, causing weight updates to stop.", "keywords": ["gradient", "networks", "vanishing", "network", "problem", "deep", "backpropagation", "neural"], "source_lectures": ["lecture_106108840_w3_l16", "lecture_106108840_w3_l17", "lecture_106108840_w3_l18", "lecture_106103843_w1_l7", "lecture_106103843_w2_l11", "lecture_106103843_w3_l16"]}}
{"id": "concept_imagenet_dataset", "type": "V_concept", "name": "ImageNet Dataset", "properties": {"description": "A large-scale image dataset used for image classification tasks, containing over 1.2 million images from 1,000 categories.", "keywords": ["imagenet", "dataset", "image", "classification", "large-scale"], "source_lectures": ["lecture_106108840_w3_l16"]}}
{"id": "concept_max_pooling_layer", "type": "V_concept", "name": "Max Pooling Layer", "properties": {"description": "A type of layer in a neural network that reduces the spatial dimensions of the input data by taking the maximum value across each patch.", "keywords": ["cnn", "dimensionality", "network", "pooling", "neural", "layer", "max", "reduction"], "source_lectures": ["lecture_106108840_w3_l16", "lecture_106108840_w3_l17", "lecture_106103843_w3_l15"]}}
{"id": "concept_softmax_layer", "type": "V_concept", "name": "Softmax Layer", "properties": {"description": "A type of layer in a neural network used for multi-class classification tasks, outputting a probability distribution over all classes.", "keywords": ["softmax", "classification", "network", "probability", "neural", "layer"], "source_lectures": ["lecture_106108840_w3_l16", "lecture_106103843_w2_l14"]}}
{"id": "concept_vgg_net", "type": "V_concept", "name": "Vgg Net", "properties": {"description": "A deep neural network architecture used for image recognition tasks", "keywords": ["vgg", "neural", "network", "image", "recognition"], "source_lectures": ["lecture_106108840_w3_l17"]}}
{"id": "concept_inception_module", "type": "V_concept", "name": "Inception Module", "properties": {"description": "A component of the Google Net architecture that uses multiple filters in parallel to capture features at different scales", "keywords": ["module", "googlenet", "cnn", "net", "filters", "google", "inception", "architecture"], "source_lectures": ["lecture_106108840_w3_l17", "lecture_106103843_w3_l15"]}}
{"id": "concept_convolution_layer", "type": "V_concept", "name": "Convolution Layer", "properties": {"description": "A layer in a neural network that applies a set of filters to an input image to capture features", "keywords": ["convolution", "layer", "neural", "network", "filters"], "source_lectures": ["lecture_106108840_w3_l17"]}}
{"id": "concept_auxiliary_classifier", "type": "V_concept", "name": "Auxiliary Classifier", "properties": {"description": "A component of the Google Net architecture that helps to mitigate the vanishing gradient problem by providing additional gradients during training", "keywords": ["auxiliary", "classifier", "google", "net", "gradients"], "source_lectures": ["lecture_106108840_w3_l17"]}}
{"id": "concept_dimensionality_reduction", "type": "V_concept", "name": "Dimensionality Reduction", "properties": {"description": "A technique used to reduce the number of features or dimensions in a dataset, improving computational efficiency and reducing overfitting", "keywords": ["dimensionality", "reduction", "features", "dataset", "efficiency"], "source_lectures": ["lecture_106108840_w3_l17"]}}
{"id": "concept_dilated_convolutions", "type": "V_concept", "name": "Dilated Convolutions", "properties": {"description": "A type of convolutional layer that uses dilated filters to increase the receptive field without increasing the number of parameters", "keywords": ["dilated", "convolutions", "filters", "receptive", "field"], "source_lectures": ["lecture_106108840_w3_l17"]}}
{"id": "concept_residual_network", "type": "V_concept", "name": "Residual Network", "properties": {"description": "A type of neural network that uses residual connections to mitigate the vanishing gradient problem.", "keywords": ["residual", "network", "connections", "deep", "learning"], "source_lectures": ["lecture_106108840_w3_l18"]}}
{"id": "concept_residual_block", "type": "V_concept", "name": "Residual Block", "properties": {"description": "A building block of a residual network that consists of a series of convolutional layers with a residual connection.", "keywords": ["residual", "block", "convolutional", "layers", "connection"], "source_lectures": ["lecture_106108840_w3_l18"]}}
{"id": "concept_skip_connection", "type": "V_concept", "name": "Skip Connection", "properties": {"description": "A connection in a neural network that skips one or more layers, used to mitigate the vanishing gradient problem.", "keywords": ["skip", "connection", "layers", "neural", "network"], "source_lectures": ["lecture_106108840_w3_l18"]}}
{"id": "concept_basic_block", "type": "V_concept", "name": "Basic Block", "properties": {"description": "A type of residual block that consists of two convolutional layers with a residual connection.", "keywords": ["block", "basic", "instructions", "convolutional", "connection", "layers", "entry", "exit"], "source_lectures": ["lecture_106108840_w3_l18", "lecture_106102229_w4_l24"]}}
{"id": "concept_bottleneck_block", "type": "V_concept", "name": "Bottleneck Block", "properties": {"description": "A type of residual block that consists of three convolutional layers with a residual connection, used to reduce computational cost.", "keywords": ["bottleneck", "block", "convolutional", "layers", "connection"], "source_lectures": ["lecture_106108840_w3_l18"]}}
{"id": "concept_identity_shortcut", "type": "V_concept", "name": "Identity Shortcut", "properties": {"description": "A type of shortcut connection in a residual network that directly adds the input to the output of a block.", "keywords": ["identity", "shortcut", "connection", "residual", "network"], "source_lectures": ["lecture_106108840_w3_l18"]}}
{"id": "concept_projection_shortcut", "type": "V_concept", "name": "Projection Shortcut", "properties": {"description": "A type of shortcut connection in a residual network that uses a linear projection to resize the input before adding it to the output of a block.", "keywords": ["projection", "shortcut", "connection", "residual", "network"], "source_lectures": ["lecture_106108840_w3_l18"]}}
{"id": "concept_resnet_34", "type": "V_concept", "name": "ResNet 34", "properties": {"description": "A 34-layer residual network architecture that uses basic blocks and identity shortcuts.", "keywords": ["resnet", "34", "layers", "architecture", "basic"], "source_lectures": ["lecture_106108840_w3_l18"]}}
{"id": "concept_resnet_50", "type": "V_concept", "name": "ResNet 50", "properties": {"description": "A 50-layer residual network architecture that uses bottleneck blocks and projection shortcuts.", "keywords": ["resnet", "50", "layers", "architecture", "bottleneck"], "source_lectures": ["lecture_106108840_w3_l18"]}}
{"id": "concept_transfer_learning", "type": "V_concept", "name": "Transfer Learning", "properties": {"description": "A machine learning technique where a model trained on one task is reused as the foundation for a second task.", "keywords": ["model", "retrain", "pretrained", "learning", "task", "transfer", "machine"], "source_lectures": ["lecture_106108840_w3_l19", "lecture_106108840_w3_l20", "lecture_106108840_w3_l21"]}}
{"id": "concept_frozen_layers", "type": "V_concept", "name": "Frozen Layers", "properties": {"description": "Layers in a neural network whose parameters are not updated during training on a new dataset.", "keywords": ["frozen", "layers", "neural", "network"], "source_lectures": ["lecture_106108840_w3_l19"]}}
{"id": "concept_trainable_layers", "type": "V_concept", "name": "Trainable Layers", "properties": {"description": "Layers in a neural network whose parameters are updated through backpropagation during training on a new dataset.", "keywords": ["trainable", "layers", "neural", "network"], "source_lectures": ["lecture_106108840_w3_l19"]}}
{"id": "concept_feature_extraction", "type": "V_concept", "name": "Feature Extraction", "properties": {"description": "A technique where a pre-trained model is used to extract meaningful features from new samples for a specific task.", "keywords": ["feature", "model", "networks", "pre-trained", "extraction", "automatic", "neural"], "source_lectures": ["lecture_106108840_w3_l19", "lecture_106103843_w2_l9"]}}
{"id": "concept_fine_tuning", "type": "V_concept", "name": "Fine-Tuning", "properties": {"description": "A technique where a pre-trained model's parameters are further trained on a target task's dataset along with additional layers.", "keywords": ["model", "adaptation", "pre-trained", "parameters", "transfer", "fine-tuning"], "source_lectures": ["lecture_106108840_w3_l19", "lecture_106103843_w1_l1"]}}
{"id": "concept_pre_trained_model", "type": "V_concept", "name": "Pre-Trained Model", "properties": {"description": "A model that has been trained on a large dataset and can be used as a starting point for other tasks.", "keywords": ["pre-trained", "model", "dataset", "transfer"], "source_lectures": ["lecture_106108840_w3_l19"]}}
{"id": "concept_zero_shot_learning", "type": "V_concept", "name": "Zero-Shot Learning", "properties": {"description": "A technique where a model performs a task without seeing any labeled examples of that task during training.", "keywords": ["zero-shot", "learning", "model", "task"], "source_lectures": ["lecture_106108840_w3_l19"]}}
{"id": "concept_few_shot_learning", "type": "V_concept", "name": "Few-Shot Learning", "properties": {"description": "A technique where a model learns to perform a new task with only a few labeled examples per class.", "keywords": ["few-shot", "learning", "model", "task"], "source_lectures": ["lecture_106108840_w3_l19"]}}
{"id": "concept_resnet", "type": "V_concept", "name": "ResNet", "properties": {"description": "A type of neural network architecture that uses residual connections to ease the training process.", "keywords": ["resnet", "neural", "network", "architecture"], "source_lectures": ["lecture_106108840_w3_l19"]}}
{"id": "concept_vgg16_model", "type": "V_concept", "name": "VGG16 Model", "properties": {"description": "A pre-trained convolutional neural network model with 16 layers, trained on the ImageNet dataset.", "keywords": ["vgg16", "model", "cnn", "imagenet", "pretrained"], "source_lectures": ["lecture_106108840_w3_l20"]}}
{"id": "concept_dense_layer", "type": "V_concept", "name": "Dense Layer", "properties": {"description": "A layer in a neural network where every input is connected to every output, also known as a fully connected layer.", "keywords": ["dense", "layer", "neural", "network", "fully"], "source_lectures": ["lecture_106108840_w3_l20"]}}
{"id": "concept_softmax_activation", "type": "V_concept", "name": "Softmax Activation", "properties": {"description": "A activation function used in the output layer of a neural network to produce a probability distribution over multiple classes.", "keywords": ["softmax", "distribution", "network", "neural", "probability", "activation"], "source_lectures": ["lecture_106108840_w3_l20", "lecture_106103843_w1_l7"]}}
{"id": "concept_convolutional_block", "type": "V_concept", "name": "Convolutional Block", "properties": {"description": "A block of layers in a convolutional neural network that consists of convolutional and pooling layers.", "keywords": ["convolutional", "block", "cnn", "layer", "pooling"], "source_lectures": ["lecture_106108840_w3_l20"]}}
{"id": "concept_function_approximation", "type": "V_concept", "name": "Function Approximation", "properties": {"description": "A problem of estimating an unknown function that maps inputs to outputs based on given observations.", "keywords": ["function", "approximation", "estimation", "machine learning"], "source_lectures": ["lecture_106108841_w1_l1"]}}
{"id": "concept_probabilistic_viewpoint", "type": "V_concept", "name": "Probabilistic Viewpoint", "properties": {"description": "A framework for understanding machine learning algorithms based on probability theory and statistical methods.", "keywords": ["probabilistic", "viewpoint", "probability", "statistics"], "source_lectures": ["lecture_106108841_w1_l1"]}}
{"id": "concept_random_variable", "type": "V_concept", "name": "Random Variable", "properties": {"description": "A deterministic function that maps a sample space to real values, used to model uncertainty in machine learning.", "keywords": ["chance", "probability distribution", "random variable", "sample", "statistics", "function", "numerical", "chance events", "value", "real numbers", "experiment", "random", "variable", "probability", "sample space", "event", "space", "events", "mathematics", "outcome"], "source_lectures": ["lecture_106108841_w1_l1", "lecture_106108841_w1_l2", "lecture_106108841_w1_l3", "lecture_106108841_w1_l4", "lecture_106108841_w1_l5", "lecture_106108841_w1_l6", "lecture_106108841_w1_l7", "lecture_106104233_w2_l8", "lecture_106104233_w2_l9", "lecture_106104233_w2_l10", "lecture_106104233_w2_l13", "lecture_106104233_w4_l28"]}}
{"id": "concept_probability_distribution", "type": "V_concept", "name": "Probability Distribution", "properties": {"description": "A function that describes the probability of different values or ranges of values of a random variable.", "keywords": ["distribution", "outcomes", "statistics", "experiment", "function", "random variable", "random", "variable", "probability", "mathematics", "outcome"], "source_lectures": ["lecture_106108841_w1_l1", "lecture_106106221_w1_l4", "lecture_106101360_w3_l17", "lecture_106101360_w5_l24", "lecture_106104233_w1_l4", "lecture_106108229_w1_l7", "lecture_106101360_w9_l46"]}}
{"id": "concept_vector_valued_function", "type": "V_concept", "name": "Vector Valued Function", "properties": {"description": "A function that takes a vector as input and returns a vector as output.", "keywords": ["vector", "valued", "function", "mathematics"], "source_lectures": ["lecture_106108841_w1_l1"]}}
{"id": "concept_deterministic_worldview", "type": "V_concept", "name": "Deterministic Worldview", "properties": {"description": "A framework for understanding machine learning algorithms based on deterministic mathematical models.", "keywords": ["deterministic", "worldview", "mathematics", "machine learning"], "source_lectures": ["lecture_106108841_w1_l1"]}}
{"id": "concept_statistical_method", "type": "V_concept", "name": "Statistical Method", "properties": {"description": "A method for making decisions or predictions based on data and statistical models.", "keywords": ["statistical", "method", "data", "modeling"], "source_lectures": ["lecture_106108841_w1_l1"]}}
{"id": "concept_sample_space", "type": "V_concept", "name": "Sample Space", "properties": {"description": "The set of all possible outcomes of a random experiment.", "keywords": ["space", "random experiment", "experiment", "probability", "sample", "outcome", "sample space", "event", "random", "outcomes"], "source_lectures": ["lecture_106108841_w1_l1", "lecture_106108841_w1_l2", "lecture_106108841_w1_l3", "lecture_106108841_w1_l5", "lecture_106108841_w1_l6", "lecture_106108841_w1_l7", "lecture_106104233_w1_l3", "lecture_106104233_w1_l5", "lecture_106104233_w1_l6", "lecture_106104233_w2_l8"]}}
{"id": "concept_probability_measure", "type": "V_concept", "name": "Probability Measure", "properties": {"description": "A function that assigns a non-negative real number to each event in a sample space, representing the probability of that event.", "keywords": ["space", "measure", "probability measure", "event", "non-negative", "sample space", "function", "probability", "real number", "likelihood"], "source_lectures": ["lecture_106108841_w1_l1", "lecture_106108841_w1_l2", "lecture_106108841_w1_l3", "lecture_106108841_w1_l4", "lecture_106108841_w1_l5", "lecture_106108841_w1_l6", "lecture_106104233_w1_l3", "lecture_106104233_w1_l5"]}}
{"id": "concept_random_experiment", "type": "V_concept", "name": "Random Experiment", "properties": {"description": "An action or situation that can produce a set of outcomes, where each outcome is a result of the experiment.", "keywords": ["situation", "random experiment", "experiment", "action", "uncertain", "probability", "random", "outcomes"], "source_lectures": ["lecture_106108841_w1_l2", "lecture_106108841_w1_l7", "lecture_106104233_w1_l6"]}}
{"id": "concept_measure_theory", "type": "V_concept", "name": "Measure Theory", "properties": {"description": "A branch of mathematics that studies mathematical descriptions of sets and their properties.", "keywords": ["measure", "theory", "mathematics", "sets", "properties"], "source_lectures": ["lecture_106108841_w1_l2"]}}
{"id": "concept_lebesgue_measure", "type": "V_concept", "name": "Lebesgue Measure", "properties": {"description": "A measure that assigns a non-negative real number to each subset of a set, representing its size or length.", "keywords": ["lebesgue", "measure", "size", "length", "subset"], "source_lectures": ["lecture_106108841_w1_l2"]}}
{"id": "concept_probability_theory", "type": "V_concept", "name": "Probability Theory", "properties": {"description": "A branch of mathematics that deals with the study of chance events and their probabilities.", "keywords": ["event", "theory", "chance", "statistics", "events", "probability", "mathematics"], "source_lectures": ["lecture_106108841_w1_l2", "lecture_106108841_w2_l12", "lecture_106104233_w2_l13"]}}
{"id": "concept_sigma_algebra", "type": "V_concept", "name": "Sigma Algebra", "properties": {"description": "A collection of subsets of a set that satisfies certain properties, used to define a measure on the set.", "keywords": ["subset", "measure", "properties", "algebra", "closure", "sample space", "subsets", "sigma algebra", "sigma"], "source_lectures": ["lecture_106108841_w1_l2", "lecture_106108841_w1_l3", "lecture_106108841_w1_l4", "lecture_106104233_w1_l5", "lecture_106104233_w2_l8"]}}
{"id": "concept_event", "type": "V_concept", "name": "Event", "properties": {"description": "A subset of the sample space, representing a specific outcome or set of outcomes of a random experiment.", "keywords": ["space", "subset", "sample", "state", "player", "states", "outcome", "world", "sample space", "event", "outcomes"], "source_lectures": ["lecture_106108841_w1_l2", "lecture_106101360_w2_l6", "lecture_106101360_w2_l7", "lecture_106104233_w1_l3", "lecture_106104233_w1_l5"]}}
{"id": "concept_likelihood", "type": "V_concept", "name": "Likelihood", "properties": {"description": "A measure of the probability of an event occurring, often interpreted as the chance or probability of the event.", "keywords": ["observation", "measure", "probability", "function", "event", "relative", "likelihood", "chance", "density"], "source_lectures": ["lecture_106108841_w1_l2", "lecture_106108841_w2_l9"]}}
{"id": "concept_probability_triplet", "type": "V_concept", "name": "Probability Triplet", "properties": {"description": "A mathematical construct consisting of a sample space, events, and a probability measure.", "keywords": ["probability", "triplet", "sample space", "events", "measure"], "source_lectures": ["lecture_106108841_w1_l3"]}}
{"id": "concept_push_forward_measure", "type": "V_concept", "name": "Push Forward Measure", "properties": {"description": "A measure defined on the range space of a random variable.", "keywords": ["measure", "push forward measure", "range space", "sample space", "random variable"], "source_lectures": ["lecture_106108841_w1_l3", "lecture_106108841_w1_l4"]}}
{"id": "concept_distribution_function", "type": "V_concept", "name": "Distribution Function", "properties": {"description": "A function that describes the probability distribution of a random variable.", "keywords": ["distribution", "real numbers", "distribution function", "probability", "function", "probability distribution", "random variable", "random", "cumulative"], "source_lectures": ["lecture_106108841_w1_l3", "lecture_106108841_w1_l4", "lecture_106108841_w1_l6", "lecture_106108841_w2_l9", "lecture_106108841_w2_l13"]}}
{"id": "concept_borel_sigma_algebra", "type": "V_concept", "name": "Borel Sigma Algebra", "properties": {"description": "A sigma algebra generated by the open sets of a topological space.", "keywords": ["borel sigma algebra", "topological space", "probability", "borel", "sigma algebra", "open sets"], "source_lectures": ["lecture_106108841_w1_l3", "lecture_106108841_w1_l4"]}}
{"id": "concept_real_valued_function", "type": "V_concept", "name": "Real-Valued Function", "properties": {"description": "A function that maps elements of a sample space to real numbers.", "keywords": ["real-valued function", "sample space", "real numbers"], "source_lectures": ["lecture_106108841_w1_l3"]}}
{"id": "concept_dimensional_real_space", "type": "V_concept", "name": "Dimensional Real Space", "properties": {"description": "A vector space with a finite number of dimensions.", "keywords": ["dimensional real space", "vector space", "dimensions"], "source_lectures": ["lecture_106108841_w1_l3"]}}
{"id": "concept_measurable_subset", "type": "V_concept", "name": "Measurable Subset", "properties": {"description": "A subset of a sample space that is an element of a sigma algebra, and can be assigned a probability measure.", "keywords": ["measurable", "subset", "sigma algebra", "probability"], "source_lectures": ["lecture_106108841_w1_l4"]}}
{"id": "concept_vector_valued_random_variable", "type": "V_concept", "name": "Vector Valued Random Variable", "properties": {"description": "A random variable that takes on values in a vector space, often used to model multiple uncertain events.", "keywords": ["vector", "uncertain events", "vector space", "valued", "variable", "random", "random variable", "vector valued random variable"], "source_lectures": ["lecture_106108841_w1_l4", "lecture_106108841_w1_l5"]}}
{"id": "concept_joint_distribution", "type": "V_concept", "name": "Joint Distribution", "properties": {"description": "A probability distribution over multiple random variables, representing the probability of different combinations of values.", "keywords": ["distribution", "joint distribution", "random variables", "probability distribution", "random", "combinations", "probability", "variable", "joint"], "source_lectures": ["lecture_106108841_w1_l4", "lecture_106108841_w1_l5", "lecture_106108841_w1_l6", "lecture_106108841_w1_l7", "lecture_106108841_w4_l23"]}}
{"id": "concept_conditional_distribution", "type": "V_concept", "name": "Conditional Distribution", "properties": {"description": "A probability distribution over a random variable, given the value of another random variable.", "keywords": ["conditional distribution", "event", "given", "probability distribution", "probability", "random", "conditional", "random variable", "distribution"], "source_lectures": ["lecture_106108841_w1_l4", "lecture_106108841_w1_l5", "lecture_106108841_w1_l7", "lecture_106108841_w2_l8", "lecture_106104233_w2_l10"]}}
{"id": "concept_event_space", "type": "V_concept", "name": "Event Space", "properties": {"description": "A set of all possible events that can occur in a sample space.", "keywords": ["event", "space", "sample", "outcomes"], "source_lectures": ["lecture_106108841_w1_l5"]}}
{"id": "concept_scalar_valued_random_variable", "type": "V_concept", "name": "Scalar Valued Random Variable", "properties": {"description": "A random variable that maps each outcome in a sample space to a single real number.", "keywords": ["scalar", "valued", "random", "variable"], "source_lectures": ["lecture_106108841_w1_l5"]}}
{"id": "concept_marginal_distribution", "type": "V_concept", "name": "Marginal Distribution", "properties": {"description": "A probability distribution that describes the probability of a single random variable, obtained by integrating out other random variables from a joint distribution.", "keywords": ["distribution", "marginal", "probability distribution", "random variable", "random", "variable", "probability", "marginal distribution"], "source_lectures": ["lecture_106108841_w1_l5", "lecture_106108841_w1_l7", "lecture_106108841_w4_l23"]}}
{"id": "concept_conditional_probability", "type": "V_concept", "name": "Conditional Probability", "properties": {"description": "The probability of an event given that another event has occurred.", "keywords": ["event", "update", "occurred", "occurrence", "conditional", "probability", "given"], "source_lectures": ["lecture_106108841_w1_l5", "lecture_106101360_w2_l12", "lecture_106104233_w1_l2", "lecture_106104233_w1_l5", "lecture_106104233_w1_l6", "lecture_106104233_w1_l7", "lecture_106104233_w2_l8", "lecture_106104233_w3_l18"]}}
{"id": "concept_cumulative_distribution_function", "type": "V_concept", "name": "Cumulative Distribution Function", "properties": {"description": "A function that describes the probability that a random variable takes on a value less than or equal to a given value.", "keywords": ["distribution", "cumulative", "function", "random", "probability"], "source_lectures": ["lecture_106108841_w1_l5", "lecture_106101360_w5_l28"]}}
{"id": "concept_range_space", "type": "V_concept", "name": "Range Space", "properties": {"description": "The set of all possible values that a random variable can take.", "keywords": ["range", "space", "random", "variable"], "source_lectures": ["lecture_106108841_w1_l6"]}}
{"id": "concept_independent_and_identically_distributed_iid", "type": "V_concept", "name": "Independent and Identically Distributed (IID)", "properties": {"description": "A concept in probability theory where random variables are independent and have the same probability distribution.", "keywords": ["iid", "independent", "statistics", "distributed", "identically"], "source_lectures": ["lecture_106108841_w1_l6", "lecture_106108841_w2_l12"]}}
{"id": "concept_data_point", "type": "V_concept", "name": "Data Point", "properties": {"description": "A single observation or measurement in a dataset.", "keywords": ["data", "point", "observation", "measurement"], "source_lectures": ["lecture_106108841_w1_l6"]}}
{"id": "concept_dimensional_vector", "type": "V_concept", "name": "Dimensional Vector", "properties": {"description": "A vector with a fixed number of dimensions, used to represent data points in a high-dimensional space.", "keywords": ["dimensional", "vector", "data", "point"], "source_lectures": ["lecture_106108841_w1_l6"]}}
{"id": "concept_probability_density_function", "type": "V_concept", "name": "Probability Density Function", "properties": {"description": "A function that describes the probability distribution of a continuous random variable.", "keywords": ["density", "function", "random", "probability", "continuous"], "source_lectures": ["lecture_106108841_w1_l6", "lecture_106108841_w2_l8", "lecture_106104233_w2_l11"]}}
{"id": "concept_iid_assumption", "type": "V_concept", "name": "Iid Assumption", "properties": {"description": "A fundamental assumption in machine learning that data points are independent and identically distributed.", "keywords": ["iid", "independence", "identical distribution", "machine learning"], "source_lectures": ["lecture_106108841_w1_l7"]}}
{"id": "concept_statistical_independence", "type": "V_concept", "name": "Statistical Independence", "properties": {"description": "A property of two or more events or random variables that are not affected by each other's occurrence or value.", "keywords": ["independence", "statistics", "probability", "random variables"], "source_lectures": ["lecture_106108841_w1_l7"]}}
{"id": "concept_identically_distributed_random_variables", "type": "V_concept", "name": "Identically Distributed Random Variables", "properties": {"description": "Random variables that have the same probability distribution.", "keywords": ["identical distribution", "random variables", "probability distribution"], "source_lectures": ["lecture_106108841_w1_l7"]}}
{"id": "concept_generative_modeling", "type": "V_concept", "name": "Generative Modeling", "properties": {"description": "A type of machine learning that involves learning to generate new data samples from a given distribution.", "keywords": ["generative modeling", "machine learning", "data generation"], "source_lectures": ["lecture_106108841_w1_l7"]}}
{"id": "concept_discriminative_modeling", "type": "V_concept", "name": "Discriminative Modeling", "properties": {"description": "A type of machine learning that involves learning to predict a target variable from a set of input variables.", "keywords": ["discriminative modeling", "machine learning", "prediction"], "source_lectures": ["lecture_106108841_w1_l7"]}}
{"id": "concept_empirical_risk_minimization", "type": "V_concept", "name": "Empirical Risk Minimization", "properties": {"description": "A framework used in machine learning to estimate the risk of a model by minimizing the error on a given dataset.", "keywords": ["machine learning", "learning", "risk", "empirical", "minimization", "machine"], "source_lectures": ["lecture_106108841_w2_l8", "lecture_106108841_w2_l10", "lecture_106108841_w3_l17", "lecture_106108841_w3_l18", "lecture_106108841_w3_l20", "lecture_106108841_w3_l21"]}}
{"id": "concept_distribution_estimation", "type": "V_concept", "name": "Distribution Estimation", "properties": {"description": "The problem of estimating the underlying distribution of a dataset.", "keywords": ["distribution", "dataset", "estimation", "machine learning", "probability"], "source_lectures": ["lecture_106108841_w2_l8", "lecture_106108841_w3_l18"]}}
{"id": "concept_independent_and_identically_distributed", "type": "V_concept", "name": "Independent And Identically Distributed", "properties": {"description": "A statistical concept where random variables are independent and have the same probability distribution.", "keywords": ["iid", "independent", "variables", "statistics", "distributed", "random", "identically"], "source_lectures": ["lecture_106108841_w2_l8", "lecture_106108841_w3_l15", "lecture_106108841_w5_l30"]}}
{"id": "concept_generative_model", "type": "V_concept", "name": "Generative Model", "properties": {"description": "A type of machine learning model that generates new data samples that resemble the training data.", "keywords": ["generative", "model", "machine learning"], "source_lectures": ["lecture_106108841_w2_l8"]}}
{"id": "concept_discriminative_model", "type": "V_concept", "name": "Discriminative Model", "properties": {"description": "A type of machine learning model that estimates the conditional distribution of a target variable given the input data.", "keywords": ["discriminative", "model", "machine learning"], "source_lectures": ["lecture_106108841_w2_l8"]}}
{"id": "concept_classification_problem", "type": "V_concept", "name": "Classification Problem", "properties": {"description": "A type of machine learning problem where the goal is to predict a categorical label or class.", "keywords": ["categorical", "label", "classification", "problem", "machine learning"], "source_lectures": ["lecture_106108841_w2_l8", "lecture_106103843_w1_l4"]}}
{"id": "concept_regression_problem", "type": "V_concept", "name": "Regression Problem", "properties": {"description": "A type of machine learning problem where the goal is to predict a continuous output variable.", "keywords": ["regression", "problem", "machine learning"], "source_lectures": ["lecture_106108841_w2_l8"]}}
{"id": "concept_density_function", "type": "V_concept", "name": "Density Function", "properties": {"description": "A non-negative function that describes the probability distribution of a continuous random variable.", "keywords": ["distribution", "density", "function", "random", "variable", "probability", "continuous"], "source_lectures": ["lecture_106108841_w2_l9", "lecture_106108841_w2_l13", "lecture_106108841_w2_l14", "lecture_106108841_w4_l24"]}}
{"id": "concept_continuous_random_variable", "type": "V_concept", "name": "Continuous Random Variable", "properties": {"description": "A random variable that can take on any value within a given interval or range.", "keywords": ["interval", "range", "random", "variable", "continuous"], "source_lectures": ["lecture_106108841_w2_l9", "lecture_106104233_w2_l11"]}}
{"id": "concept_probability_mass_function", "type": "V_concept", "name": "Probability Mass Function", "properties": {"description": "A function that describes the probability distribution of a discrete random variable.", "keywords": ["discrete", "function", "random variable", "mass", "variable", "probability", "random"], "source_lectures": ["lecture_106108841_w2_l9", "lecture_106104233_w2_l8", "lecture_106104233_w2_l9", "lecture_106104233_w2_l10", "lecture_106108841_w4_l24", "lecture_106108841_w5_l30", "lecture_106104233_w2_l11"]}}
{"id": "concept_conditional_density", "type": "V_concept", "name": "Conditional Density", "properties": {"description": "A density function that describes the probability distribution of a random variable given another random variable.", "keywords": ["conditional", "density", "function", "probability", "given"], "source_lectures": ["lecture_106108841_w2_l9"]}}
{"id": "concept_joint_density", "type": "V_concept", "name": "Joint Density", "properties": {"description": "A density function that describes the probability distribution of multiple random variables.", "keywords": ["joint", "density", "function", "probability", "multiple"], "source_lectures": ["lecture_106108841_w2_l9"]}}
{"id": "concept_marginal_density", "type": "V_concept", "name": "Marginal Density", "properties": {"description": "A density function that describes the probability distribution of a single random variable, obtained by integrating out other variables.", "keywords": ["marginal", "density", "function", "probability", "integration"], "source_lectures": ["lecture_106108841_w2_l9"]}}
{"id": "concept_density_estimation", "type": "V_concept", "name": "Density Estimation", "properties": {"description": "The process of estimating a density function from a set of observed data.", "keywords": ["density", "estimation", "process", "observed", "data"], "source_lectures": ["lecture_106108841_w2_l9"]}}
{"id": "concept_non_negativity", "type": "V_concept", "name": "Non-Negativity", "properties": {"description": "The property of a function being non-negative, which is a requirement for density functions.", "keywords": ["non-negativity", "property", "function", "requirement", "density"], "source_lectures": ["lecture_106108841_w2_l9"]}}
{"id": "concept_full_batch_gradient_descent", "type": "V_concept", "name": "Full Batch Gradient Descent", "properties": {"description": "A variant of gradient descent that uses the entire training dataset to update the model parameters.", "keywords": ["full", "batch", "gradient", "descent"], "source_lectures": ["lecture_106103843_w1_l3"]}}
{"id": "concept_linear_regression", "type": "V_concept", "name": "Linear Regression", "properties": {"description": "A linear approach to modeling the relationship between a dependent variable and one or more independent variables.", "keywords": ["relationship", "model", "modeling", "linear regression", "prediction", "statistical", "method", "linear model", "regression", "linear"], "source_lectures": ["lecture_106103843_w1_l3", "lecture_106103220_w3_l17", "lecture_106103843_w1_l2", "lecture_106108229_w1_l2", "lecture_106103220_w4_l28"]}}
{"id": "concept_multivariate_linear_regression", "type": "V_concept", "name": "Multivariate Linear Regression", "properties": {"description": "A linear approach to modeling the relationship between a dependent variable and multiple independent variables.", "keywords": ["multivariate", "linear", "regression"], "source_lectures": ["lecture_106103843_w1_l3"]}}
{"id": "concept_logistic_regression", "type": "V_concept", "name": "Logistic Regression", "properties": {"description": "A statistical method for analyzing a dataset in which there are one or more independent variables that determine an outcome", "keywords": ["model", "statistical", "logistic", "classification", "statistics", "regression", "binary"], "source_lectures": ["lecture_106103843_w1_l4", "lecture_106108229_w1_l2", "lecture_106101360_w5_l28"]}}
{"id": "concept_sigmoid_function", "type": "V_concept", "name": "Sigmoid Function", "properties": {"description": "A mathematical function that maps any real-valued number to a value between 0 and 1", "keywords": ["mathematics", "logistic", "network", "neural", "function", "sigmoid", "activation"], "source_lectures": ["lecture_106103843_w1_l4", "lecture_106103843_w1_l7"]}}
{"id": "concept_hypothesis_function", "type": "V_concept", "name": "Hypothesis Function", "properties": {"description": "A mathematical function that is used to make predictions in a machine learning model", "keywords": ["approximation", "label", "prediction", "hypothesis", "mapping", "function", "machine learning", "learning", "machine"], "source_lectures": ["lecture_106103843_w1_l4", "lecture_106108841_w3_l17", "lecture_106108841_w3_l19", "lecture_106103843_w1_l2"]}}
{"id": "concept_multiclass_classification", "type": "V_concept", "name": "Multiclass Classification", "properties": {"description": "A type of classification problem where there are more than two possible classes or labels", "keywords": ["multiclass", "classification", "multi-label", "problem"], "source_lectures": ["lecture_106103843_w1_l4"]}}
{"id": "concept_logistic_function", "type": "V_concept", "name": "Logistic Function", "properties": {"description": "A mathematical function that is used in logistic regression to model the probability of a binary outcome", "keywords": ["logistic", "function", "probability", "binary"], "source_lectures": ["lecture_106103843_w1_l4"]}}
{"id": "concept_rectified_linear_unit", "type": "V_concept", "name": "Rectified Linear Unit", "properties": {"description": "A type of activation function that outputs 0 for negative inputs and the input value for positive inputs, often used in neural networks.", "keywords": ["relu", "rectified", "linear", "unit", "activation"], "source_lectures": ["lecture_106103843_w1_l7"]}}
{"id": "concept_universal_approximation_theorem", "type": "V_concept", "name": "Universal Approximation Theorem", "properties": {"description": "A theorem that states that a neural network with a single hidden layer can approximate any continuous function to any degree of accuracy.", "keywords": ["universal", "approximation", "theorem", "neural", "network"], "source_lectures": ["lecture_106103843_w1_l7"]}}
{"id": "concept_expressiveness_of_a_model", "type": "V_concept", "name": "Expressiveness of a Model", "properties": {"description": "The ability of a model to represent and learn complex relationships and patterns in data.", "keywords": ["expressiveness", "model", "complexity", "relationships", "patterns"], "source_lectures": ["lecture_106103843_w1_l7"]}}
{"id": "concept_forward_pass", "type": "V_concept", "name": "Forward Pass", "properties": {"description": "The process of passing input data through a neural network to obtain an output, using the current weights and biases.", "keywords": ["forward", "pass", "neural", "network", "input"], "source_lectures": ["lecture_106103843_w2_l8"]}}
{"id": "concept_backward_pass", "type": "V_concept", "name": "Backward Pass", "properties": {"description": "The process of propagating error gradients through a neural network, from output to input, to update the weights and biases.", "keywords": ["backward", "pass", "neural", "network", "error"], "source_lectures": ["lecture_106103843_w2_l8"]}}
{"id": "concept_weight_update", "type": "V_concept", "name": "Weight Update", "properties": {"description": "The process of adjusting the weights and biases of a neural network based on the error gradients computed during back propagation.", "keywords": ["weight", "update", "neural", "network", "error"], "source_lectures": ["lecture_106103843_w2_l8"]}}
{"id": "concept_computational_complexity", "type": "V_concept", "name": "Computational Complexity", "properties": {"description": "A measure of the amount of computational resources required to perform a task, such as training a neural network.", "keywords": ["time", "efficiency", "resource", "resources", "computational", "space", "complexity", "network", "training", "algorithm", "computation", "neural", "problems"], "source_lectures": ["lecture_106103843_w2_l8", "lecture_106108229_w9_l59", "lecture_106104357_w1_l1", "lecture_106104357_w1_l3"]}}
{"id": "concept_space_complexity", "type": "V_concept", "name": "Space Complexity", "properties": {"description": "A measure of the amount of memory required to perform a task, such as storing the intermediate activations during back propagation.", "keywords": ["space complexity", "efficiency", "memory", "input", "space", "complexity", "network", "measure", "dspaces", "turing machine", "algorithm", "computation", "nspace", "neural"], "source_lectures": ["lecture_106103843_w2_l8", "lecture_106105847_w1_l1", "lecture_106105847_w1_l4", "lecture_106105847_w2_l9", "lecture_106105847_w2_l13", "lecture_106104357_w1_l1", "lecture_106104357_w1_l3", "lecture_106104357_w1_l4", "lecture_106104357_w2_l14", "lecture_106104357_w3_l18"]}}
{"id": "concept_checkpointing", "type": "V_concept", "name": "Checkpointing", "properties": {"description": "A technique used to optimize the space complexity of back propagation by storing only a subset of the intermediate activations.", "keywords": ["failure", "checkpointing", "process", "space", "state", "complexity", "network", "recovery", "neural"], "source_lectures": ["lecture_106103843_w2_l8", "lecture_106104182_w3_l15"]}}
{"id": "concept_layer_wise_pretraining", "type": "V_concept", "name": "Layer Wise Pretraining", "properties": {"description": "A technique used to train deep neural networks by training each layer individually, using an autoencoder to reconstruct the input at each layer.", "keywords": ["layer", "wise", "pretraining", "autoencoder", "deep"], "source_lectures": ["lecture_106103843_w2_l11"]}}
{"id": "concept_autoencoder", "type": "V_concept", "name": "Autoencoder", "properties": {"description": "A type of neural network that reconstructs its input, often used for dimensionality reduction, anomaly detection, and generative modeling.", "keywords": ["autoencoder", "neural", "network", "reconstruction", "dimensionality"], "source_lectures": ["lecture_106103843_w2_l11"]}}
{"id": "concept_hierarchical_compositionality", "type": "V_concept", "name": "Hierarchical Compositionality", "properties": {"description": "A characteristic of deep neural networks where higher-level concepts are composed of lower-level features, allowing the network to learn complex representations.", "keywords": ["hierarchical", "compositionality", "deep", "neural", "networks"], "source_lectures": ["lecture_106103843_w2_l11"]}}
{"id": "concept_end_to_end_learning", "type": "V_concept", "name": "End To End Learning", "properties": {"description": "A paradigm in deep learning where a single model is trained to map raw input directly to the final output, without intermediate manual intervention.", "keywords": ["end", "to", "end", "learning", "deep", "neural"], "source_lectures": ["lecture_106103843_w2_l11"]}}
{"id": "concept_distributed_representation", "type": "V_concept", "name": "Distributed Representation", "properties": {"description": "A concept in deep learning where a single concept is represented by a pattern of activation across many neurons, rather than a single neuron.", "keywords": ["distributed", "representation", "deep", "neural", "networks"], "source_lectures": ["lecture_106103843_w2_l11"]}}
{"id": "concept_recurrent_neural_network", "type": "V_concept", "name": "Recurrent Neural Network", "properties": {"description": "A type of neural network designed to process sequential data, such as time series or natural language, using recurrent connections.", "keywords": ["neural network", "rnn", "network", "neural", "recurrent", "sequential", "sequential data", "nlp", "data"], "source_lectures": ["lecture_106103843_w2_l11", "lecture_106103843_w2_l13"]}}
{"id": "concept_transformer_model", "type": "V_concept", "name": "Transformer Model", "properties": {"description": "A type of neural network designed primarily for natural language processing tasks, using self-attention mechanisms to weigh the importance of different input elements.", "keywords": ["transformer", "model", "natural", "language", "processing"], "source_lectures": ["lecture_106103843_w2_l11"]}}
{"id": "concept_computer_vision", "type": "V_concept", "name": "Computer Vision", "properties": {"description": "A field of study that enables computers to interpret and understand visual information from images and videos.", "keywords": ["interpretation", "vision", "recognition", "world", "image", "images", "visual", "computer vision", "field", "video", "videos", "computer", "study", "processing", "information", "machine"], "source_lectures": ["lecture_106103843_w2_l12", "lecture_106103842_w1_l3", "lecture_106103842_w1_l7", "lecture_106103842_w3_l19", "lecture_106103220_w6_l37", "lecture_106104182_w4_l22"]}}
{"id": "concept_image_classification", "type": "V_concept", "name": "Image Classification", "properties": {"description": "The process of assigning a label or category to an image based on its content.", "keywords": ["label", "image", "classification", "vision task", "category", "content", "image recognition"], "source_lectures": ["lecture_106103843_w2_l12", "lecture_106103843_w2_l14"]}}
{"id": "concept_object_detection", "type": "V_concept", "name": "Object Detection", "properties": {"description": "The process of locating and identifying objects within an image or video.", "keywords": ["object", "detection", "location", "identification", "image"], "source_lectures": ["lecture_106103843_w2_l12"]}}
{"id": "concept_semantic_segmentation", "type": "V_concept", "name": "Semantic Segmentation", "properties": {"description": "The process of assigning a label or category to each pixel in an image.", "keywords": ["semantic", "label", "pixel", "pixel labeling", "category", "segmentation", "dense prediction"], "source_lectures": ["lecture_106103843_w2_l12", "lecture_106103843_w2_l14"]}}
{"id": "concept_pose_estimation", "type": "V_concept", "name": "Pose Estimation", "properties": {"description": "The process of estimating the position and orientation of an object in 3D space.", "keywords": ["pose estimation", "estimation", "ar", "tracking", "pose", "3d", "orientation", "position"], "source_lectures": ["lecture_106103843_w2_l12", "lecture_106103842_w2_l9"]}}
{"id": "concept_depth_estimation", "type": "V_concept", "name": "Depth Estimation", "properties": {"description": "The process of estimating the distance of objects from a camera.", "keywords": ["depth", "estimation", "distance", "camera", "object"], "source_lectures": ["lecture_106103843_w2_l12"]}}
{"id": "concept_optical_flow", "type": "V_concept", "name": "Optical Flow", "properties": {"description": "The apparent motion of brightness patterns between consecutive frames in a video.", "keywords": ["optical", "flow", "motion", "brightness", "video"], "source_lectures": ["lecture_106103843_w2_l12"]}}
{"id": "concept_3d_reconstruction", "type": "V_concept", "name": "3D Reconstruction", "properties": {"description": "The process of generating a 3D model from 2D images or videos.", "keywords": ["3d", "reconstruction", "model", "image", "video"], "source_lectures": ["lecture_106103843_w2_l12"]}}
{"id": "concept_image_super_resolution", "type": "V_concept", "name": "Image Super Resolution", "properties": {"description": "The process of enhancing the resolution of an image.", "keywords": ["image", "super", "resolution", "enhancement", "quality"], "source_lectures": ["lecture_106103843_w2_l12"]}}
{"id": "concept_action_recognition", "type": "V_concept", "name": "Action Recognition", "properties": {"description": "The process of identifying human actions in videos or images.", "keywords": ["action", "recognition", "human", "video", "image"], "source_lectures": ["lecture_106103843_w2_l12"]}}
{"id": "concept_object_tracking", "type": "V_concept", "name": "Object Tracking", "properties": {"description": "The process of locating and following an object across consecutive frames in a video.", "keywords": ["object", "tracking", "location", "video", "frame"], "source_lectures": ["lecture_106103843_w2_l12"]}}
{"id": "concept_medical_image_analysis", "type": "V_concept", "name": "Medical Image Analysis", "properties": {"description": "The process of analyzing and interpreting medical images to extract clinically useful information.", "keywords": ["medical", "image", "analysis", "interpretation", "clinical"], "source_lectures": ["lecture_106103843_w2_l12"]}}
{"id": "concept_remote_sensing", "type": "V_concept", "name": "Remote Sensing", "properties": {"description": "The process of analyzing data acquired from satellites, drones, or airborne sensors to extract meaningful information.", "keywords": ["remote", "sensing", "satellite", "drone", "data"], "source_lectures": ["lecture_106103843_w2_l12"]}}
{"id": "concept_language_ai", "type": "V_concept", "name": "Language Ai", "properties": {"description": "A type of artificial intelligence system used to understand, generate, and interact with human language.", "keywords": ["language", "ai", "natural language processing", "nlp"], "source_lectures": ["lecture_106103843_w2_l13"]}}
{"id": "concept_bag_of_words", "type": "V_concept", "name": "Bag Of Words", "properties": {"description": "A representation of text data where each document is described by a vector of word frequencies.", "keywords": ["bag of words", "text representation", "nlp", "vector"], "source_lectures": ["lecture_106103843_w2_l13"]}}
{"id": "concept_word_to_vector", "type": "V_concept", "name": "Word To Vector", "properties": {"description": "A technique used to represent words as vectors in a high-dimensional space, capturing their semantic meaning.", "keywords": ["word2vec", "word embedding", "nlp", "vector"], "source_lectures": ["lecture_106103843_w2_l13"]}}
{"id": "concept_attention_mechanism", "type": "V_concept", "name": "Attention Mechanism", "properties": {"description": "A technique used in neural networks to focus on specific parts of the input data, such as words in a sentence.", "keywords": ["attention", "neural network", "nlp", "focus"], "source_lectures": ["lecture_106103843_w2_l13"]}}
{"id": "concept_transformer_architecture", "type": "V_concept", "name": "Transformer Architecture", "properties": {"description": "A type of neural network architecture introduced in 2017, designed primarily for sequence-to-sequence tasks.", "keywords": ["transformer", "neural network", "nlp", "sequence-to-sequence"], "source_lectures": ["lecture_106103843_w2_l13"]}}
{"id": "concept_self_attention", "type": "V_concept", "name": "Self Attention", "properties": {"description": "A technique used in transformer architectures to relate different parts of the input sequence to each other.", "keywords": ["self attention", "transformer", "nlp", "sequence"], "source_lectures": ["lecture_106103843_w2_l13"]}}
{"id": "concept_encoder_decoder_model", "type": "V_concept", "name": "Encoder Decoder Model", "properties": {"description": "A type of neural network architecture used for sequence-to-sequence tasks, consisting of an encoder and a decoder.", "keywords": ["encoder decoder", "neural network", "nlp", "sequence-to-sequence"], "source_lectures": ["lecture_106103843_w2_l13"]}}
{"id": "concept_language_model", "type": "V_concept", "name": "Language Model", "properties": {"description": "A statistical model that predicts the probability of a sentence or word sequence.", "keywords": ["language model", "nlp", "probability", "sentence"], "source_lectures": ["lecture_106103843_w2_l13"]}}
{"id": "concept_auto_regressive_model", "type": "V_concept", "name": "Auto Regressive Model", "properties": {"description": "A type of statistical model that predicts the next value in a sequence based on the previous values.", "keywords": ["auto regressive", "model", "nlp", "sequence"], "source_lectures": ["lecture_106103843_w2_l13"]}}
{"id": "concept_generative_pre_trained_transformer", "type": "V_concept", "name": "Generative Pre Trained Transformer", "properties": {"description": "A type of transformer architecture used for generative tasks, such as text generation.", "keywords": ["gpt", "transformer", "nlp", "generative"], "source_lectures": ["lecture_106103843_w2_l13"]}}
{"id": "concept_lenet_architecture", "type": "V_concept", "name": "LeNet Architecture", "properties": {"description": "A pioneering convolutional neural network architecture proposed in 1998", "keywords": ["lenet", "cnn", "architecture", "neural", "network"], "source_lectures": ["lecture_106103843_w3_l15"]}}
{"id": "concept_alexnet_architecture", "type": "V_concept", "name": "AlexNet Architecture", "properties": {"description": "A deep convolutional neural network architecture that won the ImageNet competition in 2012", "keywords": ["alexnet", "cnn", "architecture", "deep", "learning"], "source_lectures": ["lecture_106103843_w3_l15"]}}
{"id": "concept_padding_technique", "type": "V_concept", "name": "Padding Technique", "properties": {"description": "A method used in convolutional neural networks to add extra pixels around the border of an input image or feature map", "keywords": ["padding", "cnn", "technique", "image", "processing"], "source_lectures": ["lecture_106103843_w3_l15"]}}
{"id": "concept_vggnet_architecture", "type": "V_concept", "name": "VGGNet Architecture", "properties": {"description": "A deep convolutional neural network architecture that uses small filters and deeper networks", "keywords": ["vggnet", "cnn", "architecture", "deep", "learning"], "source_lectures": ["lecture_106103843_w3_l15"]}}
{"id": "concept_googlenet_architecture", "type": "V_concept", "name": "GoogleNet Architecture", "properties": {"description": "A deep convolutional neural network architecture that uses inception modules and bottleneck layers", "keywords": ["googlenet", "cnn", "architecture", "inception", "bottleneck"], "source_lectures": ["lecture_106103843_w3_l15"]}}
{"id": "concept_bottleneck_layer", "type": "V_concept", "name": "Bottleneck Layer", "properties": {"description": "A layer used in convolutional neural networks to reduce the dimensionality of the feature space", "keywords": ["bottleneck", "layer", "cnn", "dimensionality", "reduction"], "source_lectures": ["lecture_106103843_w3_l15"]}}
{"id": "concept_algorithm", "type": "V_concept", "name": "Algorithm", "properties": {"description": "A finite sequence of well-defined instructions to solve a problem or perform a computation.", "keywords": ["algorithm", "instructions", "computation", "problem", "solving"], "source_lectures": ["lecture_106105847_w1_l1"]}}
{"id": "concept_key_properties_of_algorithm", "type": "V_concept", "name": "Key Properties Of Algorithm", "properties": {"description": "Properties that an algorithm should have, including finiteness, definiteness, correctness, and effectiveness.", "keywords": ["algorithm", "properties", "finiteness", "definiteness", "correctness"], "source_lectures": ["lecture_106105847_w1_l1"]}}
{"id": "concept_flowchart", "type": "V_concept", "name": "Flowchart", "properties": {"description": "A graphical representation of an algorithm, showing the steps and flow of control.", "keywords": ["flowchart", "graphical", "representation", "algorithm", "control"], "source_lectures": ["lecture_106105847_w1_l1"]}}
{"id": "concept_pseudo_code", "type": "V_concept", "name": "Pseudo Code", "properties": {"description": "A high-level representation of an algorithm, using a combination of natural language and programming-like syntax.", "keywords": ["pseudo", "code", "high-level", "representation", "algorithm"], "source_lectures": ["lecture_106105847_w1_l1"]}}
{"id": "concept_time_complexity", "type": "V_concept", "name": "Time Complexity", "properties": {"description": "A measure of the amount of time an algorithm takes to complete, usually expressed as a function of the input size.", "keywords": ["time", "efficiency", "size", "steps", "input", "complexity", "measure", "algorithm", "computation", "performance", "problems"], "source_lectures": ["lecture_106105847_w1_l1", "lecture_106105847_w1_l4", "lecture_106105847_w2_l12", "lecture_106104357_w6_l36", "lecture_106105847_w1_l3", "lecture_106105847_w2_l9", "lecture_106105847_w2_l13", "lecture_106105847_w2_l14", "lecture_106106931_w2_l9", "lecture_106104357_w1_l1", "lecture_106104357_w1_l3", "lecture_106104357_w1_l4"]}}
{"id": "concept_sorting_problem", "type": "V_concept", "name": "Sorting Problem", "properties": {"description": "A classic problem in computer science, involving arranging a list of items in a specific order.", "keywords": ["sorting", "problem", "algorithm", "order", "arrangement"], "source_lectures": ["lecture_106105847_w1_l1"]}}
{"id": "concept_insertion_sort", "type": "V_concept", "name": "Insertion Sort", "properties": {"description": "A simple sorting algorithm that works by iterating through a list and inserting each item into its proper position.", "keywords": ["sort", "insertion", "simple", "sorting", "algorithm"], "source_lectures": ["lecture_106105847_w1_l1", "lecture_106105847_w1_l2", "lecture_106105847_w1_l4", "lecture_106105847_w1_l3"]}}
{"id": "concept_algorithm_design_technique", "type": "V_concept", "name": "Algorithm Design Technique", "properties": {"description": "A general approach or strategy for solving a problem or class of problems, such as divide and conquer or dynamic programming.", "keywords": ["algorithm", "design", "technique", "strategy", "problem-solving"], "source_lectures": ["lecture_106105847_w1_l1"]}}
{"id": "concept_divide_and_conquer_technique", "type": "V_concept", "name": "Divide And Conquer Technique", "properties": {"description": "A problem-solving strategy that involves breaking a problem into smaller sub-problems and solving each one recursively.", "keywords": ["conquer", "divide", "problem", "solving", "recursion", "technique", "problem-solving"], "source_lectures": ["lecture_106105847_w1_l1", "lecture_106105847_w1_l5"]}}
{"id": "concept_runtime_analysis", "type": "V_concept", "name": "Runtime Analysis", "properties": {"description": "The process of determining the amount of time an algorithm takes to complete as a function of the size of the input", "keywords": ["runtime", "analysis", "algorithm", "time"], "source_lectures": ["lecture_106105847_w1_l2"]}}
{"id": "concept_worst_case_analysis", "type": "V_concept", "name": "Worst Case Analysis", "properties": {"description": "A type of analysis that determines the maximum time an algorithm takes to complete for any input of a given size", "keywords": ["time", "worstcase", "analysis", "algorithm", "worst", "performance", "case"], "source_lectures": ["lecture_106105847_w1_l2", "lecture_106105847_w1_l3", "lecture_106105847_w2_l14"]}}
{"id": "concept_best_case_analysis", "type": "V_concept", "name": "Best Case Analysis", "properties": {"description": "A type of analysis that determines the minimum time an algorithm takes to complete for a specific input", "keywords": ["time", "analysis", "algorithm", "best", "case"], "source_lectures": ["lecture_106105847_w1_l2", "lecture_106105847_w1_l3"]}}
{"id": "concept_average_case_analysis", "type": "V_concept", "name": "Average Case Analysis", "properties": {"description": "A type of analysis that determines the expected time an algorithm takes to complete for a random input", "keywords": ["averagecase", "time", "analysis", "algorithm", "average", "performance", "case"], "source_lectures": ["lecture_106105847_w1_l2", "lecture_106105847_w1_l3", "lecture_106105847_w2_l14"]}}
{"id": "concept_asymptotic_notation", "type": "V_concept", "name": "Asymptotic Notation", "properties": {"description": "A mathematical notation used to describe the growth rate of an algorithm's runtime as the input size increases", "keywords": ["growth", "efficiency", "running-time", "asymptotic", "performance", "complexity", "asymptotic notation", "rate", "mathematics", "runtime", "theta", "big O", "growth rate", "big-o", "algorithm", "notation"], "source_lectures": ["lecture_106105847_w1_l2", "lecture_106105847_w1_l4", "lecture_106106221_w1_l6", "lecture_106105847_w1_l3", "lecture_106105847_w1_l7", "lecture_106105847_w2_l13", "lecture_106105847_w3_l15", "lecture_106104357_w1_l4"]}}
{"id": "concept_big_theta_notation", "type": "V_concept", "name": "Big Theta Notation", "properties": {"description": "A type of asymptotic notation that describes the exact growth rate of an algorithm's runtime", "keywords": ["runtime", "complexity", "tight bound", "big theta", "bound", "notation", "algorithm", "theta", "lower", "big", "upper"], "source_lectures": ["lecture_106105847_w1_l2", "lecture_106105847_w1_l5", "lecture_106105847_w1_l6", "lecture_106105847_w1_l3", "lecture_106104357_w1_l5"]}}
{"id": "concept_big_o_notation", "type": "V_concept", "name": "Big O Notation", "properties": {"description": "A type of asymptotic notation that describes the upper bound of an algorithm's runtime", "keywords": ["runtime", "o", "big o", "complexity", "bound", "upper bound", "algorithm", "notation", "big", "upper"], "source_lectures": ["lecture_106105847_w1_l2", "lecture_106105847_w1_l4", "lecture_106105847_w1_l5", "lecture_106105847_w1_l6", "lecture_106105847_w2_l8", "lecture_106105847_w1_l3", "lecture_106106221_w9_l62", "lecture_106104357_w1_l4", "lecture_106104357_w1_l5"]}}
{"id": "concept_big_omega_notation", "type": "V_concept", "name": "Big Omega Notation", "properties": {"description": "A type of asymptotic notation that describes the lower bound of an algorithm's runtime", "keywords": ["time", "big", "complexity", "lower bound", "big omega", "bound", "runtime", "lower", "omega", "algorithm", "notation"], "source_lectures": ["lecture_106105847_w1_l2", "lecture_106105847_w1_l6", "lecture_106105847_w2_l12", "lecture_106105847_w1_l3", "lecture_106104357_w1_l4", "lecture_106104357_w1_l5"]}}
{"id": "concept_loop_invariant", "type": "V_concept", "name": "Loop Invariant", "properties": {"description": "A property of a loop that remains true before and after each iteration", "keywords": ["loop", "invariant", "algorithm", "iteration"], "source_lectures": ["lecture_106105847_w1_l2"]}}
{"id": "concept_merge_sort", "type": "V_concept", "name": "Merge Sort", "properties": {"description": "A sorting algorithm that uses the divide and conquer technique to sort an array of elements.", "keywords": ["conquer", "algorithm", "sort", "divide", "merge", "comparison"], "source_lectures": ["lecture_106105847_w1_l4", "lecture_106105847_w2_l12"]}}
{"id": "concept_divide_and_conquer", "type": "V_concept", "name": "Divide And Conquer", "properties": {"description": "A problem-solving strategy that involves breaking down a problem into smaller sub-problems and solving each sub-problem recursively.", "keywords": ["divide", "conquer", "recursion", "problem", "solving"], "source_lectures": ["lecture_106105847_w1_l4"]}}
{"id": "concept_recurrence_relation", "type": "V_concept", "name": "Recurrence Relation", "properties": {"description": "A mathematical equation that defines a sequence of numbers recursively, often used to analyze the time complexity of algorithms.", "keywords": ["time", "relation", "complexity", "recursive", "sequence", "algorithm", "mathematical", "equation", "recurrence"], "source_lectures": ["lecture_106105847_w1_l4", "lecture_106105847_w1_l5", "lecture_106105847_w1_l6", "lecture_106105847_w1_l7", "lecture_106105847_w2_l9"]}}
{"id": "concept_merge", "type": "V_concept", "name": "Merge", "properties": {"description": "A subroutine used in merge sort to combine two sorted subarrays into a single sorted array.", "keywords": ["merge", "subroutine", "sort", "array"], "source_lectures": ["lecture_106105847_w1_l4"]}}
{"id": "concept_in_place_sorting", "type": "V_concept", "name": "In-place Sorting", "properties": {"description": "A sorting algorithm that sorts an array without using any additional storage, other than a small amount of extra memory for variables.", "keywords": ["memory", "technique", "in-place", "space", "in-place sorting", "sorting technique", "sorting", "array", "algorithm", "storage"], "source_lectures": ["lecture_106105847_w1_l4", "lecture_106105847_w2_l11", "lecture_106105847_w2_l9"]}}
{"id": "concept_recursion_tree_method", "type": "V_concept", "name": "Recursion Tree Method", "properties": {"description": "A method used to solve recurrence relations by visualizing the recursive calls as a tree and analyzing the tree's structure.", "keywords": ["tree", "method", "solving", "cost summation", "calls", "recursive", "tree visualization", "recursion", "recursion tree", "recurrence solving"], "source_lectures": ["lecture_106105847_w1_l5", "lecture_106105847_w1_l6", "lecture_106105847_w3_l15"]}}
{"id": "concept_substitution_method", "type": "V_concept", "name": "Substitution Method", "properties": {"description": "A method used to solve recurrence relations by guessing a solution and then verifying it using mathematical induction.", "keywords": ["verify", "substitution", "method", "solving", "induction", "verification", "substitution method", "guess", "recurrence"], "source_lectures": ["lecture_106105847_w1_l5", "lecture_106105847_w1_l6", "lecture_106105847_w3_l15"]}}
{"id": "concept_mathematical_induction", "type": "V_concept", "name": "Mathematical Induction", "properties": {"description": "A mathematical technique used to prove that a statement is true for all positive integers by showing it is true for the first integer and that it remains true for subsequent integers.", "keywords": ["mathematical", "induction", "proof", "integer"], "source_lectures": ["lecture_106105847_w1_l5"]}}
{"id": "concept_master_method", "type": "V_concept", "name": "Master Method", "properties": {"description": "A method used to solve recurrence relations of a specific form, which is a general method for solving recurrences.", "keywords": ["master", "mathematics", "method", "relation", "algorithm", "solving", "recurrence"], "source_lectures": ["lecture_106105847_w1_l5", "lecture_106105847_w1_l6", "lecture_106105847_w2_l8", "lecture_106105847_w2_l10"]}}
{"id": "concept_asymptotic_analysis", "type": "V_concept", "name": "Asymptotic Analysis", "properties": {"description": "The study of the behavior of an algorithm's time or space complexity as the input size approaches infinity.", "keywords": ["time", "asymptotic", "complexity", "behavior", "analysis", "algorithm", "performance"], "source_lectures": ["lecture_106105847_w1_l5", "lecture_106105847_w1_l6", "lecture_106105847_w2_l8", "lecture_106104357_w1_l5"]}}
{"id": "concept_geometric_series", "type": "V_concept", "name": "Geometric Series", "properties": {"description": "A sequence of numbers in which each term after the first is found by multiplying the previous term by a fixed, non-zero number called the common ratio.", "keywords": ["geometric", "series", "sequence", "common", "ratio"], "source_lectures": ["lecture_106105847_w1_l5"]}}
{"id": "concept_polynomial_factor", "type": "V_concept", "name": "Polynomial Factor", "properties": {"description": "A factor that grows polynomially with the input size, often used in asymptotic analysis.", "keywords": ["polynomial", "factor", "asymptotic", "analysis"], "source_lectures": ["lecture_106105847_w1_l6"]}}
{"id": "concept_regularity_condition", "type": "V_concept", "name": "Regularity Condition", "properties": {"description": "A condition required for the master method to apply, ensuring that the recurrence can be solved using the method.", "keywords": ["regularity", "condition", "master", "method"], "source_lectures": ["lecture_106105847_w1_l6"]}}
{"id": "concept_divide_and_conquer_algorithm", "type": "V_concept", "name": "Divide And Conquer Algorithm", "properties": {"description": "A problem-solving strategy that involves breaking down a problem into smaller sub-problems, solving each sub-problem, and then combining the solutions to solve the original problem.", "keywords": ["divide", "solving", "conquer", "problem", "recursion", "algorithm", "subproblem"], "source_lectures": ["lecture_106105847_w2_l8", "lecture_106105847_w2_l14"]}}
{"id": "concept_fibonacci_number", "type": "V_concept", "name": "Fibonacci Number", "properties": {"description": "A sequence of numbers in which each number is the sum of the two preceding numbers, starting from 0 and 1.", "keywords": ["fibonacci", "number", "sequence", "mathematics"], "source_lectures": ["lecture_106105847_w2_l8"]}}
{"id": "concept_matrix_multiplication", "type": "V_concept", "name": "Matrix Multiplication", "properties": {"description": "A mathematical operation that combines two matrices to produce another matrix, where each element is the sum of the products of corresponding elements from the rows of the first matrix and the columns of the second matrix.", "keywords": ["algebra", "multiplication", "operation", "markov", "chain", "mathematics", "linear", "matrix"], "source_lectures": ["lecture_106105847_w2_l8", "lecture_106102229_w4_l23", "lecture_106104233_w3_l19"]}}
{"id": "concept_recursion", "type": "V_concept", "name": "Recursion", "properties": {"description": "A programming technique where a function calls itself repeatedly until it reaches a base case that stops the recursion.", "keywords": ["haskell", "function call", "programming", "programming technique", "technique", "base case", "function", "recursion", "call"], "source_lectures": ["lecture_106105847_w2_l8", "lecture_106106931_w1_l1", "lecture_106106931_w2_l9", "lecture_106106931_w2_l12"]}}
{"id": "concept_strassens_algorithm", "type": "V_concept", "name": "Strassen's Algorithm", "properties": {"description": "A fast matrix multiplication algorithm that uses a divide-and-conquer approach to reduce the number of multiplications required.", "keywords": ["strassen", "algorithm", "matrix", "multiplication", "fast"], "source_lectures": ["lecture_106105847_w2_l8"]}}
{"id": "concept_logarithmic_time_complexity", "type": "V_concept", "name": "Logarithmic Time Complexity", "properties": {"description": "A time complexity that grows logarithmically with the size of the input, often expressed as O(log n).", "keywords": ["logarithmic", "time", "complexity", "algorithm", "efficiency"], "source_lectures": ["lecture_106105847_w2_l8"]}}
{"id": "concept_exponential_time_complexity", "type": "V_concept", "name": "Exponential Time Complexity", "properties": {"description": "A time complexity that grows exponentially with the size of the input, often expressed as O(2^n) or O(a^n) where a is a constant.", "keywords": ["time", "inefficiency", "exponential", "input", "complexity", "algorithm"], "source_lectures": ["lecture_106105847_w2_l8", "lecture_106104357_w2_l8"]}}
{"id": "concept_quick_sort_algorithm", "type": "V_concept", "name": "Quick Sort Algorithm", "properties": {"description": "A divide-and-conquer algorithm that sorts an array by selecting a pivot element and partitioning the array around it.", "keywords": ["quick", "sort", "algorithm", "divide", "conquer"], "source_lectures": ["lecture_106105847_w2_l10"]}}
{"id": "concept_divide_and_conquer_approach", "type": "V_concept", "name": "Divide And Conquer Approach", "properties": {"description": "A problem-solving strategy that involves breaking down a problem into smaller sub-problems and solving each sub-problem recursively.", "keywords": ["divide and conquer", "divide", "solving", "subproblems", "conquer", "problem", "algorithm design", "recursion", "approach"], "source_lectures": ["lecture_106105847_w2_l10", "lecture_106105847_w2_l9", "lecture_106105847_w3_l15"]}}
{"id": "concept_partition_scheme", "type": "V_concept", "name": "Partition Scheme", "properties": {"description": "A method of dividing an array into two parts based on a pivot element, where all elements less than the pivot are on one side and all elements greater than the pivot are on the other.", "keywords": ["partition", "subarray", "divide", "scheme", "pivot", "array"], "source_lectures": ["lecture_106105847_w2_l10", "lecture_106105847_w2_l9"]}}
{"id": "concept_randomized_quick_sort", "type": "V_concept", "name": "Randomized Quick Sort", "properties": {"description": "A variation of the quick sort algorithm that chooses the pivot element randomly to avoid worst-case scenarios.", "keywords": ["randomized", "quick", "sort", "algorithm", "pivot"], "source_lectures": ["lecture_106105847_w2_l10"]}}
{"id": "concept_worst_case_time_complexity", "type": "V_concept", "name": "Worst-Case Time Complexity", "properties": {"description": "The maximum time an algorithm takes to complete, usually expressed as a function of the input size.", "keywords": ["runtime", "worst-case", "time", "time complexity", "complexity", "algorithm", "worst", "algorithm analysis", "case"], "source_lectures": ["lecture_106105847_w2_l10", "lecture_106105847_w3_l15"]}}
{"id": "concept_average_case_time_complexity", "type": "V_concept", "name": "Average-Case Time Complexity", "properties": {"description": "The expected time an algorithm takes to complete, usually expressed as a function of the input size.", "keywords": ["average", "case", "time", "complexity", "algorithm"], "source_lectures": ["lecture_106105847_w2_l10"]}}
{"id": "concept_recursion_tree", "type": "V_concept", "name": "Recursion Tree", "properties": {"description": "A visual representation of the recursive calls made by an algorithm, used to analyze its time complexity.", "keywords": ["recursion", "tree", "algorithm", "time", "complexity"], "source_lectures": ["lecture_106105847_w2_l10"]}}
{"id": "concept_expected_runtime", "type": "V_concept", "name": "Expected Runtime", "properties": {"description": "The average time an algorithm takes to complete, usually expressed as a function of the input size.", "keywords": ["expected", "runtime", "algorithm", "time", "complexity"], "source_lectures": ["lecture_106105847_w2_l10"]}}
{"id": "concept_indicated_random_variable", "type": "V_concept", "name": "Indicated Random Variable", "properties": {"description": "A random variable that takes on the value 1 if a certain condition is met and 0 otherwise.", "keywords": ["indicated", "random", "variable", "condition", "probability"], "source_lectures": ["lecture_106105847_w2_l10"]}}
{"id": "concept_heap_data_structure", "type": "V_concept", "name": "Heap Data Structure", "properties": {"description": "A specialized tree-based data structure that satisfies the heap property, where the parent node is either greater than (max heap) or less than (min heap) its child nodes.", "keywords": ["max heap", "tree", "min heap", "data structure", "heap", "binary tree", "array"], "source_lectures": ["lecture_106105847_w2_l11", "lecture_106105847_w3_l20"]}}
{"id": "concept_max_heap", "type": "V_concept", "name": "Max Heap", "properties": {"description": "A type of heap where every parent node is greater than or equal to its child nodes.", "keywords": ["max heap", "heap", "parent node", "child node"], "source_lectures": ["lecture_106105847_w2_l11"]}}
{"id": "concept_min_heap", "type": "V_concept", "name": "Min Heap", "properties": {"description": "A type of heap where every parent node is less than or equal to its child nodes.", "keywords": ["min heap", "heap", "parent node", "child node"], "source_lectures": ["lecture_106105847_w2_l11"]}}
{"id": "concept_heap_property", "type": "V_concept", "name": "Heap Property", "properties": {"description": "The property of a heap where the parent node is either greater than (max heap) or less than (min heap) its child nodes.", "keywords": ["heap property", "parent node", "child node", "max heap", "min heap"], "source_lectures": ["lecture_106105847_w2_l11"]}}
{"id": "concept_heap_sort", "type": "V_concept", "name": "Heap Sort", "properties": {"description": "A comparison-based sorting algorithm that uses a heap data structure to sort elements in ascending or descending order.", "keywords": ["comparison-based", "sorting algorithm", "heap", "sort", "algorithm", "heap sort", "comparison", "data"], "source_lectures": ["lecture_106105847_w2_l11", "lecture_106105847_w2_l12"]}}
{"id": "concept_build_max_heap", "type": "V_concept", "name": "Build Max Heap", "properties": {"description": "An algorithm that constructs a max heap from an unsorted array by iteratively applying the heapify operation.", "keywords": ["build max heap", "max heap", "heapify", "algorithm"], "source_lectures": ["lecture_106105847_w2_l11"]}}
{"id": "concept_heapify", "type": "V_concept", "name": "Heapify", "properties": {"description": "An operation that maintains the heap property by swapping elements to ensure the parent node is greater than (max heap) or less than (min heap) its child nodes.", "keywords": ["heapify", "heap property", "parent node", "child node"], "source_lectures": ["lecture_106105847_w2_l11"]}}
{"id": "concept_priority_queue", "type": "V_concept", "name": "Priority Queue", "properties": {"description": "A data structure that allows elements to be inserted and removed based on their priority, often implemented using a heap.", "keywords": ["priority", "data structure", "heap", "priority queue", "queue", "key"], "source_lectures": ["lecture_106105847_w2_l11", "lecture_106105847_w3_l20"]}}
{"id": "concept_maxify", "type": "V_concept", "name": "Maxify", "properties": {"description": "An algorithm that corrects a single violation of the heap property in a max heap by swapping elements to ensure the parent node is greater than its child nodes.", "keywords": ["maxify", "max heap", "heap property", "algorithm"], "source_lectures": ["lecture_106105847_w2_l11"]}}
{"id": "concept_comparison_based_sorting", "type": "V_concept", "name": "Comparison Based Sorting", "properties": {"description": "A type of sorting algorithm that uses comparisons between elements to determine their order.", "keywords": ["based", "lower bound", "sorting", "elements", "comparison", "algorithm"], "source_lectures": ["lecture_106105847_w2_l12", "lecture_106105847_w2_l13"]}}
{"id": "concept_decision_tree_model", "type": "V_concept", "name": "Decision Tree Model", "properties": {"description": "A model used to represent the execution of a comparison-based sorting algorithm as a tree of decisions.", "keywords": ["decision", "tree", "model", "sorting", "algorithm"], "source_lectures": ["lecture_106105847_w2_l12"]}}
{"id": "concept_linear_time_sorting", "type": "V_concept", "name": "Linear Time Sorting", "properties": {"description": "A type of sorting algorithm that has a time complexity of O(n), where n is the number of elements being sorted.", "keywords": ["time", "complexity", "sorting", "algorithm", "linear"], "source_lectures": ["lecture_106105847_w2_l12", "lecture_106105847_w2_l13"]}}
{"id": "concept_counting_sort", "type": "V_concept", "name": "Counting Sort", "properties": {"description": "A linear time sorting algorithm that uses auxiliary arrays to count the frequency of each element and sort them.", "keywords": ["auxiliary", "sort", "stable", "counting", "algorithm", "linear", "frequency"], "source_lectures": ["lecture_106105847_w2_l12", "lecture_106105847_w2_l13"]}}
{"id": "concept_stability_property", "type": "V_concept", "name": "Stability Property", "properties": {"description": "A property of a sorting algorithm that preserves the order of equal elements after sorting.", "keywords": ["stability", "property", "sorting", "algorithm", "equal"], "source_lectures": ["lecture_106105847_w2_l12"]}}
{"id": "concept_worst_case_runtime", "type": "V_concept", "name": "Worst Case Runtime", "properties": {"description": "The maximum amount of time an algorithm takes to complete for any given input.", "keywords": ["worst", "case", "runtime", "algorithm", "input"], "source_lectures": ["lecture_106105847_w2_l12"]}}
{"id": "concept_asymptotic_optimality", "type": "V_concept", "name": "Asymptotic Optimality", "properties": {"description": "A property of an algorithm that has the best possible time complexity for a given problem.", "keywords": ["asymptotic", "optimality", "algorithm", "time", "complexity"], "source_lectures": ["lecture_106105847_w2_l12"]}}
{"id": "concept_quick_sort", "type": "V_concept", "name": "Quick Sort", "properties": {"description": "A comparison-based sorting algorithm that uses a divide-and-conquer approach to sort elements.", "keywords": ["quick", "sort", "algorithm", "comparison", "divide"], "source_lectures": ["lecture_106105847_w2_l12"]}}
{"id": "concept_indexing_mechanism", "type": "V_concept", "name": "Indexing Mechanism", "properties": {"description": "A process of organizing and storing data to facilitate efficient searching and retrieval.", "keywords": ["indexing", "search", "retrieval", "lucene"], "source_lectures": ["lecture_106106852_w3_l15"]}}
{"id": "concept_term", "type": "V_concept", "name": "Term", "properties": {"description": "A pair of a field name and an analyzed word that serves as an atomic entry into the index.", "keywords": ["word", "vocabulary item", "lucene", "field", "index", "token", "term", "indexing unit"], "source_lectures": ["lecture_106106852_w3_l15", "lecture_106106852_w2_l9"]}}
{"id": "concept_field", "type": "V_concept", "name": "Field", "properties": {"description": "A specific attribute or characteristic of a document that represents a unit of data.", "keywords": ["algebra", "lucene", "attribute", "field", "document", "mathematics", "operations", "set"], "source_lectures": ["lecture_106106852_w3_l15", "lecture_106106221_w4_l26"]}}
{"id": "concept_document", "type": "V_concept", "name": "Document", "properties": {"description": "A collection of fields that represents a single unit of data or information.", "keywords": ["document", "fields", "data", "lucene"], "source_lectures": ["lecture_106106852_w3_l15"]}}
{"id": "concept_relevancy", "type": "V_concept", "name": "Relevancy", "properties": {"description": "A measure of how well a document matches a search query or user's information need.", "keywords": ["relevancy", "search", "query", "lucene"], "source_lectures": ["lecture_106106852_w3_l15"]}}
{"id": "concept_tf_idf", "type": "V_concept", "name": "TF-IDF", "properties": {"description": "A scoring algorithm used to calculate the relevance of a document to a search query.", "keywords": ["tf-idf", "scoring", "algorithm", "lucene"], "source_lectures": ["lecture_106106852_w3_l15"]}}
{"id": "concept_field_options", "type": "V_concept", "name": "Field Options", "properties": {"description": "Configurable settings that determine the behavior of a field in a Lucene index.", "keywords": ["field", "options", "lucene", "index"], "source_lectures": ["lecture_106106852_w3_l15"]}}
{"id": "concept_indexed_field", "type": "V_concept", "name": "Indexed Field", "properties": {"description": "A field that is included in the searchable index and can be queried.", "keywords": ["indexed", "field", "searchable", "lucene"], "source_lectures": ["lecture_106106852_w3_l15"]}}
{"id": "concept_analyzed_field", "type": "V_concept", "name": "Analyzed Field", "properties": {"description": "A field that is broken down into tokens with stemming and filtering to enable partial matching.", "keywords": ["analyzed", "field", "tokens", "lucene"], "source_lectures": ["lecture_106106852_w3_l15"]}}
{"id": "concept_stored_field", "type": "V_concept", "name": "Stored Field", "properties": {"description": "A field that stores the original value for display or retrieval, but is not searchable.", "keywords": ["field", "stored", "display", "retrievability", "non-searchable", "lucene"], "source_lectures": ["lecture_106106852_w3_l15", "lecture_106106852_w3_l16"]}}
{"id": "concept_term_vectors", "type": "V_concept", "name": "Term Vectors", "properties": {"description": "A way of storing the document frequency and term frequency of individual words in a document.", "keywords": ["importance", "query", "vectors", "term", "expansion", "frequency", "document", "lucene"], "source_lectures": ["lecture_106106852_w3_l15", "lecture_106106852_w3_l16", "lecture_106106852_w4_l23"]}}
{"id": "concept_query_expansion", "type": "V_concept", "name": "Query Expansion", "properties": {"description": "A technique used to expand a search query to include related terms or concepts.", "keywords": ["results", "search", "query", "expansion", "technique", "lucene"], "source_lectures": ["lecture_106106852_w3_l15", "lecture_106106852_w4_l22", "lecture_106106852_w4_l23"]}}
{"id": "concept_textfield", "type": "V_concept", "name": "TextField", "properties": {"description": "A field class in Lucene that controls whether text is analyzed or not.", "keywords": ["text", "field", "lucene", "analysis"], "source_lectures": ["lecture_106106852_w3_l15"]}}
{"id": "concept_stringfield", "type": "V_concept", "name": "StringField", "properties": {"description": "A field class in Lucene that stores exact values without tokenization.", "keywords": ["string", "field", "lucene", "exact"], "source_lectures": ["lecture_106106852_w3_l15"]}}
{"id": "concept_pointfield", "type": "V_concept", "name": "PointField", "properties": {"description": "A field class in Lucene that stores numerical data for range queries or filtering.", "keywords": ["point", "field", "lucene", "numerical"], "source_lectures": ["lecture_106106852_w3_l15"]}}
{"id": "concept_storedfield", "type": "V_concept", "name": "StoredField", "properties": {"description": "A field class in Lucene that stores data for display or retrieval, but is not searchable.", "keywords": ["stored", "field", "lucene", "display"], "source_lectures": ["lecture_106106852_w3_l15"]}}
{"id": "concept_text_field", "type": "V_concept", "name": "Text Field", "properties": {"description": "A field type in PyLucene used for storing full text data, allowing for tokenization and searchability.", "keywords": ["lucene", "engine", "search", "field", "text", "tokenization"], "source_lectures": ["lecture_106106852_w3_l16", "lecture_106106852_w4_l25"]}}
{"id": "concept_string_field", "type": "V_concept", "name": "String Field", "properties": {"description": "A field type in PyLucene used for storing string data, applicable for exact matching and not tokenized.", "keywords": ["string", "field", "lucene", "exact", "match"], "source_lectures": ["lecture_106106852_w3_l16"]}}
{"id": "concept_int_field", "type": "V_concept", "name": "Int Field", "properties": {"description": "A field type in PyLucene used for storing integer data, applicable for exact or range-based searching.", "keywords": ["int", "field", "lucene", "integer", "search"], "source_lectures": ["lecture_106106852_w3_l16"]}}
{"id": "concept_field_class", "type": "V_concept", "name": "Field Class", "properties": {"description": "A class in PyLucene used as a base class for all field types, allowing for customization of indexing and storage options.", "keywords": ["field", "text", "integer", "indexing", "storage", "class", "lucene"], "source_lectures": ["lecture_106106852_w3_l16", "lecture_106106852_w3_l20"]}}
{"id": "concept_index_options", "type": "V_concept", "name": "Index Options", "properties": {"description": "A set of options in PyLucene that determine how data is indexed, including document, term frequency, and position storage.", "keywords": ["index", "positions", "config", "vectors", "options", "term", "indexing", "settings", "term frequency", "document", "lucene"], "source_lectures": ["lecture_106106852_w3_l16", "lecture_106106852_w3_l20", "lecture_106106852_w4_l22"]}}
{"id": "concept_tokenization", "type": "V_concept", "name": "Tokenization", "properties": {"description": "The process of breaking down text into individual words or tokens, used in PyLucene for searchability.", "keywords": ["word", "lucene", "preprocessing", "search", "information retrieval", "tokens", "token", "text", "tokenization", "nlp", "language", "information", "text splitting", "words", "natural", "processing", "term extraction"], "source_lectures": ["lecture_106106852_w3_l16", "lecture_106106852_w1_l4", "lecture_106106852_w1_l5", "lecture_106106852_w1_l7", "lecture_106106852_w2_l8", "lecture_106106852_w2_l9", "lecture_106106852_w3_l18", "lecture_106106852_w3_l21"]}}
{"id": "concept_inverted_index", "type": "V_concept", "name": "Inverted Index", "properties": {"description": "A data structure in PyLucene that stores mappings between terms and documents, used for efficient searching.", "keywords": ["lucene", "term mapping", "term", "indexing", "data", "retrieval", "document ids", "locations", "documents", "search", "data structure", "structure", "document", "text retrieval", "information", "search index", "posting list", "document retrieval", "information retrieval", "inverted index", "inverted", "mapreduce application", "term document", "index", "terms", "text indexing"], "source_lectures": ["lecture_106106852_w3_l16", "lecture_106106852_w3_l17", "lecture_106106852_w3_l20", "lecture_106106852_w4_l23", "lecture_106106852_w4_l26", "lecture_106106852_w1_l5", "lecture_106106852_w1_l6", "lecture_106106852_w1_l7", "lecture_106106852_w2_l8", "lecture_106106852_w2_l9", "lecture_106106852_w2_l10", "lecture_106106852_w2_l11", "lecture_106106852_w3_l18", "lecture_106104182_w3_l19"]}}
{"id": "concept_phrase_search", "type": "V_concept", "name": "Phrase Search", "properties": {"description": "A type of search in PyLucene that allows for searching for exact phrases or sequences of words.", "keywords": ["phrase", "search", "lucene", "exact", "sequence"], "source_lectures": ["lecture_106106852_w3_l16"]}}
{"id": "concept_document_parser", "type": "V_concept", "name": "Document Parser", "properties": {"description": "A software component that extracts relevant information from a document, such as text, metadata, and structure.", "keywords": ["parsing", "document", "parser", "information"], "source_lectures": ["lecture_106106852_w3_l17"]}}
{"id": "concept_analyzer", "type": "V_concept", "name": "Analyzer", "properties": {"description": "A software component that performs linguistic processing on text data, such as tokenization, stemming, and stopword removal.", "keywords": ["analyzing", "text", "processing", "linguistic"], "source_lectures": ["lecture_106106852_w3_l17"]}}
{"id": "concept_standard_analyzer", "type": "V_concept", "name": "Standard Analyzer", "properties": {"description": "A type of analyzer that performs standard linguistic processing on text data, such as tokenization, stemming, and stopword removal.", "keywords": ["punctuation", "lucene", "analyzing", "lowercase", "analyzer", "filtering", "text", "tokenization", "standard analyzer", "standard", "processing"], "source_lectures": ["lecture_106106852_w3_l17", "lecture_106106852_w4_l24", "lecture_106106852_w3_l18"]}}
{"id": "concept_stopword_removal", "type": "V_concept", "name": "Stopword Removal", "properties": {"description": "The process of removing common words, such as 'the' and 'and', from a text dataset to reduce noise and improve search performance.", "keywords": ["stopword", "removal", "text", "processing"], "source_lectures": ["lecture_106106852_w3_l17"]}}
{"id": "concept_stemming", "type": "V_concept", "name": "Stemming", "properties": {"description": "The process of reducing words to their base or root form, such as 'running' to 'run', to improve search performance.", "keywords": ["text", "indexing", "words", "retrieval", "efficiency", "search", "stemming", "filtering", "tokenization", "information", "natural", "inflection", "processing", "text normalization", "linguistic", "nlp", "base", "language", "reduction", "root word", "word"], "source_lectures": ["lecture_106106852_w3_l17", "lecture_106106852_w4_l24", "lecture_106106852_w1_l4", "lecture_106106852_w1_l5", "lecture_106106852_w1_l7", "lecture_106106852_w3_l18", "lecture_106106852_w3_l21"]}}
{"id": "concept_pylucene", "type": "V_concept", "name": "PyLucene", "properties": {"description": "A Python wrapper for the Lucene search engine library, allowing Python developers to use Lucene's functionality.", "keywords": ["pylucene", "lucene", "engine", "search", "text", "information", "retrieval"], "source_lectures": ["lecture_106106852_w3_l17", "lecture_106106852_w3_l20", "lecture_106106852_w3_l21"]}}
{"id": "concept_index_writer", "type": "V_concept", "name": "Index Writer", "properties": {"description": "A software component that writes the inverted index to a storage device, such as a hard disk or RAM.", "keywords": ["lucene", "documents", "writer", "index", "inverted", "data"], "source_lectures": ["lecture_106106852_w3_l17", "lecture_106106852_w3_l20", "lecture_106106852_w4_l25"]}}
{"id": "concept_document_indexing", "type": "V_concept", "name": "Document Indexing", "properties": {"description": "The process of creating an inverted index for a collection of documents, allowing for efficient search and retrieval.", "keywords": ["document", "indexing", "search", "retrieval"], "source_lectures": ["lecture_106106852_w3_l17"]}}
{"id": "concept_information_retrieval", "type": "V_concept", "name": "Information Retrieval", "properties": {"description": "The process of finding and retrieving relevant information from a large collection of data, such as documents or databases.", "keywords": ["database", "documents", "search", "query", "information", "data", "retrieval"], "source_lectures": ["lecture_106106852_w3_l17", "lecture_106106852_w1_l1", "lecture_106106852_w1_l2", "lecture_106106852_w1_l3"]}}
{"id": "concept_indexing_process", "type": "V_concept", "name": "Indexing Process", "properties": {"description": "The process of organizing and storing data in a way that allows for efficient retrieval and searching.", "keywords": ["indexing", "data", "retrieval", "searching"], "source_lectures": ["lecture_106106852_w3_l20"]}}
{"id": "concept_field_type_class", "type": "V_concept", "name": "Field Type Class", "properties": {"description": "A class in PyLucene that defines the type of field to be indexed, such as text, integer, or string.", "keywords": ["field", "type", "class", "pylucene"], "source_lectures": ["lecture_106106852_w3_l20"]}}
{"id": "concept_term_vector", "type": "V_concept", "name": "Term Vector", "properties": {"description": "A data structure that stores the frequency and position of terms in a document.", "keywords": ["engine", "search", "vector", "document", "term", "indexing", "position", "frequency"], "source_lectures": ["lecture_106106852_w3_l20", "lecture_106106852_w4_l22", "lecture_106106852_w4_l24", "lecture_106106852_w4_l25"]}}
{"id": "concept_document_object", "type": "V_concept", "name": "Document Object", "properties": {"description": "An object that represents a document to be indexed, containing fields and their values.", "keywords": ["document", "object", "fields", "values"], "source_lectures": ["lecture_106106852_w3_l20"]}}
{"id": "concept_lucene_index", "type": "V_concept", "name": "Lucene Index", "properties": {"description": "A directory that stores the inverted index and other data structures created by Lucene.", "keywords": ["directory", "data", "search", "engine", "index", "inverted", "lucene"], "source_lectures": ["lecture_106106852_w3_l20", "lecture_106106852_w4_l22"]}}
{"id": "concept_luke_tool", "type": "V_concept", "name": "Luke Tool", "properties": {"description": "A graphical index viewer and diagnostic tool for Lucene indexes.", "keywords": ["luke", "tool", "lucene", "index", "viewer"], "source_lectures": ["lecture_106106852_w4_l22"]}}
{"id": "concept_jdk_installation", "type": "V_concept", "name": "JDK Installation", "properties": {"description": "The process of installing the Java Development Kit, which provides the Java runtime environment and compiler.", "keywords": ["jdk", "installation", "java", "development", "kit"], "source_lectures": ["lecture_106106852_w4_l22"]}}
{"id": "concept_gradle_build_system", "type": "V_concept", "name": "Gradle Build System", "properties": {"description": "A build system used by Lucene to manage and compile the project.", "keywords": ["gradle", "build", "system", "lucene", "project"], "source_lectures": ["lecture_106106852_w4_l22"]}}
{"id": "concept_stop_words", "type": "V_concept", "name": "Stop Words", "properties": {"description": "Common words that are ignored during the indexing process, such as 'the' and 'is'.", "keywords": ["text analysis", "ignore", "stop words", "common words", "common", "filtering", "meaningless", "tokenization", "indexing", "stop", "words"], "source_lectures": ["lecture_106106852_w4_l22", "lecture_106106852_w4_l24", "lecture_106106852_w2_l10", "lecture_106106852_w2_l11"]}}
{"id": "concept_version_compatibility", "type": "V_concept", "name": "Version Compatibility", "properties": {"description": "The requirement that the version of Luke used to inspect an index must match the version of Lucene used to create the index.", "keywords": ["version", "compatibility", "lucene", "luke", "index"], "source_lectures": ["lecture_106106852_w4_l22"]}}
{"id": "concept_pylucene_api", "type": "V_concept", "name": "PyLucene API", "properties": {"description": "A programming interface used to interact with Lucene indexes and perform search operations.", "keywords": ["pylucene", "api", "programming", "interface", "lucene"], "source_lectures": ["lecture_106106852_w4_l22"]}}
{"id": "concept_indexing_settings", "type": "V_concept", "name": "Indexing Settings", "properties": {"description": "Configurations used to control the indexing process in information retrieval systems.", "keywords": ["indexing", "settings", "configuration", "information", "retrieval"], "source_lectures": ["lecture_106106852_w4_l23"]}}
{"id": "concept_lucene_virtual_machine", "type": "V_concept", "name": "Lucene Virtual Machine", "properties": {"description": "A Java-based search engine library used for indexing and searching data.", "keywords": ["lucene", "virtual", "machine", "search", "engine"], "source_lectures": ["lecture_106106852_w4_l23"]}}
{"id": "concept_stored_fields", "type": "V_concept", "name": "Stored Fields", "properties": {"description": "Fields in a document that are stored in the index and can be retrieved.", "keywords": ["stored", "fields", "document", "index", "retrieval"], "source_lectures": ["lecture_106106852_w4_l23"]}}
{"id": "concept_unstored_fields", "type": "V_concept", "name": "Unstored Fields", "properties": {"description": "Fields in a document that are not stored in the index and cannot be retrieved.", "keywords": ["unstored", "fields", "document", "index", "retrieval"], "source_lectures": ["lecture_106106852_w4_l23"]}}
{"id": "concept_index_document_function", "type": "V_concept", "name": "Index Document Function", "properties": {"description": "A function used to add documents to an index.", "keywords": ["index", "document", "function", "add", "documents"], "source_lectures": ["lecture_106106852_w4_l23"]}}
{"id": "concept_directory_reader", "type": "V_concept", "name": "Directory Reader", "properties": {"description": "A class used to read the contents of a directory.", "keywords": ["directory", "reader", "class", "read", "contents"], "source_lectures": ["lecture_106106852_w4_l23"]}}
{"id": "concept_num_docs", "type": "V_concept", "name": "Num Docs", "properties": {"description": "A function that returns the number of documents in an index.", "keywords": ["num", "docs", "function", "documents", "index"], "source_lectures": ["lecture_106106852_w4_l23"]}}
{"id": "concept_max_docs", "type": "V_concept", "name": "Max Docs", "properties": {"description": "A function that returns the total number of documents in an index, including deleted ones.", "keywords": ["max", "docs", "function", "documents", "index"], "source_lectures": ["lecture_106106852_w4_l23"]}}
{"id": "concept_part_field_analyzer", "type": "V_concept", "name": "Part Field Analyzer", "properties": {"description": "A type of analyzer that allows for the application of different analyzers to different fields in a document", "keywords": ["part", "field", "analyzer", "lucene", "indexing"], "source_lectures": ["lecture_106106852_w4_l24"]}}
{"id": "concept_english_analyzer", "type": "V_concept", "name": "English Analyzer", "properties": {"description": "A type of analyzer that is specifically designed to handle the English language", "keywords": ["lucene", "stopwords", "analyzer", "stop words", "stemming", "porter stemmer", "tokenization", "language", "english", "english analyzer"], "source_lectures": ["lecture_106106852_w4_l24", "lecture_106106852_w3_l18"]}}
{"id": "concept_german_analyzer", "type": "V_concept", "name": "German Analyzer", "properties": {"description": "A type of analyzer that is specifically designed to handle the German language", "keywords": ["lucene", "language specific", "stopwords", "german analyzer", "german", "analyzer", "stemming", "tokenization", "language"], "source_lectures": ["lecture_106106852_w4_l24", "lecture_106106852_w3_l18"]}}
{"id": "concept_index_writer_config", "type": "V_concept", "name": "Index Writer Config", "properties": {"description": "A configuration object that defines the settings for creating an index", "keywords": ["index", "writer", "config", "lucene", "indexing"], "source_lectures": ["lecture_106106852_w4_l24"]}}
{"id": "concept_part_field_analyzer_wrapper", "type": "V_concept", "name": "Part Field Analyzer Wrapper", "properties": {"description": "A class that wraps multiple analyzers and applies them to different fields in a document", "keywords": ["part", "field", "analyzer", "wrapper", "lucene"], "source_lectures": ["lecture_106106852_w4_l24"]}}
{"id": "concept_language_specific_analyzers", "type": "V_concept", "name": "Language-Specific Analyzers", "properties": {"description": "Analyzers that are specifically designed to handle the nuances of a particular language", "keywords": ["language", "specific", "analyzers", "tokenization", "filtering"], "source_lectures": ["lecture_106106852_w4_l24"]}}
{"id": "concept_term_frequency", "type": "V_concept", "name": "Term Frequency", "properties": {"description": "The number of times a term appears in a document.", "keywords": ["document term count", "word", "termfrequency", "importance", "text analysis", "search", "relevance signal", "inverted index", "term frequency", "tf", "document", "term", "information", "frequency", "retrieval"], "source_lectures": ["lecture_106106852_w4_l26", "lecture_106106852_w1_l4", "lecture_106106852_w1_l7", "lecture_106106852_w2_l9", "lecture_106106852_w2_l10", "lecture_106106852_w2_l11"]}}
{"id": "concept_document_frequency", "type": "V_concept", "name": "Document Frequency", "properties": {"description": "The number of documents in which a term appears.", "keywords": ["document frequency", "appearance", "corpus", "retrieval", "search", "df", "inverted index", "collection statistics", "document", "term", "information", "frequency", "term occurrence"], "source_lectures": ["lecture_106106852_w4_l26", "lecture_106106852_w1_l6", "lecture_106106852_w1_l7", "lecture_106106852_w2_l9", "lecture_106106852_w2_l10"]}}
{"id": "concept_proximity_operator", "type": "V_concept", "name": "Proximity Operator", "properties": {"description": "A query operator that requires terms to appear near each other in a document.", "keywords": ["proximity", "operator", "query", "search", "retrieval"], "source_lectures": ["lecture_106106852_w4_l26"]}}
{"id": "concept_ordered_window_proximity_operator", "type": "V_concept", "name": "Ordered Window Proximity Operator", "properties": {"description": "A type of proximity operator that requires terms to appear in a specific order within a window.", "keywords": ["ordered", "window", "proximity", "operator", "query"], "source_lectures": ["lecture_106106852_w4_l26"]}}
{"id": "concept_phrase_operator", "type": "V_concept", "name": "Phrase Operator", "properties": {"description": "A type of proximity operator that requires terms to appear immediately next to each other.", "keywords": ["phrase", "operator", "query", "search", "retrieval"], "source_lectures": ["lecture_106106852_w4_l26"]}}
{"id": "concept_unordered_window_proximity_operator", "type": "V_concept", "name": "Unordered Window Proximity Operator", "properties": {"description": "A type of proximity operator that requires terms to appear within a window, regardless of order.", "keywords": ["unordered", "window", "proximity", "operator", "query"], "source_lectures": ["lecture_106106852_w4_l26"]}}
{"id": "concept_field_restriction", "type": "V_concept", "name": "Field Restriction", "properties": {"description": "A technique that allows searching to be restricted to a specific field or section of a document.", "keywords": ["field", "restriction", "search", "retrieval", "document"], "source_lectures": ["lecture_106106852_w4_l26"]}}
{"id": "concept_wild_card_operator", "type": "V_concept", "name": "Wild Card Operator", "properties": {"description": "A query operator that allows for flexible matching of term patterns using wild cards.", "keywords": ["wild", "card", "operator", "query", "search"], "source_lectures": ["lecture_106106852_w4_l26"]}}
{"id": "concept_boosting", "type": "V_concept", "name": "Boosting", "properties": {"description": "A technique that allows assigning more weight to matches in a particular field or section of a document.", "keywords": ["boosting", "weight", "field", "search", "retrieval"], "source_lectures": ["lecture_106106852_w4_l26"]}}
{"id": "concept_positional_indexing", "type": "V_concept", "name": "Positional Indexing", "properties": {"description": "A technique that stores the positions of terms in a document to support proximity searching.", "keywords": ["positional", "indexing", "search", "retrieval", "document"], "source_lectures": ["lecture_106106852_w4_l26"]}}
{"id": "concept_query_processing", "type": "V_concept", "name": "Query Processing", "properties": {"description": "The process of analyzing and executing a query to retrieve relevant documents.", "keywords": ["search", "documents", "query", "document", "processing", "retrieval"], "source_lectures": ["lecture_106106852_w4_l26", "lecture_106106852_w1_l6"]}}
{"id": "concept_secure_multi_party_computation", "type": "V_concept", "name": "Secure Multi-Party Computation", "properties": {"description": "A protocol that enables multiple parties to jointly perform a computation on their private data without revealing their individual inputs.", "keywords": ["private", "privacy", "security", "multi-party", "protocol", "secure", "secure computation", "multi", "computation", "data", "party", "cryptography"], "source_lectures": ["lecture_106108229_w1_l3", "lecture_106108229_w9_l58", "lecture_106108229_w9_l59", "lecture_106106221_w1_l1", "lecture_106108229_w1_l1", "lecture_106108229_w1_l2", "lecture_106108229_w4_l22", "lecture_106108229_w4_l23", "lecture_106108229_w4_l27", "lecture_106108229_w5_l32", "lecture_106108229_w5_l33", "lecture_106108229_w5_l35", "lecture_106108229_w7_l47", "lecture_106106221_w9_l59"]}}
{"id": "concept_boolean_circuit_representation", "type": "V_concept", "name": "Boolean Circuit Representation", "properties": {"description": "A way to represent a function as a circuit consisting of Boolean gates, such as AND, OR, and NOT gates.", "keywords": ["boolean", "circuit", "representation", "gates"], "source_lectures": ["lecture_106108229_w1_l3"]}}
{"id": "concept_arithmetic_circuit_representation", "type": "V_concept", "name": "Arithmetic Circuit Representation", "properties": {"description": "A way to represent a function as a circuit over an algebraic structure, such as a ring or field, using addition and multiplication gates.", "keywords": ["arithmetic", "circuit", "representation", "algebraic"], "source_lectures": ["lecture_106108229_w1_l3"]}}
{"id": "concept_synchronous_communication_model", "type": "V_concept", "name": "Synchronous Communication Model", "properties": {"description": "A communication model where parties are synchronized by a global clock and operate in rounds with a fixed delay.", "keywords": ["synchronous", "communication", "model", "clock"], "source_lectures": ["lecture_106108229_w1_l3"]}}
{"id": "concept_asynchronous_communication_model", "type": "V_concept", "name": "Asynchronous Communication Model", "properties": {"description": "A communication model where parties are not synchronized by a global clock and message delays are unknown.", "keywords": ["asynchronous", "communication", "model", "delay"], "source_lectures": ["lecture_106108229_w1_l3"]}}
{"id": "concept_threshold_adversary_model", "type": "V_concept", "name": "Threshold Adversary Model", "properties": {"description": "An adversary model where the adversary can control up to a certain number of parties, but not more.", "keywords": ["threshold", "adversary", "model", "control"], "source_lectures": ["lecture_106108229_w1_l3"]}}
{"id": "concept_non_threshold_adversary_model", "type": "V_concept", "name": "Non-Threshold Adversary Model", "properties": {"description": "An adversary model where the adversary's corruption capacity is specified by a list of potentially corrupt parties, without a bound on the number of parties.", "keywords": ["non-threshold", "adversary", "model", "corruption"], "source_lectures": ["lecture_106108229_w1_l3"]}}
{"id": "concept_passive_corruption", "type": "V_concept", "name": "Passive Corruption", "properties": {"description": "A type of corruption where the adversary can only eavesdrop on the corrupt parties and analyze their messages.", "keywords": ["passive", "corruption", "eavesdropping", "analysis", "security", "model", "adversary"], "source_lectures": ["lecture_106108229_w1_l3", "lecture_106108229_w9_l58"]}}
{"id": "concept_active_corruption", "type": "V_concept", "name": "Active Corruption", "properties": {"description": "A type of corruption where the adversary can control the corrupt parties and make them behave arbitrarily.", "keywords": ["corruption", "arbitrary", "security", "active", "model", "adversary", "control"], "source_lectures": ["lecture_106108229_w1_l3", "lecture_106108229_w9_l58"]}}
{"id": "concept_byzantine_corruption", "type": "V_concept", "name": "Byzantine Corruption", "properties": {"description": "A type of corruption where the adversary can control the corrupt parties and make them behave arbitrarily, also known as malicious corruption.", "keywords": ["byzantine", "corruption", "malicious", "arbitrary"], "source_lectures": ["lecture_106108229_w1_l3"]}}
{"id": "concept_static_adversary", "type": "V_concept", "name": "Static Adversary", "properties": {"description": "An adversary that must decide which parties to corrupt before the protocol starts.", "keywords": ["static", "adversary", "corruption", "protocol"], "source_lectures": ["lecture_106108229_w1_l3"]}}
{"id": "concept_adaptive_adversary", "type": "V_concept", "name": "Adaptive Adversary", "properties": {"description": "An adversary that can corrupt parties during the protocol execution, at any time.", "keywords": ["adaptive", "adversary", "corruption", "protocol"], "source_lectures": ["lecture_106108229_w1_l3"]}}
{"id": "concept_computational_unboundedness", "type": "V_concept", "name": "Computational Unboundedness", "properties": {"description": "A property of an adversary that has unlimited computational resources.", "keywords": ["computational", "unboundedness", "adversary", "resources"], "source_lectures": ["lecture_106108229_w1_l3"]}}
{"id": "concept_polynomially_bounded_adversary", "type": "V_concept", "name": "Polynomially Bounded Adversary", "properties": {"description": "An adversary with limited computational resources, bounded by a polynomial function.", "keywords": ["polynomially", "bounded", "adversary", "resources"], "source_lectures": ["lecture_106108229_w1_l3"]}}
{"id": "concept_group_axioms", "type": "V_concept", "name": "Group Axioms", "properties": {"description": "A set of four properties that define a group in abstract algebra, including closure, associativity, identity, and inverse.", "keywords": ["group", "axioms", "algebra", "abstract"], "source_lectures": ["lecture_106108229_w1_l4"]}}
{"id": "concept_closure_property", "type": "V_concept", "name": "Closure Property", "properties": {"description": "A property of a group that states the result of combining any two elements is also an element in the group.", "keywords": ["algebra", "closure", "property", "operation", "group", "element", "binary", "set"], "source_lectures": ["lecture_106108229_w1_l4", "lecture_106108229_w1_l5", "lecture_106106221_w4_l25"]}}
{"id": "concept_associativity_property", "type": "V_concept", "name": "Associativity Property", "properties": {"description": "A property of a group that states the order in which elements are combined does not affect the result.", "keywords": ["algebra", "property", "associativity", "group", "order"], "source_lectures": ["lecture_106108229_w1_l4", "lecture_106106221_w4_l25"]}}
{"id": "concept_identity_element", "type": "V_concept", "name": "Identity Element", "properties": {"description": "An element in a group that, when combined with any other element, leaves that element unchanged.", "keywords": ["algebra", "combine", "identity", "group", "element"], "source_lectures": ["lecture_106108229_w1_l4", "lecture_106106221_w4_l25"]}}
{"id": "concept_inverse_element", "type": "V_concept", "name": "Inverse Element", "properties": {"description": "An element in a group that, when combined with another element, results in the identity element.", "keywords": ["inverse", "element", "group", "algebra"], "source_lectures": ["lecture_106108229_w1_l4"]}}
{"id": "concept_group_operation", "type": "V_concept", "name": "Group Operation", "properties": {"description": "A binary operation that combines two elements of a group to produce another element in the group.", "keywords": ["algebra", "operation", "group", "element", "binary", "mathematics"], "source_lectures": ["lecture_106108229_w1_l4", "lecture_106108229_w2_l8", "lecture_106106221_w4_l25"]}}
{"id": "concept_addition_modulo_n", "type": "V_concept", "name": "Addition Modulo N", "properties": {"description": "A group operation that adds two integers modulo N, resulting in another integer modulo N.", "keywords": ["addition", "modulo", "group", "operation"], "source_lectures": ["lecture_106108229_w1_l4"]}}
{"id": "concept_multiplication_modulo_n", "type": "V_concept", "name": "Multiplication Modulo N", "properties": {"description": "A group operation that multiplies two integers modulo N, resulting in another integer modulo N.", "keywords": ["multiplication", "modulo", "group", "operation"], "source_lectures": ["lecture_106108229_w1_l4"]}}
{"id": "concept_z_n", "type": "V_concept", "name": "Z_N", "properties": {"description": "A set of integers modulo N, used to define a group under addition or multiplication modulo N.", "keywords": ["z_n", "integers", "modulo", "group"], "source_lectures": ["lecture_106108229_w1_l4"]}}
{"id": "concept_z_n_star", "type": "V_concept", "name": "Z_N Star", "properties": {"description": "A subset of Z_N containing only the elements that are coprime to N, used to define a group under multiplication modulo N.", "keywords": ["z_n star", "coprime", "modulo", "group"], "source_lectures": ["lecture_106108229_w1_l4"]}}
{"id": "concept_coprime", "type": "V_concept", "name": "Coprime", "properties": {"description": "Two integers are coprime if their greatest common divisor is 1.", "keywords": ["coprime", "gcd", "integers", "math"], "source_lectures": ["lecture_106108229_w1_l4"]}}
{"id": "concept_greatest_common_divisor", "type": "V_concept", "name": "Greatest Common Divisor", "properties": {"description": "The largest positive integer that divides two integers without leaving a remainder.", "keywords": ["gcd", "divisor", "integers", "math"], "source_lectures": ["lecture_106108229_w1_l4"]}}
{"id": "concept_ring_axioms", "type": "V_concept", "name": "Ring Axioms", "properties": {"description": "A set of properties that define a ring in abstract algebra, including closure, associativity, and distributivity.", "keywords": ["ring", "axioms", "abstract", "algebra", "properties"], "source_lectures": ["lecture_106108229_w1_l5"]}}
{"id": "concept_abelian_group", "type": "V_concept", "name": "Abelian Group", "properties": {"description": "A group in which the result of applying the group operation to two elements does not depend on their order.", "keywords": ["commutativity", "algebra", "commutative", "structure", "group", "mathematical", "mathematics", "abelian"], "source_lectures": ["lecture_106108229_w1_l5", "lecture_106106221_w4_l25", "lecture_106106221_w4_l26"]}}
{"id": "concept_distributive_law", "type": "V_concept", "name": "Distributive Law", "properties": {"description": "A property of rings that states the dot operation is distributed over the plus operation.", "keywords": ["distributive", "law", "ring", "property", "algebra"], "source_lectures": ["lecture_106108229_w1_l5"]}}
{"id": "concept_field_axioms", "type": "V_concept", "name": "Field Axioms", "properties": {"description": "A set of properties that define a field in abstract algebra, including commutativity, associativity, and distributivity.", "keywords": ["field", "axioms", "abstract", "algebra", "properties"], "source_lectures": ["lecture_106108229_w1_l5"]}}
{"id": "concept_galois_field", "type": "V_concept", "name": "Galois Field", "properties": {"description": "A field with a finite number of elements, often used in computer science and cryptography.", "keywords": ["galois", "field", "finite", "computer", "cryptography"], "source_lectures": ["lecture_106108229_w1_l5"]}}
{"id": "concept_multiplicative_inverse", "type": "V_concept", "name": "Multiplicative Inverse", "properties": {"description": "An element that, when multiplied by another element, results in the multiplicative identity element.", "keywords": ["algebra", "inverse", "structure", "identity", "element", "algebraic", "multiplicative"], "source_lectures": ["lecture_106108229_w1_l5", "lecture_106108229_w2_l11"]}}
{"id": "concept_additive_identity", "type": "V_concept", "name": "Additive Identity", "properties": {"description": "An element that, when added to another element, results in the same element.", "keywords": ["additive", "identity", "element", "algebra", "structure"], "source_lectures": ["lecture_106108229_w1_l5"]}}
{"id": "concept_commutative_property", "type": "V_concept", "name": "Commutative Property", "properties": {"description": "A property of a binary operation that states the order of the elements does not affect the result.", "keywords": ["commutative", "property", "binary", "operation", "algebra"], "source_lectures": ["lecture_106108229_w1_l5"]}}
{"id": "concept_associative_property", "type": "V_concept", "name": "Associative Property", "properties": {"description": "A property of a binary operation that states the order in which elements are combined does not affect the result.", "keywords": ["associative", "property", "binary", "operation", "algebra"], "source_lectures": ["lecture_106108229_w1_l5"]}}
{"id": "concept_abc_conversion", "type": "V_concept", "name": "Abc Conversion", "properties": {"description": "A method to convert between different secret sharing semantics, such as arithmetic to Boolean conversion.", "keywords": ["abc", "conversion", "secret", "sharing", "semantics"], "source_lectures": ["lecture_106108229_w8_l55"]}}
{"id": "concept_gmw_semantics", "type": "V_concept", "name": "Gmw Semantics", "properties": {"description": "A secret sharing semantics that allows computations to be performed on shared values.", "keywords": ["gmw", "semantics", "secret", "sharing", "computation"], "source_lectures": ["lecture_106108229_w8_l55"]}}
{"id": "concept_boolean_adder_circuit", "type": "V_concept", "name": "Boolean Adder Circuit", "properties": {"description": "A digital circuit that performs addition on binary numbers.", "keywords": ["boolean", "adder", "circuit", "binary", "addition"], "source_lectures": ["lecture_106108229_w8_l55"]}}
{"id": "concept_yao_semantics", "type": "V_concept", "name": "Yao Semantics", "properties": {"description": "A secret sharing semantics that uses garbled circuits to evaluate computations.", "keywords": ["yao", "semantics", "secret", "sharing", "garbled"], "source_lectures": ["lecture_106108229_w8_l55"]}}
{"id": "concept_arithmetic_to_boolean_conversion", "type": "V_concept", "name": "Arithmetic To Boolean Conversion", "properties": {"description": "A method to convert arithmetic secret shared values to Boolean secret shared values.", "keywords": ["arithmetic", "boolean", "conversion", "secret", "sharing"], "source_lectures": ["lecture_106108229_w8_l55"]}}
{"id": "concept_gmw_sharing_protocol", "type": "V_concept", "name": "Gmw Sharing Protocol", "properties": {"description": "A protocol to secret share values using the GMW semantics.", "keywords": ["gmw", "sharing", "protocol", "secret", "semantics"], "source_lectures": ["lecture_106108229_w8_l55"]}}
{"id": "concept_transitive_conversion_method", "type": "V_concept", "name": "Transitive Conversion Method", "properties": {"description": "A method to convert between secret sharing semantics using intermediate conversions.", "keywords": ["transitive", "conversion", "method", "secret", "sharing"], "source_lectures": ["lecture_106108229_w8_l55"]}}
{"id": "concept_constant_round_conversion", "type": "V_concept", "name": "Constant Round Conversion", "properties": {"description": "A conversion method that requires a fixed number of rounds of interaction.", "keywords": ["constant", "round", "conversion", "interaction", "secret"], "source_lectures": ["lecture_106108229_w8_l55"]}}
{"id": "concept_non_constant_round_conversion", "type": "V_concept", "name": "Non-Constant Round Conversion", "properties": {"description": "A conversion method that requires a variable number of rounds of interaction.", "keywords": ["non-constant", "round", "conversion", "interaction", "secret"], "source_lectures": ["lecture_106108229_w8_l55"]}}
{"id": "concept_point_and_permute_optimization", "type": "V_concept", "name": "Point And Permute Optimization", "properties": {"description": "An optimization technique used in Yao's garbled circuit protocol.", "keywords": ["yao", "garbled", "optimization", "permute", "point"], "source_lectures": ["lecture_106108229_w8_l55", "lecture_106108229_w8_l51"]}}
{"id": "concept_aby_conversions", "type": "V_concept", "name": "Aby Conversions", "properties": {"description": "A set of conversions between different secret sharing semantics, including arithmetic sharing, Boolean sharing, and Yao sharing.", "keywords": ["sharing", "secret", "multi-party", "semantics", "aby", "conversions", "secure"], "source_lectures": ["lecture_106108229_w8_l56", "lecture_106108229_w9_l57"]}}
{"id": "concept_boolean_sharing", "type": "V_concept", "name": "Boolean Sharing", "properties": {"description": "A secret sharing scheme where a secret is divided into shares such that the secret can be reconstructed by combining the shares.", "keywords": ["boolean", "sharing", "secret", "scheme"], "source_lectures": ["lecture_106108229_w8_l56"]}}
{"id": "concept_arithmetic_sharing", "type": "V_concept", "name": "Arithmetic Sharing", "properties": {"description": "A secret sharing scheme where a secret is divided into shares such that the secret can be reconstructed by adding the shares modulo a certain value.", "keywords": ["arithmetic", "sharing", "secret", "scheme"], "source_lectures": ["lecture_106108229_w8_l56"]}}
{"id": "concept_yao_sharing", "type": "V_concept", "name": "Yao Sharing", "properties": {"description": "A secret sharing scheme based on the Yao protocol, which allows two parties to securely compute a function without revealing their inputs.", "keywords": ["yao", "sharing", "secret", "protocol"], "source_lectures": ["lecture_106108229_w8_l56"]}}
{"id": "concept_gmw_secret_sharing", "type": "V_concept", "name": "Gmw Secret Sharing", "properties": {"description": "A secret sharing protocol that allows two parties to securely share a secret, introduced by Goldreich, Micali, and Wigderson.", "keywords": ["gmw", "secret", "sharing", "protocol"], "source_lectures": ["lecture_106108229_w8_l56"]}}
{"id": "concept_boolean_to_arithmetic_conversion", "type": "V_concept", "name": "Boolean To Arithmetic Conversion", "properties": {"description": "A conversion from Boolean sharing to arithmetic sharing, which allows two parties to convert a shared secret from Boolean to arithmetic shares.", "keywords": ["boolean", "arithmetic", "conversion", "sharing"], "source_lectures": ["lecture_106108229_w8_l56"]}}
{"id": "concept_oblivious_transfer", "type": "V_concept", "name": "Oblivious Transfer", "properties": {"description": "A cryptographic protocol that allows a sender to transfer a message to a receiver in such a way that the receiver learns only one of the messages, without the sender learning which message was transferred.", "keywords": ["oblivious", "cryptographic", "protocol", "secure", "transfer", "cryptography"], "source_lectures": ["lecture_106108229_w8_l56", "lecture_106108229_w6_l36", "lecture_106108229_w6_l38", "lecture_106108229_w6_l41", "lecture_106108229_w7_l49", "lecture_106108229_w8_l54"]}}
{"id": "concept_ot_extension", "type": "V_concept", "name": "Ot Extension", "properties": {"description": "A technique that allows two parties to perform multiple oblivious transfers using a small number of public key operations, followed by symmetric key operations.", "keywords": ["oblivious", "ot", "protocol", "extension", "computation", "secure", "transfer"], "source_lectures": ["lecture_106108229_w8_l56", "lecture_106108229_w7_l45"]}}
{"id": "concept_secure_computation", "type": "V_concept", "name": "Secure Computation", "properties": {"description": "A field of study that deals with the design of protocols and algorithms that allow multiple parties to jointly perform computations on private data without revealing their inputs.", "keywords": ["protection", "cryptographic", "privacy", "private", "security", "sensitive", "computation", "secure", "data", "confidentiality", "cryptography"], "source_lectures": ["lecture_106108229_w8_l56", "lecture_106108229_w9_l61", "lecture_106108229_w9_l62", "lecture_106108229_w1_l6", "lecture_106108229_w3_l15", "lecture_106108229_w3_l18", "lecture_106108229_w4_l24", "lecture_106108229_w4_l26", "lecture_106108229_w5_l35", "lecture_106108229_w6_l41", "lecture_106108229_w7_l45", "lecture_106108229_w7_l48", "lecture_106108229_w8_l53"]}}
{"id": "concept_multiplicative_depth", "type": "V_concept", "name": "Multiplicative Depth", "properties": {"description": "The number of layers of AND gates in a Boolean circuit, which affects the number of rounds required for secure computation.", "keywords": ["multiplicative", "depth", "boolean", "circuit"], "source_lectures": ["lecture_106108229_w8_l56"]}}
{"id": "concept_modular_exponentiation", "type": "V_concept", "name": "Modular Exponentiation", "properties": {"description": "A mathematical operation that calculates the value of a number raised to a power modulo another number.", "keywords": ["rsa", "power", "power mod", "exponentiation", "modular", "modulo", "computation cost", "ddh", "modulus", "efficient algorithm", "computation", "public key", "modular exponentiation"], "source_lectures": ["lecture_106108229_w9_l57", "lecture_106108229_w6_l37", "lecture_106108229_w7_l44", "lecture_106106221_w7_l46", "lecture_106106221_w8_l55"]}}
{"id": "concept_square_and_multiply_trick", "type": "V_concept", "name": "Square And Multiply Trick", "properties": {"description": "An algorithmic technique used to efficiently calculate modular exponentiation by repeatedly squaring and multiplying.", "keywords": ["square", "multiply", "trick", "exponentiation", "modular"], "source_lectures": ["lecture_106108229_w9_l57"]}}
{"id": "concept_arithmetic_secret_sharing", "type": "V_concept", "name": "Arithmetic Secret Sharing", "properties": {"description": "A method of sharing a secret value among multiple parties such that each party holds a share of the value.", "keywords": ["secret", "sharing", "arithmetic", "party", "cryptography"], "source_lectures": ["lecture_106108229_w9_l57", "lecture_106108229_w8_l54"]}}
{"id": "concept_boolean_secret_sharing", "type": "V_concept", "name": "Boolean Secret Sharing", "properties": {"description": "A method of sharing a secret boolean value among multiple parties such that each party holds a share of the value.", "keywords": ["secret", "sharing", "boolean", "party", "cryptography"], "source_lectures": ["lecture_106108229_w9_l57", "lecture_106108229_w8_l54"]}}
{"id": "concept_yao_representation", "type": "V_concept", "name": "Yao Representation", "properties": {"description": "A method of representing a boolean value as a secret shared value among multiple parties.", "keywords": ["yao", "representation", "boolean", "secret"], "source_lectures": ["lecture_106108229_w9_l57"]}}
{"id": "concept_gmw_protocol", "type": "V_concept", "name": "GMW Protocol", "properties": {"description": "A secure multi-party computation protocol that enables multiple parties to jointly perform computations on private data.", "keywords": ["cryptographic", "security", "ot", "multi-party", "protocol", "secure computation", "gmw", "computation", "yao", "multi-party computation", "circuit", "secure", "cryptography", "rounds"], "source_lectures": ["lecture_106108229_w9_l57", "lecture_106108229_w9_l58", "lecture_106108229_w6_l41", "lecture_106108229_w7_l46", "lecture_106108229_w7_l47", "lecture_106108229_w8_l52", "lecture_106108229_w8_l54"]}}
{"id": "concept_mod_circuit", "type": "V_concept", "name": "Mod Circuit", "properties": {"description": "A digital circuit that calculates the modulo of a value with respect to another value.", "keywords": ["mod", "circuit", "modulo", "value"], "source_lectures": ["lecture_106108229_w9_l57"]}}
{"id": "concept_multiplication_circuit", "type": "V_concept", "name": "Multiplication Circuit", "properties": {"description": "A digital circuit that calculates the product of two values.", "keywords": ["multiplication", "circuit", "product", "value"], "source_lectures": ["lecture_106108229_w9_l57"]}}
{"id": "concept_multiplexer_circuit", "type": "V_concept", "name": "Multiplexer Circuit", "properties": {"description": "A digital circuit that selects one of multiple input values based on a control signal.", "keywords": ["multiplexer", "circuit", "select", "control"], "source_lectures": ["lecture_106108229_w9_l57"]}}
{"id": "concept_semi_honest_adversary", "type": "V_concept", "name": "Semi Honest Adversary", "properties": {"description": "A type of adversary that follows the protocol instructions but may try to learn additional information about the other parties' inputs.", "keywords": ["model", "security", "adversary", "honest", "computation", "secure", "semi-honest", "semi"], "source_lectures": ["lecture_106108229_w9_l58", "lecture_106108229_w3_l19"]}}
{"id": "concept_bgw_protocol", "type": "V_concept", "name": "BGW Protocol", "properties": {"description": "A secure multi-party computation protocol based on secret sharing.", "keywords": ["security", "polynomial", "multi-party", "secret", "protocol", "bgw", "secure", "secure computation", "sharing", "computation"], "source_lectures": ["lecture_106108229_w9_l58", "lecture_106108229_w4_l22", "lecture_106108229_w4_l23"]}}
{"id": "concept_yao_protocol", "type": "V_concept", "name": "Yao Protocol", "properties": {"description": "A secure multi-party computation protocol that provides cryptographic security with a constant number of rounds.", "keywords": ["yao", "protocol", "cryptographic", "security", "constant"], "source_lectures": ["lecture_106108229_w9_l58"]}}
{"id": "concept_synchronous_communication", "type": "V_concept", "name": "Synchronous Communication", "properties": {"description": "A communication setting where there is a strict time upper bound on message delays.", "keywords": ["synchronous", "communication", "setting", "time", "bound"], "source_lectures": ["lecture_106108229_w9_l58"]}}
{"id": "concept_asynchronous_communication", "type": "V_concept", "name": "Asynchronous Communication", "properties": {"description": "A communication setting where there is no upper bound on message delays.", "keywords": ["asynchronous", "communication", "setting", "time", "delay"], "source_lectures": ["lecture_106108229_w9_l58"]}}
{"id": "concept_perfect_security", "type": "V_concept", "name": "Perfect Security", "properties": {"description": "A security guarantee that ensures the protocol is secure against all possible attacks.", "keywords": ["attack", "guarantee", "security", "adversary", "protocol", "computation", "perfect"], "source_lectures": ["lecture_106108229_w9_l58", "lecture_106108229_w4_l27"]}}
{"id": "concept_cryptographic_security", "type": "V_concept", "name": "Cryptographic Security", "properties": {"description": "A security guarantee that ensures the protocol is secure against computationally bounded attacks.", "keywords": ["cryptographic", "security", "guarantee", "attack", "computation"], "source_lectures": ["lecture_106108229_w9_l58"]}}
{"id": "concept_secret_sharing", "type": "V_concept", "name": "Secret Sharing", "properties": {"description": "A method of dividing a secret into multiple parts, called shares, such that the secret can be reconstructed only when a certain number of shares are combined.", "keywords": ["distribution", "security", "parties", "secret", "protocol", "access", "sharing", "structure", "reconstruction", "computation", "secure", "cryptography"], "source_lectures": ["lecture_106108229_w9_l59", "lecture_106106221_w1_l1", "lecture_106108229_w1_l7", "lecture_106108229_w4_l24", "lecture_106108229_w4_l27", "lecture_106108229_w5_l35", "lecture_106108229_w8_l51", "lecture_106106221_w8_l56"]}}
{"id": "concept_pre_processing_phase", "type": "V_concept", "name": "Pre-Processing Phase", "properties": {"description": "A phase in secure multi-party computation where parties generate and exchange preliminary data, such as encrypted inputs or random numbers, before the actual computation takes place.", "keywords": ["distributor", "phase", "evaluators", "protocol", "secure", "computation", "pre-processing", "data", "processing", "pre"], "source_lectures": ["lecture_106108229_w9_l59", "lecture_106108229_w5_l31", "lecture_106108229_w5_l32", "lecture_106108229_w5_l33"]}}
{"id": "concept_online_phase", "type": "V_concept", "name": "Online Phase", "properties": {"description": "A phase in secure multi-party computation where the actual computation takes place, using the preliminary data generated during the pre-processing phase.", "keywords": ["online", "phase", "secure", "computation", "protocol"], "source_lectures": ["lecture_106108229_w9_l59"]}}
{"id": "concept_pseudo_random_function", "type": "V_concept", "name": "Pseudo-Random Function", "properties": {"description": "A function that generates a sequence of numbers that appear to be randomly distributed, but are actually deterministic.", "keywords": ["prf", "pseudorandom", "security", "pseudo-random", "protocol", "pseudo", "function", "random", "cryptography"], "source_lectures": ["lecture_106108229_w9_l59", "lecture_106108229_w8_l50", "lecture_106106221_w3_l15", "lecture_106106221_w3_l17", "lecture_106106221_w3_l18", "lecture_106106221_w4_l23", "lecture_106106221_w9_l59"]}}
{"id": "concept_byzantine_adversary", "type": "V_concept", "name": "Byzantine Adversary", "properties": {"description": "A type of adversary in secure multi-party computation that can behave arbitrarily, including sending false or misleading information to other parties.", "keywords": ["byzantine", "adversary", "secure", "computation", "protocol"], "source_lectures": ["lecture_106108229_w9_l59"]}}
{"id": "concept_asynchronous_network", "type": "V_concept", "name": "Asynchronous Network", "properties": {"description": "A network in which the timing of messages between parties is not synchronized, and messages may be delayed or lost.", "keywords": ["asynchronous", "network", "communication", "protocol", "delay"], "source_lectures": ["lecture_106108229_w9_l59"]}}
{"id": "concept_scalability", "type": "V_concept", "name": "Scalability", "properties": {"description": "The ability of a system or protocol to handle increased load or size without a significant decrease in performance.", "keywords": ["size", "efficiency", "scalability", "resources", "protocol", "handling", "system", "load", "demand", "capacity", "increased", "performance"], "source_lectures": ["lecture_106108229_w9_l59", "lecture_106103359_w6_l42", "lecture_106103359_w1_l1", "lecture_106103359_w1_l7", "lecture_106103359_w9_l62", "lecture_106104182_w1_l1"]}}
{"id": "concept_privacy_preserving_machine_learning", "type": "V_concept", "name": "Privacy-Preserving Machine Learning", "properties": {"description": "A technique that enables machine learning models to be trained on private data without revealing the individual data points.", "keywords": ["privacy-preserving", "security", "protocol", "learning", "data", "algorithms", "machine"], "source_lectures": ["lecture_106108229_w9_l59", "lecture_106108229_w8_l52"]}}
{"id": "concept_multi_party_computation", "type": "V_concept", "name": "Multi-Party Computation", "properties": {"description": "A protocol that enables multiple parties to jointly perform computations on private data without revealing their inputs.", "keywords": ["mpc", "privacy", "security", "multi-party", "computation"], "source_lectures": ["lecture_106108229_w9_l61", "lecture_106108229_w3_l16"]}}
{"id": "concept_privacy_preserving_data_mining", "type": "V_concept", "name": "Privacy Preserving Data Mining", "properties": {"description": "A technique used to extract knowledge from data while preserving the privacy of the data owners.", "keywords": ["privacy", "security", "technique", "mining", "data", "preserving"], "source_lectures": ["lecture_106108229_w9_l61", "lecture_106108229_w1_l2"]}}
{"id": "concept_set_intersection", "type": "V_concept", "name": "Set Intersection", "properties": {"description": "A mathematical operation that returns the elements common to two or more sets.", "keywords": ["mathematics", "set theory", "operation", "intersection", "element", "set"], "source_lectures": ["lecture_106108229_w9_l61", "lecture_106104233_w1_l4"]}}
{"id": "concept_polynomial_encoding", "type": "V_concept", "name": "Polynomial Encoding", "properties": {"description": "A method of representing data as polynomials to enable efficient computation and comparison.", "keywords": ["polynomial", "encoding", "data", "computation"], "source_lectures": ["lecture_106108229_w9_l61"]}}
{"id": "concept_distributed_computation", "type": "V_concept", "name": "Distributed Computation", "properties": {"description": "A model of computation where multiple parties collaborate to perform a computation.", "keywords": ["distributed", "computation", "security", "privacy"], "source_lectures": ["lecture_106108229_w9_l61"]}}
{"id": "concept_generic_mpc_techniques", "type": "V_concept", "name": "Generic MPC Techniques", "properties": {"description": "Methods for performing arbitrary computations on private data in a multi-party setting.", "keywords": ["mpc", "generic", "techniques", "computation"], "source_lectures": ["lecture_106108229_w9_l61"]}}
{"id": "concept_customized_mpc_solutions", "type": "V_concept", "name": "Customized MPC Solutions", "properties": {"description": "Tailor-made protocols for specific applications, such as privacy preserving data mining.", "keywords": ["mpc", "customized", "solutions", "privacy"], "source_lectures": ["lecture_106108229_w9_l61"]}}
{"id": "concept_privacy_preserving_database", "type": "V_concept", "name": "Privacy Preserving Database", "properties": {"description": "A database that protects the privacy of its data owners while allowing queries and computations.", "keywords": ["privacy", "database", "security", "computation"], "source_lectures": ["lecture_106108229_w9_l61"]}}
{"id": "concept_encrypted_data_storage", "type": "V_concept", "name": "Encrypted Data Storage", "properties": {"description": "A method of storing data in an encrypted form to protect it from unauthorized access.", "keywords": ["encrypted", "data", "storage", "security"], "source_lectures": ["lecture_106108229_w9_l61"]}}
{"id": "concept_cryptography", "type": "V_concept", "name": "Cryptography", "properties": {"description": "The practice and study of techniques for secure communication in the presence of third-party adversaries.", "keywords": ["protection", "privacy", "security", "decryption", "encryption", "communication", "data", "adversaries", "cryptography"], "source_lectures": ["lecture_106108229_w9_l62", "lecture_106106221_w1_l1", "lecture_106106221_w10_l64", "lecture_106108229_w1_l1", "lecture_106108229_w3_l15", "lecture_106108229_w5_l35", "lecture_106108229_w7_l48", "lecture_106106221_w9_l60"]}}
{"id": "concept_assignment_questions", "type": "V_concept", "name": "Assignment Questions", "properties": {"description": "A set of questions given to students to assess their understanding of a particular subject or topic.", "keywords": ["assignment", "questions", "assessment", "evaluation", "learning"], "source_lectures": ["lecture_106108229_w9_l62"]}}
{"id": "concept_definitional_questions", "type": "V_concept", "name": "Definitional Questions", "properties": {"description": "A type of question that requires students to define or explain a concept or term.", "keywords": ["definitional", "questions", "definition", "explanation", "concept"], "source_lectures": ["lecture_106108229_w9_l62"]}}
{"id": "concept_recall_questions", "type": "V_concept", "name": "Recall Questions", "properties": {"description": "A type of question that requires students to recall previously learned information or facts.", "keywords": ["recall", "questions", "memory", "information", "facts"], "source_lectures": ["lecture_106108229_w9_l62"]}}
{"id": "concept_weightage", "type": "V_concept", "name": "Weightage", "properties": {"description": "The relative importance or value assigned to a particular question or task in an assessment.", "keywords": ["weightage", "importance", "value", "assessment", "evaluation"], "source_lectures": ["lecture_106108229_w9_l62"]}}
{"id": "concept_course_offering", "type": "V_concept", "name": "Course Offering", "properties": {"description": "The presentation or delivery of a course or subject to students.", "keywords": ["course", "offering", "presentation", "delivery", "education"], "source_lectures": ["lecture_106108229_w9_l62"]}}
{"id": "concept_repeat_course", "type": "V_concept", "name": "Repeat Course", "properties": {"description": "A course that is offered again, often with the same content and structure as the original course.", "keywords": ["repeat", "course", "offering", "content", "structure"], "source_lectures": ["lecture_106108229_w9_l62"]}}
{"id": "concept_rerun_course", "type": "V_concept", "name": "Rerun Course", "properties": {"description": "A course that is offered again, often with updated content or changes to the original course.", "keywords": ["rerun", "course", "offering", "update", "change"], "source_lectures": ["lecture_106108229_w9_l62"]}}
{"id": "concept_discussion_forum", "type": "V_concept", "name": "Discussion Forum", "properties": {"description": "An online platform or space where students can discuss and interact with each other and the instructor.", "keywords": ["discussion", "forum", "online", "platform", "interaction"], "source_lectures": ["lecture_106108229_w9_l62"]}}
{"id": "concept_secure_communication", "type": "V_concept", "name": "Secure Communication", "properties": {"description": "A process of converting a public open channel into a virtual secure channel for secure data exchange.", "keywords": ["protection", "privacy", "security", "integrity", "channel", "authenticity", "confidential", "secure", "communication", "data", "confidentiality", "cryptography", "information"], "source_lectures": ["lecture_106106221_w1_l1", "lecture_106108229_w1_l1", "lecture_106108229_w1_l6", "lecture_106108229_w7_l45", "lecture_106108229_w7_l48", "lecture_106106221_w8_l56", "lecture_106106221_w9_l59", "lecture_106106221_w9_l60"]}}
{"id": "concept_symmetric_key_cryptography", "type": "V_concept", "name": "Symmetric Key Cryptography", "properties": {"description": "A type of cryptography where the same key is used for both encryption and decryption.", "keywords": ["symmetric", "key", "cryptography", "encryption"], "source_lectures": ["lecture_106106221_w1_l1"]}}
{"id": "concept_asymmetric_cryptography", "type": "V_concept", "name": "Asymmetric Cryptography", "properties": {"description": "A type of cryptography where different keys are used for encryption and decryption.", "keywords": ["asymmetric", "key", "cryptography", "encryption"], "source_lectures": ["lecture_106106221_w1_l1"]}}
{"id": "concept_encryption", "type": "V_concept", "name": "Encryption", "properties": {"description": "The process of converting plaintext into ciphertext to protect data.", "keywords": ["protection", "security", "encryption", "plaintext", "ciphertext", "data", "cryptography"], "source_lectures": ["lecture_106106221_w1_l1", "lecture_106108229_w7_l45", "lecture_106108229_w7_l48", "lecture_106106221_w9_l60"]}}
{"id": "concept_decryption", "type": "V_concept", "name": "Decryption", "properties": {"description": "The process of converting ciphertext back into plaintext.", "keywords": ["security", "decryption", "access", "plaintext", "ciphertext", "recovery", "data", "cryptography"], "source_lectures": ["lecture_106106221_w1_l1", "lecture_106108229_w7_l45", "lecture_106108229_w7_l48"]}}
{"id": "concept_message_authentication_code", "type": "V_concept", "name": "Message Authentication Code", "properties": {"description": "A cryptographic technique used to verify the authenticity of a message.", "keywords": ["code", "security", "integrity", "message", "mac", "verification", "authentication", "cryptography"], "source_lectures": ["lecture_106106221_w1_l1", "lecture_106106221_w4_l23", "lecture_106106221_w4_l24", "lecture_106106221_w4_l26"]}}
{"id": "concept_hash_function", "type": "V_concept", "name": "Hash Function", "properties": {"description": "A one-way mathematical function that takes input data of any size and produces a fixed-size output.", "keywords": ["compression", "input", "keys", "lookup", "hash", "mathematical", "data", "key", "hash function", "retrieval", "function", "efficient", "output", "storage", "one-way", "slot", "mapping", "slots", "index", "digest", "deterministic", "cryptography"], "source_lectures": ["lecture_106106221_w1_l1", "lecture_106106221_w10_l64", "lecture_106104357_w5_l31", "lecture_106105847_w3_l16", "lecture_106105847_w3_l17", "lecture_106105847_w3_l18", "lecture_106105847_w3_l19", "lecture_106106221_w5_l30", "lecture_106106221_w5_l31", "lecture_106104233_w4_l25", "lecture_106104233_w4_l26", "lecture_106104233_w5_l31", "lecture_106104233_w5_l32"]}}
{"id": "concept_digital_signature", "type": "V_concept", "name": "Digital Signature", "properties": {"description": "A cryptographic technique used to verify the authenticity and integrity of a message.", "keywords": ["signature", "integrity", "authentication", "digital", "cryptography"], "source_lectures": ["lecture_106106221_w1_l1", "lecture_106104233_w4_l26"]}}
{"id": "concept_zero_knowledge_proof", "type": "V_concept", "name": "Zero Knowledge Proof", "properties": {"description": "A cryptographic technique that allows one party to prove a statement without revealing any underlying information.", "keywords": ["knowledge", "security", "zero", "proof", "zero-knowledge", "cryptography"], "source_lectures": ["lecture_106106221_w1_l1", "lecture_106106221_w9_l57"]}}
{"id": "concept_fully_homomorphic_encryption", "type": "V_concept", "name": "Fully Homomorphic Encryption", "properties": {"description": "A type of encryption that allows computations to be performed on ciphertext without decrypting it first.", "keywords": ["fully", "homomorphic", "encryption", "ciphertext"], "source_lectures": ["lecture_106106221_w1_l1"]}}
{"id": "concept_distributed_consensus", "type": "V_concept", "name": "Distributed Consensus", "properties": {"description": "A process of achieving agreement among multiple parties in a distributed system.", "keywords": ["distributed", "consensus", "agreement", "system"], "source_lectures": ["lecture_106106221_w1_l1"]}}
{"id": "concept_symmetric_key_encryption", "type": "V_concept", "name": "Symmetric Key Encryption", "properties": {"description": "A type of encryption where the same key is used for both encryption and decryption.", "keywords": ["cryptography", "key", "symmetric", "encryption"], "source_lectures": ["lecture_106106221_w1_l2", "lecture_106106221_w10_l65", "lecture_106108229_w8_l50", "lecture_106106221_w7_l48"]}}
{"id": "concept_key_agreement_problem", "type": "V_concept", "name": "Key Agreement Problem", "properties": {"description": "A problem in cryptography where two parties need to agree on a shared secret key without actually exchanging the key.", "keywords": ["agreement", "security", "problem", "key", "cryptography"], "source_lectures": ["lecture_106106221_w1_l2", "lecture_106106221_w9_l59"]}}
{"id": "concept_secure_communication_problem", "type": "V_concept", "name": "Secure Communication Problem", "properties": {"description": "A problem in cryptography where two parties need to communicate securely over an insecure channel.", "keywords": ["secure", "communication", "problem", "cryptography"], "source_lectures": ["lecture_106106221_w1_l2"]}}
{"id": "concept_kerckhoffs_principle", "type": "V_concept", "name": "Kerckhoffs' Principle", "properties": {"description": "A principle in cryptography that states a cryptosystem should be secure even if everything about the system is public knowledge except the key.", "keywords": ["principle", "secret", "key", "cryptography", "security", "kerckhoffs"], "source_lectures": ["lecture_106106221_w1_l2", "lecture_106106221_w1_l4", "lecture_106106221_w2_l8"]}}
{"id": "concept_ciphertext_only_attack", "type": "V_concept", "name": "Ciphertext Only Attack", "properties": {"description": "A type of attack in cryptography where the attacker only has access to the ciphertext.", "keywords": ["attack", "ciphertext-only", "security", "only", "adversary", "plaintext", "ciphertext", "cryptography"], "source_lectures": ["lecture_106106221_w1_l2", "lecture_106106221_w2_l10", "lecture_106106221_w9_l59"]}}
{"id": "concept_known_plaintext_attack", "type": "V_concept", "name": "Known Plaintext Attack", "properties": {"description": "A type of attack in cryptography where the attacker has access to a collection of plaintext and corresponding ciphertext pairs.", "keywords": ["known", "plaintext", "attack", "cryptography"], "source_lectures": ["lecture_106106221_w1_l2"]}}
{"id": "concept_chosen_plaintext_attack", "type": "V_concept", "name": "Chosen Plaintext Attack", "properties": {"description": "A type of attack in cryptography where the attacker can choose the plaintext to be encrypted and obtain the corresponding ciphertext.", "keywords": ["attack", "security", "cpa", "oracle", "chosen", "encryption", "plaintext", "cryptography"], "source_lectures": ["lecture_106106221_w1_l2", "lecture_106106221_w2_l13", "lecture_106106221_w3_l17", "lecture_106106221_w9_l59"]}}
{"id": "concept_chosen_ciphertext_attack", "type": "V_concept", "name": "Chosen Ciphertext Attack", "properties": {"description": "A type of attack in cryptography where the attacker can choose the ciphertext to be decrypted and obtain the corresponding plaintext.", "keywords": ["attack", "cryptography", "security", "oracle", "decryption", "ciphertext", "chosen"], "source_lectures": ["lecture_106106221_w1_l2", "lecture_106106221_w7_l48", "lecture_106106221_w9_l59"]}}
{"id": "concept_encryption_algorithm", "type": "V_concept", "name": "Encryption Algorithm", "properties": {"description": "A algorithm used to transform plaintext into ciphertext.", "keywords": ["public", "security", "instruction", "secret", "encryption", "plaintext", "ciphertext", "algorithm", "data", "key", "cryptography"], "source_lectures": ["lecture_106106221_w1_l2", "lecture_106106221_w1_l4", "lecture_106106221_w1_l5", "lecture_106108229_w1_l6", "lecture_106108229_w4_l26", "lecture_106106221_w5_l34", "lecture_106106221_w7_l43"]}}
{"id": "concept_decryption_algorithm", "type": "V_concept", "name": "Decryption Algorithm", "properties": {"description": "A algorithm used to transform ciphertext into plaintext.", "keywords": ["private", "secret", "decryption", "plaintext", "ciphertext", "algorithm", "key", "cryptography"], "source_lectures": ["lecture_106106221_w1_l2", "lecture_106106221_w1_l4", "lecture_106106221_w1_l5", "lecture_106106221_w5_l34", "lecture_106106221_w7_l43"]}}
{"id": "concept_key_generation_algorithm", "type": "V_concept", "name": "Key Generation Algorithm", "properties": {"description": "A algorithm used to generate a shared secret key.", "keywords": ["random key", "cryptographic", "private", "key", "secret", "generation", "encryption", "key generation", "signatures", "algorithm", "digital", "public", "cryptography"], "source_lectures": ["lecture_106106221_w1_l2", "lecture_106106221_w1_l4", "lecture_106106221_w1_l5", "lecture_106106221_w10_l65", "lecture_106106221_w5_l34", "lecture_106106221_w6_l37", "lecture_106106221_w7_l43", "lecture_106106221_w8_l51"]}}
{"id": "concept_randomized_algorithm", "type": "V_concept", "name": "Randomized Algorithm", "properties": {"description": "A algorithm that uses randomness to produce different outputs for the same input.", "keywords": ["efficiency", "probabilistic", "randomized algorithm", "cryptography", "adversary", "randomized", "outputs", "computational", "decisions", "high probability", "algorithm", "random", "probability", "performance", "decision", "randomness"], "source_lectures": ["lecture_106106221_w1_l2", "lecture_106105847_w3_l18", "lecture_106108229_w1_l7", "lecture_106108229_w2_l11", "lecture_106104233_w3_l17", "lecture_106104233_w4_l27", "lecture_106104233_w5_l30", "lecture_106104233_w5_l31"]}}
{"id": "concept_deterministic_algorithm", "type": "V_concept", "name": "Deterministic Algorithm", "properties": {"description": "A algorithm that always produces the same output for the same input.", "keywords": ["deterministic", "algorithm", "cryptography"], "source_lectures": ["lecture_106106221_w1_l2"]}}
{"id": "concept_shift_cipher", "type": "V_concept", "name": "Shift Cipher", "properties": {"description": "A symmetric encryption process where each plaintext character is shifted by a fixed number of positions.", "keywords": ["shift", "cipher", "encryption", "symmetric"], "source_lectures": ["lecture_106106221_w1_l3"]}}
{"id": "concept_mono_alphabetic_substitution_cipher", "type": "V_concept", "name": "Mono Alphabetic Substitution Cipher", "properties": {"description": "A cipher where each plaintext character is replaced by a different ciphertext character using a one-to-one mapping.", "keywords": ["mono", "alphabetic", "substitution", "cipher"], "source_lectures": ["lecture_106106221_w1_l3"]}}
{"id": "concept_poly_alphabetic_substitution_cipher", "type": "V_concept", "name": "Poly Alphabetic Substitution Cipher", "properties": {"description": "A cipher where each plaintext character is replaced by a different ciphertext character using multiple instances of shift cipher.", "keywords": ["poly", "alphabetic", "substitution", "cipher"], "source_lectures": ["lecture_106106221_w1_l3"]}}
{"id": "concept_vigenere_cipher", "type": "V_concept", "name": "Vigenere Cipher", "properties": {"description": "A poly alphabetic substitution cipher that uses a keyword to determine the shift for each plaintext character.", "keywords": ["poly", "polyalphabetic", "substitution", "cryptography", "vigenere", "cipher", "alphabetic"], "source_lectures": ["lecture_106106221_w1_l3", "lecture_106106221_w1_l4"]}}
{"id": "concept_brute_force_attack", "type": "V_concept", "name": "Brute Force Attack", "properties": {"description": "A type of attack where an attacker tries all possible keys to decrypt a ciphertext.", "keywords": ["brute", "force", "attack", "ciphertext"], "source_lectures": ["lecture_106106221_w1_l3"]}}
{"id": "concept_frequency_analysis_attack", "type": "V_concept", "name": "Frequency Analysis Attack", "properties": {"description": "A type of attack that exploits the frequency of characters in a plaintext to recover the key.", "keywords": ["frequency", "analysis", "attack", "plaintext"], "source_lectures": ["lecture_106106221_w1_l3"]}}
{"id": "concept_kasiskis_method", "type": "V_concept", "name": "Kasiski's Method", "properties": {"description": "A method used to determine the length of the key in a Vigenere cipher.", "keywords": ["kasiski", "method", "vigenere", "key"], "source_lectures": ["lecture_106106221_w1_l3"]}}
{"id": "concept_index_of_coincidence_method", "type": "V_concept", "name": "Index of Coincidence Method", "properties": {"description": "A method used to determine the length of the key in a Vigenere cipher.", "keywords": ["index", "coincidence", "method", "vigenere"], "source_lectures": ["lecture_106106221_w1_l3"]}}
{"id": "concept_sufficient_key_space_principle", "type": "V_concept", "name": "Sufficient Key Space Principle", "properties": {"description": "A principle that states a secure cipher should have a large enough key space to make brute force attacks infeasible.", "keywords": ["sufficient", "key", "space", "principle"], "source_lectures": ["lecture_106106221_w1_l3"]}}
{"id": "concept_formal_security_definitions", "type": "V_concept", "name": "Formal Security Definitions", "properties": {"description": "A principle of modern cryptography that involves mathematically defining what is meant by security.", "keywords": ["formal", "security", "definitions", "cryptography"], "source_lectures": ["lecture_106106221_w1_l3"]}}
{"id": "concept_ciphertext_only_attack_model", "type": "V_concept", "name": "Ciphertext Only Attack Model", "properties": {"description": "A type of attack model where the attacker only has access to the ciphertext.", "keywords": ["ciphertext", "cryptography", "security", "only", "attack", "model"], "source_lectures": ["lecture_106106221_w1_l3", "lecture_106106221_w1_l4", "lecture_106106221_w1_l7"]}}
{"id": "concept_known_plaintext_attack_model", "type": "V_concept", "name": "Known Plaintext Attack Model", "properties": {"description": "A type of attack model where the attacker has access to both the ciphertext and the corresponding plaintext.", "keywords": ["known", "plaintext", "attack", "model"], "source_lectures": ["lecture_106106221_w1_l3"]}}
{"id": "concept_chosen_plaintext_attack_model", "type": "V_concept", "name": "Chosen Plaintext Attack Model", "properties": {"description": "A type of attack model where the attacker has access to the encryption oracle and can choose the plaintext to encrypt.", "keywords": ["chosen", "plaintext", "attack", "model"], "source_lectures": ["lecture_106106221_w1_l3"]}}
{"id": "concept_perfect_secrecy", "type": "V_concept", "name": "Perfect Secrecy", "properties": {"description": "A notion of security where an encryption process is considered secure if it leaks no information about the plaintext, even to an adversary with unbounded computational power.", "keywords": ["security", "adversary", "encryption", "secrecy", "perfect secrecy", "plaintext", "ciphertext", "perfect", "confidentiality", "cryptography"], "source_lectures": ["lecture_106106221_w1_l4", "lecture_106106221_w1_l5", "lecture_106106221_w1_l6", "lecture_106106221_w1_l7", "lecture_106106221_w2_l8", "lecture_106106221_w7_l43"]}}
{"id": "concept_unconditional_security", "type": "V_concept", "name": "Unconditional Security", "properties": {"description": "A type of security that does not rely on any computational assumptions, making it the strongest form of security.", "keywords": ["unconditional", "guarantee", "security", "adversary", "computational", "assumptions", "cryptography"], "source_lectures": ["lecture_106106221_w1_l4", "lecture_106108229_w1_l6", "lecture_106108229_w6_l36"]}}
{"id": "concept_information_theoretic_security", "type": "V_concept", "name": "Information Theoretic Security", "properties": {"description": "A type of security that is based on the principles of information theory, providing a mathematical framework for analyzing the security of cryptographic systems.", "keywords": ["unconditional", "theoretic", "unbounded adversary", "cryptography", "security", "adversary", "secret", "information-theoretic security", "unbounded", "secret sharing", "information", "bgw protocol", "mathematics", "information-theoretic", "perfect security"], "source_lectures": ["lecture_106106221_w1_l4", "lecture_106108229_w2_l10", "lecture_106108229_w7_l44", "lecture_106106221_w4_l25", "lecture_106106221_w4_l26"]}}
{"id": "concept_bayes_theorem", "type": "V_concept", "name": "Bayes' Theorem", "properties": {"description": "A mathematical theorem that describes how to update the probability of a hypothesis based on new evidence.", "keywords": ["evidence", "bayes", "hypothesis", "update", "conditional", "probability", "theorem", "mathematics"], "source_lectures": ["lecture_106106221_w1_l4", "lecture_106104233_w1_l2", "lecture_106104233_w1_l6", "lecture_106104233_w1_l7", "lecture_106104233_w2_l8", "lecture_106108841_w3_l18"]}}
{"id": "concept_perfect_indistinguishability", "type": "V_concept", "name": "Perfect Indistinguishability", "properties": {"description": "A notion of security where an encryption process is considered secure if it is impossible to distinguish between two different plaintexts based on their ciphertexts.", "keywords": ["security", "view", "simulator", "encryption", "perfect secrecy", "probability distribution", "perfect", "cryptography", "indistinguishability"], "source_lectures": ["lecture_106106221_w1_l4", "lecture_106108229_w3_l20"]}}
{"id": "concept_game_based_definition", "type": "V_concept", "name": "Game-Based Definition", "properties": {"description": "A type of definition that uses a game-like scenario to formalize the security requirements of a cryptographic system.", "keywords": ["game-based", "definition", "cryptography", "security", "requirements"], "source_lectures": ["lecture_106106221_w1_l4"]}}
{"id": "concept_distinguishing_advantage", "type": "V_concept", "name": "Distinguishing Advantage", "properties": {"description": "A measure of how well an adversary can distinguish between two different plaintexts based on their ciphertexts.", "keywords": ["distinguishing", "advantage", "cryptography", "security", "adversary"], "source_lectures": ["lecture_106106221_w1_l4"]}}
{"id": "concept_one_time_pad", "type": "V_concept", "name": "One Time Pad", "properties": {"description": "A type of encryption where a random key is used to encrypt and decrypt a message, and the key is as long as the message.", "keywords": ["random key", "time", "vernam cipher", "security", "one-time", "encryption", "secrecy", "otp", "random", "one", "one time pad", "key", "cryptography", "pad"], "source_lectures": ["lecture_106106221_w1_l5", "lecture_106106221_w2_l10", "lecture_106106221_w10_l65", "lecture_106108229_w5_l32", "lecture_106106221_w3_l15", "lecture_106106221_w3_l17"]}}
{"id": "concept_vernam_cipher", "type": "V_concept", "name": "Vernam Cipher", "properties": {"description": "A type of encryption where a random key is used to encrypt and decrypt a message, and the key is as long as the message.", "keywords": ["vernam cipher", "one time pad", "encryption", "random key"], "source_lectures": ["lecture_106106221_w1_l5"]}}
{"id": "concept_xor_operation", "type": "V_concept", "name": "XOR Operation", "properties": {"description": "A binary operation that takes two bits and produces an output of 1 if the bits are different, and 0 if the bits are the same.", "keywords": ["xor", "binary operation", "bits", "encryption"], "source_lectures": ["lecture_106106221_w1_l5"]}}
{"id": "concept_key_space", "type": "V_concept", "name": "Key Space", "properties": {"description": "The set of all possible keys that can be used for encryption and decryption.", "keywords": ["security", "decryption", "space", "encryption", "keys", "key space", "key", "cryptography"], "source_lectures": ["lecture_106106221_w1_l5", "lecture_106106221_w6_l36"]}}
{"id": "concept_message_space", "type": "V_concept", "name": "Message Space", "properties": {"description": "The set of all possible messages that can be encrypted and decrypted.", "keywords": ["input", "decryption", "space", "encryption", "message space", "message", "mac", "domain", "messages"], "source_lectures": ["lecture_106106221_w1_l5", "lecture_106106221_w5_l29"]}}
{"id": "concept_perfect_secrecy_theorem", "type": "V_concept", "name": "Perfect Secrecy Theorem", "properties": {"description": "A theorem that states that any perfectly secure encryption scheme must have a key space that is at least as large as the message space.", "keywords": ["perfect secrecy theorem", "encryption", "security", "key space", "message space"], "source_lectures": ["lecture_106106221_w1_l5"]}}
{"id": "concept_key_size_limitation", "type": "V_concept", "name": "Key Size Limitation", "properties": {"description": "A limitation of perfectly secure encryption schemes where the key size must be at least as large as the message size.", "keywords": ["key size limitation", "encryption", "security", "key size", "message size"], "source_lectures": ["lecture_106106221_w1_l5"]}}
{"id": "concept_fresh_key_requirement", "type": "V_concept", "name": "Fresh Key Requirement", "properties": {"description": "A requirement of perfectly secure encryption schemes where a fresh key must be generated for each instance of encryption.", "keywords": ["fresh key requirement", "encryption", "security", "fresh key"], "source_lectures": ["lecture_106106221_w1_l5"]}}
{"id": "concept_computational_security", "type": "V_concept", "name": "Computational Security", "properties": {"description": "A notion of security where the adversary's computational power is limited, and the security is achieved against efficient adversaries.", "keywords": ["security parameter", "systems", "protection", "rsa", "efficient", "attacker", "security", "adversary", "polynomial adversary", "computational", "encryption", "system", "cryptographic assumption", "polynomial-time", "secure", "cryptography", "computational security"], "source_lectures": ["lecture_106106221_w1_l6", "lecture_106106221_w2_l8", "lecture_106108229_w3_l18", "lecture_106108229_w5_l35", "lecture_106108229_w7_l44", "lecture_106106221_w2_l13"]}}
{"id": "concept_efficient_algorithm", "type": "V_concept", "name": "Efficient Algorithm", "properties": {"description": "An algorithm whose running time is a polynomial function of the security parameter.", "keywords": ["algorithm", "efficient", "polynomial", "security"], "source_lectures": ["lecture_106106221_w1_l6"]}}
{"id": "concept_negligible_probability", "type": "V_concept", "name": "Negligible Probability", "properties": {"description": "A probability that becomes almost zero as the security parameter tends to infinity.", "keywords": ["probability", "negligible", "security", "parameter"], "source_lectures": ["lecture_106106221_w1_l6"]}}
{"id": "concept_brute_force_key_recovery_attack", "type": "V_concept", "name": "Brute-Force Key-Recovery Attack", "properties": {"description": "An attack where the adversary tries all possible keys to recover the correct key.", "keywords": ["attack", "brute-force", "key-recovery", "adversary"], "source_lectures": ["lecture_106106221_w1_l6"]}}
{"id": "concept_guessing_attack", "type": "V_concept", "name": "Guessing Attack", "properties": {"description": "An attack where the adversary guesses a candidate key and checks if it is correct.", "keywords": ["attack", "guessing", "adversary", "key"], "source_lectures": ["lecture_106106221_w1_l6"]}}
{"id": "concept_security_parameter", "type": "V_concept", "name": "Security Parameter", "properties": {"description": "A parameter that determines the security of a cryptographic scheme, often the size of the secret key.", "keywords": ["security parameter", "parameter", "bit length", "size", "cryptographic", "negligible", "security", "q", "cryptographic security", "hash", "n", "cryptographic strength", "lambda", "primitive", "key size", "key"], "source_lectures": ["lecture_106106221_w1_l6", "lecture_106106221_w2_l9", "lecture_106108229_w6_l37", "lecture_106106221_w4_l27", "lecture_106106221_w6_l39"]}}
{"id": "concept_key_reusability", "type": "V_concept", "name": "Key Reusability", "properties": {"description": "The ability to use the same key for encrypting multiple messages.", "keywords": ["key", "reusability", "security", "messages", "encryption"], "source_lectures": ["lecture_106106221_w1_l6", "lecture_106106221_w1_l7", "lecture_106106221_w2_l10"]}}
{"id": "concept_polynomial_function", "type": "V_concept", "name": "Polynomial Function", "properties": {"description": "A function that can be expressed as a sum of terms, each of which is a product of a constant and a power of the variable.", "keywords": ["variables", "polynomial", "sum", "coefficients", "function", "terms", "mathematics"], "source_lectures": ["lecture_106106221_w1_l6", "lecture_106108229_w7_l45"]}}
{"id": "concept_semantic_security", "type": "V_concept", "name": "Semantic Security", "properties": {"description": "A notion of security that ensures a ciphertext does not reveal any additional information about the underlying plaintext to an attacker.", "keywords": ["information", "semantic", "ciphertext", "plaintext", "security", "attack"], "source_lectures": ["lecture_106106221_w1_l7", "lecture_106106221_w2_l10"]}}
{"id": "concept_indistinguishability_based_definition", "type": "V_concept", "name": "Indistinguishability Based Definition", "properties": {"description": "A definition of security that requires an attacker to be unable to distinguish between two ciphertexts with a significant advantage.", "keywords": ["indistinguishability", "ciphertext", "generator", "definition", "security", "pseudorandom", "secure"], "source_lectures": ["lecture_106106221_w1_l7", "lecture_106106221_w2_l8", "lecture_106106221_w2_l9"]}}
{"id": "concept_computational_indistinguishability", "type": "V_concept", "name": "Computational Indistinguishability", "properties": {"description": "A notion of indistinguishability that holds when an attacker's advantage is upper bounded by a negligible function.", "keywords": ["efficient", "negligible", "security", "polynomial", "computational", "distributions", "probability", "cryptography", "algorithm", "indistinguishability"], "source_lectures": ["lecture_106106221_w1_l7", "lecture_106106221_w2_l9", "lecture_106108229_w6_l39", "lecture_106106221_w2_l11", "lecture_106106221_w6_l36"]}}
{"id": "concept_reduction_based_proof", "type": "V_concept", "name": "Reduction Based Proof", "properties": {"description": "A proof technique used to establish the security of a cryptographic scheme by reducing it to another scheme or problem.", "keywords": ["assumption", "security", "based", "proof", "scheme", "reduction-based", "reduction", "cryptography"], "source_lectures": ["lecture_106106221_w1_l7", "lecture_106106221_w2_l10", "lecture_106106221_w5_l31"]}}
{"id": "concept_negligible_function", "type": "V_concept", "name": "Negligible Function", "properties": {"description": "A function that grows slower than any polynomial function, used to model the advantage of an attacker.", "keywords": ["event", "cryptographic", "parameter", "negligible", "security", "distinguisher", "polynomial", "negligible function", "asymptotic", "cryptographic security", "function", "advantage", "mathematics", "probability", "cryptography"], "source_lectures": ["lecture_106106221_w1_l7", "lecture_106106221_w2_l8", "lecture_106106221_w2_l9", "lecture_106106221_w9_l63", "lecture_106108229_w6_l37", "lecture_106106221_w2_l13", "lecture_106106221_w3_l15", "lecture_106106221_w4_l27", "lecture_106106221_w6_l37", "lecture_106106221_w6_l39", "lecture_106106221_w8_l53", "lecture_106106221_w9_l62"]}}
{"id": "concept_coa_indistinguishability_game", "type": "V_concept", "name": "COA Indistinguishability Game", "properties": {"description": "A game played between an attacker and a challenger to determine if an encryption scheme is secure in the ciphertext only attack model.", "keywords": ["coa", "indistinguishability", "game", "security"], "source_lectures": ["lecture_106106221_w1_l7"]}}
{"id": "concept_polynomial_time_algorithm", "type": "V_concept", "name": "Polynomial Time Algorithm", "properties": {"description": "An algorithm that runs in time proportional to a polynomial function of the input size.", "keywords": ["time", "efficiency", "efficient", "security", "polynomial", "complexity", "algorithm", "cryptography"], "source_lectures": ["lecture_106106221_w1_l7", "lecture_106106221_w10_l64", "lecture_106108229_w6_l39", "lecture_106106221_w3_l15", "lecture_106104233_w5_l30"]}}
{"id": "concept_pseudorandom_generator", "type": "V_concept", "name": "Pseudorandom Generator", "properties": {"description": "A deterministic algorithm that takes a short random seed and produces a longer pseudorandom output", "keywords": ["generator", "pseudorandom", "security", "algorithm", "deterministic", "cryptography", "randomness"], "source_lectures": ["lecture_106106221_w2_l8", "lecture_106106221_w2_l9", "lecture_106106221_w5_l31", "lecture_106106221_w9_l62"]}}
{"id": "concept_one_time_pad_scheme", "type": "V_concept", "name": "One-Time Pad Scheme", "properties": {"description": "A symmetric-key encryption technique where a plaintext message is encrypted by bitwise XOR with a random key of the same length", "keywords": ["one-time", "pad", "encryption", "symmetric-key", "xor"], "source_lectures": ["lecture_106106221_w2_l8"]}}
{"id": "concept_next_bit_prediction_experiment", "type": "V_concept", "name": "Next-Bit Prediction Experiment", "properties": {"description": "An experiment where an adversary tries to predict the next bit of a pseudorandom generator's output given the previous bits", "keywords": ["next-bit", "prediction", "experiment", "pseudorandom", "generator"], "source_lectures": ["lecture_106106221_w2_l8"]}}
{"id": "concept_probabilistic_polynomial_time", "type": "V_concept", "name": "Probabilistic Polynomial Time", "properties": {"description": "A concept referring to an algorithm that runs in polynomial time and uses randomness", "keywords": ["error", "probabilistic", "complexity", "randomness", "algorithm", "polynomial", "time"], "source_lectures": ["lecture_106106221_w2_l8", "lecture_106104357_w6_l36"]}}
{"id": "concept_distinguisher", "type": "V_concept", "name": "Distinguisher", "properties": {"description": "An algorithm that tries to distinguish between two different distributions, such as the output of a pseudorandom generator and a truly random string", "keywords": ["distinguisher", "distributions", "input", "security", "pseudorandom", "algorithm", "random", "distribution"], "source_lectures": ["lecture_106106221_w2_l8", "lecture_106106221_w2_l10"]}}
{"id": "concept_parallel_composition", "type": "V_concept", "name": "Parallel Composition", "properties": {"description": "A method of composing multiple independent executions of a pseudorandom generator to increase the input size and output size of the generator.", "keywords": ["parallel", "composition", "pseudorandom", "generator"], "source_lectures": ["lecture_106106221_w2_l9"]}}
{"id": "concept_hybrid_argument", "type": "V_concept", "name": "Hybrid Argument", "properties": {"description": "A proof strategy used to prove the security of a composed pseudorandom generator by introducing intermediate hybrid experiments.", "keywords": ["hybrid", "argument", "security", "technique", "proof", "indistinguishable", "cryptography"], "source_lectures": ["lecture_106106221_w2_l9", "lecture_106106221_w2_l11", "lecture_106106221_w3_l18"]}}
{"id": "concept_polynomial_time_distinguisher", "type": "V_concept", "name": "Polynomial Time Distinguisher", "properties": {"description": "An algorithm that runs in polynomial time and attempts to distinguish apart the output of a pseudorandom generator from a truly random sample.", "keywords": ["time", "distinguisher", "polynomial", "algorithm", "cryptography"], "source_lectures": ["lecture_106106221_w2_l9", "lecture_106106221_w2_l12"]}}
{"id": "concept_serial_composition", "type": "V_concept", "name": "Serial Composition", "properties": {"description": "A method of composing multiple executions of a pseudorandom generator in a sequential manner to increase the input size and output size of the generator.", "keywords": ["serial", "composition", "pseudorandom", "generator"], "source_lectures": ["lecture_106106221_w2_l9"]}}
{"id": "concept_randomness_expansion", "type": "V_concept", "name": "Randomness Expansion", "properties": {"description": "The process of expanding a short random seed into a longer pseudorandom string using a pseudorandom generator.", "keywords": ["randomness", "expansion", "pseudorandom", "generator"], "source_lectures": ["lecture_106106221_w2_l9"]}}
{"id": "concept_stream_cipher", "type": "V_concept", "name": "Stream Cipher", "properties": {"description": "A type of encryption algorithm that uses a pseudo-random generator to produce a keystream, which is then XORed with the plaintext to produce the ciphertext.", "keywords": ["pseudo-random", "keystream", "encryption", "stream", "cipher", "algorithm"], "source_lectures": ["lecture_106106221_w2_l10", "lecture_106106221_w2_l13"]}}
{"id": "concept_pseudo_random_generator", "type": "V_concept", "name": "Pseudo-Random Generator", "properties": {"description": "An algorithm that generates a sequence of bits that appear to be random, but are actually deterministic.", "keywords": ["generator", "security", "pseudo-random", "pseudo", "bits", "random", "algorithm", "cryptography"], "source_lectures": ["lecture_106106221_w2_l10", "lecture_106106221_w2_l11", "lecture_106106221_w2_l12", "lecture_106106221_w2_l13", "lecture_106106221_w3_l18", "lecture_106106221_w9_l59"]}}
{"id": "concept_indistinguishability_game", "type": "V_concept", "name": "Indistinguishability Game", "properties": {"description": "A game-based security definition that measures the ability of an adversary to distinguish between two distributions.", "keywords": ["security", "adversary", "distributions", "game", "cryptography", "indistinguishability"], "source_lectures": ["lecture_106106221_w2_l10", "lecture_106106221_w5_l31"]}}
{"id": "concept_multi_message_security", "type": "V_concept", "name": "Multi-Message Security", "properties": {"description": "A security notion that ensures that an encryption scheme remains secure even when multiple messages are encrypted using the same key.", "keywords": ["security", "encryption", "message", "multi", "messages", "key", "multi-message"], "source_lectures": ["lecture_106106221_w2_l10", "lecture_106106221_w2_l13"]}}
{"id": "concept_birthday_attack", "type": "V_concept", "name": "Birthday Attack", "properties": {"description": "A type of cryptographic attack that exploits the probability of two different inputs producing the same output hash value.", "keywords": ["attack", "hash", "function", "collision", "birthday", "cryptography"], "source_lectures": ["lecture_106106221_w9_l63", "lecture_106106221_w5_l30"]}}
{"id": "concept_confusion_diffusion", "type": "V_concept", "name": "Confusion Diffusion", "properties": {"description": "A concept in cryptography that refers to the properties of a secure cipher, where confusion refers to the complexity of the relationship between the plaintext and the ciphertext, and diffusion refers to the spreading of the plaintext information across the ciphertext.", "keywords": ["confusion", "diffusion", "cryptography", "security"], "source_lectures": ["lecture_106106221_w9_l63"]}}
{"id": "concept_secure_prg", "type": "V_concept", "name": "Secure PRG", "properties": {"description": "A pseudorandom generator that is computationally indistinguishable from a true random number generator.", "keywords": ["secure", "prg", "pseudorandom", "cryptography"], "source_lectures": ["lecture_106106221_w9_l63"]}}
{"id": "concept_cpa_security", "type": "V_concept", "name": "CPA Security", "properties": {"description": "A security notion in cryptography that refers to the indistinguishability of a ciphertext from a random string, even when the adversary has access to an encryption oracle.", "keywords": ["attack", "cryptographic", "publickey", "security", "cpa", "adversary", "authenticity", "chosen", "public-key", "encryption", "chosen plaintext", "plaintext", "ciphertext", "chosen-plaintext", "confidentiality", "cryptography", "indistinguishability"], "source_lectures": ["lecture_106106221_w9_l63", "lecture_106106221_w10_l65", "lecture_106108229_w7_l49", "lecture_106106221_w2_l13", "lecture_106106221_w3_l15", "lecture_106106221_w3_l16", "lecture_106106221_w3_l17", "lecture_106106221_w3_l21", "lecture_106106221_w5_l34", "lecture_106106221_w5_l35", "lecture_106106221_w7_l43", "lecture_106106221_w7_l47", "lecture_106106221_w7_l49", "lecture_106106221_w8_l50"]}}
{"id": "concept_coa_security", "type": "V_concept", "name": "COA Security", "properties": {"description": "A security notion in cryptography that refers to the indistinguishability of a ciphertext from a random string, when the adversary only has access to the ciphertext.", "keywords": ["security", "authenticity", "ciphertext", "coa", "chosen-plaintext", "confidentiality", "cryptography", "indistinguishability"], "source_lectures": ["lecture_106106221_w9_l63", "lecture_106106221_w7_l43", "lecture_106106221_w7_l47"]}}
{"id": "concept_cca_security", "type": "V_concept", "name": "CCA Security", "properties": {"description": "A security notion in cryptography that refers to the indistinguishability of a ciphertext from a random string, even when the adversary has access to both an encryption and a decryption oracle.", "keywords": ["attack", "cryptography", "security", "cca", "oracle", "decryption", "chosen-ciphertext", "encryption", "public-key", "publickey", "indistinguishability"], "source_lectures": ["lecture_106106221_w9_l63", "lecture_106106221_w3_l21", "lecture_106106221_w5_l34", "lecture_106106221_w5_l35", "lecture_106106221_w7_l48", "lecture_106106221_w7_l49", "lecture_106106221_w8_l50"]}}
{"id": "concept_diffie_hellman_key_exchange", "type": "V_concept", "name": "Diffie-Hellman Key Exchange", "properties": {"description": "A key exchange protocol that allows two parties to establish a shared secret key over an insecure channel.", "keywords": ["diffiehellman", "hellman", "cryptographic", "security", "protocol", "exchange", "diffie-hellman", "secure", "diffie", "key", "cryptography", "keyexchange"], "source_lectures": ["lecture_106106221_w9_l63", "lecture_106106221_w6_l36", "lecture_106106221_w6_l40", "lecture_106106221_w6_l41", "lecture_106106221_w7_l43", "lecture_106106221_w7_l47", "lecture_106106221_w7_l49"]}}
{"id": "concept_discrete_logarithm_problem", "type": "V_concept", "name": "Discrete Logarithm Problem", "properties": {"description": "A computational problem in cryptography that involves finding the discrete logarithm of a given element in a finite field.", "keywords": ["generator", "hardness", "logarithm", "dlog", "discrete", "finite", "cyclic group", "problem", "field", "group", "exponent", "discrete log", "cyclic", "cryptography"], "source_lectures": ["lecture_106106221_w9_l63", "lecture_106108229_w6_l39", "lecture_106106221_w6_l39", "lecture_106106221_w6_l40", "lecture_106106221_w6_l41", "lecture_106106221_w8_l53", "lecture_106106221_w8_l54"]}}
{"id": "concept_hardcore_predicate", "type": "V_concept", "name": "Hardcore Predicate", "properties": {"description": "A concept in cryptography that refers to a predicate that is hard to compute from the output of a one-way function.", "keywords": ["one-way", "security", "hardcore", "function", "predicate", "cryptography"], "source_lectures": ["lecture_106106221_w9_l63", "lecture_106108229_w6_l38", "lecture_106106221_w9_l62"]}}
{"id": "concept_public_key_encryption", "type": "V_concept", "name": "Public Key Encryption", "properties": {"description": "A method of encrypting data using a pair of keys, one public and one private, to ensure secure communication.", "keywords": ["cryptography", "public-key", "encryption", "secure", "public", "key", "asymmetric"], "source_lectures": ["lecture_106106221_w10_l64", "lecture_106106221_w7_l48"]}}
{"id": "concept_private_key_encryption", "type": "V_concept", "name": "Private Key Encryption", "properties": {"description": "A method of encrypting data using a single private key, shared between the sender and receiver, to ensure secure communication.", "keywords": ["private", "key", "encryption", "secure"], "source_lectures": ["lecture_106106221_w10_l64"]}}
{"id": "concept_blockchain", "type": "V_concept", "name": "Blockchain", "properties": {"description": "A decentralized, distributed ledger technology that records transactions across a network of computers.", "keywords": ["decentralized", "ledger", "pointer", "hash", "blockchain", "distributed", "cryptography"], "source_lectures": ["lecture_106106221_w10_l64", "lecture_106106221_w5_l30"]}}
{"id": "concept_substitution_permutation_network", "type": "V_concept", "name": "Substitution Permutation Network", "properties": {"description": "A type of symmetric-key block cipher that uses a combination of substitution and permutation to encrypt data.", "keywords": ["substitution", "permutation", "network", "symmetric-key"], "source_lectures": ["lecture_106106221_w10_l64"]}}
{"id": "concept_s_box", "type": "V_concept", "name": "S-Box", "properties": {"description": "A substitution box, a component of a block cipher that replaces input bits with output bits according to a predefined table.", "keywords": ["s-box", "substitution", "box", "block"], "source_lectures": ["lecture_106106221_w10_l64"]}}
{"id": "concept_one_time_secure_mac", "type": "V_concept", "name": "One-Time Secure Mac", "properties": {"description": "A type of message authentication code that is secure against an adversary who is only allowed to query once.", "keywords": ["one-time", "secure", "mac", "message"], "source_lectures": ["lecture_106106221_w10_l64"]}}
{"id": "concept_quantum_cryptography", "type": "V_concept", "name": "Quantum Cryptography", "properties": {"description": "A method of secure communication that uses the principles of quantum mechanics to encode and decode messages.", "keywords": ["quantum", "cryptography", "secure", "communication"], "source_lectures": ["lecture_106106221_w10_l64"]}}
{"id": "concept_exponential_time_algorithm", "type": "V_concept", "name": "Exponential Time Algorithm", "properties": {"description": "An algorithm that runs in a time proportional to an exponential function of the input size.", "keywords": ["exponential", "time", "algorithm", "inefficient"], "source_lectures": ["lecture_106106221_w10_l64"]}}
{"id": "concept_random_oracle_model", "type": "V_concept", "name": "Random Oracle Model", "properties": {"description": "A theoretical model used to analyze the security of cryptographic protocols, assuming a random function is available.", "keywords": ["key derivation", "theoretical", "model", "security", "randomoracle", "oracle", "ideal model", "hash", "function", "random", "cryptographic model", "random oracle", "cryptography", "hash function"], "source_lectures": ["lecture_106106221_w10_l64", "lecture_106106221_w5_l31", "lecture_106106221_w6_l39", "lecture_106106221_w7_l47", "lecture_106106221_w7_l49", "lecture_106106221_w8_l50", "lecture_106106221_w8_l52"]}}
{"id": "concept_ideal_cipher_model", "type": "V_concept", "name": "Ideal Cipher Model", "properties": {"description": "A theoretical model used to analyze the security of block ciphers, assuming an ideal, randomly chosen permutation.", "keywords": ["ideal-cipher", "model", "security", "random-permutation", "ideal", "cipher", "block-cipher"], "source_lectures": ["lecture_106106221_w10_l64", "lecture_106106221_w5_l29"]}}
{"id": "concept_probabilistic_algorithm", "type": "V_concept", "name": "Probabilistic Algorithm", "properties": {"description": "An algorithm that uses randomness to make decisions or produce outputs.", "keywords": ["probabilistic", "algorithm", "randomness", "cryptography"], "source_lectures": ["lecture_106106221_w10_l65"]}}
{"id": "concept_polynomial_time", "type": "V_concept", "name": "Polynomial Time", "properties": {"description": "A computational complexity theory concept where an algorithm's running time grows polynomially with the size of the input.", "keywords": ["time", "efficiency", "polynomial", "input", "resources", "class", "complexity", "algorithm", "computation", "cryptography", "decision"], "source_lectures": ["lecture_106106221_w10_l65", "lecture_106104357_w7_l44", "lecture_106104357_w7_l45", "lecture_106106221_w2_l13", "lecture_106106221_w6_l37", "lecture_106104357_w1_l1", "lecture_106104357_w3_l16"]}}
{"id": "concept_deterministic_computation", "type": "V_concept", "name": "Deterministic Computation", "properties": {"description": "A computation that always produces the same output given the same inputs, without any randomness or uncertainty.", "keywords": ["deterministic", "computation", "cryptography", "algorithm"], "source_lectures": ["lecture_106106221_w10_l65"]}}
{"id": "concept_randomized_computation", "type": "V_concept", "name": "Randomized Computation", "properties": {"description": "A computation that uses randomness to produce outputs, making it unpredictable and secure.", "keywords": ["randomized", "computation", "cryptography", "security"], "source_lectures": ["lecture_106106221_w10_l65"]}}
{"id": "concept_asymptotic_approach", "type": "V_concept", "name": "Asymptotic Approach", "properties": {"description": "A method of analyzing algorithms by studying their behavior as the input size approaches infinity.", "keywords": ["asymptotic", "approach", "algorithm", "analysis"], "source_lectures": ["lecture_106106221_w10_l65"]}}
{"id": "concept_concrete_security", "type": "V_concept", "name": "Concrete Security", "properties": {"description": "A security concept that focuses on the actual, practical security of a system, rather than its theoretical security.", "keywords": ["concrete", "security", "cryptography", "practical"], "source_lectures": ["lecture_106106221_w10_l65"]}}
{"id": "concept_frequency_analysis", "type": "V_concept", "name": "Frequency Analysis", "properties": {"description": "A method of cryptanalysis that involves analyzing the frequency of letters or symbols in a ciphertext to deduce the underlying plaintext.", "keywords": ["frequency", "analysis", "cryptanalysis", "ciphertext"], "source_lectures": ["lecture_106106221_w10_l65"]}}
{"id": "concept_true_randomness", "type": "V_concept", "name": "True Randomness", "properties": {"description": "A source of randomness that is unpredictable and uniformly distributed, used in cryptography to generate secure keys.", "keywords": ["true", "randomness", "cryptography", "security"], "source_lectures": ["lecture_106106221_w10_l65"]}}
{"id": "concept_public_key_cryptography", "type": "V_concept", "name": "Public Key Cryptography", "properties": {"description": "A type of cryptography that uses a pair of keys, one public and one private, to secure data.", "keywords": ["public", "security", "decryption", "public-key", "encryption", "asymmetric", "communication", "key", "cryptography"], "source_lectures": ["lecture_106106221_w10_l65", "lecture_106108229_w1_l6", "lecture_106108229_w7_l45", "lecture_106106221_w8_l54", "lecture_106106221_w9_l59"]}}
{"id": "concept_computational_hard_problem", "type": "V_concept", "name": "Computational Hard Problem", "properties": {"description": "A problem that is computationally infeasible to solve, used as the basis for many cryptographic algorithms.", "keywords": ["computational", "hard", "problem", "cryptography"], "source_lectures": ["lecture_106106221_w10_l65"]}}
{"id": "concept_game_theory", "type": "V_concept", "name": "Game Theory", "properties": {"description": "A branch of mathematics that studies strategic decision making in situations where the outcome depends on the actions of multiple individuals or parties.", "keywords": ["theory", "economics", "strategy", "outcome", "game", "mathematical", "strategic", "decision", "making"], "source_lectures": ["lecture_106101360_w1_l1", "lecture_106101360_w1_l2", "lecture_106101360_w1_l3", "lecture_106101360_w1_l5", "lecture_106101360_w2_l6", "lecture_106101360_w5_l24", "lecture_106101360_w5_l26", "lecture_106101360_w6_l31", "lecture_106101360_w10_l49", "lecture_106101360_w12_l60"]}}
{"id": "concept_prisoners_dilemma", "type": "V_concept", "name": "Prisoner's Dilemma", "properties": {"description": "A classic game theory paradox that illustrates the conflict between individual and group rationality, where two prisoners must decide whether to cooperate or defect.", "keywords": ["prisoner", "theory", "defection", "dilemma", "prisoners", "paradox", "game", "prisoner's", "cooperation"], "source_lectures": ["lecture_106101360_w1_l1", "lecture_106101360_w1_l2", "lecture_106101360_w1_l3", "lecture_106101360_w11_l56"]}}
{"id": "concept_non_cooperative_game", "type": "V_concept", "name": "Non-Cooperative Game", "properties": {"description": "A type of game where players cannot communicate or cooperate with each other, and each player makes decisions independently.", "keywords": ["agreements", "cooperative", "independent", "communication", "non-cooperative", "game", "non", "decision"], "source_lectures": ["lecture_106101360_w1_l1", "lecture_106101360_w1_l2", "lecture_106101360_w1_l3", "lecture_106101360_w11_l56"]}}
{"id": "concept_cooperative_game", "type": "V_concept", "name": "Cooperative Game", "properties": {"description": "A type of game where players can communicate and cooperate with each other, and can form binding agreements.", "keywords": ["cooperative", "game", "communication", "agreement", "binding"], "source_lectures": ["lecture_106101360_w1_l1"]}}
{"id": "concept_payoff_function", "type": "V_concept", "name": "Payoff Function", "properties": {"description": "A mathematical function that assigns a payoff or reward to each player in a game, based on the actions taken by all players.", "keywords": ["reward", "theory", "utility", "function", "mathematical", "game", "payoff"], "source_lectures": ["lecture_106101360_w1_l1", "lecture_106101360_w1_l2", "lecture_106101360_w6_l30"]}}
{"id": "concept_binding_agreement", "type": "V_concept", "name": "Binding Agreement", "properties": {"description": "A formal agreement between players in a cooperative game that is enforceable and cannot be broken.", "keywords": ["enforceable", "cooperative", "agreement", "binding", "enforcement", "contract", "game"], "source_lectures": ["lecture_106101360_w1_l1", "lecture_106101360_w11_l56"]}}
{"id": "concept_pre_play_communication", "type": "V_concept", "name": "Pre-Play Communication", "properties": {"description": "The ability of players to communicate with each other before making decisions in a game.", "keywords": ["agreement", "coordination", "pre-play", "game", "play", "communication", "decision", "pre"], "source_lectures": ["lecture_106101360_w1_l1", "lecture_106101360_w10_l51"]}}
{"id": "concept_mediator", "type": "V_concept", "name": "Mediator", "properties": {"description": "A third-party entity that facilitates communication and agreement between players in a cooperative game.", "keywords": ["mediator", "third", "party", "cooperative", "game"], "source_lectures": ["lecture_106101360_w1_l1"]}}
{"id": "concept_conflict", "type": "V_concept", "name": "Conflict", "properties": {"description": "A situation in a game where the interests of players are in opposition, and cooperation is not possible.", "keywords": ["conflict", "game", "opposition", "cooperation", "interests"], "source_lectures": ["lecture_106101360_w1_l1"]}}
{"id": "concept_nash_equilibrium", "type": "V_concept", "name": "Nash Equilibrium", "properties": {"description": "A concept in game theory that describes a state where no player can improve their payoff by unilaterally changing their strategy, assuming all other players keep their strategies unchanged.", "keywords": ["theory", "strategy profile", "saddle point", "non-cooperative", "deviation", "equilibrium", "strategy", "game theory", "best response", "nash equilibrium", "nash", "game", "game equilibrium", "payoff"], "source_lectures": ["lecture_106101360_w1_l1", "lecture_106101360_w1_l2", "lecture_106101360_w1_l3", "lecture_106101360_w1_l4", "lecture_106101360_w1_l5", "lecture_106101360_w3_l14", "lecture_106101360_w3_l15", "lecture_106101360_w3_l16", "lecture_106101360_w3_l17", "lecture_106101360_w4_l19", "lecture_106101360_w4_l22", "lecture_106101360_w5_l24", "lecture_106101360_w12_l61", "lecture_106101360_w5_l23", "lecture_106101360_w5_l26", "lecture_106101360_w5_l28", "lecture_106101360_w6_l30", "lecture_106101360_w6_l31", "lecture_106101360_w6_l32", "lecture_106101360_w7_l36", "lecture_106101360_w8_l38", "lecture_106101360_w8_l40", "lecture_106101360_w8_l41", "lecture_106101360_w10_l49", "lecture_106101360_w10_l50", "lecture_106101360_w10_l51", "lecture_106101360_w10_l52", "lecture_106101360_w12_l58"]}}
{"id": "concept_strategy_profile", "type": "V_concept", "name": "Strategy Profile", "properties": {"description": "A set of strategies, one for each player in a game, that defines the actions each player will take.", "keywords": ["game", "strategy", "choice", "theory", "profile"], "source_lectures": ["lecture_106101360_w1_l2", "lecture_106101360_w1_l5"]}}
{"id": "concept_static_game", "type": "V_concept", "name": "Static Game", "properties": {"description": "A game in which all players make decisions simultaneously, without any knowledge of the actions of other players.", "keywords": ["theory", "static", "information", "game", "perfect"], "source_lectures": ["lecture_106101360_w1_l2", "lecture_106101360_w8_l40"]}}
{"id": "concept_dynamic_game", "type": "V_concept", "name": "Dynamic Game", "properties": {"description": "A game in which players make decisions sequentially, with some knowledge of the actions of other players.", "keywords": ["theory", "turn-based", "dynamic game", "time-dependent", "player", "action", "strategy", "sequence", "game theory", "game", "dynamic", "decision", "sequential game"], "source_lectures": ["lecture_106101360_w1_l2", "lecture_106101360_w6_l30", "lecture_106101360_w6_l31", "lecture_106101360_w6_l32", "lecture_106101360_w7_l36", "lecture_106101360_w8_l38"]}}
{"id": "concept_optimal_control", "type": "V_concept", "name": "Optimal Control", "properties": {"description": "A field of study that deals with finding the best control strategy for a system over time, often used in dynamic games.", "keywords": ["optimal", "control", "dynamic", "game"], "source_lectures": ["lecture_106101360_w1_l2"]}}
{"id": "concept_coordination_problem", "type": "V_concept", "name": "Coordination Problem", "properties": {"description": "A type of problem in game theory where multiple players must coordinate their actions to achieve a desired outcome.", "keywords": ["information", "game", "coordination", "theory", "problem"], "source_lectures": ["lecture_106101360_w1_l2", "lecture_106101360_w2_l9"]}}
{"id": "concept_dominance", "type": "V_concept", "name": "Dominance", "properties": {"description": "A concept in game theory where a strategy is said to dominate another if it yields a better payoff regardless of the actions of other players.", "keywords": ["game", "payoff", "strategy", "player", "dominance", "action", "theory", "better"], "source_lectures": ["lecture_106101360_w1_l3", "lecture_106101360_w3_l14"]}}
{"id": "concept_rationality", "type": "V_concept", "name": "Rationality", "properties": {"description": "The assumption that players in a game make decisions based on rational reasoning to maximize their payoffs.", "keywords": ["theory", "maximize", "expected", "decision making", "rationality", "game theory", "game", "payoff", "decision"], "source_lectures": ["lecture_106101360_w1_l3", "lecture_106101360_w1_l4", "lecture_106101360_w3_l14", "lecture_106101360_w6_l31"]}}
{"id": "concept_elimination_of_dominated_strategies", "type": "V_concept", "name": "Elimination of Dominated Strategies", "properties": {"description": "A method in game theory to solve games by iteratively eliminating strategies that are dominated by other strategies.", "keywords": ["game", "dominated", "theory", "strategies", "game theory", "elimination"], "source_lectures": ["lecture_106101360_w1_l3", "lecture_106101360_w1_l4"]}}
{"id": "concept_payoff_matrix", "type": "V_concept", "name": "Payoff Matrix", "properties": {"description": "A table that represents the payoffs of different strategies for each player in a game.", "keywords": ["game", "payoff", "matrix", "strategy", "theory", "strategies"], "source_lectures": ["lecture_106101360_w1_l3", "lecture_106101360_w1_l5"]}}
{"id": "concept_strategic_alternatives", "type": "V_concept", "name": "Strategic Alternatives", "properties": {"description": "The possible actions or strategies available to players in a game.", "keywords": ["strategic", "alternatives", "game", "theory", "action"], "source_lectures": ["lecture_106101360_w1_l3"]}}
{"id": "concept_randomization", "type": "V_concept", "name": "Randomization", "properties": {"description": "The act of introducing randomness into a player's strategy to make it more unpredictable.", "keywords": ["chance", "system", "term", "game", "technique", "secure computation", "making", "privacy", "decision-making", "polynomial", "strategy", "random", "decision", "randomness", "theory", "constant", "uncertainty", "game theory", "randomization"], "source_lectures": ["lecture_106101360_w1_l3", "lecture_106101360_w3_l17", "lecture_106108229_w4_l22", "lecture_106108229_w4_l23", "lecture_106108229_w5_l35", "lecture_106101360_w9_l43", "lecture_106101360_w9_l46"]}}
{"id": "concept_strictly_dominated_strategy", "type": "V_concept", "name": "Strictly Dominated Strategy", "properties": {"description": "A strategy that is always worse than another strategy, regardless of what the other players play.", "keywords": ["game", "strictly", "strategy", "dominated", "theory", "game theory"], "source_lectures": ["lecture_106101360_w1_l4", "lecture_106101360_w1_l5"]}}
{"id": "concept_weakly_dominated_strategy", "type": "V_concept", "name": "Weakly Dominated Strategy", "properties": {"description": "A strategy that is worse than another strategy for at least one possible action of the other players, but not necessarily for all possible actions.", "keywords": ["game", "strategy", "dominated", "weakly", "theory", "game theory"], "source_lectures": ["lecture_106101360_w1_l4", "lecture_106101360_w1_l5"]}}
{"id": "concept_common_knowledge", "type": "V_concept", "name": "Common Knowledge", "properties": {"description": "A fact or event that is known to all players, and that all players know that all other players know, and so on.", "keywords": ["event", "theory", "knowledge", "epistemology", "state", "player", "players", "system", "common", "fact", "strategy", "shared", "game theory", "information", "game", "payoff"], "source_lectures": ["lecture_106101360_w1_l4", "lecture_106101360_w2_l6", "lecture_106101360_w2_l7", "lecture_106101360_w2_l8", "lecture_106101360_w2_l9", "lecture_106101360_w2_l11", "lecture_106101360_w2_l12", "lecture_106101360_w2_l13", "lecture_106101360_w3_l14", "lecture_106101360_w2_l10"]}}
{"id": "concept_public_announcement", "type": "V_concept", "name": "Public Announcement", "properties": {"description": "An event or statement that is publicly known and observed by all players, making it common knowledge.", "keywords": ["public", "announcement", "common knowledge", "game theory"], "source_lectures": ["lecture_106101360_w1_l4"]}}
{"id": "concept_mutual_knowledge", "type": "V_concept", "name": "Mutual Knowledge", "properties": {"description": "A fact or event that is known to all players, but not necessarily common knowledge.", "keywords": ["mutual", "knowledge", "game theory", "epistemology"], "source_lectures": ["lecture_106101360_w1_l4"]}}
{"id": "concept_degeneracy", "type": "V_concept", "name": "Degeneracy", "properties": {"description": "A situation in which multiple strategies are identical or equivalent, making it difficult to eliminate dominated strategies.", "keywords": ["degeneracy", "game theory", "strategies"], "source_lectures": ["lecture_106101360_w1_l4"]}}
{"id": "concept_strategic_outcome", "type": "V_concept", "name": "Strategic Outcome", "properties": {"description": "A possible result or consequence of a game, taking into account the strategies and actions of all players.", "keywords": ["strategic", "outcome", "game theory", "result"], "source_lectures": ["lecture_106101360_w1_l4"]}}
{"id": "concept_iterated_elimination", "type": "V_concept", "name": "Iterated Elimination", "properties": {"description": "A process of repeatedly eliminating dominated strategies to find the Nash equilibrium of a game.", "keywords": ["iterated", "elimination", "dominated", "strategies", "game", "theory"], "source_lectures": ["lecture_106101360_w1_l5"]}}
{"id": "concept_dominant_strategy", "type": "V_concept", "name": "Dominant Strategy", "properties": {"description": "A strategy that is the best choice for a player, regardless of what the other players choose.", "keywords": ["game", "best", "strategy", "theory", "dominant"], "source_lectures": ["lecture_106101360_w1_l5", "lecture_106101360_w4_l22"]}}
{"id": "concept_equilibrium_concept", "type": "V_concept", "name": "Equilibrium Concept", "properties": {"description": "A concept in game theory that describes a state where no player can improve their payoff by unilaterally changing their strategy.", "keywords": ["equilibrium", "concept", "game", "theory", "strategy"], "source_lectures": ["lecture_106101360_w1_l5"]}}
{"id": "concept_aumann_model", "type": "V_concept", "name": "Aumann Model", "properties": {"description": "A framework for modeling incomplete information in game theory, which represents the knowledge of players as partitions of the state space.", "keywords": ["information", "game", "aumann", "beliefs", "incomplete", "model"], "source_lectures": ["lecture_106101360_w2_l6", "lecture_106101360_w2_l12"]}}
{"id": "concept_partition", "type": "V_concept", "name": "Partition", "properties": {"description": "A division of a set into disjoint subsets, used to represent the knowledge of a player in the Aumann model.", "keywords": ["partition", "world", "kafka", "subsets", "scalability", "subset", "knowledge", "topic", "player", "state", "states", "disjoint", "division", "information", "set"], "source_lectures": ["lecture_106101360_w2_l6", "lecture_106101360_w2_l8", "lecture_106101360_w2_l9", "lecture_106101360_w2_l11", "lecture_106101360_w2_l13", "lecture_106101360_w2_l10", "lecture_106104182_w3_l21"]}}
{"id": "concept_state_of_the_world", "type": "V_concept", "name": "State Of The World", "properties": {"description": "A particular situation or configuration of the world, which is one of the possible states in the state space.", "keywords": ["state", "world", "situation", "configuration"], "source_lectures": ["lecture_106101360_w2_l6"]}}
{"id": "concept_obtains", "type": "V_concept", "name": "Obtains", "properties": {"description": "A term used to indicate that an event occurs or is true in a particular state of the world.", "keywords": ["obtains", "event", "state", "world"], "source_lectures": ["lecture_106101360_w2_l6"]}}
{"id": "concept_knowledge", "type": "V_concept", "name": "Knowledge", "properties": {"description": "The ability of a player to determine the occurrence of an event or the truth of a statement, based on their partition of the state space.", "keywords": ["knowledge", "player", "event", "partition"], "source_lectures": ["lecture_106101360_w2_l6"]}}
{"id": "concept_incomplete_information", "type": "V_concept", "name": "Incomplete Information", "properties": {"description": "A situation where players do not have complete knowledge of the state of the world or the actions of other players.", "keywords": ["theory", "outcomes", "incomplete", "uncertainty", "players", "information", "game", "type"], "source_lectures": ["lecture_106101360_w2_l6", "lecture_106101360_w2_l13", "lecture_106101360_w10_l48", "lecture_106101360_w12_l60"]}}
{"id": "concept_color_blindness", "type": "V_concept", "name": "Color Blindness", "properties": {"description": "A condition where a person is unable to distinguish between certain colors, used as an example in the lecture to illustrate the Aumann model.", "keywords": ["condition", "color", "example", "aumann", "colors", "blindness"], "source_lectures": ["lecture_106101360_w2_l6", "lecture_106101360_w2_l7"]}}
{"id": "concept_omans_model", "type": "V_concept", "name": "Oman's Model", "properties": {"description": "A model of incomplete information that comprises three elements: the state of nature, a set of players, and a partition of the states of the world for each player.", "keywords": ["omans", "model", "incomplete", "information"], "source_lectures": ["lecture_106101360_w2_l7"]}}
{"id": "concept_state_of_nature", "type": "V_concept", "name": "State Of Nature", "properties": {"description": "The true configuration of the world being modeled.", "keywords": ["state", "nature", "configuration", "world"], "source_lectures": ["lecture_106101360_w2_l7"]}}
{"id": "concept_partition_of_states", "type": "V_concept", "name": "Partition Of States", "properties": {"description": "A way to divide the states of the world into subsets based on a player's knowledge.", "keywords": ["partition", "states", "knowledge", "player"], "source_lectures": ["lecture_106101360_w2_l7"]}}
{"id": "concept_knowledge_operator", "type": "V_concept", "name": "Knowledge Operator", "properties": {"description": "A function that determines the states of the world in which a player knows an event.", "keywords": ["event", "knowledge", "state", "player", "fact", "game", "operator"], "source_lectures": ["lecture_106101360_w2_l7", "lecture_106101360_w2_l8", "lecture_106101360_w2_l11", "lecture_106101360_w2_l10"]}}
{"id": "concept_hierarchy_of_knowledge", "type": "V_concept", "name": "Hierarchy Of Knowledge", "properties": {"description": "A framework for discussing what players know about each other's knowledge.", "keywords": ["hierarchy", "knowledge", "players", "framework"], "source_lectures": ["lecture_106101360_w2_l7"]}}
{"id": "concept_ki_of_a", "type": "V_concept", "name": "Ki Of A", "properties": {"description": "The set of states of the world in which player I knows event a.", "keywords": ["ki", "a", "states", "world", "player"], "source_lectures": ["lecture_106101360_w2_l7"]}}
{"id": "concept_kj_of_ki_of_a", "type": "V_concept", "name": "Kj Of Ki Of A", "properties": {"description": "The set of states of the world in which player J knows that player I knows event a.", "keywords": ["kj", "ki", "a", "states", "world", "players"], "source_lectures": ["lecture_106101360_w2_l7"]}}
{"id": "concept_self_awareness", "type": "V_concept", "name": "Self-Awareness", "properties": {"description": "The property of a player knowing that they know an event, which is a consequence of the knowledge operator.", "keywords": ["event", "knowledge", "player", "self", "awareness", "operator"], "source_lectures": ["lecture_106101360_w2_l8", "lecture_106101360_w2_l10"]}}
{"id": "concept_subset_relation", "type": "V_concept", "name": "Subset Relation", "properties": {"description": "A relation between two events, where one event is a subset of the other, meaning that the occurrence of the first event implies the occurrence of the second event.", "keywords": ["subset", "relation", "event", "occurrence", "implication"], "source_lectures": ["lecture_106101360_w2_l8"]}}
{"id": "concept_complement", "type": "V_concept", "name": "Complement", "properties": {"description": "The set of states of the world where an event does not occur, which is used to define the knowledge operator.", "keywords": ["complement", "event", "state", "knowledge", "operator"], "source_lectures": ["lecture_106101360_w2_l8"]}}
{"id": "concept_belief", "type": "V_concept", "name": "Belief", "properties": {"description": "A probability distribution assigned by a player to an event, which represents their uncertainty about the event.", "keywords": ["belief", "probability", "distribution", "event", "uncertainty"], "source_lectures": ["lecture_106101360_w2_l8"]}}
{"id": "concept_control_theory", "type": "V_concept", "name": "Control Theory", "properties": {"description": "A mathematical framework for modeling and analyzing systems that interact with their environment, which is related to the knowledge operator.", "keywords": ["control", "theory", "system", "environment", "interaction"], "source_lectures": ["lecture_106101360_w2_l8"]}}
{"id": "concept_causal_model", "type": "V_concept", "name": "Causal Model", "properties": {"description": "A mathematical model that represents the causal relationships between events in a system, which is related to the knowledge operator.", "keywords": ["causal", "model", "event", "relationship", "system"], "source_lectures": ["lecture_106101360_w2_l8"]}}
{"id": "concept_finite_memory", "type": "V_concept", "name": "Finite Memory", "properties": {"description": "A property of a system that has limited memory, which can affect its ability to know and reason about events.", "keywords": ["finite", "memory", "system", "knowledge", "reasoning"], "source_lectures": ["lecture_106101360_w2_l8"]}}
{"id": "concept_structural_theorem_of_common_knowledge", "type": "V_concept", "name": "Structural Theorem Of Common Knowledge", "properties": {"description": "A theorem that describes the structure of sets that can be common knowledge in a game or system.", "keywords": ["structural", "theorem", "common", "knowledge", "game"], "source_lectures": ["lecture_106101360_w2_l9"]}}
{"id": "concept_connected_component", "type": "V_concept", "name": "Connected Component", "properties": {"description": "A subset of vertices in a graph that are connected by edges, representing states of the world that are indistinguishable by at least one player.", "keywords": ["graph", "subgraph", "edges", "component", "nodes", "path", "state", "vertices", "connected"], "source_lectures": ["lecture_106101360_w2_l9", "lecture_106101360_w2_l11", "lecture_106101360_w2_l13", "lecture_106101360_w2_l10"]}}
{"id": "concept_knowledge_set", "type": "V_concept", "name": "Knowledge Set", "properties": {"description": "The set of states of the world that a player knows or can distinguish from other states.", "keywords": ["knowledge", "set", "states", "world", "player"], "source_lectures": ["lecture_106101360_w2_l9"]}}
{"id": "concept_graph_theory", "type": "V_concept", "name": "Graph Theory", "properties": {"description": "The study of graphs, which are collections of vertices connected by edges, used to represent relationships between states of the world.", "keywords": ["graph", "theory", "edges", "vertex", "edge", "relationships", "vertices"], "source_lectures": ["lecture_106101360_w2_l9", "lecture_106101360_w2_l10"]}}
{"id": "concept_maximal_connected_component", "type": "V_concept", "name": "Maximal Connected Component", "properties": {"description": "The largest connected component in a graph, representing the largest set of states of the world that are indistinguishable by at least one player.", "keywords": ["maximal", "connected", "component", "graph", "states"], "source_lectures": ["lecture_106101360_w2_l9"]}}
{"id": "concept_common_knowledge_criterion", "type": "V_concept", "name": "Common Knowledge Criterion", "properties": {"description": "The condition that an event or fact must satisfy to be considered common knowledge, including that every player knows it and every player knows that every other player knows it.", "keywords": ["common", "knowledge", "criterion", "condition", "game"], "source_lectures": ["lecture_106101360_w2_l9"]}}
{"id": "concept_distributed_optimization", "type": "V_concept", "name": "Distributed Optimization", "properties": {"description": "A field of study that focuses on optimizing systems or processes that involve multiple players or agents, often requiring common knowledge or shared information.", "keywords": ["distributed", "optimization", "game", "theory", "information"], "source_lectures": ["lecture_106101360_w2_l9"]}}
{"id": "concept_player_partition", "type": "V_concept", "name": "Player Partition", "properties": {"description": "A partition of the set of states of the world from the perspective of a player.", "keywords": ["player", "partition", "states", "world"], "source_lectures": ["lecture_106101360_w2_l11"]}}
{"id": "concept_structural_theorem", "type": "V_concept", "name": "Structural Theorem", "properties": {"description": "A theorem that describes the structure of common knowledge in a game or system.", "keywords": ["graph", "knowledge", "common", "structural", "theorem", "game", "set"], "source_lectures": ["lecture_106101360_w2_l11", "lecture_106101360_w2_l10"]}}
{"id": "concept_agreement", "type": "V_concept", "name": "Agreement", "properties": {"description": "A state in which multiple players have the same knowledge or belief about a fact.", "keywords": ["agreement", "knowledge", "belief", "fact", "players"], "source_lectures": ["lecture_106101360_w2_l11"]}}
{"id": "concept_consensus", "type": "V_concept", "name": "Consensus", "properties": {"description": "A state of agreement among multiple players or agents.", "keywords": ["consensus", "agreement", "players", "agents"], "source_lectures": ["lecture_106101360_w2_l11"]}}
{"id": "concept_common_knowledge_operator", "type": "V_concept", "name": "Common Knowledge Operator", "properties": {"description": "An operator that represents the common knowledge of all players about a fact.", "keywords": ["common", "knowledge", "operator", "players", "fact"], "source_lectures": ["lecture_106101360_w2_l11"]}}
{"id": "concept_c_of_omega", "type": "V_concept", "name": "C Of Omega", "properties": {"description": "The set of states of the world that are common knowledge among all players.", "keywords": ["c", "omega", "common", "knowledge", "states"], "source_lectures": ["lecture_106101360_w2_l11"]}}
{"id": "concept_prior_belief", "type": "V_concept", "name": "Prior Belief", "properties": {"description": "A belief that players have before they get any information, representing the probability distribution with which nature is going to choose a true state of the world.", "keywords": ["prior", "belief", "probability", "distribution"], "source_lectures": ["lecture_106101360_w2_l12"]}}
{"id": "concept_posterior_belief", "type": "V_concept", "name": "Posterior Belief", "properties": {"description": "The updated belief that players have after getting new information, representing the conditional probability of an event given the new information.", "keywords": ["posterior", "belief", "conditional", "probability"], "source_lectures": ["lecture_106101360_w2_l12"]}}
{"id": "concept_bayesian_rationality", "type": "V_concept", "name": "Bayesian Rationality", "properties": {"description": "A type of rationality where players update their beliefs based on new information using Bayes' rule.", "keywords": ["bayesian", "rationality", "bayes", "rule"], "source_lectures": ["lecture_106101360_w2_l12"]}}
{"id": "concept_common_prior", "type": "V_concept", "name": "Common Prior", "properties": {"description": "A common belief that all players have about the probability distribution with which nature is going to choose a true state of the world.", "keywords": ["prior", "players", "common", "belief", "probability", "distribution"], "source_lectures": ["lecture_106101360_w2_l12", "lecture_106101360_w2_l13"]}}
{"id": "concept_agreement_theorem", "type": "V_concept", "name": "Agreement Theorem", "properties": {"description": "A theorem that states that if two players have a common prior and agree on the process of updating their beliefs, they must have the same posterior belief about an event.", "keywords": ["agreement", "theorem", "common", "prior", "posterior"], "source_lectures": ["lecture_106101360_w2_l12"]}}
{"id": "concept_belief_hierarchy", "type": "V_concept", "name": "Belief Hierarchy", "properties": {"description": "A hierarchy of beliefs where players can have beliefs about other players' beliefs, and so on.", "keywords": ["belief", "hierarchy", "players", "beliefs"], "source_lectures": ["lecture_106101360_w2_l12"]}}
{"id": "concept_bayes_rule", "type": "V_concept", "name": "Bayes' Rule", "properties": {"description": "A formula for updating the probability of an event based on new information, using the prior probability and the likelihood of the new information.", "keywords": ["information", "probability", "bayes", "update", "event", "rule"], "source_lectures": ["lecture_106101360_w2_l12", "lecture_106101360_w2_l13"]}}
{"id": "concept_aumanns_agreement_theorem", "type": "V_concept", "name": "Aumann's Agreement Theorem", "properties": {"description": "A theorem stating that if two players have common knowledge of each other's probability assessments for an event and common priors, then their posterior probabilities for the event must be equal.", "keywords": ["aumann", "agreement", "theorem", "probability", "common knowledge"], "source_lectures": ["lecture_106101360_w2_l13"]}}
{"id": "concept_posterior_probability", "type": "V_concept", "name": "Posterior Probability", "properties": {"description": "The probability of an event after considering new information or evidence.", "keywords": ["event", "evidence", "label", "bayes", "input", "class", "posterior", "probability", "information", "theorem"], "source_lectures": ["lecture_106101360_w2_l13", "lecture_106108841_w3_l18", "lecture_106108841_w3_l19", "lecture_106108841_w3_l20"]}}
{"id": "concept_prior_probability", "type": "V_concept", "name": "Prior Probability", "properties": {"description": "The probability of an event before considering new information or evidence.", "keywords": ["event", "evidence", "label", "probability", "information", "data", "prior"], "source_lectures": ["lecture_106101360_w2_l13", "lecture_106108841_w3_l19", "lecture_106108841_w4_l26"]}}
{"id": "concept_disagreement", "type": "V_concept", "name": "Disagreement", "properties": {"description": "A situation where players have different opinions or assessments of an event.", "keywords": ["disagreement", "players", "opinions", "assessments", "event"], "source_lectures": ["lecture_106101360_w2_l13"]}}
{"id": "concept_zero_sum_game", "type": "V_concept", "name": "Zero Sum Game", "properties": {"description": "A game where the total payoff to all players is zero, meaning one player's gain is equal to another player's loss.", "keywords": ["competitive game", "theory", "loss", "gain", "constant-sum", "zero-sum", "sum", "player", "zero", "zero sum", "minimax", "game theory", "game", "zero-sum game", "payoff", "opposing interests"], "source_lectures": ["lecture_106101360_w3_l14", "lecture_106101360_w3_l16", "lecture_106101360_w3_l17", "lecture_106101360_w4_l18", "lecture_106101360_w4_l19", "lecture_106101360_w4_l22", "lecture_106101360_w6_l32", "lecture_106101360_w8_l40"]}}
{"id": "concept_security_strategy", "type": "V_concept", "name": "Security Strategy", "properties": {"description": "A strategy that minimizes the worst-case damage a player can suffer, regardless of the other player's actions.", "keywords": ["minimax", "game", "payoff", "minimize", "damage", "security", "strategy", "player", "theory", "game theory", "worst-case"], "source_lectures": ["lecture_106101360_w3_l14", "lecture_106101360_w3_l15", "lecture_106101360_w3_l16", "lecture_106101360_w4_l18", "lecture_106101360_w4_l22"]}}
{"id": "concept_security_level", "type": "V_concept", "name": "Security Level", "properties": {"description": "The minimum payoff a player can guarantee for themselves, regardless of the other player's actions.", "keywords": ["guarantee", "level", "payoff", "minimax", "minimize", "security level", "security", "maximin", "game theory"], "source_lectures": ["lecture_106101360_w3_l14", "lecture_106101360_w3_l17", "lecture_106101360_w4_l18", "lecture_106101360_w4_l19"]}}
{"id": "concept_minimax_theorem", "type": "V_concept", "name": "Minimax Theorem", "properties": {"description": "A theorem that states the maximum of the minimum payoffs is less than or equal to the minimum of the maximum payoffs in a zero-sum game.", "keywords": ["theory", "minimax theorem", "zero-sum", "minimax", "von neumann", "optimization", "game theory", "saddle point", "zero-sum game", "theorem", "game", "payoff"], "source_lectures": ["lecture_106101360_w3_l14", "lecture_106101360_w3_l15", "lecture_106101360_w3_l17", "lecture_106101360_w4_l22", "lecture_106101360_w4_l21"]}}
{"id": "concept_best_response", "type": "V_concept", "name": "Best Response", "properties": {"description": "The optimal action for a player to take, given the other player's strategy.", "keywords": ["theory", "maximize", "optimality", "action", "response", "optimal", "reaction", "strategy", "best response", "game theory", "game", "best", "beliefs", "payoff"], "source_lectures": ["lecture_106101360_w3_l14", "lecture_106101360_w4_l22", "lecture_106101360_w5_l24", "lecture_106101360_w5_l23", "lecture_106101360_w5_l28", "lecture_106101360_w6_l31", "lecture_106101360_w10_l50", "lecture_106101360_w10_l52"]}}
{"id": "concept_game_matrix", "type": "V_concept", "name": "Game Matrix", "properties": {"description": "A matrix that represents the payoffs of a game, where the rows represent the strategies of one player and the columns represent the strategies of the other player.", "keywords": ["game", "matrix", "payoff", "strategy", "player"], "source_lectures": ["lecture_106101360_w3_l14"]}}
{"id": "concept_v_upper_bar", "type": "V_concept", "name": "V Upper Bar", "properties": {"description": "The maximum expected payoff for the maximizing player in a game, assuming the minimizing player plays optimally.", "keywords": ["game", "payoff", "upper", "maximization", "player", "theory", "bar", "v"], "source_lectures": ["lecture_106101360_w3_l15", "lecture_106101360_w3_l16"]}}
{"id": "concept_v_lower_bar", "type": "V_concept", "name": "V Lower Bar", "properties": {"description": "The minimum expected payoff for the minimizing player in a game, assuming the maximizing player plays optimally.", "keywords": ["game", "payoff", "lower", "player", "theory", "minimization", "bar", "v"], "source_lectures": ["lecture_106101360_w3_l15", "lecture_106101360_w3_l16"]}}
{"id": "concept_matrix_game", "type": "V_concept", "name": "Matrix Game", "properties": {"description": "A game where the payoffs are represented by a matrix, with each entry corresponding to a possible outcome.", "keywords": ["matrix", "game", "theory", "payoff", "representation"], "source_lectures": ["lecture_106101360_w3_l15"]}}
{"id": "concept_best_reply", "type": "V_concept", "name": "Best Reply", "properties": {"description": "A strategy that is the best response to a given strategy of the other player.", "keywords": ["best", "reply", "game", "theory", "response"], "source_lectures": ["lecture_106101360_w3_l15"]}}
{"id": "concept_interchangeability_of_saddle_points", "type": "V_concept", "name": "Interchangeability of Saddle Points", "properties": {"description": "The property that any pair of security strategies can be combined to form a new saddle point, as long as the original saddle points have the same value.", "keywords": ["interchangeability", "saddle", "point", "security", "strategy"], "source_lectures": ["lecture_106101360_w3_l16"]}}
{"id": "concept_sequential_play", "type": "V_concept", "name": "Sequential Play", "properties": {"description": "A game where players take turns making decisions, with each player's decision affecting the subsequent player's actions.", "keywords": ["sequential", "play", "game", "player", "decision"], "source_lectures": ["lecture_106101360_w3_l16"]}}
{"id": "concept_simultaneous_play", "type": "V_concept", "name": "Simultaneous Play", "properties": {"description": "A game where players make decisions at the same time, without knowing the other player's actions.", "keywords": ["simultaneous", "play", "game", "player", "decision"], "source_lectures": ["lecture_106101360_w3_l16"]}}
{"id": "concept_regret", "type": "V_concept", "name": "Regret", "properties": {"description": "The feeling of disappointment or dissatisfaction that a player experiences when they realize they could have made a better decision.", "keywords": ["regret", "player", "decision", "game", "theory"], "source_lectures": ["lecture_106101360_w3_l16"]}}
{"id": "concept_mixed_strategy", "type": "V_concept", "name": "Mixed Strategy", "properties": {"description": "A randomized choice of a pure strategy in game theory, where a player assigns probabilities to each possible action.", "keywords": ["distribution", "theory", "randomized", "strategy", "random", "game theory", "probability", "randomize", "mixed", "game", "randomization", "pure"], "source_lectures": ["lecture_106101360_w3_l17", "lecture_106101360_w4_l18", "lecture_106101360_w4_l22", "lecture_106101360_w5_l23", "lecture_106101360_w5_l28", "lecture_106101360_w6_l31", "lecture_106101360_w9_l43", "lecture_106101360_w9_l44", "lecture_106101360_w9_l45", "lecture_106101360_w9_l46", "lecture_106101360_w10_l49", "lecture_106101360_w10_l50", "lecture_106101360_w12_l58"]}}
{"id": "concept_pure_strategy", "type": "V_concept", "name": "Pure Strategy", "properties": {"description": "A definite choice of action in game theory, where a player chooses one specific action with certainty.", "keywords": ["theory", "definite", "action", "certainty", "strategy", "game theory", "information", "game", "plan", "deterministic", "pure", "set"], "source_lectures": ["lecture_106101360_w3_l17", "lecture_106101360_w4_l18", "lecture_106101360_w5_l23", "lecture_106101360_w9_l43", "lecture_106101360_w9_l44", "lecture_106101360_w9_l45", "lecture_106101360_w9_l46", "lecture_106101360_w10_l49"]}}
{"id": "concept_expected_value", "type": "V_concept", "name": "Expected Value", "properties": {"description": "The average value of a random variable, calculated by multiplying each possible outcome by its probability and summing these products.", "keywords": ["value", "expected", "random variable", "random", "variable", "average"], "source_lectures": ["lecture_106101360_w3_l17", "lecture_106104233_w2_l9", "lecture_106108841_w2_l13", "lecture_106104233_w4_l25"]}}
{"id": "concept_weierstrass_theorem", "type": "V_concept", "name": "Weierstrass Theorem", "properties": {"description": "A theorem stating that a continuous function on a closed and bounded set attains its minimum value.", "keywords": ["weierstrass", "theorem", "continuous", "minimum"], "source_lectures": ["lecture_106101360_w4_l18"]}}
{"id": "concept_infimum", "type": "V_concept", "name": "Infimum", "properties": {"description": "The greatest lower bound of a set of numbers.", "keywords": ["infimum", "lower bound", "numbers"], "source_lectures": ["lecture_106101360_w4_l18"]}}
{"id": "concept_continuous_function", "type": "V_concept", "name": "Continuous Function", "properties": {"description": "A function where small changes in the input result in small changes in the output.", "keywords": ["continuous", "function", "input", "output"], "source_lectures": ["lecture_106101360_w4_l18"]}}
{"id": "concept_closed_set", "type": "V_concept", "name": "Closed Set", "properties": {"description": "A set that contains all its limit points.", "keywords": ["closed set", "limit points", "set"], "source_lectures": ["lecture_106101360_w4_l18"]}}
{"id": "concept_bounded_set", "type": "V_concept", "name": "Bounded Set", "properties": {"description": "A set that is contained within a finite interval.", "keywords": ["bounded set", "interval", "finite"], "source_lectures": ["lecture_106101360_w4_l18"]}}
{"id": "concept_minmax_theorem", "type": "V_concept", "name": "Minmax Theorem", "properties": {"description": "A concept in game theory that states the upper and lower values of a game are equal when players use mixed strategies.", "keywords": ["minmax", "game theory", "mixed strategies", "upper value", "lower value"], "source_lectures": ["lecture_106101360_w4_l19"]}}
{"id": "concept_linear_programming_duality", "type": "V_concept", "name": "Linear Programming Duality", "properties": {"description": "A principle in linear programming that states the optimal values of the primal and dual problems are equal.", "keywords": ["optimal value", "optimization", "programming", "linear programming", "linear", "dual problem", "duality", "problem", "primal problem"], "source_lectures": ["lecture_106101360_w4_l19", "lecture_106101360_w4_l22"]}}
{"id": "concept_mixed_strategies", "type": "V_concept", "name": "Mixed Strategies", "properties": {"description": "A concept in game theory where players randomize over their pure strategies to achieve a better payoff.", "keywords": ["distribution", "mixed strategies", "theory", "randomization", "probability", "pure strategies", "strategies", "game theory", "mixed", "game", "payoff"], "source_lectures": ["lecture_106101360_w4_l19", "lecture_106101360_w12_l61", "lecture_106101360_w5_l26"]}}
{"id": "concept_primal_problem", "type": "V_concept", "name": "Primal Problem", "properties": {"description": "The original linear programming problem, as opposed to its dual problem.", "keywords": ["primal problem", "linear programming", "dual problem", "optimization"], "source_lectures": ["lecture_106101360_w4_l19"]}}
{"id": "concept_dual_problem", "type": "V_concept", "name": "Dual Problem", "properties": {"description": "A linear programming problem that is derived from the primal problem and has the same optimal value.", "keywords": ["dual problem", "linear programming", "primal problem", "optimization"], "source_lectures": ["lecture_106101360_w4_l19"]}}
{"id": "concept_von_neumanns_minmax_theorem", "type": "V_concept", "name": "Von Neumann's Minmax Theorem", "properties": {"description": "A theorem in game theory that states the upper and lower values of a zero-sum game are equal when players use mixed strategies.", "keywords": ["von neumann", "minmax theorem", "game theory", "mixed strategies", "zero-sum game"], "source_lectures": ["lecture_106101360_w4_l19"]}}
{"id": "concept_nonzero_sum_game", "type": "V_concept", "name": "Nonzero-Sum Game", "properties": {"description": "A game where the total payoff to all players is not zero, meaning that one player's gain is not necessarily equal to another player's loss.", "keywords": ["nonzero-sum", "game", "theory", "payoff", "gain"], "source_lectures": ["lecture_106101360_w4_l22"]}}
{"id": "concept_kakutani_fixed_point_theorem", "type": "V_concept", "name": "Kakutani Fixed Point Theorem", "properties": {"description": "A theorem that states a set-valued function on a compact, convex subset of a locally convex topological vector space has a fixed point.", "keywords": ["fixed", "topology", "theorem", "point", "mathematics", "kakutani"], "source_lectures": ["lecture_106101360_w5_l24", "lecture_106101360_w5_l23"]}}
{"id": "concept_convex_set", "type": "V_concept", "name": "Convex Set", "properties": {"description": "A set where the line segment connecting any two points in the set lies entirely within the set.", "keywords": ["convex", "geometry", "line", "mathematical", "linear", "mathematics", "set"], "source_lectures": ["lecture_106101360_w5_l24", "lecture_106101360_w5_l26"]}}
{"id": "concept_linear_program", "type": "V_concept", "name": "Linear Program", "properties": {"description": "A method to achieve the best outcome in a mathematical model whose requirements are represented by linear relationships.", "keywords": ["linear", "program", "optimization", "mathematics", "modeling"], "source_lectures": ["lecture_106101360_w5_l24"]}}
{"id": "concept_compact_set", "type": "V_concept", "name": "Compact Set", "properties": {"description": "A set where every open cover has a finite subcover, often used in topology and real analysis.", "keywords": ["bounded", "topology", "analysis", "real", "mathematical", "closed", "compact", "set"], "source_lectures": ["lecture_106101360_w5_l24", "lecture_106101360_w5_l26"]}}
{"id": "concept_locally_convex_topological_vector_space", "type": "V_concept", "name": "Locally Convex Topological Vector Space", "properties": {"description": "A topological vector space where every point has a local base of convex sets.", "keywords": ["locally", "convex", "topological", "vector", "space"], "source_lectures": ["lecture_106101360_w5_l24"]}}
{"id": "concept_fixed_point", "type": "V_concept", "name": "Fixed Point", "properties": {"description": "A point that is mapped to itself by a function, often used in mathematics and computer science.", "keywords": ["theory", "fixed", "function", "game", "computer", "point", "mathematics"], "source_lectures": ["lecture_106101360_w5_l24", "lecture_106101360_w5_l23"]}}
{"id": "concept_revelation_principle", "type": "V_concept", "name": "Revelation Principle", "properties": {"description": "A concept in game theory that states that all possible outcomes of a game with communication can be achieved by players confidentially communicating with a mediator and the mediator implementing a plan in which it's in players' interest to reveal their true types.", "keywords": ["theory", "communication", "principle", "game", "revelation"], "source_lectures": ["lecture_106101360_w12_l61", "lecture_106101360_w12_l60"]}}
{"id": "concept_correlated_equilibrium", "type": "V_concept", "name": "Correlated Equilibrium", "properties": {"description": "A concept in game theory that describes a state where no player can improve their payoff by unilaterally changing their strategy, assuming all other players keep their strategies unchanged.", "keywords": ["theory", "coordination", "equilibrium", "strategy", "correlated", "game"], "source_lectures": ["lecture_106101360_w12_l61", "lecture_106101360_w12_l58", "lecture_106101360_w12_l60"]}}
{"id": "concept_bayesian_game", "type": "V_concept", "name": "Bayesian Game", "properties": {"description": "A game where players have incomplete information about the other players' types or payoffs.", "keywords": ["incomplete", "bayesian", "strategic", "information", "game", "type"], "source_lectures": ["lecture_106101360_w12_l61", "lecture_106101360_w12_l60"]}}
{"id": "concept_incentive_compatibility", "type": "V_concept", "name": "Incentive Compatibility", "properties": {"description": "A concept in game theory that describes a situation where it is in a player's best interest to reveal their true type or information.", "keywords": ["theory", "mechanism", "incentive", "compatibility", "truth", "strategy", "truthfulness", "game", "revelation"], "source_lectures": ["lecture_106101360_w12_l61", "lecture_106101360_w11_l55", "lecture_106101360_w12_l58", "lecture_106101360_w12_l60"]}}
{"id": "concept_mediation_plan", "type": "V_concept", "name": "Mediation Plan", "properties": {"description": "A plan implemented by a mediator to achieve a desired outcome in a game, often by providing recommendations to players.", "keywords": ["mediation", "theory", "recommendation", "strategy", "game", "plan"], "source_lectures": ["lecture_106101360_w12_l61", "lecture_106101360_w12_l60"]}}
{"id": "concept_communication_system", "type": "V_concept", "name": "Communication System", "properties": {"description": "A system that allows players to exchange information or messages in a game.", "keywords": ["theory", "messages", "system", "game", "information", "communication"], "source_lectures": ["lecture_106101360_w12_l61", "lecture_106101360_w12_l58"]}}
{"id": "concept_linear_inequalities", "type": "V_concept", "name": "Linear Inequalities", "properties": {"description": "A mathematical concept that describes a set of linear constraints or inequalities.", "keywords": ["linear", "inequalities", "mathematics", "constraint", "optimization"], "source_lectures": ["lecture_106101360_w12_l61"]}}
{"id": "concept_game_theoretic_results", "type": "V_concept", "name": "Game Theoretic Results", "properties": {"description": "A general term that refers to theorems, principles, or concepts that are derived from game theory.", "keywords": ["game", "theoretic", "results", "theory", "concept"], "source_lectures": ["lecture_106101360_w12_l61"]}}
{"id": "concept_msp430_microcontroller", "type": "V_concept", "name": "MSP430 Microcontroller", "properties": {"description": "A 16-bit, ultra-low power microcontroller from Texas Instruments, commonly used in embedded systems.", "keywords": ["systems", "ultra-low power", "power", "instruments", "texas", "msp430", "texas instruments", "embedded", "low", "16-bit", "microcontroller", "low power"], "source_lectures": ["lecture_108102169_w2_l11", "lecture_108102169_w2_l12", "lecture_108102169_w2_l13", "lecture_108102169_w2_l14", "lecture_108102169_w4_l23", "lecture_108102169_w4_l27", "lecture_108102169_w5_l35"]}}
{"id": "concept_risc_architecture", "type": "V_concept", "name": "RISC Architecture", "properties": {"description": "A computer architecture that uses a reduced instruction set to improve performance and efficiency.", "keywords": ["architecture", "efficiency", "instruction", "processor", "risc", "microprocessor", "reduced instruction set", "instruction set", "microcontroller", "performance"], "source_lectures": ["lecture_108102169_w2_l11", "lecture_108102169_w2_l12", "lecture_108102169_w2_l13", "lecture_108102169_w1_l5"]}}
{"id": "concept_von_neumann_architecture", "type": "V_concept", "name": "Von Neumann Architecture", "properties": {"description": "A computer architecture that uses a single bus to transfer data between the central processing unit, memory, and input/output devices.", "keywords": ["bus", "architecture", "memory", "processor", "von neumann", "cpu", "computer", "von", "neumann"], "source_lectures": ["lecture_108102169_w2_l11", "lecture_106103220_w2_l9", "lecture_108102169_w1_l3"]}}
{"id": "concept_flash_memory", "type": "V_concept", "name": "Flash Memory", "properties": {"description": "A type of non-volatile memory that can be erased and reprogrammed electrically.", "keywords": ["erasable", "memory", "non-volatile", "reprogrammable", "electrically erasable", "flash memory", "flash"], "source_lectures": ["lecture_108102169_w2_l11", "lecture_108102169_w2_l12", "lecture_108102169_w2_l13", "lecture_108102169_w1_l6"]}}
{"id": "concept_fram_memory", "type": "V_concept", "name": "FRAM Memory", "properties": {"description": "A type of non-volatile memory that combines the benefits of flash and RAM, offering low power consumption and high speed.", "keywords": ["fram", "memory", "non-volatile", "low power"], "source_lectures": ["lecture_108102169_w2_l11"]}}
{"id": "concept_low_power_modes", "type": "V_concept", "name": "Low Power Modes", "properties": {"description": "Operating modes that reduce power consumption in microcontrollers, such as sleep, standby, and shutdown modes.", "keywords": ["standby", "power", "modes", "low power", "low", "idle", "shutdown", "microcontroller", "sleep"], "source_lectures": ["lecture_108102169_w2_l11", "lecture_108102169_w4_l27"]}}
{"id": "concept_serial_communication", "type": "V_concept", "name": "Serial Communication", "properties": {"description": "A method of data transmission where data is sent one bit at a time, sequentially, over a single communication channel.", "keywords": ["devices", "channel", "serial", "transmitting", "communication", "data", "data transmission"], "source_lectures": ["lecture_108102169_w2_l11", "lecture_108102169_w5_l35"]}}
{"id": "concept_spi_bus", "type": "V_concept", "name": "SPI Bus", "properties": {"description": "A synchronous serial communication bus used for short-distance communication between devices.", "keywords": ["spi", "bus", "synchronous", "serial", "communication"], "source_lectures": ["lecture_108102169_w2_l11"]}}
{"id": "concept_i2c_bus", "type": "V_concept", "name": "I2C Bus", "properties": {"description": "A multi-master, multi-slave serial communication bus used for short-distance communication between devices.", "keywords": ["i2c", "bus", "multi-master", "multi-slave", "serial", "communication"], "source_lectures": ["lecture_108102169_w2_l11"]}}
{"id": "concept_analog_to_digital_converter_adc", "type": "V_concept", "name": "Analog-to-Digital Converter (ADC)", "properties": {"description": "A device that converts analog signals into digital signals, allowing microcontrollers to interact with analog sensors and systems.", "keywords": ["adc", "converter", "analog", "voltage", "analog-to-digital", "conversion", "digital"], "source_lectures": ["lecture_108102169_w2_l11", "lecture_108102169_w1_l5", "lecture_108102169_w5_l31"]}}
{"id": "concept_debugging", "type": "V_concept", "name": "Debugging", "properties": {"description": "The process of identifying and fixing errors or bugs in software or hardware systems.", "keywords": ["debugging", "errors", "bugs", "software", "hardware"], "source_lectures": ["lecture_108102169_w2_l11"]}}
{"id": "concept_jtag_interface", "type": "V_concept", "name": "JTAG Interface", "properties": {"description": "A standard interface for debugging and testing integrated circuits, particularly microcontrollers.", "keywords": ["interface", "microcontrollers", "jtag", "testing", "integrated circuits", "debugging", "jtag interface", "programming"], "source_lectures": ["lecture_108102169_w2_l11", "lecture_108102169_w2_l12", "lecture_108102169_w2_l14"]}}
{"id": "concept_spy_by_wire_protocol", "type": "V_concept", "name": "Spy-By-Wire Protocol", "properties": {"description": "A protocol used for debugging and testing microcontrollers, particularly those with limited pinouts.", "keywords": ["spy-by-wire", "protocol", "debugging", "testing", "microcontrollers"], "source_lectures": ["lecture_108102169_w2_l11"]}}
{"id": "concept_interrupt_vector_table", "type": "V_concept", "name": "Interrupt Vector Table", "properties": {"description": "A table that stores the memory addresses of interrupt handlers.", "keywords": ["interrupt vector table", "interrupt handlers", "memory addresses"], "source_lectures": ["lecture_108102169_w2_l12"]}}
{"id": "concept_watchdog_timer", "type": "V_concept", "name": "Watchdog Timer", "properties": {"description": "A timer that resets the microcontroller if it fails to respond within a certain time period.", "keywords": ["watchdog", "watchdog timer", "monitor", "lockup", "operation", "timer", "reliability", "freeze", "microcontroller", "time period", "reset"], "source_lectures": ["lecture_108102169_w2_l12", "lecture_108102169_w1_l5", "lecture_108102169_w2_l8", "lecture_108102169_w5_l32"]}}
{"id": "concept_brownout_reset", "type": "V_concept", "name": "Brownout Reset", "properties": {"description": "A reset that occurs when the microcontroller's power supply voltage falls below a certain threshold.", "keywords": ["brownout reset", "power supply voltage", "threshold"], "source_lectures": ["lecture_108102169_w2_l12"]}}
{"id": "concept_power_down_mode", "type": "V_concept", "name": "Power-Down Mode", "properties": {"description": "A low-power mode that reduces the microcontroller's power consumption.", "keywords": ["power-down mode", "low-power", "power consumption"], "source_lectures": ["lecture_108102169_w2_l12"]}}
{"id": "concept_spi_interface", "type": "V_concept", "name": "SPI Interface", "properties": {"description": "A serial communication interface that allows for the transfer of data between devices.", "keywords": ["spi interface", "serial communication", "data transfer"], "source_lectures": ["lecture_108102169_w2_l12"]}}
{"id": "concept_i2c_interface", "type": "V_concept", "name": "I2C Interface", "properties": {"description": "A serial communication interface that allows for the transfer of data between devices.", "keywords": ["i2c interface", "serial communication", "data transfer"], "source_lectures": ["lecture_108102169_w2_l12"]}}
{"id": "concept_uart_interface", "type": "V_concept", "name": "UART Interface", "properties": {"description": "A serial communication interface that allows for the transfer of data between devices.", "keywords": ["uart interface", "serial communication", "data transfer"], "source_lectures": ["lecture_108102169_w2_l12"]}}
{"id": "concept_endianness", "type": "V_concept", "name": "Endianness", "properties": {"description": "The order in which bytes are stored in memory.", "keywords": ["endianness", "byte order", "memory storage"], "source_lectures": ["lecture_108102169_w2_l12"]}}
{"id": "concept_little_endian", "type": "V_concept", "name": "Little-Endian", "properties": {"description": "A byte order in which the least significant byte is stored first.", "keywords": ["little-endian", "byte order", "least significant byte"], "source_lectures": ["lecture_108102169_w2_l12"]}}
{"id": "concept_big_endian", "type": "V_concept", "name": "Big-Endian", "properties": {"description": "A byte order in which the most significant byte is stored first.", "keywords": ["big-endian", "byte order", "most significant byte"], "source_lectures": ["lecture_108102169_w2_l12"]}}
{"id": "concept_memory_mapping", "type": "V_concept", "name": "Memory Mapping", "properties": {"description": "The process of assigning memory addresses to peripherals and memory regions.", "keywords": ["memory mapping", "memory addresses", "peripherals", "memory regions"], "source_lectures": ["lecture_108102169_w2_l12"]}}
{"id": "concept_program_counter", "type": "V_concept", "name": "Program Counter", "properties": {"description": "A register that stores the memory address of the next instruction to be executed.", "keywords": ["memory", "memory address", "instruction", "program", "program counter", "register", "counter"], "source_lectures": ["lecture_108102169_w2_l12", "lecture_106102229_w1_l5", "lecture_108102169_w4_l26"]}}
{"id": "concept_stack_pointer", "type": "V_concept", "name": "Stack Pointer", "properties": {"description": "A register that stores the memory address of the top of the stack.", "keywords": ["memory", "memory address", "pointer", "stack pointer", "stack", "register", "data"], "source_lectures": ["lecture_108102169_w2_l12", "lecture_108102169_w2_l13", "lecture_108102169_w4_l26", "lecture_106102229_w1_l7"]}}
{"id": "concept_status_register", "type": "V_concept", "name": "Status Register", "properties": {"description": "A register that stores the status of the microcontroller, including flags and interrupt enable bits.", "keywords": ["status register", "interrupt enable bits", "status information", "status", "cpu", "flags", "register"], "source_lectures": ["lecture_108102169_w2_l12", "lecture_108102169_w2_l13", "lecture_108102169_w4_l26"]}}
{"id": "concept_segment", "type": "V_concept", "name": "Segment", "properties": {"description": "The smallest unit of memory that can be erased or programmed in a flash memory device.", "keywords": ["segment", "flash memory", "erase", "program"], "source_lectures": ["lecture_108102169_w2_l13"]}}
{"id": "concept_information_memory", "type": "V_concept", "name": "Information Memory", "properties": {"description": "A type of memory used to store constants and other non-volatile data.", "keywords": ["information memory", "constants", "non-volatile data"], "source_lectures": ["lecture_108102169_w2_l13"]}}
{"id": "concept_bootloader", "type": "V_concept", "name": "Bootloader", "properties": {"description": "A program that loads the operating system or application program into memory.", "keywords": ["memory", "update", "application program", "program", "initialize", "operating system", "application software", "bootloader", "firmware"], "source_lectures": ["lecture_108102169_w2_l13", "lecture_108102169_w2_l14", "lecture_108102169_w2_l8"]}}
{"id": "concept_bootstrapping", "type": "V_concept", "name": "Bootstrapping", "properties": {"description": "The process of loading a program into memory, typically using a bootloader.", "keywords": ["bootstrapping", "program", "memory", "bootloader"], "source_lectures": ["lecture_108102169_w2_l13"]}}
{"id": "concept_general_purpose_registers", "type": "V_concept", "name": "General Purpose Registers", "properties": {"description": "Registers that can be used for a variety of purposes, such as storing data or addresses.", "keywords": ["general purpose registers", "data", "addresses"], "source_lectures": ["lecture_108102169_w2_l13"]}}
{"id": "concept_constant_generator", "type": "V_concept", "name": "Constant Generator", "properties": {"description": "A circuit that generates a constant value, such as zero or one.", "keywords": ["constant generator", "constant value", "zero", "one"], "source_lectures": ["lecture_108102169_w2_l13"]}}
{"id": "concept_addressing_modes", "type": "V_concept", "name": "Addressing Modes", "properties": {"description": "The ways in which a microcontroller can access memory or registers.", "keywords": ["addressing modes", "memory", "registers", "access"], "source_lectures": ["lecture_108102169_w2_l13"]}}
{"id": "concept_instruction_set", "type": "V_concept", "name": "Instruction Set", "properties": {"description": "The set of instructions that a microcontroller can execute.", "keywords": ["instruction set", "instructions", "microcontroller", "execute"], "source_lectures": ["lecture_108102169_w2_l13"]}}
{"id": "concept_uart", "type": "V_concept", "name": "UART", "properties": {"description": "A type of serial communication interface.", "keywords": ["uart", "serial communication", "interface"], "source_lectures": ["lecture_108102169_w2_l13"]}}
{"id": "concept_spi", "type": "V_concept", "name": "SPI", "properties": {"description": "A type of serial communication interface.", "keywords": ["spi", "serial communication", "interface"], "source_lectures": ["lecture_108102169_w2_l13"]}}
{"id": "concept_i2c", "type": "V_concept", "name": "I2C", "properties": {"description": "A type of serial communication interface.", "keywords": ["i2c", "serial communication", "interface"], "source_lectures": ["lecture_108102169_w2_l13"]}}
{"id": "concept_usb", "type": "V_concept", "name": "USB", "properties": {"description": "A type of serial communication interface.", "keywords": ["usb", "serial communication", "interface"], "source_lectures": ["lecture_108102169_w2_l13"]}}
{"id": "concept_evaluation_board", "type": "V_concept", "name": "Evaluation Board", "properties": {"description": "A board used to evaluate or test a microcontroller or other electronic component.", "keywords": ["evaluation board", "microcontroller", "electronic component", "test"], "source_lectures": ["lecture_108102169_w2_l13"]}}
{"id": "concept_breadboard", "type": "V_concept", "name": "Breadboard", "properties": {"description": "A type of board used to prototype or test electronic circuits.", "keywords": ["breadboard", "electronic circuits", "prototype", "test"], "source_lectures": ["lecture_108102169_w2_l13"]}}
{"id": "concept_pcb", "type": "V_concept", "name": "PCB", "properties": {"description": "A type of board used to manufacture electronic circuits.", "keywords": ["pcb", "electronic circuits", "manufacture"], "source_lectures": ["lecture_108102169_w2_l13"]}}
{"id": "concept_code_composer_studio", "type": "V_concept", "name": "Code Composer Studio", "properties": {"description": "An integrated development environment (IDE) for developing and debugging embedded software applications.", "keywords": ["code composer studio", "ide", "embedded software", "debugging"], "source_lectures": ["lecture_108102169_w2_l14"]}}
{"id": "concept_eclipse_software_framework", "type": "V_concept", "name": "Eclipse Software Framework", "properties": {"description": "An open-source software framework used for building integrated development environments (IDEs).", "keywords": ["eclipse", "software framework", "ide", "open-source"], "source_lectures": ["lecture_108102169_w2_l14"]}}
{"id": "concept_spy_bi_wire_protocol", "type": "V_concept", "name": "Spy-Bi-Wire Protocol", "properties": {"description": "A two-wire protocol used for debugging and programming MSP430 microcontrollers.", "keywords": ["spy-bi-wire", "protocol", "debugging", "programming", "msp430"], "source_lectures": ["lecture_108102169_w2_l14"]}}
{"id": "concept_uart_communication", "type": "V_concept", "name": "UART Communication", "properties": {"description": "A protocol used for serial communication between devices.", "keywords": ["uart", "communication", "serial", "protocol"], "source_lectures": ["lecture_108102169_w2_l14"]}}
{"id": "concept_high_level_language_programming", "type": "V_concept", "name": "High-Level Language Programming", "properties": {"description": "A programming paradigm that uses abstract, human-readable code to develop software applications.", "keywords": ["high-level language", "programming", "abstract", "human-readable"], "source_lectures": ["lecture_108102169_w2_l14"]}}
{"id": "concept_assembly_language_programming", "type": "V_concept", "name": "Assembly Language Programming", "properties": {"description": "A low-level programming paradigm that uses symbolic codes to represent machine-specific instructions.", "keywords": ["assembly language", "programming", "low-level", "symbolic codes"], "source_lectures": ["lecture_108102169_w2_l14"]}}
{"id": "concept_third_party_libraries", "type": "V_concept", "name": "Third-Party Libraries", "properties": {"description": "Pre-built software libraries developed by external parties to provide additional functionality.", "keywords": ["third-party libraries", "software libraries", "external parties", "functionality"], "source_lectures": ["lecture_108102169_w2_l14"]}}
{"id": "concept_push_button_switch", "type": "V_concept", "name": "Push Button Switch", "properties": {"description": "A type of switch that is activated by pressing a button.", "keywords": ["switch", "button", "activate"], "source_lectures": ["lecture_108102169_w3_l15"]}}
{"id": "concept_toggle_switch", "type": "V_concept", "name": "Toggle Switch", "properties": {"description": "A type of switch that has two states: on and off.", "keywords": ["switch", "toggle", "on", "off"], "source_lectures": ["lecture_108102169_w3_l15"]}}
{"id": "concept_single_pole_single_throw_spst_switch", "type": "V_concept", "name": "Single Pole Single Throw (SPST) Switch", "properties": {"description": "A type of switch that has one pole and one throw, allowing a single circuit to be connected or disconnected.", "keywords": ["switch", "single", "pole", "throw"], "source_lectures": ["lecture_108102169_w3_l15"]}}
{"id": "concept_single_pole_double_throw_spdt_switch", "type": "V_concept", "name": "Single Pole Double Throw (SPDT) Switch", "properties": {"description": "A type of switch that has one pole and two throws, allowing a single circuit to be connected to one of two different circuits.", "keywords": ["switch", "single", "pole", "double", "throw"], "source_lectures": ["lecture_108102169_w3_l15"]}}
{"id": "concept_debouncing", "type": "V_concept", "name": "Debouncing", "properties": {"description": "The process of removing unwanted signals or noise from a switch or other electronic component.", "keywords": ["debouncing", "false", "triggers", "signal", "input", "switch", "noise", "interrupt", "digital", "signals", "button", "bouncing"], "source_lectures": ["lecture_108102169_w3_l15", "lecture_108102169_w4_l26", "lecture_108102169_w4_l27", "lecture_108102169_w5_l35"]}}
{"id": "concept_pull_up_resistor", "type": "V_concept", "name": "Pull-up Resistor", "properties": {"description": "A resistor connected between a signal line and a power source, used to pull the signal line up to a logical high level when not being driven by another component.", "keywords": ["resistor", "power", "pull-up", "input", "signal", "logic", "microcontroller"], "source_lectures": ["lecture_108102169_w3_l15", "lecture_108102169_w1_l5"]}}
{"id": "concept_pull_down_resistor", "type": "V_concept", "name": "Pull-down Resistor", "properties": {"description": "A resistor connected between a signal line and ground, used to pull the signal line down to a logical low level when not being driven by another component.", "keywords": ["resistor", "ground", "input", "signal", "logic", "pull-down", "microcontroller"], "source_lectures": ["lecture_108102169_w3_l15", "lecture_108102169_w1_l5"]}}
{"id": "concept_switch_bouncing", "type": "V_concept", "name": "Switch Bouncing", "properties": {"description": "The phenomenon of a switch producing multiple signals or oscillations when activated or deactivated, due to mechanical or electrical noise.", "keywords": ["switch", "bouncing", "noise", "signal"], "source_lectures": ["lecture_108102169_w3_l15"]}}
{"id": "concept_software_debouncing", "type": "V_concept", "name": "Software Debouncing", "properties": {"description": "A technique used to remove unwanted signals or noise from a switch or other electronic component using software or programming.", "keywords": ["debouncing", "software", "switch", "noise"], "source_lectures": ["lecture_108102169_w3_l15"]}}
{"id": "concept_hardware_debouncing", "type": "V_concept", "name": "Hardware Debouncing", "properties": {"description": "A technique used to remove unwanted signals or noise from a switch or other electronic component using hardware or electronic components.", "keywords": ["debouncing", "hardware", "switch", "noise"], "source_lectures": ["lecture_108102169_w3_l15"]}}
{"id": "concept_in_order_pipeline", "type": "V_concept", "name": "In-Order Pipeline", "properties": {"description": "A type of pipeline where instructions are processed in the order they are received, without any reordering or skipping of stages.", "keywords": ["architecture", "in", "instructions", "in-order", "order", "sequential", "stages", "pipeline", "execution", "processing"], "source_lectures": ["lecture_106102229_w1_l2", "lecture_106102229_w2_l8", "lecture_106102229_w2_l9", "lecture_106102229_w1_l1"]}}
{"id": "concept_pipeline_register", "type": "V_concept", "name": "Pipeline Register", "properties": {"description": "A register that stores the instruction packet and allows instructions to be processed in parallel across different stages.", "keywords": ["pipeline", "register", "instruction", "packet"], "source_lectures": ["lecture_106102229_w1_l2"]}}
{"id": "concept_structural_hazard", "type": "V_concept", "name": "Structural Hazard", "properties": {"description": "A conflict that occurs when two or more instructions try to access the same resource at the same time.", "keywords": ["structural", "hazard", "conflict", "resource"], "source_lectures": ["lecture_106102229_w1_l2"]}}
{"id": "concept_data_hazard", "type": "V_concept", "name": "Data Hazard", "properties": {"description": "A situation where an instruction depends on the result of a previous instruction that has not yet been written back to the register file.", "keywords": ["data", "hazard", "dependency", "instruction"], "source_lectures": ["lecture_106102229_w1_l2"]}}
{"id": "concept_control_hazard", "type": "V_concept", "name": "Control Hazard", "properties": {"description": "A situation where the flow of instructions is altered due to a branch instruction, causing incorrect instructions to be fetched and executed.", "keywords": ["control", "hazard", "branch", "instruction"], "source_lectures": ["lecture_106102229_w1_l2"]}}
{"id": "concept_forwarding", "type": "V_concept", "name": "Forwarding", "properties": {"description": "A technique used to resolve data hazards by forwarding the result of an instruction to a dependent instruction before it is written back to the register file.", "keywords": ["forwarding", "data", "hazard", "instruction"], "source_lectures": ["lecture_106102229_w1_l2"]}}
{"id": "concept_load_use_hazard", "type": "V_concept", "name": "Load-Use Hazard", "properties": {"description": "A specific type of data hazard that occurs when an instruction tries to use the result of a load instruction before it is available.", "keywords": ["load-use", "hazard", "data", "instruction"], "source_lectures": ["lecture_106102229_w1_l2"]}}
{"id": "concept_interlock_logic", "type": "V_concept", "name": "Interlock Logic", "properties": {"description": "A mechanism that detects and resolves hazards by inserting bubbles or stalls in the pipeline.", "keywords": ["interlock", "logic", "hazard", "pipeline"], "source_lectures": ["lecture_106102229_w1_l2"]}}
{"id": "concept_bubble", "type": "V_concept", "name": "Bubble", "properties": {"description": "A no-operation instruction that is inserted into the pipeline to resolve hazards and maintain correct instruction order.", "keywords": ["bubble", "no-op", "instruction", "pipeline"], "source_lectures": ["lecture_106102229_w1_l2"]}}
{"id": "concept_stall", "type": "V_concept", "name": "Stall", "properties": {"description": "A situation where the pipeline is halted for one or more cycles due to a hazard, causing a delay in instruction processing.", "keywords": ["stall", "pipeline", "hazard", "delay"], "source_lectures": ["lecture_106102229_w1_l2"]}}
{"id": "concept_out_of_order_pipeline", "type": "V_concept", "name": "Out-of-Order Pipeline", "properties": {"description": "A type of pipeline that allows instructions to be processed out of the order they were received, to improve performance and reduce stalls.", "keywords": ["architecture", "out", "instruction", "out of order", "processor", "performance", "of", "order", "pipeline", "out-of-order", "execution", "processing"], "source_lectures": ["lecture_106102229_w1_l2", "lecture_106102229_w2_l8", "lecture_106102229_w2_l9", "lecture_106102229_w1_l7", "lecture_106102229_w2_l10"]}}
{"id": "concept_fetch_logic", "type": "V_concept", "name": "Fetch Logic", "properties": {"description": "The process of retrieving instructions from memory in a computer system.", "keywords": ["fetch", "logic", "instruction", "memory"], "source_lectures": ["lecture_106102229_w1_l5"]}}
{"id": "concept_branch_prediction", "type": "V_concept", "name": "Branch Prediction", "properties": {"description": "A technique used to predict the outcome of a branch instruction in a computer program.", "keywords": ["architecture", "prediction", "instructions", "instruction", "processor", "branch", "computer", "performance"], "source_lectures": ["lecture_106102229_w1_l5", "lecture_106102229_w1_l3", "lecture_106102229_w1_l6"]}}
{"id": "concept_instruction_cache", "type": "V_concept", "name": "Instruction Cache", "properties": {"description": "A small, fast memory that stores recently accessed instructions in a computer system.", "keywords": ["memory", "instruction", "access", "computer", "cache"], "source_lectures": ["lecture_106102229_w1_l5", "lecture_106102229_w1_l7"]}}
{"id": "concept_decoder", "type": "V_concept", "name": "Decoder", "properties": {"description": "A component that translates instructions from a compressed format to a format that can be executed by a computer.", "keywords": ["word", "compression", "instruction", "decoder", "circuit", "address", "computer", "cache"], "source_lectures": ["lecture_106102229_w1_l5", "lecture_106102229_w3_l21"]}}
{"id": "concept_instruction_packet", "type": "V_concept", "name": "Instruction Packet", "properties": {"description": "A data structure that contains all the information needed to execute an instruction in a computer program.", "keywords": ["instruction", "packet", "data", "structure"], "source_lectures": ["lecture_106102229_w1_l5"]}}
{"id": "concept_multi_way_branch", "type": "V_concept", "name": "Multi-Way Branch", "properties": {"description": "A type of branch instruction that can have multiple possible targets.", "keywords": ["multi-way", "branch", "instruction", "target"], "source_lectures": ["lecture_106102229_w1_l5"]}}
{"id": "concept_alias_table", "type": "V_concept", "name": "Alias Table", "properties": {"description": "A data structure used to store information about previously encountered instructions in a computer program.", "keywords": ["alias", "table", "instruction", "computer"], "source_lectures": ["lecture_106102229_w1_l5"]}}
{"id": "concept_temporal_locality", "type": "V_concept", "name": "Temporal Locality", "properties": {"description": "The tendency of a computer program to access the same data or instructions repeatedly over time.", "keywords": ["memory", "program", "access", "temporal", "computer", "locality"], "source_lectures": ["lecture_106102229_w1_l5", "lecture_106102229_w3_l19"]}}
{"id": "concept_spatial_locality", "type": "V_concept", "name": "Spatial Locality", "properties": {"description": "The tendency of a computer program to access data or instructions that are located near each other in memory.", "keywords": ["spatial locality", "memory", "access", "program", "locality of reference", "spatial", "memory access pattern", "data prefetching", "computer", "cache block", "locality"], "source_lectures": ["lecture_106102229_w1_l5", "lecture_106103359_w4_l28", "lecture_106102229_w3_l19", "lecture_106102229_w4_l24", "lecture_106103359_w3_l15"]}}
{"id": "concept_branch_target_buffer", "type": "V_concept", "name": "Branch Target Buffer", "properties": {"description": "A cache that stores the targets of recently encountered branch instructions in a computer program.", "keywords": ["target", "branch", "buffer", "cache"], "source_lectures": ["lecture_106102229_w1_l5", "lecture_106102229_w1_l6"]}}
{"id": "concept_instruction_renaming", "type": "V_concept", "name": "Instruction Renaming", "properties": {"description": "A technique used in out of order pipelines to eliminate WAR and WAW hazards", "keywords": ["instruction", "renaming", "out", "of", "order"], "source_lectures": ["lecture_106102229_w2_l8"]}}
{"id": "concept_war_hazards", "type": "V_concept", "name": "WAR Hazards", "properties": {"description": "Write after read hazards that occur when a instruction writes to a register after another instruction has read from it", "keywords": ["war", "hazards", "write", "after", "read"], "source_lectures": ["lecture_106102229_w2_l8"]}}
{"id": "concept_waw_hazards", "type": "V_concept", "name": "WAW Hazards", "properties": {"description": "Write after write hazards that occur when two instructions write to the same register", "keywords": ["waw", "hazards", "write", "after", "write"], "source_lectures": ["lecture_106102229_w2_l8"]}}
{"id": "concept_register_alias_table_rat", "type": "V_concept", "name": "Register Alias Table (RAT)", "properties": {"description": "A table used in out of order pipelines to keep track of the mapping between architectural and physical registers", "keywords": ["register", "alias", "table", "rat"], "source_lectures": ["lecture_106102229_w2_l8"]}}
{"id": "concept_free_list", "type": "V_concept", "name": "Free List", "properties": {"description": "A data structure used to manage the allocation and deallocation of physical registers", "keywords": ["free", "list", "physical", "registers"], "source_lectures": ["lecture_106102229_w2_l8"]}}
{"id": "concept_dependency_check_logic", "type": "V_concept", "name": "Dependency Check Logic", "properties": {"description": "A hardware mechanism used to resolve dependencies between instructions in an out of order pipeline", "keywords": ["dependency", "check", "logic", "out", "of", "order"], "source_lectures": ["lecture_106102229_w2_l8"]}}
{"id": "concept_available_bit", "type": "V_concept", "name": "Available Bit", "properties": {"description": "A bit associated with each entry in the RAT that indicates whether the result is ready or not", "keywords": ["operands", "available", "bit", "instruction", "ready", "rat"], "source_lectures": ["lecture_106102229_w2_l8", "lecture_106102229_w2_l10"]}}
{"id": "concept_circular_queue", "type": "V_concept", "name": "Circular Queue", "properties": {"description": "A data structure used to implement the free list and other buffers in an out of order pipeline", "keywords": ["implementation", "circular", "structure", "queue", "array", "data"], "source_lectures": ["lecture_106102229_w2_l8", "lecture_106102229_w2_l10"]}}
{"id": "concept_instruction_window", "type": "V_concept", "name": "Instruction Window", "properties": {"description": "A buffer that holds instructions waiting to be executed", "keywords": ["buffer", "window", "execution", "instruction"], "source_lectures": ["lecture_106102229_w2_l9", "lecture_106102229_w1_l4", "lecture_106102229_w2_l10"]}}
{"id": "concept_dispatch_stage", "type": "V_concept", "name": "Dispatch Stage", "properties": {"description": "The stage where instructions are transferred from the rename stage to the instruction window", "keywords": ["dispatch", "stage", "instruction", "window"], "source_lectures": ["lecture_106102229_w2_l9"]}}
{"id": "concept_wake_up_mechanism", "type": "V_concept", "name": "Wake Up Mechanism", "properties": {"description": "A process where instructions are notified when their operands are ready", "keywords": ["wake", "up", "mechanism", "instruction", "operand"], "source_lectures": ["lecture_106102229_w2_l9"]}}
{"id": "concept_tag_bus", "type": "V_concept", "name": "Tag Bus", "properties": {"description": "A communication channel that broadcasts tags to notify instructions of ready operands", "keywords": ["tag", "bus", "communication", "channel"], "source_lectures": ["lecture_106102229_w2_l9"]}}
{"id": "concept_select_unit", "type": "V_concept", "name": "Select Unit", "properties": {"description": "A component that selects instructions to be executed based on their readiness and priority", "keywords": ["select", "unit", "instruction", "priority"], "source_lectures": ["lecture_106102229_w2_l9"]}}
{"id": "concept_early_broadcast", "type": "V_concept", "name": "Early Broadcast", "properties": {"description": "A technique where tags are broadcast before the execution of an instruction is complete", "keywords": ["early", "broadcast", "tag", "execution"], "source_lectures": ["lecture_106102229_w2_l9"]}}
{"id": "concept_bypassing", "type": "V_concept", "name": "Bypassing", "properties": {"description": "A technique where results are forwarded from one instruction to another without storing them in a register", "keywords": ["bypassing", "forwarding", "result", "instruction"], "source_lectures": ["lecture_106102229_w2_l9"]}}
{"id": "concept_instruction_level_parallelism", "type": "V_concept", "name": "Instruction Level Parallelism", "properties": {"description": "A technique where multiple instructions are executed simultaneously to improve performance", "keywords": ["instruction", "pipelining", "processor", "level", "superscalar", "performance", "multicore", "executing", "parallel execution", "out-of-order execution", "instruction level parallelism", "parallelism", "instruction-level", "pipeline", "execution", "simultaneous", "ilp"], "source_lectures": ["lecture_106102229_w2_l9", "lecture_106102229_w1_l3", "lecture_106102229_w1_l4", "lecture_106102229_w3_l16", "lecture_106102229_w4_l28", "lecture_106103359_w1_l2", "lecture_106103359_w1_l3", "lecture_106103359_w1_l7", "lecture_106103359_w10_l69"]}}
{"id": "concept_dragon_protocol", "type": "V_concept", "name": "Dragon Protocol", "properties": {"description": "A cache coherence protocol used in parallel computer architectures to maintain consistency among multiple caches.", "keywords": ["architecture", "update", "coherence", "write", "protocol", "dragon", "parallel", "dynamic", "cache"], "source_lectures": ["lecture_106103359_w4_l27", "lecture_106103359_w5_l29", "lecture_106103359_w10_l67", "lecture_106103359_w10_l70"]}}
{"id": "concept_write_back_protocol", "type": "V_concept", "name": "Write Back Protocol", "properties": {"description": "A cache protocol where data is written to the cache and only updated in main memory when the cache line is replaced.", "keywords": ["write", "back", "cache", "protocol"], "source_lectures": ["lecture_106103359_w4_l27"]}}
{"id": "concept_update_based_protocol", "type": "V_concept", "name": "Update Based Protocol", "properties": {"description": "A type of cache coherence protocol where updates are sent to all caches that have a copy of the data.", "keywords": ["coherence", "cache", "update", "protocol", "based", "memory"], "source_lectures": ["lecture_106103359_w4_l27", "lecture_106103359_w7_l46"]}}
{"id": "concept_bus_update_transaction", "type": "V_concept", "name": "Bus Update Transaction", "properties": {"description": "A transaction sent over the bus to update the data in other caches.", "keywords": ["bus", "update", "transaction", "cache"], "source_lectures": ["lecture_106103359_w4_l27"]}}
{"id": "concept_shared_clean_state", "type": "V_concept", "name": "Shared Clean State", "properties": {"description": "A state in the Dragon protocol where a cache line is shared among multiple caches and the data is clean.", "keywords": ["shared", "clean", "state", "cache", "dragon"], "source_lectures": ["lecture_106103359_w4_l27"]}}
{"id": "concept_shared_modified_state", "type": "V_concept", "name": "Shared Modified State", "properties": {"description": "A state in the Dragon protocol where a cache line is shared among multiple caches and the data is modified.", "keywords": ["protocol", "state", "dragon", "shared", "modified", "cache"], "source_lectures": ["lecture_106103359_w4_l27", "lecture_106103359_w10_l70"]}}
{"id": "concept_exclusive_state", "type": "V_concept", "name": "Exclusive State", "properties": {"description": "A state in the Dragon protocol where a cache line is exclusively owned by one cache.", "keywords": ["block", "exclusive", "mesi", "processor", "state", "dragon", "access", "data", "cache"], "source_lectures": ["lecture_106103359_w4_l27", "lecture_106103359_w7_l48", "lecture_106103359_w4_l23", "lecture_106103359_w4_l26"]}}
{"id": "concept_modified_state", "type": "V_concept", "name": "Modified State", "properties": {"description": "A state in the Dragon protocol where a cache line is modified and exclusively owned by one cache.", "keywords": ["mesi", "state", "dragon", "modified", "cache"], "source_lectures": ["lecture_106103359_w4_l27", "lecture_106103359_w4_l26"]}}
{"id": "concept_cache_coherence", "type": "V_concept", "name": "Cache Coherence", "properties": {"description": "The ability of a cache system to maintain consistency among multiple caches.", "keywords": ["concurrency", "memory", "snooping", "shared cache", "protocol", "reads", "system", "multicore", "data", "coherence protocol", "processors", "processor", "memory consistency", "multiprocessor cache", "shared memory", "multi-core", "consistency", "multiprocessor", "coherence", "replica", "multiple", "parallel", "invalidation", "cache consistency", "synchronization", "distributed", "shared", "consistent", "cache coherence", "cache"], "source_lectures": ["lecture_106103359_w4_l27", "lecture_106103359_w5_l29", "lecture_106103359_w5_l30", "lecture_106103359_w5_l31", "lecture_106103359_w5_l32", "lecture_106103359_w5_l33", "lecture_106103359_w6_l38", "lecture_106103359_w7_l44", "lecture_106103359_w7_l47", "lecture_106102229_w4_l26", "lecture_106102229_w4_l28", "lecture_106102229_w5_l32", "lecture_106103359_w2_l9", "lecture_106103359_w3_l15", "lecture_106103359_w3_l20", "lecture_106103359_w4_l22", "lecture_106103359_w4_l25", "lecture_106103359_w4_l26", "lecture_106103359_w5_l34", "lecture_106103359_w9_l59", "lecture_106103359_w10_l67", "lecture_106103359_w10_l69", "lecture_106103359_w10_l70", "lecture_106103359_w11_l71"]}}
{"id": "concept_finite_state_machine", "type": "V_concept", "name": "Finite State Machine", "properties": {"description": "A mathematical model used to describe the behavior of a system that can be in one of a finite number of states.", "keywords": ["model", "finite", "state", "system", "behavior", "fsm", "mathematical", "digital", "machine"], "source_lectures": ["lecture_106103359_w4_l27", "lecture_106103359_w5_l31", "lecture_106103359_w4_l22", "lecture_106103359_w4_l24", "lecture_106103359_w10_l70"]}}
{"id": "concept_cold_miss", "type": "V_concept", "name": "Cold Miss", "properties": {"description": "A type of cache miss that occurs when a block is accessed for the first time.", "keywords": ["block", "compulsory", "access", "cold", "data", "miss", "cache"], "source_lectures": ["lecture_106103359_w4_l28", "lecture_106103359_w5_l29", "lecture_106102229_w3_l20", "lecture_106103359_w10_l67"]}}
{"id": "concept_capacity_miss", "type": "V_concept", "name": "Capacity Miss", "properties": {"description": "A type of cache miss that occurs when the cache is full and a block needs to be replaced.", "keywords": ["size", "full", "cache exhaustion", "replacement", "cache size miss", "capacity miss", "working set overflow", "capacity", "fully associative miss", "data", "miss", "cache"], "source_lectures": ["lecture_106103359_w4_l28", "lecture_106102229_w3_l20", "lecture_106103359_w3_l15", "lecture_106103359_w10_l67"]}}
{"id": "concept_conflict_miss", "type": "V_concept", "name": "Conflict Miss", "properties": {"description": "A type of cache miss that occurs when multiple blocks map to the same cache set.", "keywords": ["direct mapped miss", "conflict miss", "conflict", "line", "set associative miss", "set conflict", "miss", "data", "collision miss", "cache", "set"], "source_lectures": ["lecture_106103359_w4_l28", "lecture_106102229_w3_l20", "lecture_106103359_w3_l15", "lecture_106103359_w10_l67"]}}
{"id": "concept_coherence_miss", "type": "V_concept", "name": "Coherence Miss", "properties": {"description": "A type of cache miss that occurs when multiple processors share data and one processor invalidates the block.", "keywords": ["multiprocessor", "multiprocessor miss", "coherence", "coherence miss", "shared data", "cache invalidation", "data", "shared", "shared memory", "cache coherence", "miss", "invalidation", "cache"], "source_lectures": ["lecture_106103359_w4_l28", "lecture_106103359_w3_l15", "lecture_106103359_w10_l67", "lecture_106103359_w10_l69", "lecture_106103359_w10_l70"]}}
{"id": "concept_true_sharing_miss", "type": "V_concept", "name": "True Sharing Miss", "properties": {"description": "A type of coherence miss that occurs when a processor accesses a block that has been modified by another processor.", "keywords": ["sharing", "miss", "cache", "true", "multiprocessor"], "source_lectures": ["lecture_106103359_w4_l28", "lecture_106103359_w5_l29"]}}
{"id": "concept_false_sharing_miss", "type": "V_concept", "name": "False Sharing Miss", "properties": {"description": "A type of coherence miss that occurs when a processor accesses a block that has not been modified by another processor.", "keywords": ["sharing", "false", "miss", "cache", "block"], "source_lectures": ["lecture_106103359_w4_l28", "lecture_106103359_w5_l29"]}}
{"id": "concept_cache_block_lifetime", "type": "V_concept", "name": "Cache Block Lifetime", "properties": {"description": "The duration of time a cache block resides in the cache, from being loaded to being removed.", "keywords": ["cache", "block", "lifetime", "duration"], "source_lectures": ["lecture_106103359_w4_l28"]}}
{"id": "concept_cache_invalidation", "type": "V_concept", "name": "Cache Invalidation", "properties": {"description": "The process of marking a cache block as invalid, usually due to a write operation by another processor.", "keywords": ["remove", "update", "coherence", "write", "processor", "invalidation", "cache"], "source_lectures": ["lecture_106103359_w4_l28", "lecture_106103359_w3_l20"]}}
{"id": "concept_cache_replacement", "type": "V_concept", "name": "Cache Replacement", "properties": {"description": "The process of removing a cache block to make room for a new block.", "keywords": ["cache", "replacement", "remove", "block"], "source_lectures": ["lecture_106103359_w4_l28"]}}
{"id": "concept_cache_miss", "type": "V_concept", "name": "Cache Miss", "properties": {"description": "An event that occurs when a processor attempts to access data that is not present in its cache", "keywords": ["event", "time", "memory", "memory hierarchy", "cache miss", "item", "processor", "access", "fetch", "miss", "data", "cache", "not found"], "source_lectures": ["lecture_106103359_w5_l29", "lecture_106103359_w6_l38", "lecture_106103359_w2_l13", "lecture_106103359_w3_l18", "lecture_106103359_w4_l23", "lecture_106103359_w4_l24", "lecture_106103359_w10_l67", "lecture_106103359_w10_l69"]}}
{"id": "concept_cache_block", "type": "V_concept", "name": "Cache Block", "properties": {"description": "A unit of data that is stored in a cache", "keywords": ["block", "cache", "tag", "data", "unit", "storage"], "source_lectures": ["lecture_106103359_w5_l29", "lecture_106103359_w4_l22"]}}
{"id": "concept_update_protocol", "type": "V_concept", "name": "Update Protocol", "properties": {"description": "A cache coherence protocol that sends updates to all caches that have a copy of the modified data", "keywords": ["update", "protocol", "cache", "coherence"], "source_lectures": ["lecture_106103359_w5_l29"]}}
{"id": "concept_invalidate_protocol", "type": "V_concept", "name": "Invalidate Protocol", "properties": {"description": "A cache coherence protocol that invalidates all caches that have a copy of the modified data", "keywords": ["invalidate", "protocol", "cache", "coherence"], "source_lectures": ["lecture_106103359_w5_l29"]}}
{"id": "concept_prefetching", "type": "V_concept", "name": "Prefetching", "properties": {"description": "A technique that brings data into the cache before it is actually needed", "keywords": ["prediction", "instructions", "prefetching", "data", "performance", "cache"], "source_lectures": ["lecture_106103359_w5_l29", "lecture_106102229_w4_l24"]}}
{"id": "concept_cache_hierarchy", "type": "V_concept", "name": "Cache Hierarchy", "properties": {"description": "A multi-level cache system where each level has a larger capacity and slower access time than the previous level", "keywords": ["multi-level", "memory", "processor", "organization", "levels", "hierarchy", "performance", "cache"], "source_lectures": ["lecture_106103359_w5_l29", "lecture_106102229_w3_l19", "lecture_106102229_w4_l24"]}}
{"id": "concept_snoop_based_multiprocessor_design", "type": "V_concept", "name": "Snoop-Based Multiprocessor Design", "properties": {"description": "A type of multiprocessor design where each processor snoops on the bus to maintain cache coherence.", "keywords": ["coherence", "snooping", "cache", "design", "snoop", "multiprocessor"], "source_lectures": ["lecture_106103359_w5_l30", "lecture_106103359_w5_l31"]}}
{"id": "concept_correctness_requirements", "type": "V_concept", "name": "Correctness Requirements", "properties": {"description": "The conditions that must be met to ensure that a system functions correctly and produces the expected results.", "keywords": ["correctness", "requirements", "system", "function", "results"], "source_lectures": ["lecture_106103359_w5_l30"]}}
{"id": "concept_sequential_consistency", "type": "V_concept", "name": "Sequential Consistency", "properties": {"description": "A consistency model that ensures that all processors see the same order of operations.", "keywords": ["concurrency", "memory", "sequential consistency", "program order", "memory model", "global order", "processors", "processor", "memory consistency", "consistency model", "sequential", "consistency", "systems", "model", "variables", "parallel", "program", "operation", "synchronization", "shared-memory", "access", "distributed", "order"], "source_lectures": ["lecture_106103359_w5_l30", "lecture_106102229_w4_l26", "lecture_106102229_w4_l27", "lecture_106102229_w5_l31", "lecture_106103359_w8_l56", "lecture_106103359_w9_l57", "lecture_106103359_w9_l58", "lecture_106103359_w9_l59", "lecture_106103359_w11_l71", "lecture_106104182_w3_l16"]}}
{"id": "concept_write_atomicity", "type": "V_concept", "name": "Write Atomicity", "properties": {"description": "The property that ensures that a write operation is seen by all processors in the same order.", "keywords": ["correct", "multiprocessor", "memory", "processors", "coherence", "write", "property", "atomicity", "reads", "indivisible", "system", "order", "consistency", "unit", "visibility"], "source_lectures": ["lecture_106103359_w5_l30", "lecture_106103359_w5_l32", "lecture_106103359_w6_l38", "lecture_106103359_w7_l46", "lecture_106103359_w8_l56", "lecture_106103359_w9_l57"]}}
{"id": "concept_write_serialization", "type": "V_concept", "name": "Write Serialization", "properties": {"description": "The process of ordering write operations to ensure that they are seen by all processors in the same order.", "keywords": ["correct", "multiprocessor", "serialization", "memory", "cache", "processors", "coherence", "write", "process", "reads", "order", "consistency"], "source_lectures": ["lecture_106103359_w5_l30", "lecture_106103359_w5_l32", "lecture_106103359_w6_l38", "lecture_106103359_w7_l46", "lecture_106103359_w4_l23", "lecture_106103359_w4_l24", "lecture_106103359_w4_l25"]}}
{"id": "concept_deadlock", "type": "V_concept", "name": "Deadlock", "properties": {"description": "A situation where two or more processes are blocked indefinitely, each waiting for the other to release a resource.", "keywords": ["concurrency", "indefinitely", "multiprocessor", "block", "wait", "devices", "packet", "processes", "resource", "resources", "process", "synchronization", "network", "deadlock", "situation", "blocked"], "source_lectures": ["lecture_106103359_w5_l30", "lecture_106103359_w5_l32", "lecture_106103359_w7_l49", "lecture_106102229_w4_l27", "lecture_106102229_w5_l32", "lecture_106102229_w5_l33", "lecture_106103359_w9_l62", "lecture_106103359_w10_l64"]}}
{"id": "concept_livelock", "type": "V_concept", "name": "Livelock", "properties": {"description": "A situation where two or more processes are unable to proceed because they are too busy responding to each other's actions.", "keywords": ["multiprocessor", "interference", "requests", "processes", "state", "synchronization", "livelock", "responses", "starvation", "deadlock", "proceed", "responding", "situation", "changes", "actions"], "source_lectures": ["lecture_106103359_w5_l30", "lecture_106103359_w5_l32", "lecture_106103359_w7_l49", "lecture_106102229_w5_l32", "lecture_106103359_w9_l60"]}}
{"id": "concept_starvation", "type": "V_concept", "name": "Starvation", "properties": {"description": "A situation where one or more processes are unable to gain access to a shared resource, causing them to make no progress.", "keywords": ["multiprocessor", "extended", "processes", "resource", "process", "starvation", "synchronization", "access", "situation", "progress"], "source_lectures": ["lecture_106103359_w5_l30", "lecture_106103359_w5_l32", "lecture_106103359_w7_l49", "lecture_106102229_w5_l32"]}}
{"id": "concept_cache_coherence_protocol", "type": "V_concept", "name": "Cache Coherence Protocol", "properties": {"description": "A set of rules that ensures cache coherence in a multiprocessor system.", "keywords": ["multiprocessor", "memory", "integrity", "coherence", "protocol", "parallel", "system", "data", "consistency", "cache", "propagation"], "source_lectures": ["lecture_106103359_w5_l30", "lecture_106103359_w6_l39", "lecture_106103359_w6_l41", "lecture_106103359_w6_l42", "lecture_106103359_w7_l46", "lecture_106103359_w4_l23", "lecture_106103359_w4_l24", "lecture_106103359_w9_l60"]}}
{"id": "concept_interconnect", "type": "V_concept", "name": "Interconnect", "properties": {"description": "A communication link between processors in a multiprocessor system.", "keywords": ["interconnect", "communication", "link", "processors", "system"], "source_lectures": ["lecture_106103359_w5_l30"]}}
{"id": "concept_split_transaction_bus", "type": "V_concept", "name": "Split Transaction Bus", "properties": {"description": "A type of bus that allows multiple transactions to be processed simultaneously.", "keywords": ["bus", "transactions", "multiprocessor", "efficient", "response", "multiple", "protocol", "transaction", "parallel", "request", "complexity", "split", "processing", "performance"], "source_lectures": ["lecture_106103359_w5_l30", "lecture_106103359_w5_l35", "lecture_106103359_w6_l36", "lecture_106103359_w6_l37", "lecture_106103359_w6_l38", "lecture_106103359_w6_l39", "lecture_106103359_w9_l60", "lecture_106103359_w10_l67"]}}
{"id": "concept_atomic_bus", "type": "V_concept", "name": "Atomic Bus", "properties": {"description": "A type of bus that processes one transaction at a time.", "keywords": ["bus", "time", "multiprocessor", "memory", "transaction", "atomic", "interruption", "consistency"], "source_lectures": ["lecture_106103359_w5_l30", "lecture_106103359_w5_l31", "lecture_106103359_w5_l33", "lecture_106103359_w5_l34"]}}
{"id": "concept_mesi_protocol", "type": "V_concept", "name": "MESI Protocol", "properties": {"description": "A cache coherence protocol that uses four states (Modified, Exclusive, Shared, Invalid) to manage cache lines.", "keywords": ["multiprocessor", "coherence", "mesi", "finite", "protocol", "parallel", "cache"], "source_lectures": ["lecture_106103359_w5_l31", "lecture_106103359_w5_l32", "lecture_106103359_w5_l33", "lecture_106103359_w6_l38", "lecture_106103359_w7_l47", "lecture_106103359_w7_l48", "lecture_106102229_w5_l29", "lecture_106103359_w4_l26", "lecture_106103359_w8_l50", "lecture_106103359_w10_l67", "lecture_106103359_w10_l70"]}}
{"id": "concept_snooping_protocol", "type": "V_concept", "name": "Snooping Protocol", "properties": {"description": "A protocol that allows caches to monitor bus transactions and update their contents accordingly.", "keywords": ["bus", "broadcast", "snooping", "coherence", "protocol", "parallel", "system", "cache"], "source_lectures": ["lecture_106103359_w5_l31", "lecture_106103359_w5_l32", "lecture_106103359_w7_l47", "lecture_106103359_w4_l22", "lecture_106103359_w4_l23", "lecture_106103359_w8_l50", "lecture_106103359_w10_l67"]}}
{"id": "concept_cache_controller", "type": "V_concept", "name": "Cache Controller", "properties": {"description": "A component that manages cache operations, including cache misses, hits, and coherence maintenance.", "keywords": ["memory access", "multiprocessor", "cache controller", "coherence", "component", "cache line", "controller", "hardware", "management", "cache management", "cache", "manager"], "source_lectures": ["lecture_106103359_w5_l31", "lecture_106103359_w5_l32", "lecture_106103359_w4_l22", "lecture_106103359_w10_l69"]}}
{"id": "concept_dual_tag_array", "type": "V_concept", "name": "Dual Tag Array", "properties": {"description": "A cache organization that uses two separate tag arrays to improve performance in multiprocessor systems.", "keywords": ["dual", "tag", "array", "cache", "multiprocessor"], "source_lectures": ["lecture_106103359_w5_l31"]}}
{"id": "concept_wired_or_signal", "type": "V_concept", "name": "Wired-OR Signal", "properties": {"description": "A signal that is used to combine multiple signals, often used in snooping protocols to indicate shared or dirty lines.", "keywords": ["dirty", "wired-or", "snooping", "signal", "mesi", "shared", "sharers"], "source_lectures": ["lecture_106103359_w5_l31", "lecture_106103359_w4_l26"]}}
{"id": "concept_snoop_valid_signal", "type": "V_concept", "name": "Snoop Valid Signal", "properties": {"description": "A signal that indicates when snooping results are valid and can be sampled by the memory or requester.", "keywords": ["snoop", "valid", "signal", "memory", "requester"], "source_lectures": ["lecture_106103359_w5_l31"]}}
{"id": "concept_write_buffer", "type": "V_concept", "name": "Write Buffer", "properties": {"description": "A buffer that holds data to be written back to memory, used to improve performance in cache systems.", "keywords": ["latency hiding", "buffer", "memory", "memory write", "requests", "write", "processor", "write buffer", "store buffer", "request", "access", "out-of-order", "execution", "performance", "cache"], "source_lectures": ["lecture_106103359_w5_l31", "lecture_106103359_w6_l39", "lecture_106102229_w3_l20", "lecture_106102229_w4_l26"]}}
{"id": "concept_cache_to_cache_transfer", "type": "V_concept", "name": "Cache to Cache Transfer", "properties": {"description": "A technique that allows caches to transfer data directly, without involving memory.", "keywords": ["cache", "transfer", "data", "memory"], "source_lectures": ["lecture_106103359_w5_l31"]}}
{"id": "concept_write_completeness", "type": "V_concept", "name": "Write Completeness", "properties": {"description": "The guarantee that all processors have seen a write before it is considered complete", "keywords": ["guarantee", "order", "write", "completeness", "consistency", "multiprocessor"], "source_lectures": ["lecture_106103359_w5_l32", "lecture_106103359_w6_l39"]}}
{"id": "concept_bus_arbitration", "type": "V_concept", "name": "Bus Arbitration", "properties": {"description": "The process of managing access to a shared bus in a multiprocessor system", "keywords": ["resolution", "access", "management", "bus", "arbitration", "multiprocessor", "conflict"], "source_lectures": ["lecture_106103359_w5_l32", "lecture_106103359_w5_l35", "lecture_106103359_w6_l36"]}}
{"id": "concept_transient_states", "type": "V_concept", "name": "Transient States", "properties": {"description": "Temporary states that a cache line can be in during the execution of a protocol", "keywords": ["transient", "states", "cache", "coherence"], "source_lectures": ["lecture_106103359_w5_l32"]}}
{"id": "concept_stable_states", "type": "V_concept", "name": "Stable States", "properties": {"description": "Permanent states that a cache line can be in during the execution of a protocol", "keywords": ["stable", "states", "cache", "coherence"], "source_lectures": ["lecture_106103359_w5_l32"]}}
{"id": "concept_busrdx", "type": "V_concept", "name": "BusRdX", "properties": {"description": "A bus transaction that reads and invalidates a cache line", "keywords": ["busrdx", "bus", "transaction", "cache", "invalidate", "memory"], "source_lectures": ["lecture_106103359_w5_l32", "lecture_106103359_w5_l35"]}}
{"id": "concept_busupgr", "type": "V_concept", "name": "BusUpgr", "properties": {"description": "A bus transaction that upgrades a cache line to a modified state", "keywords": ["busupgr", "bus", "transaction", "cache"], "source_lectures": ["lecture_106103359_w5_l32"]}}
{"id": "concept_multi_level_cache", "type": "V_concept", "name": "Multi-Level Cache", "properties": {"description": "A cache hierarchy with multiple levels of caches, each with its own size and access time, used to improve processor performance by reducing memory latency.", "keywords": ["multi-level", "cache", "size", "latency", "access", "hierarchy", "performance", "multilevel"], "source_lectures": ["lecture_106103359_w5_l33", "lecture_106103359_w4_l23"]}}
{"id": "concept_inclusion_property", "type": "V_concept", "name": "Inclusion Property", "properties": {"description": "A property of multi-level caches where the contents of a higher-level cache are a subset of the contents of a lower-level cache.", "keywords": ["subset", "property", "inclusion", "hierarchy", "cache"], "source_lectures": ["lecture_106103359_w5_l33", "lecture_106103359_w5_l34"]}}
{"id": "concept_set_associative_cache", "type": "V_concept", "name": "Set Associative Cache", "properties": {"description": "A cache organization where each set contains multiple lines, and the replacement policy is used to select a line to replace.", "keywords": ["cache", "memory", "limited", "mapping", "replacement", "associative", "organization", "n-way set associative", "cache set", "set associative", "conflict miss reduction", "address", "cache mapping", "data", "lines", "set"], "source_lectures": ["lecture_106103359_w5_l33", "lecture_106102229_w3_l19", "lecture_106102229_w3_l21", "lecture_106102229_w4_l24", "lecture_106103359_w2_l13", "lecture_106103359_w3_l15", "lecture_106103359_w5_l34"]}}
{"id": "concept_lru_replacement_policy", "type": "V_concept", "name": "LRU Replacement Policy", "properties": {"description": "A cache replacement policy that replaces the least recently used line in a set.", "keywords": ["lru", "replacement", "policy", "ram", "line", "cache", "page"], "source_lectures": ["lecture_106103359_w5_l33", "lecture_106103359_w3_l18"]}}
{"id": "concept_moesi_protocol", "type": "V_concept", "name": "MOESI Protocol", "properties": {"description": "A cache coherence protocol that extends the MESI protocol with an additional state (Owned) to improve performance in multi-processor systems.", "keywords": ["multiprocessor", "owned", "coherence", "mesi", "protocol", "moesi", "cache"], "source_lectures": ["lecture_106103359_w5_l33", "lecture_106102229_w5_l29", "lecture_106103359_w4_l26"]}}
{"id": "concept_snoop_based_coherence", "type": "V_concept", "name": "Snoop-Based Coherence", "properties": {"description": "A cache coherence protocol that uses a snooping mechanism to monitor bus transactions and maintain cache coherence.", "keywords": ["snoop", "coherence", "protocol", "cache", "bus"], "source_lectures": ["lecture_106103359_w5_l33"]}}
{"id": "concept_bus_snooper", "type": "V_concept", "name": "Bus Snooper", "properties": {"description": "A hardware component that monitors bus transactions and updates the cache accordingly to maintain cache coherence.", "keywords": ["bus", "monitor", "component", "coherence", "state", "snooper", "hardware", "cache"], "source_lectures": ["lecture_106103359_w5_l33", "lecture_106103359_w4_l22", "lecture_106103359_w4_l23"]}}
{"id": "concept_atomic_transaction", "type": "V_concept", "name": "Atomic Transaction", "properties": {"description": "A type of transaction that is executed as a single, indivisible unit, where all steps must be completed before the next transaction can start", "keywords": ["atomic", "transaction", "indivisible", "sequential"], "source_lectures": ["lecture_106103359_w5_l35"]}}
{"id": "concept_request_phase", "type": "V_concept", "name": "Request Phase", "properties": {"description": "The phase of a transaction where the request is sent and the bus is arbitrated for", "keywords": ["bus", "transaction", "arbitration", "request", "split", "phase"], "source_lectures": ["lecture_106103359_w5_l35", "lecture_106103359_w6_l36"]}}
{"id": "concept_response_phase", "type": "V_concept", "name": "Response Phase", "properties": {"description": "The phase of a transaction where the response is sent and the data is transferred", "keywords": ["bus", "transaction", "response", "transfer", "split", "phase", "data"], "source_lectures": ["lecture_106103359_w5_l35", "lecture_106103359_w6_l36"]}}
{"id": "concept_serialization", "type": "V_concept", "name": "Serialization", "properties": {"description": "The process of ordering transactions to ensure that they are executed in a consistent and predictable manner", "keywords": ["location", "transactions", "ordering", "serialization", "memory", "parallel", "access", "system", "writes", "order", "consistency", "correctness"], "source_lectures": ["lecture_106103359_w5_l35", "lecture_106103359_w7_l45", "lecture_106103359_w7_l49", "lecture_106103359_w3_l20"]}}
{"id": "concept_flow_control", "type": "V_concept", "name": "Flow Control", "properties": {"description": "The mechanism used to manage the flow of data through a network or bus, preventing congestion and ensuring reliable data transfer", "keywords": ["bus", "buffer", "control", "network", "data", "transmission", "interconnect", "management", "flow", "congestion"], "source_lectures": ["lecture_106103359_w5_l35", "lecture_106103359_w6_l37", "lecture_106103359_w9_l62", "lecture_106103359_w10_l65", "lecture_106103359_w11_l71"]}}
{"id": "concept_conflicting_request", "type": "V_concept", "name": "Conflicting Request", "properties": {"description": "A situation where multiple requests are made for the same resource, potentially leading to conflicts and inconsistencies", "keywords": ["conflicting", "request", "resource", "conflict", "inconsistency"], "source_lectures": ["lecture_106103359_w5_l35"]}}
{"id": "concept_snoop_result", "type": "V_concept", "name": "Snoop Result", "properties": {"description": "The result of a snoop operation, indicating the state of a cache line or memory location", "keywords": ["result", "memory", "coherence", "state", "snoop", "cache"], "source_lectures": ["lecture_106103359_w5_l35", "lecture_106103359_w10_l67"]}}
{"id": "concept_bus_read", "type": "V_concept", "name": "Bus Read", "properties": {"description": "A type of transaction where a device reads data from a memory location or cache", "keywords": ["bus", "read", "transaction", "memory", "cache"], "source_lectures": ["lecture_106103359_w5_l35"]}}
{"id": "concept_bus_upgrade", "type": "V_concept", "name": "Bus Upgrade", "properties": {"description": "A type of transaction where a device upgrades its cache line or memory location to a new state", "keywords": ["upgrade", "bus", "transaction", "cache", "modify", "memory"], "source_lectures": ["lecture_106103359_w5_l35", "lecture_106103359_w6_l38"]}}
{"id": "concept_write_back", "type": "V_concept", "name": "Write Back", "properties": {"description": "A type of transaction where a device writes data back to a memory location or cache", "keywords": ["main", "memory", "back", "write", "transaction", "line", "cache"], "source_lectures": ["lecture_106103359_w5_l35", "lecture_106103359_w7_l48", "lecture_106102229_w5_l29", "lecture_106103359_w8_l52"]}}
{"id": "concept_tag_matching", "type": "V_concept", "name": "Tag Matching", "properties": {"description": "A method for matching requests with responses in a split transaction bus, using a unique identifier or tag.", "keywords": ["tag", "matching", "request", "response", "split"], "source_lectures": ["lecture_106103359_w6_l36"]}}
{"id": "concept_data_request_phase", "type": "V_concept", "name": "Data Request Phase", "properties": {"description": "A phase in a split transaction bus where a device requests access to the data bus to send data.", "keywords": ["data", "request", "phase", "split", "transaction"], "source_lectures": ["lecture_106103359_w6_l36"]}}
{"id": "concept_data_response_phase", "type": "V_concept", "name": "Data Response Phase", "properties": {"description": "A phase in a split transaction bus where a device sends data on the data bus.", "keywords": ["data", "response", "phase", "split", "transaction"], "source_lectures": ["lecture_106103359_w6_l36"]}}
{"id": "concept_turnaround_time", "type": "V_concept", "name": "Turnaround Time", "properties": {"description": "A period of time required between data transfers on a bus, to ensure proper bus operation.", "keywords": ["turnaround", "time", "bus", "operation"], "source_lectures": ["lecture_106103359_w6_l36"]}}
{"id": "concept_snoop_protocol", "type": "V_concept", "name": "Snoop Protocol", "properties": {"description": "A protocol used in multiprocessor systems to maintain cache coherence, by monitoring bus transactions.", "keywords": ["snoop", "protocol", "multiprocessor", "cache", "coherence"], "source_lectures": ["lecture_106103359_w6_l36"]}}
{"id": "concept_busupgr_request", "type": "V_concept", "name": "BusUpgr Request", "properties": {"description": "A type of request in a split transaction bus, where a device requests an upgrade to a shared resource.", "keywords": ["busupgr", "request", "split", "transaction", "bus"], "source_lectures": ["lecture_106103359_w6_l36"]}}
{"id": "concept_write_back_request", "type": "V_concept", "name": "Write-Back Request", "properties": {"description": "A type of request in a split transaction bus, where a device requests to write data back to a shared resource.", "keywords": ["write-back", "request", "split", "transaction", "bus"], "source_lectures": ["lecture_106103359_w6_l36"]}}
{"id": "concept_request_table", "type": "V_concept", "name": "Request Table", "properties": {"description": "A data structure used to store information about outstanding requests in a split transaction bus", "keywords": ["bus", "pending", "processors", "transaction", "request", "split", "table"], "source_lectures": ["lecture_106103359_w6_l37", "lecture_106103359_w6_l38", "lecture_106103359_w10_l67"]}}
{"id": "concept_fully_associative_data_structure", "type": "V_concept", "name": "Fully Associative Data Structure", "properties": {"description": "A type of data structure where each entry can be accessed directly using its contents", "keywords": ["fully", "associative", "data", "structure"], "source_lectures": ["lecture_106103359_w6_l37"]}}
{"id": "concept_tag_assignment", "type": "V_concept", "name": "Tag Assignment", "properties": {"description": "The process of assigning a unique identifier to each request in a split transaction bus", "keywords": ["tag", "assignment", "request", "identifier"], "source_lectures": ["lecture_106103359_w6_l37"]}}
{"id": "concept_request_conflict_resolution", "type": "V_concept", "name": "Request Conflict Resolution", "properties": {"description": "The process of resolving conflicts between multiple requests accessing the same location", "keywords": ["request", "conflict", "resolution", "multiprocessor"], "source_lectures": ["lecture_106103359_w6_l37"]}}
{"id": "concept_negative_acknowledgement_nack", "type": "V_concept", "name": "Negative Acknowledgement (NACK)", "properties": {"description": "A signal used to indicate that a transaction cannot be completed due to buffer overflow", "keywords": ["nack", "negative", "acknowledgement", "signal"], "source_lectures": ["lecture_106103359_w6_l37"]}}
{"id": "concept_backoff_algorithm", "type": "V_concept", "name": "Backoff Algorithm", "properties": {"description": "An algorithm used to handle retries in flow control", "keywords": ["backoff", "algorithm", "retry", "flow", "control"], "source_lectures": ["lecture_106103359_w6_l37"]}}
{"id": "concept_priority_scheduling", "type": "V_concept", "name": "Priority Scheduling", "properties": {"description": "A technique used to prioritize transactions in flow control", "keywords": ["priority", "scheduling", "transaction", "flow", "control"], "source_lectures": ["lecture_106103359_w6_l37"]}}
{"id": "concept_sgi_challenge_flow_control", "type": "V_concept", "name": "SGI Challenge Flow Control", "properties": {"description": "A flow control implementation that uses negative acknowledgement to stop transactions", "keywords": ["sgi", "challenge", "flow", "control", "implementation"], "source_lectures": ["lecture_106103359_w6_l37"]}}
{"id": "concept_sun_enterprise_flow_control", "type": "V_concept", "name": "Sun Enterprise Flow Control", "properties": {"description": "A flow control implementation that uses receiver-initiated retries to manage flow control", "keywords": ["sun", "enterprise", "flow", "control", "implementation"], "source_lectures": ["lecture_106103359_w6_l37"]}}
{"id": "concept_read_miss", "type": "V_concept", "name": "Read Miss", "properties": {"description": "A type of cache miss where the processor wants to read data that is not in the cache.", "keywords": ["read", "processor", "miss", "data", "cache"], "source_lectures": ["lecture_106103359_w6_l38", "lecture_106103359_w7_l48", "lecture_106103359_w8_l51"]}}
{"id": "concept_write_miss", "type": "V_concept", "name": "Write Miss", "properties": {"description": "A type of cache miss where the processor wants to write data that is not in the cache.", "keywords": ["write", "processor", "request", "node", "miss", "data", "cache"], "source_lectures": ["lecture_106103359_w6_l38", "lecture_106103359_w7_l48", "lecture_106103359_w8_l51", "lecture_106103359_w8_l52"]}}
{"id": "concept_bus_read_transaction", "type": "V_concept", "name": "Bus Read Transaction", "properties": {"description": "A transaction where a processor sends a request to read data from the main memory or another cache.", "keywords": ["bus", "read", "processor", "transaction", "cache", "busread"], "source_lectures": ["lecture_106103359_w6_l38", "lecture_106103359_w4_l25"]}}
{"id": "concept_busrdx_transaction", "type": "V_concept", "name": "BusRdX Transaction", "properties": {"description": "A transaction where a processor sends a request to read and modify data from the main memory or another cache.", "keywords": ["exclusive", "busrdx", "processor", "modify", "transaction", "cache"], "source_lectures": ["lecture_106103359_w6_l38", "lecture_106103359_w4_l25"]}}
{"id": "concept_snoop_signals", "type": "V_concept", "name": "Snoop Signals", "properties": {"description": "Signals used by caches to communicate with each other and with the main memory to maintain cache coherence.", "keywords": ["snoop", "signals", "cache", "coherence"], "source_lectures": ["lecture_106103359_w6_l38"]}}
{"id": "concept_inhibit_signal", "type": "V_concept", "name": "Inhibit Signal", "properties": {"description": "A signal used by a cache to indicate that it has not finished snooping and needs more time.", "keywords": ["inhibit", "signal", "cache", "snooping"], "source_lectures": ["lecture_106103359_w6_l38"]}}
{"id": "concept_dirty_signal", "type": "V_concept", "name": "Dirty Signal", "properties": {"description": "A signal used by a cache to indicate that it has modified data that needs to be written back to the main memory.", "keywords": ["dirty", "signal", "cache", "modified"], "source_lectures": ["lecture_106103359_w6_l38"]}}
{"id": "concept_multilevel_cache_hierarchy", "type": "V_concept", "name": "Multilevel Cache Hierarchy", "properties": {"description": "A cache organization that consists of multiple levels of cache, each with its own size and access time.", "keywords": ["l2 cache", "cache hierarchy", "multilevel", "l1 cache", "organization", "miss penalty reduction", "hierarchy", "multilevel cache", "performance", "cache"], "source_lectures": ["lecture_106103359_w6_l39", "lecture_106103359_w3_l15"]}}
{"id": "concept_cache_snoop_protocol", "type": "V_concept", "name": "Cache Snoop Protocol", "properties": {"description": "A protocol that allows multiple processors to share a common bus and maintain cache coherence.", "keywords": ["cache", "snoop", "protocol", "coherence", "multiprocessor"], "source_lectures": ["lecture_106103359_w6_l39"]}}
{"id": "concept_fetch_deadlock", "type": "V_concept", "name": "Fetch Deadlock", "properties": {"description": "A situation where a processor is waiting for a response to a request, but is unable to process other requests due to limited buffer space.", "keywords": ["fetch", "deadlock", "processor", "request", "buffer"], "source_lectures": ["lecture_106103359_w6_l39"]}}
{"id": "concept_buffer_deadlock", "type": "V_concept", "name": "Buffer Deadlock", "properties": {"description": "A situation where two or more processors are waiting for each other to release a buffer, causing a circular dependency.", "keywords": ["buffer", "deadlock", "circular", "dependency", "processor"], "source_lectures": ["lecture_106103359_w6_l39"]}}
{"id": "concept_reorder_buffer", "type": "V_concept", "name": "Reorder Buffer", "properties": {"description": "A buffer that stores instructions from a processor, allowing them to be executed out of order and improving performance.", "keywords": ["buffer", "reorder buffer", "instructions", "instruction", "reorder", "processor", "rob", "commit", "pipeline", "out-of-order", "execution", "inflight", "instruction ordering"], "source_lectures": ["lecture_106103359_w6_l39", "lecture_106102229_w2_l11", "lecture_106103359_w10_l69"]}}
{"id": "concept_lockup_free_cache", "type": "V_concept", "name": "Lockup-Free Cache", "properties": {"description": "A cache organization that allows multiple requests to be processed simultaneously, without blocking or stalling the processor.", "keywords": ["lockup-free", "cache", "organization", "performance", "processor"], "source_lectures": ["lecture_106103359_w6_l39"]}}
{"id": "concept_scalable_shared_memory_systems", "type": "V_concept", "name": "Scalable Shared Memory Systems", "properties": {"description": "A type of parallel computer architecture that allows multiple processors to share a common memory space, enabling efficient communication and data exchange between processors.", "keywords": ["scalable", "shared", "memory", "systems", "parallel"], "source_lectures": ["lecture_106103359_w6_l40"]}}
{"id": "concept_directory_cache_coherence", "type": "V_concept", "name": "Directory Cache Coherence", "properties": {"description": "A protocol used to maintain cache coherence in a scalable shared memory system, where a directory is used to keep track of the location of cached data.", "keywords": ["directory", "cache", "coherence", "scalable", "shared"], "source_lectures": ["lecture_106103359_w6_l40"]}}
{"id": "concept_snooping_cache_coherence", "type": "V_concept", "name": "Snooping Cache Coherence", "properties": {"description": "A protocol used to maintain cache coherence in a shared memory system, where each processor snoops on the bus to detect changes to shared data.", "keywords": ["snooping", "cache", "coherence", "shared", "bus"], "source_lectures": ["lecture_106103359_w6_l40"]}}
{"id": "concept_cache_coherence_problem", "type": "V_concept", "name": "Cache Coherence Problem", "properties": {"description": "The problem of ensuring that changes to shared data are properly propagated to all caches in a shared memory system.", "keywords": ["cache", "coherence", "problem", "shared", "memory"], "source_lectures": ["lecture_106103359_w6_l40"]}}
{"id": "concept_hierarchical_snooping", "type": "V_concept", "name": "Hierarchical Snooping", "properties": {"description": "A technique used to improve the scalability of snooping cache coherence protocols by organizing processors into a hierarchical structure.", "keywords": ["hierarchical", "snooping", "scalability", "cache", "coherence"], "source_lectures": ["lecture_106103359_w6_l40"]}}
{"id": "concept_directory_based_protocol", "type": "V_concept", "name": "Directory-Based Protocol", "properties": {"description": "A type of cache coherence protocol that uses a directory to keep track of the location of cached data.", "keywords": ["coherence", "based", "protocol", "centralized", "directory", "cache"], "source_lectures": ["lecture_106103359_w6_l40", "lecture_106103359_w4_l22", "lecture_106103359_w10_l67"]}}
{"id": "concept_scalable_interconnect", "type": "V_concept", "name": "Scalable Interconnect", "properties": {"description": "A type of interconnect that allows multiple processors to communicate with each other in a scalable and efficient manner.", "keywords": ["high-speed", "efficient", "processors", "scalable", "communication", "interconnect"], "source_lectures": ["lecture_106103359_w6_l40", "lecture_106103359_w11_l71"]}}
{"id": "concept_cache_state", "type": "V_concept", "name": "Cache State", "properties": {"description": "The state of a cache line, which can be either valid, invalid, or modified.", "keywords": ["state", "valid", "shared", "invalid", "modified", "cache"], "source_lectures": ["lecture_106103359_w6_l40", "lecture_106103359_w4_l23", "lecture_106103359_w4_l25"]}}
{"id": "concept_two_level_hierarchy", "type": "V_concept", "name": "Two-Level Hierarchy", "properties": {"description": "A technique used to improve the scalability of cache coherence protocols by organizing processors into a two-level hierarchical structure.", "keywords": ["coherence", "level", "hierarchy", "system", "scalability", "cache", "two"], "source_lectures": ["lecture_106103359_w6_l40", "lecture_106103359_w7_l44"]}}
{"id": "concept_cc_numa_architecture", "type": "V_concept", "name": "CC-NUMA Architecture", "properties": {"description": "A type of parallel computer architecture that uses a cache-coherent non-uniform memory access (CC-NUMA) protocol to manage shared memory.", "keywords": ["coherence", "access", "cc", "coherent", "cache", "memory", "numa", "non", "architecture", "cc-numa", "uniform"], "source_lectures": ["lecture_106103359_w6_l40", "lecture_106103359_w7_l46"]}}
{"id": "concept_home_node", "type": "V_concept", "name": "Home Node", "properties": {"description": "A node in a system where a data block is stored in its memory slice.", "keywords": ["home", "memory", "slice", "authority", "system", "shared", "distributed", "node", "management", "central", "consistency"], "source_lectures": ["lecture_106103359_w6_l41", "lecture_106103359_w7_l45", "lecture_106103359_w7_l49", "lecture_106103359_w8_l52"]}}
{"id": "concept_dirty_node", "type": "V_concept", "name": "Dirty Node", "properties": {"description": "A node that has a data block in a modified state and needs to write it back to memory.", "keywords": ["distributed", "dirty", "state", "modified", "node"], "source_lectures": ["lecture_106103359_w6_l41", "lecture_106103359_w7_l45"]}}
{"id": "concept_owner_node", "type": "V_concept", "name": "Owner Node", "properties": {"description": "A node that has a valid copy of a data item and is responsible for providing it when requested.", "keywords": ["owner", "node", "valid", "copy"], "source_lectures": ["lecture_106103359_w6_l41"]}}
{"id": "concept_exclusive_node", "type": "V_concept", "name": "Exclusive Node", "properties": {"description": "A node that has the only copy of a data block in the system, either in a clean or dirty state.", "keywords": ["exclusive", "node", "copy", "state"], "source_lectures": ["lecture_106103359_w6_l41"]}}
{"id": "concept_local_node", "type": "V_concept", "name": "Local Node", "properties": {"description": "A node that contains the processor issuing a request for a data block.", "keywords": ["local", "node", "processor", "request"], "source_lectures": ["lecture_106103359_w6_l41"]}}
{"id": "concept_remote_node", "type": "V_concept", "name": "Remote Node", "properties": {"description": "A node that does not contain the processor issuing a request for a data block.", "keywords": ["remote", "node", "processor", "request"], "source_lectures": ["lecture_106103359_w6_l41"]}}
{"id": "concept_directory", "type": "V_concept", "name": "Directory", "properties": {"description": "A data structure that maintains information about the nodes in a system and their cached data items.", "keywords": ["directory", "data", "structure", "nodes"], "source_lectures": ["lecture_106103359_w6_l41"]}}
{"id": "concept_presence_bit_vector", "type": "V_concept", "name": "Presence Bit Vector", "properties": {"description": "A bit vector used by a directory to keep track of which nodes have cached a particular data item.", "keywords": ["block", "bit", "vector", "presence", "directory", "line", "cache"], "source_lectures": ["lecture_106103359_w6_l41", "lecture_106103359_w6_l42", "lecture_106103359_w7_l48", "lecture_106103359_w10_l67"]}}
{"id": "concept_dirty_bit", "type": "V_concept", "name": "Dirty Bit", "properties": {"description": "A bit used by a directory to indicate whether a data item has been modified by a node.", "keywords": ["dirty", "bit", "coherence", "write", "directory", "modified", "cache", "page"], "source_lectures": ["lecture_106103359_w6_l41", "lecture_106103359_w3_l18", "lecture_106103359_w10_l67"]}}
{"id": "concept_read_request", "type": "V_concept", "name": "Read Request", "properties": {"description": "A request from a processor to read a data block from memory or a remote node.", "keywords": ["read", "request", "processor", "memory"], "source_lectures": ["lecture_106103359_w6_l41"]}}
{"id": "concept_write_request", "type": "V_concept", "name": "Write Request", "properties": {"description": "A request from a processor to write a data block to memory or a remote node.", "keywords": ["write", "request", "processor", "memory"], "source_lectures": ["lecture_106103359_w6_l41"]}}
{"id": "concept_block_replacement", "type": "V_concept", "name": "Block Replacement", "properties": {"description": "The process of replacing a data block in a node's cache with a new block from memory or a remote node.", "keywords": ["block", "replacement", "cache", "memory"], "source_lectures": ["lecture_106103359_w6_l41"]}}
{"id": "concept_centralized_directory_organization", "type": "V_concept", "name": "Centralized Directory Organization", "properties": {"description": "A directory organization where all directory information is stored in a single, central location.", "keywords": ["centralized", "directory", "organization", "single", "location"], "source_lectures": ["lecture_106103359_w6_l42"]}}
{"id": "concept_distributed_directory_organization", "type": "V_concept", "name": "Distributed Directory Organization", "properties": {"description": "A directory organization where directory information is distributed across multiple nodes or locations.", "keywords": ["distributed", "directory", "organization", "multiple", "nodes"], "source_lectures": ["lecture_106103359_w6_l42"]}}
{"id": "concept_flat_directory_organization", "type": "V_concept", "name": "Flat Directory Organization", "properties": {"description": "A type of distributed directory organization where directory information is stored in a flat, non-hierarchical structure.", "keywords": ["flat", "directory", "organization", "distributed", "non-hierarchical"], "source_lectures": ["lecture_106103359_w6_l42"]}}
{"id": "concept_hierarchical_directory_organization", "type": "V_concept", "name": "Hierarchical Directory Organization", "properties": {"description": "A type of distributed directory organization where directory information is stored in a hierarchical, tree-like structure.", "keywords": ["hierarchical", "directory", "organization", "distributed", "tree-like"], "source_lectures": ["lecture_106103359_w6_l42"]}}
{"id": "concept_memory_based_directory_organization", "type": "V_concept", "name": "Memory-Based Directory Organization", "properties": {"description": "A type of flat directory organization where directory information is stored in memory.", "keywords": ["memory-based", "directory", "organization", "flat", "memory"], "source_lectures": ["lecture_106103359_w6_l42"]}}
{"id": "concept_cache_based_directory_organization", "type": "V_concept", "name": "Cache-Based Directory Organization", "properties": {"description": "A type of flat directory organization where directory information is stored in cache.", "keywords": ["cache-based", "directory", "organization", "flat", "cache"], "source_lectures": ["lecture_106103359_w6_l42"]}}
{"id": "concept_directory_information", "type": "V_concept", "name": "Directory Information", "properties": {"description": "Information about the sharers of a given block or memory location.", "keywords": ["directory", "information", "sharers", "block", "memory"], "source_lectures": ["lecture_106103359_w6_l42"]}}
{"id": "concept_linked_list", "type": "V_concept", "name": "Linked List", "properties": {"description": "A data structure where each element points to the next element in the list.", "keywords": ["linked", "list", "data", "structure", "element"], "source_lectures": ["lecture_106103359_w6_l42"]}}
{"id": "concept_snooping", "type": "V_concept", "name": "Snooping", "properties": {"description": "A technique used in cache coherence protocols to monitor and update cache state.", "keywords": ["snooping", "cache", "coherence", "protocol", "technique"], "source_lectures": ["lecture_106103359_w6_l42"]}}
{"id": "concept_bit_vector", "type": "V_concept", "name": "Bit Vector", "properties": {"description": "A data structure used to represent a set of bits or flags.", "keywords": ["sharing", "vector", "data", "state", "cache", "line", "bit", "flags", "structure"], "source_lectures": ["lecture_106103359_w6_l42", "lecture_106103359_w7_l43", "lecture_106103359_w7_l47", "lecture_106103359_w7_l48"]}}
{"id": "concept_invalidation_message", "type": "V_concept", "name": "Invalidation Message", "properties": {"description": "A message sent to invalidate a block in a cache.", "keywords": ["processor", "directory", "message", "invalidation", "cache", "block"], "source_lectures": ["lecture_106103359_w6_l42", "lecture_106103359_w7_l48"]}}
{"id": "concept_update_message", "type": "V_concept", "name": "Update Message", "properties": {"description": "A message sent to update a block in a cache.", "keywords": ["update", "message", "cache", "block"], "source_lectures": ["lecture_106103359_w6_l42"]}}
{"id": "concept_read_operation", "type": "V_concept", "name": "Read Operation", "properties": {"description": "An operation that retrieves data from a memory location.", "keywords": ["location", "memory", "read", "operation", "data", "retrieve"], "source_lectures": ["lecture_106103359_w6_l42", "lecture_106103359_w3_l20"]}}
{"id": "concept_write_operation", "type": "V_concept", "name": "Write Operation", "properties": {"description": "An operation that writes data to a memory location.", "keywords": ["location", "memory", "write", "modify", "operation", "data"], "source_lectures": ["lecture_106103359_w6_l42", "lecture_106103359_w3_l20"]}}
{"id": "concept_latency", "type": "V_concept", "name": "Latency", "properties": {"description": "The time delay between a request and a response.", "keywords": ["time", "delay", "latency", "movement", "virtual", "response", "network", "real-time", "request", "application", "performance", "applications"], "source_lectures": ["lecture_106103359_w6_l42", "lecture_106104449_w1_l3", "lecture_106104449_w2_l12", "lecture_106103842_w2_l10"]}}
{"id": "concept_traffic", "type": "V_concept", "name": "Traffic", "properties": {"description": "The amount of data or messages transmitted over a network.", "keywords": ["traffic", "data", "messages", "network"], "source_lectures": ["lecture_106103359_w6_l42"]}}
{"id": "concept_storage_overhead", "type": "V_concept", "name": "Storage Overhead", "properties": {"description": "The additional storage required to implement a directory organization.", "keywords": ["storage", "overhead", "directory", "organization"], "source_lectures": ["lecture_106103359_w6_l42"]}}
{"id": "concept_fairness", "type": "V_concept", "name": "Fairness", "properties": {"description": "The ability of a system to provide equal access to resources.", "keywords": ["fairness", "system", "resources", "access"], "source_lectures": ["lecture_106103359_w6_l42"]}}
{"id": "concept_directory_organization", "type": "V_concept", "name": "Directory Organization", "properties": {"description": "A way to structure and manage directory information in a shared memory system.", "keywords": ["memory", "coherence", "organization", "shared", "directory", "cache"], "source_lectures": ["lecture_106103359_w7_l43", "lecture_106103359_w10_l67"]}}
{"id": "concept_centralized_directory", "type": "V_concept", "name": "Centralized Directory", "properties": {"description": "A directory organization where all directory information is stored in a single location.", "keywords": ["centralized", "directory", "single", "location"], "source_lectures": ["lecture_106103359_w7_l43"]}}
{"id": "concept_distributed_directory", "type": "V_concept", "name": "Distributed Directory", "properties": {"description": "A directory organization where directory information is spread across multiple locations.", "keywords": ["distributed", "directory", "multiple", "locations"], "source_lectures": ["lecture_106103359_w7_l43"]}}
{"id": "concept_flat_memory_based_directory", "type": "V_concept", "name": "Flat Memory-Based Directory", "properties": {"description": "A type of distributed directory organization that uses a flat memory structure.", "keywords": ["flat", "memory-based", "directory", "distributed"], "source_lectures": ["lecture_106103359_w7_l43"]}}
{"id": "concept_cache_based_directory", "type": "V_concept", "name": "Cache-Based Directory", "properties": {"description": "A type of distributed directory organization that uses a cache structure.", "keywords": ["cache-based", "directory", "distributed", "cache"], "source_lectures": ["lecture_106103359_w7_l43"]}}
{"id": "concept_directory_storage_overhead", "type": "V_concept", "name": "Directory Storage Overhead", "properties": {"description": "The additional storage required to maintain directory information.", "keywords": ["directory", "storage", "overhead", "additional"], "source_lectures": ["lecture_106103359_w7_l43"]}}
{"id": "concept_p_term_optimization", "type": "V_concept", "name": "P-Term Optimization", "properties": {"description": "A technique to reduce directory storage overhead by optimizing the P-term.", "keywords": ["p-term", "optimization", "directory", "storage"], "source_lectures": ["lecture_106103359_w7_l43"]}}
{"id": "concept_m_term_optimization", "type": "V_concept", "name": "M-Term Optimization", "properties": {"description": "A technique to reduce directory storage overhead by optimizing the M-term.", "keywords": ["m-term", "optimization", "directory", "storage"], "source_lectures": ["lecture_106103359_w7_l43"]}}
{"id": "concept_sparse_directory", "type": "V_concept", "name": "Sparse Directory", "properties": {"description": "A type of directory organization that only stores information for actively shared memory blocks.", "keywords": ["sparse", "directory", "shared", "memory"], "source_lectures": ["lecture_106103359_w7_l43"]}}
{"id": "concept_broadcast_overflow_scheme", "type": "V_concept", "name": "Broadcast Overflow Scheme", "properties": {"description": "A method to handle overflow in directory organizations by broadcasting invalidations to all nodes.", "keywords": ["broadcast", "overflow", "scheme", "invalidations"], "source_lectures": ["lecture_106103359_w7_l43"]}}
{"id": "concept_no_broadcast_overflow_scheme", "type": "V_concept", "name": "No Broadcast Overflow Scheme", "properties": {"description": "A method to handle overflow in directory organizations by not broadcasting invalidations.", "keywords": ["no", "broadcast", "overflow", "scheme"], "source_lectures": ["lecture_106103359_w7_l43"]}}
{"id": "concept_coarse_vector_overflow_scheme", "type": "V_concept", "name": "Coarse Vector Overflow Scheme", "properties": {"description": "A method to handle overflow in directory organizations by using a coarse vector to represent sharers.", "keywords": ["coarse", "vector", "overflow", "scheme"], "source_lectures": ["lecture_106103359_w7_l43"]}}
{"id": "concept_software_overflow_scheme", "type": "V_concept", "name": "Software Overflow Scheme", "properties": {"description": "A method to handle overflow in directory organizations by using software to manage overflow.", "keywords": ["software", "overflow", "scheme", "management"], "source_lectures": ["lecture_106103359_w7_l43"]}}
{"id": "concept_dynamic_pointers_overflow_scheme", "type": "V_concept", "name": "Dynamic Pointers Overflow Scheme", "properties": {"description": "A method to handle overflow in directory organizations by using dynamic pointers to manage overflow.", "keywords": ["dynamic", "pointers", "overflow", "scheme"], "source_lectures": ["lecture_106103359_w7_l43"]}}
{"id": "concept_directory_protocol", "type": "V_concept", "name": "Directory Protocol", "properties": {"description": "A protocol used to maintain cache coherence in a shared memory system", "keywords": ["coherence", "protocol", "system", "shared memory", "distributed", "directory", "cache"], "source_lectures": ["lecture_106103359_w7_l44", "lecture_106103359_w7_l47", "lecture_106102229_w5_l29", "lecture_106103359_w4_l23", "lecture_106103359_w8_l52"]}}
{"id": "concept_strict_request_response", "type": "V_concept", "name": "Strict Request Response", "properties": {"description": "A communication method where a request is guaranteed to receive a response", "keywords": ["acknowledgment", "response", "protocol", "strict", "request", "communication"], "source_lectures": ["lecture_106103359_w7_l44", "lecture_106103359_w7_l46", "lecture_106103359_w10_l67"]}}
{"id": "concept_intervention_forwarding", "type": "V_concept", "name": "Intervention Forwarding", "properties": {"description": "A communication method where a node sends a request on behalf of another node", "keywords": ["intervention", "protocol", "request", "node", "optimization", "forwarding", "communication"], "source_lectures": ["lecture_106103359_w7_l44", "lecture_106103359_w7_l46", "lecture_106103359_w10_l67"]}}
{"id": "concept_reply_forwarding", "type": "V_concept", "name": "Reply Forwarding", "properties": {"description": "A communication method where a node sends a response directly to the requesting node", "keywords": ["latency", "reply", "owner", "response", "protocol", "node", "optimization", "forwarding", "directory", "communication"], "source_lectures": ["lecture_106103359_w7_l44", "lecture_106103359_w7_l46", "lecture_106103359_w7_l47", "lecture_106103359_w7_l48", "lecture_106103359_w10_l67"]}}
{"id": "concept_memory_based_system", "type": "V_concept", "name": "Memory Based System", "properties": {"description": "A system where directory information is stored in memory", "keywords": ["memory", "based", "system", "directory"], "source_lectures": ["lecture_106103359_w7_l44"]}}
{"id": "concept_cache_based_system", "type": "V_concept", "name": "Cache Based System", "properties": {"description": "A system where directory information is stored in a cache", "keywords": ["cache", "based", "system", "directory"], "source_lectures": ["lecture_106103359_w7_l44"]}}
{"id": "concept_network_latency", "type": "V_concept", "name": "Network Latency", "properties": {"description": "The time it takes for data to travel through a network", "keywords": ["network", "latency", "time", "data"], "source_lectures": ["lecture_106103359_w7_l44"]}}
{"id": "concept_communication_assist", "type": "V_concept", "name": "Communication Assist", "properties": {"description": "A hardware component that assists in communication between nodes", "keywords": ["communication", "assist", "hardware", "node"], "source_lectures": ["lecture_106103359_w7_l44"]}}
{"id": "concept_deadlock_avoidance", "type": "V_concept", "name": "Deadlock Avoidance", "properties": {"description": "Techniques used to prevent deadlocks in a system", "keywords": ["deadlock", "avoidance", "technique", "system"], "source_lectures": ["lecture_106103359_w7_l44"]}}
{"id": "concept_pipelined_design", "type": "V_concept", "name": "Pipelined Design", "properties": {"description": "A design technique where multiple tasks are executed in a pipeline fashion", "keywords": ["pipelined", "design", "technique", "pipeline"], "source_lectures": ["lecture_106103359_w7_l44"]}}
{"id": "concept_sram_directory", "type": "V_concept", "name": "SRAM Directory", "properties": {"description": "A directory stored in Static Random Access Memory (SRAM)", "keywords": ["sram", "directory", "memory", "static"], "source_lectures": ["lecture_106103359_w7_l44"]}}
{"id": "concept_machine_organization", "type": "V_concept", "name": "Machine Organization", "properties": {"description": "The way components are organized in a machine", "keywords": ["machine", "organization", "component"], "source_lectures": ["lecture_106103359_w7_l44"]}}
{"id": "concept_protocol_optimization", "type": "V_concept", "name": "Protocol Optimization", "properties": {"description": "The process of improving the performance of a protocol", "keywords": ["protocol", "optimization", "performance"], "source_lectures": ["lecture_106103359_w7_l44"]}}
{"id": "concept_scalable_shared_memory_system", "type": "V_concept", "name": "Scalable Shared Memory System", "properties": {"description": "A system that allows multiple processors to share memory and scale to a large number of processors.", "keywords": ["scalable", "shared", "memory", "system"], "source_lectures": ["lecture_106103359_w7_l45"]}}
{"id": "concept_correctness_protocol", "type": "V_concept", "name": "Correctness Protocol", "properties": {"description": "A protocol that ensures the correctness of a system by guaranteeing coherence, consistency, and freedom from deadlock, livelock, and starvation.", "keywords": ["correctness", "protocol", "coherence", "consistency"], "source_lectures": ["lecture_106103359_w7_l45"]}}
{"id": "concept_coherence", "type": "V_concept", "name": "Coherence", "properties": {"description": "The property of a system that ensures all shared blocks are either updated or invalidated before a new value can be written.", "keywords": ["coherence", "shared", "blocks", "updated"], "source_lectures": ["lecture_106103359_w7_l45"]}}
{"id": "concept_consistency", "type": "V_concept", "name": "Consistency", "properties": {"description": "The property of a system that ensures all nodes see the same value for a shared variable.", "keywords": ["consistency", "nodes", "shared", "variable"], "source_lectures": ["lecture_106103359_w7_l45"]}}
{"id": "concept_deadlock_freedom", "type": "V_concept", "name": "Deadlock Freedom", "properties": {"description": "The property of a system that ensures no two or more processes are blocked indefinitely, each waiting for the other to release a resource.", "keywords": ["freedom", "deadlock", "resource", "process", "system", "blocked", "processes"], "source_lectures": ["lecture_106103359_w7_l45", "lecture_106103359_w7_l46"]}}
{"id": "concept_livelock_freedom", "type": "V_concept", "name": "Livelock Freedom", "properties": {"description": "The property of a system that ensures no two or more processes are unable to proceed because they are too busy responding to each other's requests.", "keywords": ["freedom", "livelock", "system", "progress", "retry", "processes", "responding"], "source_lectures": ["lecture_106103359_w7_l45", "lecture_106103359_w7_l46"]}}
{"id": "concept_starvation_freedom", "type": "V_concept", "name": "Starvation Freedom", "properties": {"description": "The property of a system that ensures no process is indefinitely denied access to a resource.", "keywords": ["freedom", "resource", "process", "system", "starvation"], "source_lectures": ["lecture_106103359_w7_l45", "lecture_106103359_w7_l46"]}}
{"id": "concept_buffering", "type": "V_concept", "name": "Buffering", "properties": {"description": "A technique used to manage multiple requests to a shared resource by storing them in a buffer.", "keywords": ["buffering", "requests", "shared", "resource"], "source_lectures": ["lecture_106103359_w7_l45"]}}
{"id": "concept_nack_on_retry", "type": "V_concept", "name": "NACK on Retry", "properties": {"description": "A technique used to manage multiple requests to a shared resource by sending a negative acknowledgement and retrying later.", "keywords": ["nack", "retry", "requests", "shared"], "source_lectures": ["lecture_106103359_w7_l45"]}}
{"id": "concept_forward_to_dirty_node", "type": "V_concept", "name": "Forward to Dirty Node", "properties": {"description": "A technique used to manage multiple requests to a shared resource by forwarding them to the dirty node.", "keywords": ["forward", "dirty", "node", "requests"], "source_lectures": ["lecture_106103359_w7_l45"]}}
{"id": "concept_local_serialization", "type": "V_concept", "name": "Local Serialization", "properties": {"description": "The process of ensuring that each node in a system serves incoming transactions in a serial order.", "keywords": ["local", "serialization", "node", "transactions"], "source_lectures": ["lecture_106103359_w7_l45"]}}
{"id": "concept_global_serialization_entity", "type": "V_concept", "name": "Global Serialization Entity", "properties": {"description": "An entity in a system that is responsible for ensuring global serialization.", "keywords": ["global", "serialization", "entity", "system"], "source_lectures": ["lecture_106103359_w7_l45"]}}
{"id": "concept_write_completion", "type": "V_concept", "name": "Write Completion", "properties": {"description": "The state when a write operation has been acknowledged by all nodes in a system, ensuring that the write is visible to all.", "keywords": ["write", "completion", "acknowledgement", "memory", "coherence"], "source_lectures": ["lecture_106103359_w7_l46"]}}
{"id": "concept_invalidation_based_protocol", "type": "V_concept", "name": "Invalidation Based Protocol", "properties": {"description": "A type of cache coherence protocol that uses invalidation messages to ensure consistency of shared data.", "keywords": ["multiprocessor", "memory", "coherence", "protocol", "based", "invalidation", "cache"], "source_lectures": ["lecture_106103359_w7_l46", "lecture_106103359_w4_l24", "lecture_106103359_w4_l25", "lecture_106103359_w4_l26", "lecture_106103359_w10_l70"]}}
{"id": "concept_fifo_buffer", "type": "V_concept", "name": "FIFO Buffer", "properties": {"description": "A type of buffer that stores requests in the order they are received and serves them in that order.", "keywords": ["requests", "order", "fifo", "request", "buffer", "serving"], "source_lectures": ["lecture_106103359_w7_l46", "lecture_106103359_w7_l49"]}}
{"id": "concept_nack_based_protocol", "type": "V_concept", "name": "NACK Based Protocol", "properties": {"description": "A type of protocol that uses negative acknowledgments to handle failed operations and prevent deadlocks.", "keywords": ["nack", "protocol", "negative", "acknowledgment", "deadlock"], "source_lectures": ["lecture_106103359_w7_l46"]}}
{"id": "concept_sgi_origin_architecture", "type": "V_concept", "name": "SGI Origin Architecture", "properties": {"description": "A parallel computer architecture that uses a directory protocol to maintain cache coherence", "keywords": ["directory", "parallel", "multiprocessor", "origin", "sgi", "architecture"], "source_lectures": ["lecture_106103359_w7_l47", "lecture_106103359_w7_l48"]}}
{"id": "concept_speculative_reply", "type": "V_concept", "name": "Speculative Reply", "properties": {"description": "A technique used in the SGI Origin architecture to optimize latency by sending data to the requester in parallel with the directory protocol", "keywords": ["directory", "optimization", "requester", "latency", "speculative", "reply"], "source_lectures": ["lecture_106103359_w7_l47", "lecture_106103359_w7_l48"]}}
{"id": "concept_directory_states", "type": "V_concept", "name": "Directory States", "properties": {"description": "The different states that a directory can be in, including unowned, shared, exclusive, and busy states", "keywords": ["directory", "states", "unowned", "shared", "exclusive"], "source_lectures": ["lecture_106103359_w7_l47"]}}
{"id": "concept_coarse_vector_format", "type": "V_concept", "name": "Coarse Vector Format", "properties": {"description": "A method of representing the sharing of cache lines among multiple nodes in a distributed system, where each bit in the vector represents multiple nodes", "keywords": ["coarse", "vector", "format", "sharing"], "source_lectures": ["lecture_106103359_w7_l47"]}}
{"id": "concept_xbow_switch", "type": "V_concept", "name": "Xbow Switch", "properties": {"description": "A type of switch used in the SGI Origin architecture to connect multiple nodes in a distributed system", "keywords": ["xbow", "switch", "distributed", "system"], "source_lectures": ["lecture_106103359_w7_l47"]}}
{"id": "concept_hub", "type": "V_concept", "name": "Hub", "properties": {"description": "A module in the SGI Origin architecture that connects multiple nodes in a distributed system and manages cache coherence", "keywords": ["hub", "module", "cache", "coherence"], "source_lectures": ["lecture_106103359_w7_l47"]}}
{"id": "concept_directory_controller", "type": "V_concept", "name": "Directory Controller", "properties": {"description": "A module in the SGI Origin architecture that manages the directory protocol and maintains cache coherence", "keywords": ["memory", "coherence", "controller", "distributed", "shared", "directory", "cache"], "source_lectures": ["lecture_106103359_w7_l47", "lecture_106103359_w8_l51"]}}
{"id": "concept_directory_coherence_protocol", "type": "V_concept", "name": "Directory Coherence Protocol", "properties": {"description": "A protocol that ensures coherence between multiple caches in a multiprocessor system by maintaining a directory of cache states", "keywords": ["multiprocessor", "cache", "memory", "coherence", "protocol", "parallel", "system", "distributed", "directory", "consistency"], "source_lectures": ["lecture_106103359_w7_l48", "lecture_106103359_w7_l49", "lecture_106103359_w8_l50", "lecture_106103359_w8_l51"]}}
{"id": "concept_shared_state", "type": "V_concept", "name": "Shared State", "properties": {"description": "A state where multiple processors have shared access to a data block", "keywords": ["block", "processors", "mesi", "state", "shared", "data", "cache"], "source_lectures": ["lecture_106103359_w7_l48", "lecture_106103359_w4_l26"]}}
{"id": "concept_busy_state", "type": "V_concept", "name": "Busy State", "properties": {"description": "A state where the directory is busy handling a request and cannot accept new requests", "keywords": ["directory", "requests", "busy", "state", "request", "node"], "source_lectures": ["lecture_106103359_w7_l48", "lecture_106103359_w7_l49"]}}
{"id": "concept_acknowledgement_message", "type": "V_concept", "name": "Acknowledgement Message", "properties": {"description": "A message sent by a processor to the directory to acknowledge a request", "keywords": ["acknowledgement", "message", "processor", "directory", "request"], "source_lectures": ["lecture_106103359_w7_l48"]}}
{"id": "concept_buffer_overflow", "type": "V_concept", "name": "Buffer Overflow", "properties": {"description": "A situation that occurs when a buffer is full and cannot accept any more requests.", "keywords": ["buffer", "overflow", "full", "requests"], "source_lectures": ["lecture_106103359_w7_l49"]}}
{"id": "concept_nack", "type": "V_concept", "name": "NACK", "properties": {"description": "A negative acknowledgement sent to a request that cannot be serviced.", "keywords": ["nack", "negative", "acknowledgement", "request"], "source_lectures": ["lecture_106103359_w7_l49"]}}
{"id": "concept_request_response_protocol", "type": "V_concept", "name": "Request Response Protocol", "properties": {"description": "A protocol that governs the interaction between a requester and a responder in a distributed system.", "keywords": ["request", "response", "protocol", "distributed"], "source_lectures": ["lecture_106103359_w7_l49"]}}
{"id": "concept_origin_protocol", "type": "V_concept", "name": "Origin Protocol", "properties": {"description": "A protocol used in the SGI Origin system to manage requests and maintain consistency.", "keywords": ["origin", "protocol", "sgi", "consistency"], "source_lectures": ["lecture_106103359_w7_l49"]}}
{"id": "concept_sgi_origin", "type": "V_concept", "name": "SGI Origin", "properties": {"description": "A distributed system that uses a directory coherence protocol to maintain consistency among multiple caches.", "keywords": ["sgi", "origin", "distributed", "system"], "source_lectures": ["lecture_106103359_w7_l49"]}}
{"id": "concept_mit_alewife_processor", "type": "V_concept", "name": "MIT Alewife Processor", "properties": {"description": "A processor that uses a cache-based flat memory directory style design to manage requests and maintain consistency.", "keywords": ["mit", "alewife", "processor", "cache"], "source_lectures": ["lecture_106103359_w7_l49"]}}
{"id": "concept_stanford_dash_protocol", "type": "V_concept", "name": "Stanford DASH Protocol", "properties": {"description": "A protocol used in the Stanford DASH system to manage requests and maintain consistency.", "keywords": ["stanford", "dash", "protocol", "consistency"], "source_lectures": ["lecture_106103359_w7_l49"]}}
{"id": "concept_sci_protocol", "type": "V_concept", "name": "SCI Protocol", "properties": {"description": "A protocol that uses a distributed FIFO buffer to manage requests and maintain consistency.", "keywords": ["communication", "memory", "fifo", "protocol", "sci", "coherent", "distributed", "scalable", "interface"], "source_lectures": ["lecture_106103359_w7_l49", "lecture_106103359_w8_l50", "lecture_106103359_w8_l51"]}}
{"id": "concept_human_computer_interaction", "type": "V_concept", "name": "Human Computer Interaction", "properties": {"description": "A discipline concerned with the design, evaluation, and implementation of interactive computing systems for human use.", "keywords": ["evaluation", "usability", "interaction", "human", "design", "computer", "interface", "hci"], "source_lectures": ["lecture_106103220_w1_l2", "lecture_106103220_w1_l3", "lecture_106103220_w2_l8", "lecture_106103220_w5_l31", "lecture_106103220_w6_l37", "lecture_106103220_w6_l40"]}}
{"id": "concept_user_centric_design", "type": "V_concept", "name": "User Centric Design", "properties": {"description": "A design approach that focuses on the needs and expectations of the user.", "keywords": ["product", "centric", "approach", "human", "factors", "usability", "design", "user", "interaction"], "source_lectures": ["lecture_106103220_w1_l2", "lecture_106103220_w1_l4", "lecture_106103220_w1_l5", "lecture_106103220_w2_l8"]}}
{"id": "concept_acm_sigchi", "type": "V_concept", "name": "ACM SIGCHI", "properties": {"description": "A special interest group on human computer interaction, part of the Association for Computing Machinery.", "keywords": ["acm", "sigchi", "human", "computer", "interaction"], "source_lectures": ["lecture_106103220_w1_l2"]}}
{"id": "concept_human_factors", "type": "V_concept", "name": "Human Factors", "properties": {"description": "A broad term that refers to the study of how humans interact with systems and technology.", "keywords": ["human", "factors", "interaction", "technology", "design"], "source_lectures": ["lecture_106103220_w1_l2"]}}
{"id": "concept_user_classification", "type": "V_concept", "name": "User Classification", "properties": {"description": "A way to categorize users based on their level of expertise, such as novice, intermittent, and expert.", "keywords": ["user", "classification", "novice", "intermittent", "expert"], "source_lectures": ["lecture_106103220_w1_l2"]}}
{"id": "concept_model_based_design", "type": "V_concept", "name": "Model Based Design", "properties": {"description": "An approach to design that uses models to automate certain aspects of the design cycle.", "keywords": ["model", "based", "design", "automation", "user"], "source_lectures": ["lecture_106103220_w1_l2"]}}
{"id": "concept_iterative_design_cycle", "type": "V_concept", "name": "Iterative Design Cycle", "properties": {"description": "A process of designing, implementing, and refining a design based on user feedback.", "keywords": ["iterative", "design", "cycle", "feedback", "refine"], "source_lectures": ["lecture_106103220_w1_l2"]}}
{"id": "concept_layered_software_design", "type": "V_concept", "name": "Layered Software Design", "properties": {"description": "A way to structure software into layers, each with a specific function or purpose.", "keywords": ["layered", "software", "design", "architecture", "structure"], "source_lectures": ["lecture_106103220_w1_l2"]}}
{"id": "concept_user_modeling", "type": "V_concept", "name": "User Modeling", "properties": {"description": "The process of creating models to represent user behavior and characteristics.", "keywords": ["user", "modeling", "behavior", "characteristics", "design"], "source_lectures": ["lecture_106103220_w1_l2"]}}
{"id": "concept_computational_models_of_the_user", "type": "V_concept", "name": "Computational Models Of The User", "properties": {"description": "Mathematical or computational representations of user behavior and characteristics.", "keywords": ["computational", "cognition", "behavior", "user", "models", "characteristics"], "source_lectures": ["lecture_106103220_w1_l2", "lecture_106103220_w2_l12"]}}
{"id": "concept_user_centric_computing", "type": "V_concept", "name": "User Centric Computing", "properties": {"description": "A design approach that focuses on creating systems that are intuitive and easy to use for humans.", "keywords": ["user-centric", "computing", "interaction", "abilities", "centric", "human", "needs", "design", "user", "human-computer"], "source_lectures": ["lecture_106103220_w1_l3", "lecture_106103220_w2_l9", "lecture_106103220_w2_l10", "lecture_106103220_w2_l13", "lecture_106103220_w5_l31", "lecture_106103220_w6_l37", "lecture_106103220_w6_l40"]}}
{"id": "concept_mobile_interaction", "type": "V_concept", "name": "Mobile Interaction", "properties": {"description": "The study of how humans interact with mobile devices and design of systems that are intuitive and easy to use on these devices.", "keywords": ["mobile", "interaction", "device", "interface", "design"], "source_lectures": ["lecture_106103220_w1_l3"]}}
{"id": "concept_non_traditional_interfaces", "type": "V_concept", "name": "Non Traditional Interfaces", "properties": {"description": "Interfaces that do not use traditional screens or input methods, such as virtual reality or augmented reality environments.", "keywords": ["non", "traditional", "interfaces", "virtual", "reality"], "source_lectures": ["lecture_106103220_w1_l3"]}}
{"id": "concept_computer_mediated_communication", "type": "V_concept", "name": "Computer Mediated Communication", "properties": {"description": "The use of computers to facilitate communication between humans, such as video conferencing or instant messaging.", "keywords": ["computer", "mediated", "communication", "human", "interaction"], "source_lectures": ["lecture_106103220_w1_l3"]}}
{"id": "concept_ubiquitous_computing", "type": "V_concept", "name": "Ubiquitous Computing", "properties": {"description": "A design approach that focuses on creating systems that are embedded in the environment and interact with humans in a natural way.", "keywords": ["ubiquitous", "environment", "computing", "interaction", "respond", "aware", "natural"], "source_lectures": ["lecture_106103220_w1_l3", "lecture_106103220_w6_l37"]}}
{"id": "concept_natural_interaction", "type": "V_concept", "name": "Natural Interaction", "properties": {"description": "The use of natural human behaviors, such as speech or gesture, to interact with computers.", "keywords": ["interaction", "behavior", "human", "computer", "natural"], "source_lectures": ["lecture_106103220_w1_l3", "lecture_106103220_w6_l37"]}}
{"id": "concept_context_awareness", "type": "V_concept", "name": "Context Awareness", "properties": {"description": "The ability of a computer system to understand the context in which it is being used and adapt its behavior accordingly.", "keywords": ["context", "awareness", "computer", "system", "adaptation"], "source_lectures": ["lecture_106103220_w1_l3"]}}
{"id": "concept_peripheral_interaction", "type": "V_concept", "name": "Peripheral Interaction", "properties": {"description": "The study of how humans interact with multiple devices and systems that are competing for their attention.", "keywords": ["peripheral", "interaction", "human", "device", "attention"], "source_lectures": ["lecture_106103220_w1_l3"]}}
{"id": "concept_calm_technology", "type": "V_concept", "name": "Calm Technology", "properties": {"description": "A design approach that focuses on creating systems that are subtle and do not compete for the user's attention.", "keywords": ["calm", "technology", "design", "subtle", "attention"], "source_lectures": ["lecture_106103220_w1_l3"]}}
{"id": "concept_wimp_paradigm", "type": "V_concept", "name": "WIMP Paradigm", "properties": {"description": "A design approach that uses windows, icons, menus, and pointers to interact with computers.", "keywords": ["wimp", "paradigm", "design", "interface", "interaction"], "source_lectures": ["lecture_106103220_w1_l3"]}}
{"id": "concept_internet_of_things", "type": "V_concept", "name": "Internet of Things", "properties": {"description": "A network of physical devices, vehicles, and other items that are embedded with sensors and software to connect and exchange data.", "keywords": ["things", "device", "network", "iot", "internet", "connectivity", "sensor", "sensors"], "source_lectures": ["lecture_106103220_w1_l3", "lecture_106104449_w1_l2", "lecture_106104449_w1_l3"]}}
{"id": "concept_pervasive_computing", "type": "V_concept", "name": "Pervasive Computing", "properties": {"description": "A design approach that focuses on creating systems that are embedded in the environment and interact with humans in a natural way, with a high level of embeddedness and low mobility.", "keywords": ["pervasive", "computing", "environment", "natural", "interaction"], "source_lectures": ["lecture_106103220_w1_l3"]}}
{"id": "concept_mobile_computing", "type": "V_concept", "name": "Mobile Computing", "properties": {"description": "A design approach that focuses on creating systems that are mobile and interact with humans in a natural way, with a high level of mobility and low embeddedness.", "keywords": ["mobile", "computing", "design", "interface", "interaction"], "source_lectures": ["lecture_106103220_w1_l3"]}}
{"id": "concept_software_development_lifecycle", "type": "V_concept", "name": "Software Development Lifecycle", "properties": {"description": "A framework that outlines the stages involved in developing software, from planning to deployment and maintenance.", "keywords": ["application", "stages", "sdlc", "process", "lifecycle", "software", "development"], "source_lectures": ["lecture_106103220_w1_l4", "lecture_106103220_w1_l5", "lecture_106103220_w2_l9"]}}
{"id": "concept_waterfall_model", "type": "V_concept", "name": "Waterfall Model", "properties": {"description": "A linear software development lifecycle model that follows a sequential approach, with each stage completed before moving on to the next one.", "keywords": ["waterfall", "model", "linear", "sequential", "sdlc"], "source_lectures": ["lecture_106103220_w1_l4"]}}
{"id": "concept_usability", "type": "V_concept", "name": "Usability", "properties": {"description": "A measure of how easy it is for users to use a product or system to achieve their goals effectively, efficiently, and with satisfaction.", "keywords": ["application", "experience", "usability", "system", "use", "ease", "user"], "source_lectures": ["lecture_106103220_w1_l4", "lecture_106103220_w1_l5"]}}
{"id": "concept_iso_9241_2102009", "type": "V_concept", "name": "ISO 9241-210:2009", "properties": {"description": "An international standard that defines usability as the extent to which a product can be used by specified users to achieve specified goals with effectiveness, efficiency, and satisfaction.", "keywords": ["iso", "9241", "2009", "usability", "standard"], "source_lectures": ["lecture_106103220_w1_l4"]}}
{"id": "concept_nielsens_usability_framework", "type": "V_concept", "name": "Nielsen's Usability Framework", "properties": {"description": "A framework that proposes five quality components of usability: learnability, efficiency, memorability, errors, and satisfaction.", "keywords": ["nielsen", "usability", "framework", "quality", "components"], "source_lectures": ["lecture_106103220_w1_l4"]}}
{"id": "concept_learnability", "type": "V_concept", "name": "Learnability", "properties": {"description": "A measure of how easy it is for a first-time user to perform basic tasks with a system.", "keywords": ["learnability", "usability", "user", "experience", "ease"], "source_lectures": ["lecture_106103220_w1_l4"]}}
{"id": "concept_efficiency", "type": "V_concept", "name": "Efficiency", "properties": {"description": "A measure of the speed at which users can perform tasks with a system.", "keywords": ["efficiency", "usability", "resources", "parallel", "speed", "user", "experience", "processing"], "source_lectures": ["lecture_106103220_w1_l4", "lecture_106103359_w1_l6"]}}
{"id": "concept_memorability", "type": "V_concept", "name": "Memorability", "properties": {"description": "A measure of how easily an intermittent user can reestablish proficiency with a system after some time has passed.", "keywords": ["memorability", "usability", "user", "experience", "memory"], "source_lectures": ["lecture_106103220_w1_l4"]}}
{"id": "concept_human_centered_design", "type": "V_concept", "name": "Human Centered Design", "properties": {"description": "A design approach that focuses on creating products that are centered on human needs and goals.", "keywords": ["human", "centered", "design", "usability", "user"], "source_lectures": ["lecture_106103220_w1_l4"]}}
{"id": "concept_iterative_lifecycle_model", "type": "V_concept", "name": "Iterative Lifecycle Model", "properties": {"description": "A software development lifecycle model that involves iterative stages, with feedback and refinement at each stage.", "keywords": ["iterative", "lifecycle", "model", "software", "development"], "source_lectures": ["lecture_106103220_w1_l4"]}}
{"id": "concept_contextual_inquiry", "type": "V_concept", "name": "Contextual Inquiry", "properties": {"description": "A research method used to gather information about users' behavior and needs in a specific context.", "keywords": ["contextual", "method", "inquiry", "user", "research"], "source_lectures": ["lecture_106103220_w1_l5", "lecture_106103220_w2_l8"]}}
{"id": "concept_requirement_gathering", "type": "V_concept", "name": "Requirement Gathering", "properties": {"description": "The process of collecting and documenting the requirements of a system or application.", "keywords": ["requirement", "gathering", "process", "system", "application"], "source_lectures": ["lecture_106103220_w1_l5"]}}
{"id": "concept_active_inquiry", "type": "V_concept", "name": "Active Inquiry", "properties": {"description": "A method of contextual inquiry where the observer is physically present in the work environment.", "keywords": ["active", "inquiry", "method", "observer", "environment"], "source_lectures": ["lecture_106103220_w1_l5"]}}
{"id": "concept_passive_inquiry", "type": "V_concept", "name": "Passive Inquiry", "properties": {"description": "A method of contextual inquiry where the observer is not physically present in the work environment.", "keywords": ["passive", "inquiry", "method", "observer", "environment"], "source_lectures": ["lecture_106103220_w1_l5"]}}
{"id": "concept_affinity_diagram", "type": "V_concept", "name": "Affinity Diagram", "properties": {"description": "A tool used to organize and analyze data in contextual inquiry.", "keywords": ["affinity", "diagram", "tool", "data", "analysis"], "source_lectures": ["lecture_106103220_w1_l5"]}}
{"id": "concept_iterative_design", "type": "V_concept", "name": "Iterative Design", "properties": {"description": "A design approach that involves repeated cycles of design, testing, and refinement.", "keywords": ["iterative", "design", "approach", "cycle", "refinement"], "source_lectures": ["lecture_106103220_w1_l5"]}}
{"id": "concept_empirical_study", "type": "V_concept", "name": "Empirical Study", "properties": {"description": "A research method that involves collecting and analyzing data through observation or experimentation.", "keywords": ["empirical", "study", "research", "method", "data"], "source_lectures": ["lecture_106103220_w1_l5"]}}
{"id": "concept_interactive_development_lifecycle", "type": "V_concept", "name": "Interactive Development Lifecycle", "properties": {"description": "A process for developing interactive systems, involving stages such as requirement gathering, design, prototyping, and empirical study.", "keywords": ["interactive", "development", "lifecycle", "software", "design"], "source_lectures": ["lecture_106103220_w1_l6"]}}
{"id": "concept_contextual_inquiry_method", "type": "V_concept", "name": "Contextual Inquiry Method", "properties": {"description": "A research method used to gather information about users and their needs, involving observation and interviews.", "keywords": ["contextual", "inquiry", "research", "method", "users"], "source_lectures": ["lecture_106103220_w1_l6"]}}
{"id": "concept_design_guidelines", "type": "V_concept", "name": "Design Guidelines", "properties": {"description": "A set of principles and rules used to guide the design of interactive systems, ensuring consistency and usability.", "keywords": ["guidelines", "usability", "principles", "design", "standards", "interactive"], "source_lectures": ["lecture_106103220_w1_l6", "lecture_106103220_w2_l8"]}}
{"id": "concept_eight_golden_rules", "type": "V_concept", "name": "Eight Golden Rules", "properties": {"description": "A set of design principles proposed by Ben Schneiderman, aiming to improve the usability of interactive systems.", "keywords": ["eight", "golden", "rules", "design", "usability"], "source_lectures": ["lecture_106103220_w1_l6"]}}
{"id": "concept_strive_for_consistency", "type": "V_concept", "name": "Strive For Consistency", "properties": {"description": "A design principle that aims to ensure consistency in the design of interactive systems, both internally and externally.", "keywords": ["consistency", "design", "principle", "interactive", "systems"], "source_lectures": ["lecture_106103220_w1_l6"]}}
{"id": "concept_universal_usability", "type": "V_concept", "name": "Universal Usability", "properties": {"description": "A design principle that aims to make interactive systems accessible and usable by all users, regardless of their abilities or experience.", "keywords": ["universal", "accessibility", "principle", "usability", "design", "inclusion"], "source_lectures": ["lecture_106103220_w1_l6", "lecture_106103220_w2_l8"]}}
{"id": "concept_informative_feedback", "type": "V_concept", "name": "Informative Feedback", "properties": {"description": "A design principle that aims to provide users with clear and timely feedback about their actions and the system's response.", "keywords": ["informative", "feedback", "design", "principle", "usability"], "source_lectures": ["lecture_106103220_w1_l6"]}}
{"id": "concept_design_dialogues_to_yield_closure", "type": "V_concept", "name": "Design Dialogues To Yield Closure", "properties": {"description": "A design principle that aims to ensure that interactive systems provide a clear and logical sequence of actions, allowing users to feel in control.", "keywords": ["design", "dialogues", "closure", "principle", "usability"], "source_lectures": ["lecture_106103220_w1_l6"]}}
{"id": "concept_error_prevention_and_handling", "type": "V_concept", "name": "Error Prevention And Handling", "properties": {"description": "A design principle that aims to minimize the occurrence of errors and provide users with clear and helpful error messages and recovery options.", "keywords": ["error", "prevention", "handling", "design", "principle"], "source_lectures": ["lecture_106103220_w1_l6"]}}
{"id": "concept_permit_easy_reversal_of_actions", "type": "V_concept", "name": "Permit Easy Reversal Of Actions", "properties": {"description": "A design principle that aims to provide users with the ability to easily undo and redo actions, reducing anxiety and improving usability.", "keywords": ["reversal", "actions", "design", "principle", "usability"], "source_lectures": ["lecture_106103220_w1_l6"]}}
{"id": "concept_keep_users_in_control", "type": "V_concept", "name": "Keep Users In Control", "properties": {"description": "A design principle that aims to ensure that users feel in control of the interactive system, with clear and predictable behavior.", "keywords": ["users", "control", "design", "principle", "usability"], "source_lectures": ["lecture_106103220_w1_l6"]}}
{"id": "concept_millers_rule", "type": "V_concept", "name": "Miller's Rule", "properties": {"description": "A cognitive principle that states that the human short-term memory can hold approximately 7 \u00b1 2 chunks of information.", "keywords": ["miller", "rule", "short-term", "memory", "cognitive"], "source_lectures": ["lecture_106103220_w1_l6"]}}
{"id": "concept_short_term_memory_load", "type": "V_concept", "name": "Short-Term Memory Load", "properties": {"description": "A design principle that aims to minimize the amount of information that users need to hold in their short-term memory, reducing cognitive load.", "keywords": ["short-term", "memory", "load", "design", "principle"], "source_lectures": ["lecture_106103220_w1_l6"]}}
{"id": "concept_usability_concerns", "type": "V_concept", "name": "Usability Concerns", "properties": {"description": "Issues related to how easily and effectively users can interact with a product or system.", "keywords": ["usability", "concerns", "user", "experience", "interaction"], "source_lectures": ["lecture_106103220_w2_l8"]}}
{"id": "concept_shneidermans_eight_golden_rules", "type": "V_concept", "name": "Shneiderman's Eight Golden Rules", "properties": {"description": "A set of principles for designing user-friendly interfaces, including rules such as 'strive for consistency' and 'provide feedback'.", "keywords": ["shneiderman", "golden", "rules", "design", "usability"], "source_lectures": ["lecture_106103220_w2_l8"]}}
{"id": "concept_predictive_input", "type": "V_concept", "name": "Predictive Input", "properties": {"description": "A design technique that provides users with suggestions or completions as they enter data, to help them complete tasks more efficiently.", "keywords": ["predictive", "input", "design", "technique", "usability"], "source_lectures": ["lecture_106103220_w2_l8"]}}
{"id": "concept_user_profiling", "type": "V_concept", "name": "User Profiling", "properties": {"description": "The process of creating a profile or description of the target users of a product or system, including their characteristics, needs, and behaviors.", "keywords": ["user", "profiling", "design", "research", "method"], "source_lectures": ["lecture_106103220_w2_l8"]}}
{"id": "concept_user_experience", "type": "V_concept", "name": "User Experience", "properties": {"description": "The overall experience and perception a user has when interacting with a product or system.", "keywords": ["ux", "usability", "interaction", "design", "user", "experience"], "source_lectures": ["lecture_106103220_w2_l8", "lecture_106103220_w6_l40"]}}
{"id": "concept_algorithmic_computation", "type": "V_concept", "name": "Algorithmic Computation", "properties": {"description": "A type of computation that involves the application of a step-by-step procedure to transform input into output.", "keywords": ["algorithmic", "computation", "step-by-step", "procedure"], "source_lectures": ["lecture_106103220_w2_l9"]}}
{"id": "concept_discrete_state_machine", "type": "V_concept", "name": "Discrete-State Machine", "properties": {"description": "A mathematical model that represents a system as a set of discrete states, with transitions between them.", "keywords": ["discrete-state", "machine", "mathematical", "model"], "source_lectures": ["lecture_106103220_w2_l9"]}}
{"id": "concept_turing_machine", "type": "V_concept", "name": "Turing Machine", "properties": {"description": "A theoretical model of computation that represents a discrete-state machine with a finite set of states and transitions.", "keywords": ["theoretical", "theory", "model", "finite control", "finite", "control", "tape", "turing", "automata", "sequential", "algorithm", "computation", "machine"], "source_lectures": ["lecture_106103220_w2_l9", "lecture_106104357_w7_l47", "lecture_106104357_w1_l1", "lecture_106104357_w1_l3", "lecture_106104357_w1_l4", "lecture_106104357_w1_l5", "lecture_106104357_w2_l10", "lecture_106104357_w2_l11", "lecture_106104357_w3_l16", "lecture_106104357_w7_l46"]}}
{"id": "concept_stored_program_computer", "type": "V_concept", "name": "Stored Program Computer", "properties": {"description": "A model of computation that assumes a computer with a processing unit, control unit, memory, and input/output mechanisms.", "keywords": ["stored", "program", "computer", "model"], "source_lectures": ["lecture_106103220_w2_l9"]}}
{"id": "concept_cognitive_state", "type": "V_concept", "name": "Cognitive State", "properties": {"description": "The state of mind or mental state of a user, which can be represented as a set of variables.", "keywords": ["cognitive", "state", "mind", "mental"], "source_lectures": ["lecture_106103220_w2_l9"]}}
{"id": "concept_human_cognition", "type": "V_concept", "name": "Human Cognition", "properties": {"description": "The process of acquiring knowledge and understanding through thought, experience, and senses.", "keywords": ["human", "cognition", "process", "knowledge"], "source_lectures": ["lecture_106103220_w2_l9"]}}
{"id": "concept_computational_psychology", "type": "V_concept", "name": "Computational Psychology", "properties": {"description": "A field of study that applies computational models to understand human cognition and behavior.", "keywords": ["computational", "psychology", "field", "study"], "source_lectures": ["lecture_106103220_w2_l9"]}}
{"id": "concept_layered_view_of_a_system", "type": "V_concept", "name": "Layered View of a System", "properties": {"description": "A way of representing a system as a set of layers, each with its own set of components and interfaces.", "keywords": ["layered", "view", "system", "components"], "source_lectures": ["lecture_106103220_w2_l9"]}}
{"id": "concept_interactive_system", "type": "V_concept", "name": "Interactive System", "properties": {"description": "A system that allows users to interact with it, providing input and receiving output.", "keywords": ["interactive", "input", "system", "output", "user", "interface"], "source_lectures": ["lecture_106103220_w2_l9", "lecture_106103220_w6_l40"]}}
{"id": "concept_interactive_system_development_lifecycle", "type": "V_concept", "name": "Interactive System Development Lifecycle", "properties": {"description": "A software development lifecycle tailored for the development of interactive systems", "keywords": ["interactive", "system", "development", "lifecycle", "software"], "source_lectures": ["lecture_106103220_w2_l10"]}}
{"id": "concept_computation_in_interactive_system_design", "type": "V_concept", "name": "Computation In Interactive System Design", "properties": {"description": "A way of understanding the development process of interactive systems by analyzing the computation involved", "keywords": ["computation", "interactive", "system", "design", "development"], "source_lectures": ["lecture_106103220_w2_l10"]}}
{"id": "concept_layered_view_of_software", "type": "V_concept", "name": "Layered View Of Software", "properties": {"description": "A way of understanding software as a collection of layers, each with its own components and functions", "keywords": ["layered", "view", "software", "components", "functions"], "source_lectures": ["lecture_106103220_w2_l10"]}}
{"id": "concept_application_layer", "type": "V_concept", "name": "Application Layer", "properties": {"description": "The topmost layer of software that interacts with the user and provides the main functionality", "keywords": ["application", "layer", "software", "user", "functionality"], "source_lectures": ["lecture_106103220_w2_l10"]}}
{"id": "concept_operating_system_layer", "type": "V_concept", "name": "Operating System Layer", "properties": {"description": "The layer of software that manages the computer's hardware resources and provides services to the application layer", "keywords": ["operating", "system", "layer", "hardware", "resources"], "source_lectures": ["lecture_106103220_w2_l10"]}}
{"id": "concept_hardware_layer", "type": "V_concept", "name": "Hardware Layer", "properties": {"description": "The physical components of a computer system that provide the basic functionality", "keywords": ["hardware", "layer", "physical", "components", "functionality"], "source_lectures": ["lecture_106103220_w2_l10"]}}
{"id": "concept_user_state_predictor", "type": "V_concept", "name": "User State Predictor", "properties": {"description": "A component of the application layer that predicts the next state of the user based on the current state and input", "keywords": ["user", "state", "predictor", "application", "layer"], "source_lectures": ["lecture_106103220_w2_l10"]}}
{"id": "concept_interface_state_predictor", "type": "V_concept", "name": "Interface State Predictor", "properties": {"description": "A component of the application layer that predicts the next state of the interface based on the current state and user input", "keywords": ["interface", "state", "predictor", "application", "layer"], "source_lectures": ["lecture_106103220_w2_l10"]}}
{"id": "concept_adaptive_system", "type": "V_concept", "name": "Adaptive System", "properties": {"description": "A system that adapts to the user's behavior and changes its interface and interaction accordingly", "keywords": ["adaptive", "system", "user", "behavior", "interface"], "source_lectures": ["lecture_106103220_w2_l10"]}}
{"id": "concept_non_adaptive_system", "type": "V_concept", "name": "Non-Adaptive System", "properties": {"description": "A system that does not adapt to the user's behavior and has a static interface and interaction", "keywords": ["non-adaptive", "system", "user", "behavior", "interface"], "source_lectures": ["lecture_106103220_w2_l10"]}}
{"id": "concept_user_centric_framework", "type": "V_concept", "name": "User Centric Framework", "properties": {"description": "A framework for understanding and designing interactive systems that focuses on the user's needs and characteristics", "keywords": ["user", "centric", "framework", "interactive", "systems"], "source_lectures": ["lecture_106103220_w2_l10"]}}
{"id": "concept_computational_model_of_user_performance", "type": "V_concept", "name": "Computational Model Of User Performance", "properties": {"description": "A model that represents the user's behavior and performance when interacting with a system", "keywords": ["computational", "model", "user", "performance", "behavior"], "source_lectures": ["lecture_106103220_w2_l10"]}}
{"id": "concept_text_entry_rate", "type": "V_concept", "name": "Text Entry Rate", "properties": {"description": "A measure of the user's typing speed and efficiency when interacting with a system", "keywords": ["text", "entry", "rate", "typing", "speed"], "source_lectures": ["lecture_106103220_w2_l10"]}}
{"id": "concept_error_rate", "type": "V_concept", "name": "Error Rate", "properties": {"description": "A measure of the user's error frequency when interacting with a system", "keywords": ["error", "rate", "frequency", "user", "interaction"], "source_lectures": ["lecture_106103220_w2_l10"]}}
{"id": "concept_key_search_time", "type": "V_concept", "name": "Key Search Time", "properties": {"description": "A measure of the time it takes for a user to locate a key on a keyboard or interface", "keywords": ["key", "search", "time", "user", "interface"], "source_lectures": ["lecture_106103220_w2_l10"]}}
{"id": "concept_descriptive_model", "type": "V_concept", "name": "Descriptive Model", "properties": {"description": "A type of model that describes the behavior of a system or user, but lacks predictive power.", "keywords": ["descriptive", "system", "explanation", "behavior", "model", "user"], "source_lectures": ["lecture_106103220_w2_l12", "lecture_106103220_w3_l16"]}}
{"id": "concept_predictive_model", "type": "V_concept", "name": "Predictive Model", "properties": {"description": "A type of model that uses mathematical equations or computational frameworks to predict the behavior of a system or user.", "keywords": ["predictive", "forecast", "system", "behavior", "model", "user"], "source_lectures": ["lecture_106103220_w2_l12", "lecture_106103220_w3_l16"]}}
{"id": "concept_user_centric_computing_model", "type": "V_concept", "name": "User-Centric Computing Model", "properties": {"description": "A type of model that captures user behavior and has predictive power, used in human-computer interaction.", "keywords": ["user-centric", "computing", "model", "behavior", "human-computer"], "source_lectures": ["lecture_106103220_w2_l12"]}}
{"id": "concept_predictive_attention_model_pam", "type": "V_concept", "name": "Predictive Attention Model (PAM)", "properties": {"description": "A hypothetical model that predicts the attention factor of on-screen elements based on position, size, and contrast.", "keywords": ["predictive", "attention", "model", "pam", "attention factor"], "source_lectures": ["lecture_106103220_w2_l12"]}}
{"id": "concept_f_pattern", "type": "V_concept", "name": "F-Pattern", "properties": {"description": "A pattern of viewing behavior where users follow an F-shaped trajectory when reading on-screen content.", "keywords": ["f-pattern", "viewing", "behavior", "trajectory", "reading"], "source_lectures": ["lecture_106103220_w2_l12"]}}
{"id": "concept_attention_factor", "type": "V_concept", "name": "Attention Factor", "properties": {"description": "A measure of the relative importance of an on-screen element in drawing user attention.", "keywords": ["attention", "factor", "importance", "element", "attention factor"], "source_lectures": ["lecture_106103220_w2_l12"]}}
{"id": "concept_formal_structure", "type": "V_concept", "name": "Formal Structure", "properties": {"description": "A mathematical or computational representation of a model that allows for algorithmic implementation.", "keywords": ["formal", "structure", "mathematical", "computational", "algorithmic"], "source_lectures": ["lecture_106103220_w2_l12"]}}
{"id": "concept_formal_models_of_interactive_systems", "type": "V_concept", "name": "Formal Models of Interactive Systems", "properties": {"description": "Models that represent external aspects of the user-centric system, including interface and interaction.", "keywords": ["formal", "models", "interactive", "systems", "interface"], "source_lectures": ["lecture_106103220_w2_l12"]}}
{"id": "concept_hybrid_models", "type": "V_concept", "name": "Hybrid Models", "properties": {"description": "Models that combine computational models of the user and formal models of interactive systems to represent both internal and external aspects of the user-centric system.", "keywords": ["models", "hybrid", "user-centric", "computational", "learning", "combinations", "formal", "machine"], "source_lectures": ["lecture_106103220_w2_l12", "lecture_106103842_w2_l12"]}}
{"id": "concept_taxonomy_of_user_centric_models", "type": "V_concept", "name": "Taxonomy of User-Centric Models", "properties": {"description": "A classification system for user-centric models, including descriptive, predictive, computational, formal, and hybrid models.", "keywords": ["taxonomy", "user-centric", "models", "classification", "system"], "source_lectures": ["lecture_106103220_w2_l12"]}}
{"id": "concept_goms_family", "type": "V_concept", "name": "Goms Family", "properties": {"description": "A group of models used to predict human performance and interaction with computer systems", "keywords": ["goms", "human", "performance", "interaction", "models"], "source_lectures": ["lecture_106103220_w2_l13"]}}
{"id": "concept_predictive_models", "type": "V_concept", "name": "Predictive Models", "properties": {"description": "Models used to forecast or predict the behavior of a system or user", "keywords": ["predictive", "models", "forecast", "behavior", "system"], "source_lectures": ["lecture_106103220_w2_l13"]}}
{"id": "concept_keystroke_level_model", "type": "V_concept", "name": "Keystroke Level Model", "properties": {"description": "A model that predicts the time it takes for a user to perform a task based on keystrokes", "keywords": ["klm", "level", "task", "operators", "engineering", "keystroke", "user-centric", "predictive", "model", "time", "cognitive"], "source_lectures": ["lecture_106103220_w2_l13", "lecture_106103220_w2_l14", "lecture_106103220_w3_l15"]}}
{"id": "concept_cognitive_architecture", "type": "V_concept", "name": "Cognitive Architecture", "properties": {"description": "A conceptual framework that describes the mental processes and structures involved in cognition", "keywords": ["cognitive", "architecture", "mental", "processes", "structures"], "source_lectures": ["lecture_106103220_w2_l13"]}}
{"id": "concept_human_information_processing", "type": "V_concept", "name": "Human Information Processing", "properties": {"description": "The process by which humans perceive, interpret, and respond to information", "keywords": ["human", "information", "processing", "perception", "interpretation"], "source_lectures": ["lecture_106103220_w2_l13"]}}
{"id": "concept_graphical_user_interface", "type": "V_concept", "name": "Graphical User Interface", "properties": {"description": "A type of user interface that uses visual elements such as icons and menus to interact with a computer", "keywords": ["graphical", "user", "interface", "visual", "elements"], "source_lectures": ["lecture_106103220_w2_l13"]}}
{"id": "concept_engineering_models", "type": "V_concept", "name": "Engineering Models", "properties": {"description": "Models used to predict and analyze the behavior of complex systems", "keywords": ["engineering", "models", "predict", "analyze", "behavior"], "source_lectures": ["lecture_106103220_w2_l13"]}}
{"id": "concept_goms_acronym", "type": "V_concept", "name": "Goms Acronym", "properties": {"description": "An acronym that stands for Goals, Operators, Methods, and Selection rules", "keywords": ["goms", "acronym", "goals", "operators", "methods"], "source_lectures": ["lecture_106103220_w2_l13"]}}
{"id": "concept_sequential_processing", "type": "V_concept", "name": "Sequential Processing", "properties": {"description": "A model of human information processing that assumes tasks are performed in a sequential manner", "keywords": ["sequential", "processing", "human", "information", "tasks"], "source_lectures": ["lecture_106103220_w2_l13"]}}
{"id": "concept_cognitive_perceptual_motor_goms", "type": "V_concept", "name": "Cognitive Perceptual Motor Goms", "properties": {"description": "A variant of the GOMS model that takes into account cognitive, perceptual, and motor activities", "keywords": ["cognitive", "perceptual", "motor", "goms", "variant"], "source_lectures": ["lecture_106103220_w2_l13"]}}
{"id": "concept_critical_path_method_goms", "type": "V_concept", "name": "Critical Path Method Goms", "properties": {"description": "A variant of the GOMS model that uses a critical path method to analyze tasks", "keywords": ["critical", "path", "method", "goms", "variant"], "source_lectures": ["lecture_106103220_w2_l13"]}}
{"id": "concept_goms_models", "type": "V_concept", "name": "GOMS Models", "properties": {"description": "A family of predictive engineering models that include the Keystroke Level Model, used to analyze and design user-centric systems.", "keywords": ["goms", "predictive", "engineering", "models", "user-centric"], "source_lectures": ["lecture_106103220_w2_l14"]}}
{"id": "concept_operator", "type": "V_concept", "name": "Operator", "properties": {"description": "A low-level cognitive task with a predetermined execution time, used in the Keystroke Level Model to represent user interactions.", "keywords": ["time", "symbol", "activity", "operation", "behavior", "function", "task", "low-level", "execution", "operator", "cognitive"], "source_lectures": ["lecture_106103220_w2_l14", "lecture_106103220_w3_l15", "lecture_106106931_w2_l9"]}}
{"id": "concept_physical_motor_operators", "type": "V_concept", "name": "Physical Motor Operators", "properties": {"description": "A group of operators in the Keystroke Level Model that represent physical interactions, such as keystrokes and mouse movements.", "keywords": ["physical", "motor", "operators", "interactions", "keystrokes"], "source_lectures": ["lecture_106103220_w2_l14"]}}
{"id": "concept_mental_operators", "type": "V_concept", "name": "Mental Operators", "properties": {"description": "A group of operators in the Keystroke Level Model that represent cognitive tasks, such as decision-making and thinking.", "keywords": ["mental", "operators", "cognitive", "tasks", "thinking"], "source_lectures": ["lecture_106103220_w2_l14"]}}
{"id": "concept_system_response_operators", "type": "V_concept", "name": "System Response Operators", "properties": {"description": "A group of operators in the Keystroke Level Model that represent system responses, such as delays and feedback.", "keywords": ["system", "response", "operators", "delays", "feedback"], "source_lectures": ["lecture_106103220_w2_l14"]}}
{"id": "concept_k_operator", "type": "V_concept", "name": "K Operator", "properties": {"description": "An operator in the Keystroke Level Model that represents a keystroke or key press.", "keywords": ["k", "operator", "keystroke", "key", "press"], "source_lectures": ["lecture_106103220_w2_l14"]}}
{"id": "concept_b_operator", "type": "V_concept", "name": "B Operator", "properties": {"description": "An operator in the Keystroke Level Model that represents a mouse button press or release.", "keywords": ["b", "operator", "mouse", "button", "press"], "source_lectures": ["lecture_106103220_w2_l14"]}}
{"id": "concept_p_operator", "type": "V_concept", "name": "P Operator", "properties": {"description": "An operator in the Keystroke Level Model that represents a pointing task, such as moving a mouse pointer.", "keywords": ["p", "operator", "pointing", "task", "mouse"], "source_lectures": ["lecture_106103220_w2_l14"]}}
{"id": "concept_h_operator", "type": "V_concept", "name": "H Operator", "properties": {"description": "An operator in the Keystroke Level Model that represents a homing task, such as switching between devices.", "keywords": ["h", "operator", "homing", "task", "devices"], "source_lectures": ["lecture_106103220_w2_l14"]}}
{"id": "concept_m_operator", "type": "V_concept", "name": "M Operator", "properties": {"description": "An operator in the Keystroke Level Model that represents a mental task, such as thinking or decision-making.", "keywords": ["m", "operator", "mental", "task", "thinking"], "source_lectures": ["lecture_106103220_w2_l14"]}}
{"id": "concept_cognitive_task_analysis", "type": "V_concept", "name": "Cognitive Task Analysis", "properties": {"description": "A method of analyzing user interactions by modeling cognitive tasks and processes.", "keywords": ["cognitive", "task", "analysis", "user", "interactions"], "source_lectures": ["lecture_106103220_w2_l14"]}}
{"id": "concept_task_execution_time", "type": "V_concept", "name": "Task Execution Time", "properties": {"description": "The time it takes to complete a task, used as a metric to evaluate the usability of a system.", "keywords": ["task", "usability", "metric", "goms", "user", "time", "execution"], "source_lectures": ["lecture_106103220_w2_l14", "lecture_106103220_w3_l15"]}}
{"id": "concept_goms_model", "type": "V_concept", "name": "Goms Model", "properties": {"description": "A user-centric model that represents human cognitive processes as a hierarchical sequence of goals, operators, methods, and selection rules.", "keywords": ["model", "prediction", "computer", "interaction", "performance", "task", "human", "behavior", "cognitive", "user", "information", "hierarchy", "processing", "goms"], "source_lectures": ["lecture_106103220_w3_l15", "lecture_106103220_w3_l16", "lecture_106103220_w3_l17", "lecture_106103220_w3_l18", "lecture_106103220_w5_l31"]}}
{"id": "concept_goal_hierarchy", "type": "V_concept", "name": "Goal Hierarchy", "properties": {"description": "A representation of human thought processes as a hierarchical structure of goals and sub-goals.", "keywords": ["goal", "hierarchy", "thought", "process", "cognitive"], "source_lectures": ["lecture_106103220_w3_l15"]}}
{"id": "concept_method", "type": "V_concept", "name": "Method", "properties": {"description": "A sequence of operators used to achieve a goal or sub-goal.", "keywords": ["method", "operators", "goal", "sub-goal", "sequence"], "source_lectures": ["lecture_106103220_w3_l15"]}}
{"id": "concept_selection_rule", "type": "V_concept", "name": "Selection Rule", "properties": {"description": "A condition that specifies which method to use to achieve a goal or sub-goal.", "keywords": ["selection", "rule", "method", "goal", "condition"], "source_lectures": ["lecture_106103220_w3_l15"]}}
{"id": "concept_cmn_goms", "type": "V_concept", "name": "Cmn Goms", "properties": {"description": "A specific type of GOMS model that represents human cognitive processes as a hierarchical sequence of goals, operators, methods, and selection rules.", "keywords": ["human", "cognitive", "goms", "behavior", "model", "cmn"], "source_lectures": ["lecture_106103220_w3_l15", "lecture_106103220_w3_l17"]}}
{"id": "concept_quantitative_prediction", "type": "V_concept", "name": "Quantitative Prediction", "properties": {"description": "A method of using a GOMS model to predict the task execution time for a given design.", "keywords": ["quantitative", "prediction", "goms", "model", "task"], "source_lectures": ["lecture_106103220_w3_l15"]}}
{"id": "concept_qualitative_comparison", "type": "V_concept", "name": "Qualitative Comparison", "properties": {"description": "A method of comparing different designs by analyzing the depth and nature of their goal hierarchies.", "keywords": ["qualitative", "comparison", "design", "goal", "hierarchy"], "source_lectures": ["lecture_106103220_w3_l15"]}}
{"id": "concept_fitts_law", "type": "V_concept", "name": "Fitts' Law", "properties": {"description": "A model of human motor performance that predicts the time required to move to a target based on the distance to the target and the size of the target.", "keywords": ["human-computer", "law", "fitts", "distance", "motor", "human", "performance", "time", "acquisition", "movement", "target", "interaction"], "source_lectures": ["lecture_106103220_w3_l16", "lecture_106103220_w3_l17", "lecture_106103220_w3_l18", "lecture_106103220_w3_l19", "lecture_106103220_w3_l20", "lecture_106103220_w3_l21", "lecture_106103220_w4_l22"]}}
{"id": "concept_index_of_difficulty", "type": "V_concept", "name": "Index Of Difficulty", "properties": {"description": "A measure of the difficulty of a target acquisition task, calculated as a function of the distance to the target and the width of the target.", "keywords": ["human-computer", "fitts", "task", "width", "distance", "pointing", "acquisition", "difficulty", "index", "model", "movement", "target", "interaction"], "source_lectures": ["lecture_106103220_w3_l16", "lecture_106103220_w3_l18", "lecture_106103220_w3_l19", "lecture_106103220_w3_l20", "lecture_106103220_w4_l22"]}}
{"id": "concept_throughput", "type": "V_concept", "name": "Throughput", "properties": {"description": "A measure of human manual performance, calculated as the ratio of the index of difficulty to the movement time.", "keywords": ["throughput", "human", "manual", "performance", "measure"], "source_lectures": ["lecture_106103220_w3_l16"]}}
{"id": "concept_movement_time", "type": "V_concept", "name": "Movement Time", "properties": {"description": "The time it takes to move to a target, used in the calculation of throughput.", "keywords": ["movement", "time", "target", "throughput", "calculation"], "source_lectures": ["lecture_106103220_w3_l16"]}}
{"id": "concept_speed_accuracy_tradeoff", "type": "V_concept", "name": "Speed Accuracy Tradeoff", "properties": {"description": "The tradeoff between the speed of movement and the accuracy of target acquisition, where faster movements are more likely to result in errors.", "keywords": ["task", "performance", "accuracy", "speed", "tradeoff", "acquisition", "movement", "target"], "source_lectures": ["lecture_106103220_w3_l16", "lecture_106103220_w3_l18", "lecture_106103220_w4_l22"]}}
{"id": "concept_effective_target_width", "type": "V_concept", "name": "Effective Target Width", "properties": {"description": "A measure of the width of a target that takes into account the distribution of movement endpoints, used to account for the speed accuracy tradeoff.", "keywords": ["width", "effective", "accuracy", "speed", "selection", "target"], "source_lectures": ["lecture_106103220_w3_l16", "lecture_106103220_w4_l22"]}}
{"id": "concept_klm_model", "type": "V_concept", "name": "KLM Model", "properties": {"description": "A type of human performance model that represents the keystroke-level model of human behavior, used to predict the time required to perform tasks.", "keywords": ["klm", "prediction", "task", "human", "behavior", "keystroke", "model", "time"], "source_lectures": ["lecture_106103220_w3_l16", "lecture_106103220_w3_l17", "lecture_106103220_w3_l18"]}}
{"id": "concept_hick_hyman_law", "type": "V_concept", "name": "Hick-Hyman Law", "properties": {"description": "A law that models the time it takes to react to a stimulus in the presence of choice.", "keywords": ["hyman", "human-computer", "hick", "choice", "reaction", "law", "time", "decision", "interaction"], "source_lectures": ["lecture_106103220_w3_l17", "lecture_106103220_w3_l18", "lecture_106103220_w3_l20", "lecture_106103220_w3_l21"]}}
{"id": "concept_choice_reaction_time", "type": "V_concept", "name": "Choice Reaction Time", "properties": {"description": "The time it takes for a person to react to a stimulus in the presence of multiple choices.", "keywords": ["choice", "reaction", "time", "stimulus", "decision"], "source_lectures": ["lecture_106103220_w3_l17"]}}
{"id": "concept_entropy", "type": "V_concept", "name": "Entropy", "properties": {"description": "A measure of uncertainty or randomness in a system, used to model uncertainty in decision making.", "keywords": ["distribution", "uncertainty", "randomness", "decision", "probability", "information", "entropy", "making"], "source_lectures": ["lecture_106103220_w3_l17", "lecture_106108841_w2_l13", "lecture_106108841_w2_l14"]}}
{"id": "concept_context_specific_behavioral_model", "type": "V_concept", "name": "Context-Specific Behavioral Model", "properties": {"description": "A type of model that describes human behavior in a specific context or situation.", "keywords": ["context", "specific", "behavioral", "model", "human"], "source_lectures": ["lecture_106103220_w3_l17"]}}
{"id": "concept_information_theoretic_considerations", "type": "V_concept", "name": "Information Theoretic Considerations", "properties": {"description": "A framework for understanding human behavior and decision making in terms of information processing.", "keywords": ["information", "theoretic", "considerations", "human", "behavior"], "source_lectures": ["lecture_106103220_w3_l17"]}}
{"id": "concept_wimp_interface", "type": "V_concept", "name": "Wimp Interface", "properties": {"description": "A type of graphical user interface that uses windows, icons, menus, and pointers to interact with a computer.", "keywords": ["wimp", "interface", "graphical", "gui", "interaction"], "source_lectures": ["lecture_106103220_w3_l18"]}}
{"id": "concept_bivariate_pointing_model", "type": "V_concept", "name": "Bivariate Pointing Model", "properties": {"description": "A mathematical model that extends Fitts Law to two-dimensional pointing tasks, considering both distance and direction.", "keywords": ["human-computer", "fitts", "task", "performance", "pointing", "2d", "model", "interaction", "bivariate"], "source_lectures": ["lecture_106103220_w3_l18", "lecture_106103220_w3_l19", "lecture_106103220_w3_l20"]}}
{"id": "concept_amplitude_pointing", "type": "V_concept", "name": "Amplitude Pointing", "properties": {"description": "A type of pointing task that involves controlling errors in distance, regardless of direction.", "keywords": ["amplitude", "pointing", "distance", "error", "control"], "source_lectures": ["lecture_106103220_w3_l18"]}}
{"id": "concept_directional_pointing", "type": "V_concept", "name": "Directional Pointing", "properties": {"description": "A type of pointing task that involves controlling errors in direction, regardless of distance.", "keywords": ["directional", "pointing", "direction", "error", "control"], "source_lectures": ["lecture_106103220_w3_l18"]}}
{"id": "concept_trivariate_pointing_model", "type": "V_concept", "name": "Trivariate Pointing Model", "properties": {"description": "A mathematical model that extends the bivariate pointing model to three-dimensional pointing tasks, considering distance, direction, and object dimensions.", "keywords": ["human-computer", "3d", "trivariate", "task", "performance", "pointing", "model", "interaction", "bivariate"], "source_lectures": ["lecture_106103220_w3_l18", "lecture_106103220_w3_l19", "lecture_106103220_w3_l20"]}}
{"id": "concept_cmn_goms_model", "type": "V_concept", "name": "Cmn-Goms Model", "properties": {"description": "A model used to predict the time it takes to perform a task on a computer, based on cognitive, motor, and perceptual analysis.", "keywords": ["cmn-goms", "model", "cognitive", "motor", "perceptual"], "source_lectures": ["lecture_106103220_w3_l18"]}}
{"id": "concept_steering_law", "type": "V_concept", "name": "Steering Law", "properties": {"description": "A model used to compute the performance of users during constrained navigation tasks, particularly in path tracing tasks.", "keywords": ["human-computer", "constrained", "steering", "tracing", "navigation", "path", "model", "law", "interaction"], "source_lectures": ["lecture_106103220_w3_l19", "lecture_106103220_w3_l20"]}}
{"id": "concept_constrained_navigation", "type": "V_concept", "name": "Constrained Navigation", "properties": {"description": "A type of navigation where the movement of the pointer or hand is restricted to a specific path or tunnel with a fixed width.", "keywords": ["human-computer", "constrained", "width", "tunnel", "navigation", "path", "pointer", "interaction"], "source_lectures": ["lecture_106103220_w3_l19", "lecture_106103220_w3_l20"]}}
{"id": "concept_tunnel_path", "type": "V_concept", "name": "Tunnel Path", "properties": {"description": "A path with a fixed width that the pointer or hand must follow during a constrained navigation task.", "keywords": ["tunnel", "path", "width", "constrained", "navigation"], "source_lectures": ["lecture_106103220_w3_l19"]}}
{"id": "concept_segmented_tunnel", "type": "V_concept", "name": "Segmented Tunnel", "properties": {"description": "A tunnel path divided into smaller segments, each with its own length and width.", "keywords": ["segmented", "tunnel", "path", "length", "width"], "source_lectures": ["lecture_106103220_w3_l19"]}}
{"id": "concept_infinitesimal_segment", "type": "V_concept", "name": "Infinitesimal Segment", "properties": {"description": "A segment of a tunnel path with an infinitesimally small length, used in the Steering Law model.", "keywords": ["infinitesimal", "segment", "tunnel", "path", "length"], "source_lectures": ["lecture_106103220_w3_l19"]}}
{"id": "concept_taylor_series_expansion", "type": "V_concept", "name": "Taylor Series Expansion", "properties": {"description": "A mathematical technique used to simplify complex expressions, such as the logarithmic term in the Steering Law model.", "keywords": ["taylor", "series", "expansion", "mathematical", "technique"], "source_lectures": ["lecture_106103220_w3_l19"]}}
{"id": "concept_movement_time_model", "type": "V_concept", "name": "Movement Time Model", "properties": {"description": "A model that predicts the time required to complete a movement task, such as the Steering Law model.", "keywords": ["movement", "time", "model", "prediction", "task"], "source_lectures": ["lecture_106103220_w3_l19"]}}
{"id": "concept_menu_selection_model", "type": "V_concept", "name": "Menu Selection Model", "properties": {"description": "A computational model that predicts the performance of menu selection tasks in human-computer interaction.", "keywords": ["menu", "selection", "model", "human-computer", "interaction"], "source_lectures": ["lecture_106103220_w3_l20"]}}
{"id": "concept_goms_family_of_models", "type": "V_concept", "name": "Goms Family Of Models", "properties": {"description": "A set of models that describe the behavior of users in human-computer interaction, including the keystroke-level model and the unit task model.", "keywords": ["goms", "family", "models", "human-computer", "interaction"], "source_lectures": ["lecture_106103220_w3_l20"]}}
{"id": "concept_tunnel_path_movement", "type": "V_concept", "name": "Tunnel Path Movement", "properties": {"description": "A type of movement where the pointer moves through a constrained path with a constant width.", "keywords": ["tunnel", "path", "movement", "human-computer", "interaction"], "source_lectures": ["lecture_106103220_w3_l20"]}}
{"id": "concept_fitts_digraph_model", "type": "V_concept", "name": "Fitts-Digraph Model", "properties": {"description": "A model of typing performance for single finger typing on a mobile device, combining Fitts' Law and Hick-Hyman Law.", "keywords": ["fitts", "digraph", "model", "typing", "single finger"], "source_lectures": ["lecture_106103220_w3_l21"]}}
{"id": "concept_two_thumb_typing_model", "type": "V_concept", "name": "Two-Thumb Typing Model", "properties": {"description": "A model of typing performance for two-thumb typing on a mobile device, using a recursive equation to model the time to type a sequence of characters.", "keywords": ["two", "thumb", "typing", "model", "recursive"], "source_lectures": ["lecture_106103220_w3_l21"]}}
{"id": "concept_digraph_probability", "type": "V_concept", "name": "Digraph Probability", "properties": {"description": "The probability of occurrence of a pair of letters in a text, used to model the average movement time in typing.", "keywords": ["digraph", "probability", "typing", "movement", "text"], "source_lectures": ["lecture_106103220_w3_l21"]}}
{"id": "concept_bigram_probability", "type": "V_concept", "name": "Bigram Probability", "properties": {"description": "The probability of occurrence of a pair of letters in a text, used to model the average movement time in typing.", "keywords": ["bigram", "probability", "typing", "movement", "text"], "source_lectures": ["lecture_106103220_w3_l21"]}}
{"id": "concept_typing_performance", "type": "V_concept", "name": "Typing Performance", "properties": {"description": "The measure of how efficiently a user can type on a device, often represented in terms of characters per second or words per minute.", "keywords": ["typing", "performance", "efficiency", "characters", "words"], "source_lectures": ["lecture_106103220_w3_l21"]}}
{"id": "concept_single_finger_typing", "type": "V_concept", "name": "Single Finger Typing", "properties": {"description": "A method of typing where only one finger is used to press keys on a keyboard or keypad.", "keywords": ["single", "finger", "typing", "keyboard", "keypad"], "source_lectures": ["lecture_106103220_w3_l21"]}}
{"id": "concept_two_thumb_typing", "type": "V_concept", "name": "Two-Thumb Typing", "properties": {"description": "A method of typing where two thumbs are used to press keys on a keyboard or keypad, often used on mobile devices.", "keywords": ["two", "thumb", "typing", "keyboard", "keypad"], "source_lectures": ["lecture_106103220_w3_l21"]}}
{"id": "concept_qwerty_layout", "type": "V_concept", "name": "QWERTY Layout", "properties": {"description": "A standard keyboard layout used for typing, where the keys are arranged in a specific pattern to facilitate efficient typing.", "keywords": ["qwerty", "layout", "keyboard", "typing", "efficient"], "source_lectures": ["lecture_106103220_w3_l21"]}}
{"id": "concept_target_acquisition", "type": "V_concept", "name": "Target Acquisition", "properties": {"description": "The process of selecting a target on a screen using a pointing device", "keywords": ["target", "acquisition", "pointing", "device"], "source_lectures": ["lecture_106103220_w4_l22"]}}
{"id": "concept_fat_finger_problem", "type": "V_concept", "name": "Fat Finger Problem", "properties": {"description": "A problem that occurs when the size of the finger is larger than the target, making it difficult to select the target accurately", "keywords": ["fat", "finger", "problem", "target", "selection"], "source_lectures": ["lecture_106103220_w4_l22"]}}
{"id": "concept_relative_precision", "type": "V_concept", "name": "Relative Precision", "properties": {"description": "The precision of the finger when acquiring a target, affected by the speed accuracy tradeoff", "keywords": ["relative", "precision", "finger", "target", "acquisition"], "source_lectures": ["lecture_106103220_w4_l22"]}}
{"id": "concept_absolute_precision", "type": "V_concept", "name": "Absolute Precision", "properties": {"description": "The precision of the finger when acquiring a target, affected by the fat finger problem", "keywords": ["absolute", "precision", "finger", "target", "acquisition"], "source_lectures": ["lecture_106103220_w4_l22"]}}
{"id": "concept_ffitts_law", "type": "V_concept", "name": "FFitts Law", "properties": {"description": "A modified version of Fitts Law that takes into account the fat finger problem and relative precision", "keywords": ["ffitts", "law", "fat", "finger", "precision"], "source_lectures": ["lecture_106103220_w4_l22"]}}
{"id": "concept_tap_behavior", "type": "V_concept", "name": "Tap Behavior", "properties": {"description": "The behavior of tapping on a screen using a finger", "keywords": ["tap", "behavior", "finger", "screen"], "source_lectures": ["lecture_106103220_w4_l22"]}}
{"id": "concept_multi_touch_gestures", "type": "V_concept", "name": "Multi Touch Gestures", "properties": {"description": "Gestures that involve multiple fingers touching the screen", "keywords": ["multi", "touch", "gestures", "fingers", "screen"], "source_lectures": ["lecture_106103220_w4_l22"]}}
{"id": "concept_scrolling_behavior", "type": "V_concept", "name": "Scrolling Behavior", "properties": {"description": "The behavior of scrolling on a screen using a finger", "keywords": ["scrolling", "behavior", "finger", "screen"], "source_lectures": ["lecture_106103220_w4_l22"]}}
{"id": "concept_formal_model", "type": "V_concept", "name": "Formal Model", "properties": {"description": "A mathematical representation of a system that uses a formal language with precise syntax and semantics to describe its behavior.", "keywords": ["system", "representation", "mathematical", "formal", "model"], "source_lectures": ["lecture_106103220_w4_l23", "lecture_106103220_w4_l24"]}}
{"id": "concept_informal_model", "type": "V_concept", "name": "Informal Model", "properties": {"description": "A model that uses natural language to describe a system, which can be ambiguous and lead to different interpretations.", "keywords": ["informal", "model", "natural", "language", "ambiguous"], "source_lectures": ["lecture_106103220_w4_l23"]}}
{"id": "concept_semiformal_model", "type": "V_concept", "name": "Semiformal Model", "properties": {"description": "A model that uses a specific notation with clearly defined syntax to represent a system, but lacks mathematically defined semantics.", "keywords": ["semiformal", "model", "notation", "syntax", "semantics"], "source_lectures": ["lecture_106103220_w4_l23"]}}
{"id": "concept_formal_language", "type": "V_concept", "name": "Formal Language", "properties": {"description": "A language with precise syntax and mathematically defined semantics, used to represent formal models.", "keywords": ["formal", "language", "syntax", "semantics", "mathematical"], "source_lectures": ["lecture_106103220_w4_l23"]}}
{"id": "concept_matrix_algebra", "type": "V_concept", "name": "Matrix Algebra", "properties": {"description": "A branch of mathematics that deals with the study of matrices and their properties, used to represent and analyze formal models.", "keywords": ["matrix", "algebra", "mathematics", "matrices", "properties"], "source_lectures": ["lecture_106103220_w4_l23"]}}
{"id": "concept_state_transition_diagram", "type": "V_concept", "name": "State Transition Diagram", "properties": {"description": "A graphical representation of a system's states and transitions, used to model and analyze its behavior.", "keywords": ["representation", "transition", "state", "diagram", "graphical"], "source_lectures": ["lecture_106103220_w4_l23", "lecture_106103359_w4_l22"]}}
{"id": "concept_reachability", "type": "V_concept", "name": "Reachability", "properties": {"description": "A property of a system that indicates whether it is possible to reach a particular state from any other state.", "keywords": ["reachability", "property", "system", "state", "transition"], "source_lectures": ["lecture_106103220_w4_l23"]}}
{"id": "concept_reversibility", "type": "V_concept", "name": "Reversibility", "properties": {"description": "A property of a system that indicates whether it is possible to return to a previous state after a transition.", "keywords": ["reversibility", "property", "system", "state", "transition"], "source_lectures": ["lecture_106103220_w4_l23"]}}
{"id": "concept_determinism", "type": "V_concept", "name": "Determinism", "properties": {"description": "A property of a system that indicates whether its behavior is predictable and deterministic, given a particular state and action.", "keywords": ["determinism", "property", "system", "behavior", "predictable"], "source_lectures": ["lecture_106103220_w4_l23"]}}
{"id": "concept_completeness", "type": "V_concept", "name": "Completeness", "properties": {"description": "A property of a system that indicates whether all possible actions and transitions are specified and accounted for.", "keywords": ["completeness", "property", "system", "actions", "transitions"], "source_lectures": ["lecture_106103220_w4_l23"]}}
{"id": "concept_formal_verification", "type": "V_concept", "name": "Formal Verification", "properties": {"description": "The process of using formal methods to verify that a system satisfies certain properties and requirements.", "keywords": ["formal", "verification", "process", "methods", "properties"], "source_lectures": ["lecture_106103220_w4_l23"]}}
{"id": "concept_state_transition_network", "type": "V_concept", "name": "State Transition Network", "properties": {"description": "A graphical representation of a system's states and transitions between them.", "keywords": ["state", "transition", "network", "graphical"], "source_lectures": ["lecture_106103220_w4_l24"]}}
{"id": "concept_hierarchical_state_transition_network", "type": "V_concept", "name": "Hierarchical State Transition Network", "properties": {"description": "An extension of state transition networks that organizes states into a hierarchical structure.", "keywords": ["hierarchical", "state", "transition", "network"], "source_lectures": ["lecture_106103220_w4_l24"]}}
{"id": "concept_state_chart", "type": "V_concept", "name": "State Chart", "properties": {"description": "A visual formalism for representing complex systems, extending state transition diagrams with hierarchy, concurrency, and communication.", "keywords": ["state", "chart", "visual", "formalism"], "source_lectures": ["lecture_106103220_w4_l24"]}}
{"id": "concept_super_state", "type": "V_concept", "name": "Super State", "properties": {"description": "A state in a state chart that contains other states, used to represent hierarchy.", "keywords": ["super", "state", "hierarchy"], "source_lectures": ["lecture_106103220_w4_l24"]}}
{"id": "concept_basic_state", "type": "V_concept", "name": "Basic State", "properties": {"description": "A state in a state chart that is not composed of other states.", "keywords": ["basic", "state", "simple"], "source_lectures": ["lecture_106103220_w4_l24"]}}
{"id": "concept_default_state_mechanism", "type": "V_concept", "name": "Default State Mechanism", "properties": {"description": "A notation in state charts that indicates the initial state to enter when a super state is activated.", "keywords": ["default", "state", "mechanism"], "source_lectures": ["lecture_106103220_w4_l24"]}}
{"id": "concept_history_mechanism", "type": "V_concept", "name": "History Mechanism", "properties": {"description": "A notation in state charts that remembers the last active state before exiting a super state.", "keywords": ["history", "mechanism", "memory"], "source_lectures": ["lecture_106103220_w4_l24"]}}
{"id": "concept_concurrency", "type": "V_concept", "name": "Concurrency", "properties": {"description": "The ability of a system to perform multiple tasks simultaneously.", "keywords": ["concurrency", "parallel", "system", "task", "execution", "simultaneous"], "source_lectures": ["lecture_106103220_w4_l24", "lecture_106102229_w4_l27"]}}
{"id": "concept_and_super_state", "type": "V_concept", "name": "AND Super State", "properties": {"description": "A super state in a state chart that activates all its sub-states simultaneously, used to represent concurrency.", "keywords": ["and", "super", "state", "concurrency"], "source_lectures": ["lecture_106103220_w4_l24"]}}
{"id": "concept_formal_modeling", "type": "V_concept", "name": "Formal Modeling", "properties": {"description": "The process of creating a formal representation of a system to analyze and predict its behavior.", "keywords": ["formal", "modeling", "system", "representation"], "source_lectures": ["lecture_106103220_w4_l24"]}}
{"id": "concept_cycle_cover", "type": "V_concept", "name": "Cycle Cover", "properties": {"description": "A set of cycles in a graph that covers all edges of the graph.", "keywords": ["cover", "graph", "directed graph", "edge", "vertex cover", "permutation", "cycle"], "source_lectures": ["lecture_106104357_w5_l30", "lecture_106104357_w5_l29"]}}
{"id": "concept_xor_gadget", "type": "V_concept", "name": "XOR Gadget", "properties": {"description": "A graph gadget used to represent the XOR operation in a computational complexity context.", "keywords": ["xor", "gadget", "graph", "complexity"], "source_lectures": ["lecture_106104357_w5_l30"]}}
{"id": "concept_satisfying_assignment", "type": "V_concept", "name": "Satisfying Assignment", "properties": {"description": "An assignment of values to variables that makes a given formula true.", "keywords": ["assignment", "satisfying", "boolean", "variable", "formula"], "source_lectures": ["lecture_106104357_w5_l30", "lecture_106104357_w7_l46"]}}
{"id": "concept_permanent", "type": "V_concept", "name": "Permanent", "properties": {"description": "A function that calculates the number of perfect matchings in a graph.", "keywords": ["graph", "matching", "matchings", "function", "permanent"], "source_lectures": ["lecture_106104357_w5_l30", "lecture_106104357_w1_l2"]}}
{"id": "concept_modular_arithmetic", "type": "V_concept", "name": "Modular Arithmetic", "properties": {"description": "A system of arithmetic that wraps around after reaching a certain value, called the modulus.", "keywords": ["cryptographic", "theory", "algebra", "calculations", "remainder", "finite", "number", "modular", "modulus", "field", "arithmetic", "mathematics", "operations"], "source_lectures": ["lecture_106104357_w5_l30", "lecture_106108229_w2_l8", "lecture_106108229_w8_l53", "lecture_106106221_w6_l40", "lecture_106106221_w8_l55", "lecture_106104233_w4_l28"]}}
{"id": "concept_binary_representation", "type": "V_concept", "name": "Binary Representation", "properties": {"description": "A way of representing numbers using only two digits: 0 and 1.", "keywords": ["binary", "representation", "number"], "source_lectures": ["lecture_106104357_w5_l30"]}}
{"id": "concept_sharp_p_hardness", "type": "V_concept", "name": "Sharp-P Hardness", "properties": {"description": "A property of a problem that means it is at least as hard as the hardest problems in the Sharp-P complexity class.", "keywords": ["sharp-p", "hardness", "complexity"], "source_lectures": ["lecture_106104357_w5_l30"]}}
{"id": "concept_polynomial_time_reduction", "type": "V_concept", "name": "Polynomial Time Reduction", "properties": {"description": "A reduction from one problem to another that can be computed in polynomial time.", "keywords": ["theory", "time", "polynomial", "complexity", "problem", "reduction", "computation"], "source_lectures": ["lecture_106104357_w5_l30", "lecture_106104357_w2_l8", "lecture_106104357_w2_l11"]}}
{"id": "concept_counting_sat", "type": "V_concept", "name": "Counting SAT", "properties": {"description": "The problem of counting the number of satisfying assignments of a given Boolean formula.", "keywords": ["counting", "sat", "formula"], "source_lectures": ["lecture_106104357_w5_l30"]}}
{"id": "concept_functional_polynomial_time", "type": "V_concept", "name": "Functional Polynomial Time", "properties": {"description": "A complexity class that includes problems that can be solved in polynomial time using a functional reduction.", "keywords": ["functional", "polynomial", "time"], "source_lectures": ["lecture_106104357_w5_l30"]}}
{"id": "concept_valiant_vazirani_lemma", "type": "V_concept", "name": "Valiant-Vazirani Lemma", "properties": {"description": "A theorem that establishes a connection between the complexity classes NP and ParityP", "keywords": ["unique-sat", "lemma", "unique assignment", "hashing", "valiant", "satisfiability", "vazirani", "randomized reduction", "valiant-vazirani", "sat", "np", "parityp"], "source_lectures": ["lecture_106104357_w5_l31", "lecture_106104357_w5_l33", "lecture_106104357_w5_l32"]}}
{"id": "concept_sharpp_completeness", "type": "V_concept", "name": "SharpP Completeness", "properties": {"description": "A property of a problem that is complete for the complexity class SharpP", "keywords": ["sharpp", "completeness", "complexity", "class"], "source_lectures": ["lecture_106104357_w5_l31"]}}
{"id": "concept_parityp_complexity_class", "type": "V_concept", "name": "ParityP Complexity Class", "properties": {"description": "A complexity class that contains problems that can be solved by a nondeterministic Turing machine with an odd number of accepting paths", "keywords": ["parityp", "complexity", "class", "nondeterministic", "turing"], "source_lectures": ["lecture_106104357_w5_l31"]}}
{"id": "concept_randomized_reduction", "type": "V_concept", "name": "Randomized Reduction", "properties": {"description": "A technique used to reduce one problem to another using randomization", "keywords": ["probabilistic", "polynomial time", "technique", "randomized", "complexity", "randomized reduction", "problem", "reduction", "algorithm"], "source_lectures": ["lecture_106104357_w5_l31", "lecture_106104357_w5_l33", "lecture_106104357_w5_l34", "lecture_106104357_w5_l32"]}}
{"id": "concept_todas_theorem", "type": "V_concept", "name": "Toda's Theorem", "properties": {"description": "A theorem that establishes a connection between the complexity classes PH and SharpP", "keywords": ["polynomial", "sharpp", "p^#p", "ph", "oracle", "complexity", "toda's theorem", "polynomial hierarchy", "sharp set", "theorem", "hierarchy", "toda"], "source_lectures": ["lecture_106104357_w5_l31", "lecture_106104357_w5_l33", "lecture_106104357_w5_l34", "lecture_106104357_w5_l32"]}}
{"id": "concept_nondeterministic_turing_machine", "type": "V_concept", "name": "Nondeterministic Turing Machine", "properties": {"description": "A theoretical model of computation that can explore multiple branches of computation simultaneously", "keywords": ["model", "computational model", "ntm", "turing", "nondeterministic", "computation", "nondeterministic turing machine", "machine"], "source_lectures": ["lecture_106104357_w5_l31", "lecture_106104357_w3_l19", "lecture_106104357_w4_l26", "lecture_106104357_w4_l28"]}}
{"id": "concept_polytime_reduction", "type": "V_concept", "name": "Polytime Reduction", "properties": {"description": "A reduction between two problems that can be computed in polynomial time", "keywords": ["polytime", "reduction", "polynomial", "time", "complexity"], "source_lectures": ["lecture_106104357_w5_l31"]}}
{"id": "concept_pp_oracle", "type": "V_concept", "name": "PP Oracle", "properties": {"description": "An oracle that can solve problems in the complexity class PP", "keywords": ["pp", "oracle", "complexity", "class"], "source_lectures": ["lecture_106104357_w5_l31"]}}
{"id": "concept_sigma_protocol", "type": "V_concept", "name": "Sigma Protocol", "properties": {"description": "A protocol that reduces a problem in the complexity class Sigma to another problem", "keywords": ["sigma", "protocol", "reduction", "complexity", "class"], "source_lectures": ["lecture_106104357_w5_l31"]}}
{"id": "concept_parity_quantification", "type": "V_concept", "name": "Parity Quantification", "properties": {"description": "A method of quantification that uses parity to determine the existence of satisfying assignments.", "keywords": ["parity", "quantification", "satisfying assignments"], "source_lectures": ["lecture_106104357_w5_l33"]}}
{"id": "concept_hash_functions", "type": "V_concept", "name": "Hash Functions", "properties": {"description": "A mathematical function that maps input data of any size to a fixed-size output.", "keywords": ["hash", "function", "mapping"], "source_lectures": ["lecture_106104357_w5_l33"]}}
{"id": "concept_probability_amplification", "type": "V_concept", "name": "Probability Amplification", "properties": {"description": "A technique used to increase the success probability of a randomized algorithm.", "keywords": ["probability", "amplification", "randomized algorithm"], "source_lectures": ["lecture_106104357_w5_l33"]}}
{"id": "concept_union_bound", "type": "V_concept", "name": "Union Bound", "properties": {"description": "A mathematical inequality that bounds the probability of a union of events.", "keywords": ["inequality", "union", "union bound", "bound", "events", "probability", "probability bound"], "source_lectures": ["lecture_106104357_w5_l33", "lecture_106104233_w3_l17", "lecture_106104233_w4_l27"]}}
{"id": "concept_np_completeness", "type": "V_concept", "name": "NP-Completeness", "properties": {"description": "A concept in computational complexity theory that describes a class of problems that are at least as hard as the hardest problems in NP.", "keywords": ["theory", "completeness", "hardness", "polynomial", "computational", "np", "complexity", "computational complexity", "problem", "np-complete", "reduction", "computation", "np-completeness", "cryptography", "decision"], "source_lectures": ["lecture_106104357_w5_l33", "lecture_106106221_w9_l62", "lecture_106104357_w1_l1", "lecture_106104357_w2_l8", "lecture_106104357_w2_l10", "lecture_106104357_w2_l11", "lecture_106104357_w3_l16", "lecture_106104357_w7_l46"]}}
{"id": "concept_polynomial_hierarchy", "type": "V_concept", "name": "Polynomial Hierarchy", "properties": {"description": "A concept in computational complexity theory that describes a hierarchy of classes of problems that can be solved in polynomial time.", "keywords": ["polynomial", "conp", "class", "oracle", "complexity", "computational complexity", "turing", "nondeterministic", "np", "classes", "hierarchy", "machine"], "source_lectures": ["lecture_106104357_w5_l33", "lecture_106104357_w5_l34", "lecture_106104357_w7_l45", "lecture_106104357_w1_l2", "lecture_106104357_w4_l23", "lecture_106104357_w4_l24", "lecture_106104357_w4_l26"]}}
{"id": "concept_sharp_set", "type": "V_concept", "name": "Sharp Set", "properties": {"description": "A set that is used in the definition of the polynomial hierarchy.", "keywords": ["sharp", "set", "polynomial hierarchy"], "source_lectures": ["lecture_106104357_w5_l33"]}}
{"id": "concept_parity_operator", "type": "V_concept", "name": "Parity Operator", "properties": {"description": "A mathematical operator that determines whether a number is even or odd.", "keywords": ["parity", "operator", "modulus", "arithmetic"], "source_lectures": ["lecture_106104357_w5_l34"]}}
{"id": "concept_mod_2_arithmetic", "type": "V_concept", "name": "Mod 2 Arithmetic", "properties": {"description": "A system of arithmetic that uses modulo 2 operations.", "keywords": ["mod", "arithmetic", "binary", "operation"], "source_lectures": ["lecture_106104357_w5_l34"]}}
{"id": "concept_hensel_lifting", "type": "V_concept", "name": "Hensel Lifting", "properties": {"description": "A mathematical technique used to lift solutions from a smaller modulus to a larger one.", "keywords": ["hensel", "lifting", "modulus", "algebra"], "source_lectures": ["lecture_106104357_w5_l34"]}}
{"id": "concept_quantifier_reduction", "type": "V_concept", "name": "Quantifier Reduction", "properties": {"description": "A method of reducing the number of quantifiers in a logical formula.", "keywords": ["quantifier", "reduction", "logic", "formula"], "source_lectures": ["lecture_106104357_w5_l34"]}}
{"id": "concept_sigma_c_sat", "type": "V_concept", "name": "Sigma C Sat", "properties": {"description": "A complexity class that represents the set of problems that can be solved by a non-deterministic Turing machine with a certain number of quantifiers.", "keywords": ["sigma", "sat", "complexity", "class"], "source_lectures": ["lecture_106104357_w5_l34"]}}
{"id": "concept_parity_set", "type": "V_concept", "name": "Parity Set", "properties": {"description": "A set of problems that can be solved by a deterministic Turing machine using parity operators.", "keywords": ["parity", "set", "complexity", "class"], "source_lectures": ["lecture_106104357_w5_l34"]}}
{"id": "concept_derandomization", "type": "V_concept", "name": "Derandomization", "properties": {"description": "A technique used to convert a randomized algorithm into a deterministic one.", "keywords": ["derandomization", "algorithm", "randomized", "deterministic"], "source_lectures": ["lecture_106104357_w5_l34"]}}
{"id": "concept_probabilistic_turing_machine", "type": "V_concept", "name": "Probabilistic Turing Machine", "properties": {"description": "A type of Turing machine that uses random bits to make decisions during its computation.", "keywords": ["probabilistic", "turing", "random", "computation", "machine"], "source_lectures": ["lecture_106104357_w6_l36", "lecture_106104357_w6_l37"]}}
{"id": "concept_randomized_polynomial_time", "type": "V_concept", "name": "Randomized Polynomial Time", "properties": {"description": "A complexity class that refers to problems that can be solved in polynomial time using a probabilistic Turing machine.", "keywords": ["randomized", "polynomial", "time", "complexity", "probabilistic"], "source_lectures": ["lecture_106104357_w6_l36"]}}
{"id": "concept_bounded_error_probabilistic_polynomial_time", "type": "V_concept", "name": "Bounded Error Probabilistic Polynomial Time", "properties": {"description": "A complexity class that refers to problems that can be solved in polynomial time with a bounded error probability using a probabilistic Turing machine.", "keywords": ["bounded", "error", "probabilistic", "polynomial", "time"], "source_lectures": ["lecture_106104357_w6_l36"]}}
{"id": "concept_polytime", "type": "V_concept", "name": "Polytime", "properties": {"description": "A complexity class that refers to problems that can be solved in polynomial time.", "keywords": ["polytime", "polynomial", "time", "complexity", "class"], "source_lectures": ["lecture_106104357_w6_l36"]}}
{"id": "concept_deterministic_turing_machine", "type": "V_concept", "name": "Deterministic Turing Machine", "properties": {"description": "A type of Turing machine that always produces the same output given a particular input.", "keywords": ["deterministic", "turing", "machine", "input", "output"], "source_lectures": ["lecture_106104357_w6_l36"]}}
{"id": "concept_non_deterministic_turing_machine", "type": "V_concept", "name": "Non-Deterministic Turing Machine", "properties": {"description": "A type of Turing machine that can produce different outputs given a particular input.", "keywords": ["non-deterministic", "model", "input", "turing", "output", "computation", "accept", "machine"], "source_lectures": ["lecture_106104357_w6_l36", "lecture_106104357_w2_l8", "lecture_106104357_w3_l21"]}}
{"id": "concept_primality_test", "type": "V_concept", "name": "Primality Test", "properties": {"description": "An algorithm that determines whether a given number is prime or composite.", "keywords": ["primality", "test", "algorithm", "prime", "composite"], "source_lectures": ["lecture_106104357_w6_l36"]}}
{"id": "concept_solovay_strassen_algorithm", "type": "V_concept", "name": "Solovay-Strassen Algorithm", "properties": {"description": "A probabilistic algorithm for testing whether a given number is prime or composite.", "keywords": ["solovay", "strassen", "algorithm", "primality", "test"], "source_lectures": ["lecture_106104357_w6_l36"]}}
{"id": "concept_jacobi_symbol", "type": "V_concept", "name": "Jacobi Symbol", "properties": {"description": "A mathematical symbol used to determine whether a number is a quadratic residue modulo another number.", "keywords": ["jacobi", "symbol", "quadratic", "residue", "modulus"], "source_lectures": ["lecture_106104357_w6_l36"]}}
{"id": "concept_one_sided_error", "type": "V_concept", "name": "One-Sided Error", "properties": {"description": "A type of error that occurs when a probabilistic algorithm produces a false positive or false negative result, but not both.", "keywords": ["one-sided", "error", "probabilistic", "algorithm", "result"], "source_lectures": ["lecture_106104357_w6_l36"]}}
{"id": "concept_two_sided_error", "type": "V_concept", "name": "Two-Sided Error", "properties": {"description": "A type of error that occurs when a probabilistic algorithm produces both false positive and false negative results.", "keywords": ["two-sided", "error", "probabilistic", "algorithm", "result"], "source_lectures": ["lecture_106104357_w6_l36"]}}
{"id": "concept_boolean_function", "type": "V_concept", "name": "Boolean Function", "properties": {"description": "A mathematical function that takes Boolean values as input and returns a Boolean value as output.", "keywords": ["computing", "function", "boolean", "logic", "mathematics"], "source_lectures": ["lecture_106104357_w7_l44", "lecture_106104357_w1_l3"]}}
{"id": "concept_circuit_complexity", "type": "V_concept", "name": "Circuit Complexity", "properties": {"description": "A measure of the computational resources required to compute a function using a digital circuit.", "keywords": ["circuit", "complexity", "computation", "resources"], "source_lectures": ["lecture_106104357_w7_l44"]}}
{"id": "concept_upper_bound", "type": "V_concept", "name": "Upper Bound", "properties": {"description": "A maximum value or limit that a quantity can have.", "keywords": ["upper", "bound", "limit", "maximum"], "source_lectures": ["lecture_106104357_w7_l44"]}}
{"id": "concept_lower_bound", "type": "V_concept", "name": "Lower Bound", "properties": {"description": "A minimum value or limit that a quantity can have.", "keywords": ["lower", "bound", "limit", "minimum"], "source_lectures": ["lecture_106104357_w7_l44"]}}
{"id": "concept_proof_by_counting", "type": "V_concept", "name": "Proof By Counting", "properties": {"description": "A method of proof that involves counting the number of possible cases or configurations.", "keywords": ["proof", "counting", "method", "combinatorics"], "source_lectures": ["lecture_106104357_w7_l44"]}}
{"id": "concept_non_explicit_lower_bound", "type": "V_concept", "name": "Non-Explicit Lower Bound", "properties": {"description": "A lower bound that is proven to exist, but without providing an explicit example or construction.", "keywords": ["non-explicit", "lower", "bound", "existence"], "source_lectures": ["lecture_106104357_w7_l44"]}}
{"id": "concept_time_hierarchy_theorem", "type": "V_concept", "name": "Time Hierarchy Theorem", "properties": {"description": "A theorem that states that there are problems that can be solved in a certain amount of time, but not in a smaller amount of time.", "keywords": ["time", "dtimes", "time hierarchy", "complexity classes", "time bounds", "turing machine", "computation", "theorem", "hierarchy"], "source_lectures": ["lecture_106104357_w7_l44", "lecture_106104357_w2_l14"]}}
{"id": "concept_circuit_family", "type": "V_concept", "name": "Circuit Family", "properties": {"description": "A set of digital circuits, one for each input size, that compute a function.", "keywords": ["computational", "family", "problem", "function", "circuit", "computation"], "source_lectures": ["lecture_106104357_w7_l44", "lecture_106104357_w7_l46"]}}
{"id": "concept_ppoly", "type": "V_concept", "name": "P/poly", "properties": {"description": "A complexity class that consists of problems that have polynomial-sized circuit families.", "keywords": ["class", "complexity", "circuit", "problems", "p/poly", "decision"], "source_lectures": ["lecture_106104357_w7_l44", "lecture_106104357_w7_l46"]}}
{"id": "concept_boolean_circuit", "type": "V_concept", "name": "Boolean Circuit", "properties": {"description": "A mathematical model for digital circuits that consists of logical gates and wires.", "keywords": ["model", "gate", "representation", "operation", "parallel", "boolean", "circuit", "logic", "computation", "mathematical", "digital"], "source_lectures": ["lecture_106104357_w7_l45", "lecture_106104357_w7_l47", "lecture_106108229_w3_l18", "lecture_106108229_w7_l49"]}}
{"id": "concept_ppoly_complexity_class", "type": "V_concept", "name": "P/poly Complexity Class", "properties": {"description": "A complexity class that consists of decision problems that can be solved by polynomial-sized Boolean circuits.", "keywords": ["p/poly", "complexity", "class", "boolean", "circuit"], "source_lectures": ["lecture_106104357_w7_l45"]}}
{"id": "concept_non_uniform_hierarchy_theorem", "type": "V_concept", "name": "Non-uniform Hierarchy Theorem", "properties": {"description": "A theorem that states that there exists a hierarchy of complexity classes based on the size of Boolean circuits.", "keywords": ["non-uniform", "hierarchy", "theorem", "complexity", "class"], "source_lectures": ["lecture_106104357_w7_l45"]}}
{"id": "concept_turing_machine_with_advice", "type": "V_concept", "name": "Turing Machine with Advice", "properties": {"description": "A Turing machine that receives additional information, known as advice, to help it solve a decision problem.", "keywords": ["turing", "machine", "advice", "decision", "problem"], "source_lectures": ["lecture_106104357_w7_l45"]}}
{"id": "concept_advice_function", "type": "V_concept", "name": "Advice Function", "properties": {"description": "A function that provides additional information to a Turing machine to help it solve a decision problem.", "keywords": ["advice", "function", "turing", "machine", "decision"], "source_lectures": ["lecture_106104357_w7_l45"]}}
{"id": "concept_self_reducibility", "type": "V_concept", "name": "Self-reducibility", "properties": {"description": "A property of a decision problem that allows it to be reduced to a smaller instance of the same problem.", "keywords": ["self-reducibility", "decision", "problem", "reduction", "instance"], "source_lectures": ["lecture_106104357_w7_l45"]}}
{"id": "concept_karp_lipton_theorem", "type": "V_concept", "name": "Karp-Lipton Theorem", "properties": {"description": "A theorem that states that if SAT can be solved by polynomial-sized circuits, then the polynomial hierarchy collapses to the second level.", "keywords": ["karp-lipton", "theorem", "sat", "circuit", "polynomial"], "source_lectures": ["lecture_106104357_w7_l45"]}}
{"id": "concept_sat_problem", "type": "V_concept", "name": "SAT Problem", "properties": {"description": "A decision problem that consists of determining whether a given Boolean formula has a satisfying assignment.", "keywords": ["assignment", "satisfying", "satisfiability", "problem", "boolean", "sat", "formula"], "source_lectures": ["lecture_106104357_w7_l45", "lecture_106104357_w2_l10", "lecture_106104357_w3_l16"]}}
{"id": "concept_parallel_algorithm", "type": "V_concept", "name": "Parallel Algorithm", "properties": {"description": "A method of solving problems using multiple processors or gates simultaneously.", "keywords": ["processors", "gates", "units", "parallel", "design", "algorithm", "computation", "processing"], "source_lectures": ["lecture_106104357_w7_l47", "lecture_106103359_w1_l7"]}}
{"id": "concept_nc_complexity_class", "type": "V_concept", "name": "NC Complexity Class", "properties": {"description": "A class of problems that can be solved in parallel polynomial time, using a polynomial number of processors and logarithmic depth.", "keywords": ["nc", "complexity", "class", "parallel", "polynomial"], "source_lectures": ["lecture_106104357_w7_l47"]}}
{"id": "concept_ac_complexity_class", "type": "V_concept", "name": "AC Complexity Class", "properties": {"description": "A class of problems that can be solved in parallel polynomial time, using a polynomial number of processors and unbounded fan-in.", "keywords": ["ac", "complexity", "class", "parallel", "unbounded"], "source_lectures": ["lecture_106104357_w7_l47"]}}
{"id": "concept_nc0_complexity_class", "type": "V_concept", "name": "NC0 Complexity Class", "properties": {"description": "A subclass of NC, where the depth of the circuit is constant and the fan-in is constant.", "keywords": ["nc0", "complexity", "class", "constant", "depth"], "source_lectures": ["lecture_106104357_w7_l47"]}}
{"id": "concept_nc1_complexity_class", "type": "V_concept", "name": "NC1 Complexity Class", "properties": {"description": "A subclass of NC, where the depth of the circuit is logarithmic and the fan-in is constant.", "keywords": ["nc1", "complexity", "class", "logarithmic", "depth"], "source_lectures": ["lecture_106104357_w7_l47"]}}
{"id": "concept_p_completeness", "type": "V_concept", "name": "P-Completeness", "properties": {"description": "A property of a problem, where every problem in P can be reduced to it in logarithmic space.", "keywords": ["space", "complexity", "p-completeness", "hardness", "logarithmic", "computational complexity", "reduction"], "source_lectures": ["lecture_106104357_w7_l47", "lecture_106104357_w7_l48"]}}
{"id": "concept_log_space_reduction", "type": "V_concept", "name": "Log Space Reduction", "properties": {"description": "A reduction from one problem to another, where the reduction can be computed in logarithmic space.", "keywords": ["space", "complexity", "theory", "computational complexity", "reduction", "log", "log space reduction"], "source_lectures": ["lecture_106104357_w7_l47", "lecture_106104357_w7_l48"]}}
{"id": "concept_circuit_depth", "type": "V_concept", "name": "Circuit Depth", "properties": {"description": "The maximum number of gates that a signal must pass through from input to output in a circuit.", "keywords": ["circuit", "depth", "gates", "signal", "computation"], "source_lectures": ["lecture_106104357_w7_l47"]}}
{"id": "concept_fan_in", "type": "V_concept", "name": "Fan-In", "properties": {"description": "The number of inputs to a gate in a circuit.", "keywords": ["fan-in", "gate", "circuit", "inputs", "computation"], "source_lectures": ["lecture_106104357_w7_l47"]}}
{"id": "concept_nc", "type": "V_concept", "name": "NC", "properties": {"description": "A class of problems that can be solved in polylogarithmic time using a parallel computer.", "keywords": ["nc", "parallel computing", "polylogarithmic time"], "source_lectures": ["lecture_106104357_w7_l48"]}}
{"id": "concept_circuit_evaluation", "type": "V_concept", "name": "Circuit Evaluation", "properties": {"description": "The problem of determining whether a given circuit accepts a given input.", "keywords": ["evaluation", "input", "computational complexity", "circuit evaluation", "boolean", "output", "circuit", "digital"], "source_lectures": ["lecture_106104357_w7_l48", "lecture_106108229_w3_l18", "lecture_106108229_w7_l47"]}}
{"id": "concept_p_hardness", "type": "V_concept", "name": "P-Hardness", "properties": {"description": "A property of a problem that is at least as hard as the hardest problems in the class P.", "keywords": ["p-hardness", "computational complexity", "hardness"], "source_lectures": ["lecture_106104357_w7_l48"]}}
{"id": "concept_cook_levin_theorem", "type": "V_concept", "name": "Cook-Levin Theorem", "properties": {"description": "A theorem that states that the satisfiability problem is NP-complete.", "keywords": ["cook-levin theorem", "cook", "satisfiability", "complete", "boolean", "np-complete", "np", "theorem", "levin", "np-completeness"], "source_lectures": ["lecture_106104357_w7_l48", "lecture_106104357_w2_l11", "lecture_106104357_w4_l26"]}}
{"id": "concept_succinct_circuit", "type": "V_concept", "name": "Succinct Circuit", "properties": {"description": "A circuit that can be described using a small amount of information, but has a large number of gates and edges.", "keywords": ["succinct circuit", "computational complexity", "circuit"], "source_lectures": ["lecture_106104357_w7_l48"]}}
{"id": "concept_nexp_completeness", "type": "V_concept", "name": "NEXP-Completeness", "properties": {"description": "A property of a problem that is at least as hard as the hardest problems in the class NEXP.", "keywords": ["nexp-completeness", "computational complexity", "hardness"], "source_lectures": ["lecture_106104357_w7_l48"]}}
{"id": "concept_succinct_circuit_set", "type": "V_concept", "name": "Succinct Circuit Set", "properties": {"description": "The problem of determining whether a given succinct circuit has a satisfying assignment.", "keywords": ["succinct circuit set", "computational complexity", "circuit"], "source_lectures": ["lecture_106104357_w7_l48"]}}
{"id": "concept_exponential_time", "type": "V_concept", "name": "Exponential Time", "properties": {"description": "A measure of the time complexity of an algorithm, where the running time grows exponentially with the size of the input.", "keywords": ["exponential time", "time complexity", "algorithm"], "source_lectures": ["lecture_106104357_w7_l48"]}}
{"id": "concept_probability_definition", "type": "V_concept", "name": "Probability Definition", "properties": {"description": "A measure of the likelihood of an event occurring, calculated as the number of favorable outcomes divided by the total number of possible outcomes.", "keywords": ["probability", "likelihood", "event", "outcome"], "source_lectures": ["lecture_106104233_w1_l1"]}}
{"id": "concept_unbiased_coin", "type": "V_concept", "name": "Unbiased Coin", "properties": {"description": "A coin that has an equal probability of landing on either side, typically heads or tails.", "keywords": ["unbiased", "coin", "probability", "fair"], "source_lectures": ["lecture_106104233_w1_l1"]}}
{"id": "concept_fair_coin_toss", "type": "V_concept", "name": "Fair Coin Toss", "properties": {"description": "An experiment where a fair coin is tossed, resulting in either heads or tails with equal probability.", "keywords": ["fair", "coin", "toss", "probability"], "source_lectures": ["lecture_106104233_w1_l1"]}}
{"id": "concept_co_prime_numbers", "type": "V_concept", "name": "Co-Prime Numbers", "properties": {"description": "Two numbers that have no common factors other than 1.", "keywords": ["co-prime", "numbers", "factors"], "source_lectures": ["lecture_106104233_w1_l1"]}}
{"id": "concept_greatest_common_divisor_gcd", "type": "V_concept", "name": "Greatest Common Divisor (GCD)", "properties": {"description": "The largest positive integer that divides two numbers without leaving a remainder.", "keywords": ["integer", "gcd", "greatest", "numbers", "divisor", "common"], "source_lectures": ["lecture_106104233_w1_l1", "lecture_106106931_w1_l5", "lecture_106106221_w8_l55"]}}
{"id": "concept_random_chord_experiment", "type": "V_concept", "name": "Random Chord Experiment", "properties": {"description": "An experiment where a random chord is drawn in a circle, and the probability of the chord's length is calculated.", "keywords": ["random", "chord", "circle", "probability"], "source_lectures": ["lecture_106104233_w1_l1"]}}
{"id": "concept_geometric_probability", "type": "V_concept", "name": "Geometric Probability", "properties": {"description": "A method of calculating probability using geometric shapes and their properties.", "keywords": ["geometric", "probability", "shapes"], "source_lectures": ["lecture_106104233_w1_l1"]}}
{"id": "concept_infinite_sample_space", "type": "V_concept", "name": "Infinite Sample Space", "properties": {"description": "A sample space that contains an infinite number of possible outcomes.", "keywords": ["outcomes", "space", "sample", "infinite", "sample space", "elements"], "source_lectures": ["lecture_106104233_w1_l1", "lecture_106104233_w1_l2", "lecture_106104233_w1_l3", "lecture_106104233_w2_l10"]}}
{"id": "concept_formal_definition_of_probability", "type": "V_concept", "name": "Formal Definition of Probability", "properties": {"description": "A rigorous and mathematical definition of probability that can handle infinite sample spaces.", "keywords": ["formal", "definition", "probability", "mathematical"], "source_lectures": ["lecture_106104233_w1_l1"]}}
{"id": "concept_symmetry_in_probability", "type": "V_concept", "name": "Symmetry in Probability", "properties": {"description": "The use of symmetry to simplify probability calculations and reduce the number of possible outcomes.", "keywords": ["symmetry", "probability", "calculations"], "source_lectures": ["lecture_106104233_w1_l1"]}}
{"id": "concept_probability_function", "type": "V_concept", "name": "Probability Function", "properties": {"description": "A mathematical function that assigns a probability to each subset of a sample space.", "keywords": ["probability", "function", "sample", "space"], "source_lectures": ["lecture_106104233_w1_l2"]}}
{"id": "concept_counting_principle", "type": "V_concept", "name": "Counting Principle", "properties": {"description": "A principle used to count the number of possible outcomes in a finite sample space.", "keywords": ["counting", "principle", "finite", "outcomes"], "source_lectures": ["lecture_106104233_w1_l2"]}}
{"id": "concept_probability_paradox", "type": "V_concept", "name": "Probability Paradox", "properties": {"description": "A situation where different probability functions assign different probabilities to the same event.", "keywords": ["probability", "paradox", "event", "functions"], "source_lectures": ["lecture_106104233_w1_l2"]}}
{"id": "concept_false_positives", "type": "V_concept", "name": "False Positives", "properties": {"description": "The number of false positive results in a test or experiment.", "keywords": ["false", "positives", "test", "results"], "source_lectures": ["lecture_106104233_w1_l2"]}}
{"id": "concept_false_negatives", "type": "V_concept", "name": "False Negatives", "properties": {"description": "The number of false negative results in a test or experiment.", "keywords": ["false", "negatives", "test", "results"], "source_lectures": ["lecture_106104233_w1_l2"]}}
{"id": "concept_true_positives", "type": "V_concept", "name": "True Positives", "properties": {"description": "The number of true positive results in a test or experiment.", "keywords": ["true", "positives", "test", "results"], "source_lectures": ["lecture_106104233_w1_l2"]}}
{"id": "concept_probabilistic_method", "type": "V_concept", "name": "Probabilistic Method", "properties": {"description": "A method used to prove the existence of an object or event by calculating its probability.", "keywords": ["probabilistic", "method", "technique", "existence", "proof", "probability", "combinatorics", "mathematics"], "source_lectures": ["lecture_106104233_w1_l2", "lecture_106104233_w4_l26", "lecture_106104233_w4_l27", "lecture_106104233_w4_l28", "lecture_106104233_w5_l29", "lecture_106104233_w5_l31"]}}
{"id": "concept_concentration_inequalities", "type": "V_concept", "name": "Concentration Inequalities", "properties": {"description": "Inequalities used to bound the probability of a random variable deviating from its expected value.", "keywords": ["inequalities", "concentration inequalities", "statistics", "deviation", "concentration", "random variable", "probability"], "source_lectures": ["lecture_106104233_w1_l2", "lecture_106108841_w3_l21", "lecture_106104233_w3_l15"]}}
{"id": "concept_random_variables", "type": "V_concept", "name": "Random Variables", "properties": {"description": "Variables whose possible values are determined by chance events.", "keywords": ["random", "variables", "chance", "events"], "source_lectures": ["lecture_106104233_w1_l2"]}}
{"id": "concept_expectation", "type": "V_concept", "name": "Expectation", "properties": {"description": "The long-run average value of a random variable.", "keywords": ["statistics", "expectation", "tendency", "random", "variable", "random variable", "average", "central tendency", "central"], "source_lectures": ["lecture_106104233_w1_l2", "lecture_106108841_w3_l15", "lecture_106104233_w2_l13", "lecture_106104233_w3_l15", "lecture_106104233_w5_l29"]}}
{"id": "concept_moments", "type": "V_concept", "name": "Moments", "properties": {"description": "Quantities used to describe the shape and behavior of a probability distribution.", "keywords": ["moments", "probability", "distribution", "shape"], "source_lectures": ["lecture_106104233_w1_l2"]}}
{"id": "concept_probability_distribution_function", "type": "V_concept", "name": "Probability Distribution Function", "properties": {"description": "A function that assigns a probability to each element in the sample space.", "keywords": ["space", "subset", "sample", "function", "sample space", "probability", "distribution"], "source_lectures": ["lecture_106104233_w1_l3", "lecture_106104233_w1_l5", "lecture_106104233_w2_l8"]}}
{"id": "concept_finite_sample_space", "type": "V_concept", "name": "Finite Sample Space", "properties": {"description": "A sample space with a finite number of elements.", "keywords": ["finite", "sample space", "elements"], "source_lectures": ["lecture_106104233_w1_l3"]}}
{"id": "concept_probability_axioms", "type": "V_concept", "name": "Probability Axioms", "properties": {"description": "A set of axioms that define the properties of a probability measure.", "keywords": ["probability", "axioms", "properties", "measure"], "source_lectures": ["lecture_106104233_w1_l3"]}}
{"id": "concept_union_of_events", "type": "V_concept", "name": "Union of Events", "properties": {"description": "The event that occurs when at least one of the individual events occurs.", "keywords": ["union", "events", "individual events"], "source_lectures": ["lecture_106104233_w1_l3"]}}
{"id": "concept_intersection_of_events", "type": "V_concept", "name": "Intersection of Events", "properties": {"description": "The event that occurs when all of the individual events occur.", "keywords": ["intersection", "events", "individual events"], "source_lectures": ["lecture_106104233_w1_l3"]}}
{"id": "concept_complement_of_an_event", "type": "V_concept", "name": "Complement of an Event", "properties": {"description": "The event that occurs when the individual event does not occur.", "keywords": ["complement", "event", "individual event"], "source_lectures": ["lecture_106104233_w1_l3"]}}
{"id": "concept_probability_of_the_union", "type": "V_concept", "name": "Probability of the Union", "properties": {"description": "The probability that at least one of the individual events occurs.", "keywords": ["probability", "union", "individual events"], "source_lectures": ["lecture_106104233_w1_l3"]}}
{"id": "concept_probability_of_the_complement", "type": "V_concept", "name": "Probability of the Complement", "properties": {"description": "The probability that the individual event does not occur.", "keywords": ["probability", "complement", "individual event"], "source_lectures": ["lecture_106104233_w1_l3"]}}
{"id": "concept_inclusion_exclusion_principle", "type": "V_concept", "name": "Inclusion-Exclusion Principle", "properties": {"description": "A principle for calculating the probability of the union of multiple events.", "keywords": ["intersection", "principle", "inclusion-exclusion", "overlap", "exclusion", "inclusion", "union", "counting", "probability", "set"], "source_lectures": ["lecture_106104233_w1_l3", "lecture_106104233_w1_l4", "lecture_106104233_w1_l5", "lecture_106104357_w5_l32", "lecture_106104233_w2_l11", "lecture_106104233_w3_l17"]}}
{"id": "concept_derangement", "type": "V_concept", "name": "Derangement", "properties": {"description": "A permutation of objects in which no object is in its original position.", "keywords": ["derangement", "permutation", "object", "position"], "source_lectures": ["lecture_106104233_w1_l4"]}}
{"id": "concept_complement_event", "type": "V_concept", "name": "Complement Event", "properties": {"description": "An event that occurs when the original event does not occur.", "keywords": ["complement", "event", "probability", "occurrence"], "source_lectures": ["lecture_106104233_w1_l4"]}}
{"id": "concept_binomial_expansion", "type": "V_concept", "name": "Binomial Expansion", "properties": {"description": "A way of expanding a binomial expression using the binomial theorem.", "keywords": ["binomial", "expansion", "theorem", "expression"], "source_lectures": ["lecture_106104233_w1_l4"]}}
{"id": "concept_permutation", "type": "V_concept", "name": "Permutation", "properties": {"description": "An arrangement of objects in a specific order.", "keywords": ["permutation", "arrangement", "object", "order"], "source_lectures": ["lecture_106104233_w1_l4"]}}
{"id": "concept_factorial", "type": "V_concept", "name": "Factorial", "properties": {"description": "The product of all positive integers up to a given number.", "keywords": ["factorial", "product", "integer", "number"], "source_lectures": ["lecture_106104233_w1_l4"]}}
{"id": "concept_eulers_number", "type": "V_concept", "name": "Euler's Number", "properties": {"description": "A mathematical constant approximately equal to 2.71828, often used in probability and statistics.", "keywords": ["euler", "number", "constant", "probability", "statistics"], "source_lectures": ["lecture_106104233_w1_l4"]}}
{"id": "concept_set_union", "type": "V_concept", "name": "Set Union", "properties": {"description": "The set of all elements that are in at least one of the sets.", "keywords": ["set", "union", "element", "set theory"], "source_lectures": ["lecture_106104233_w1_l4"]}}
{"id": "concept_countable_union", "type": "V_concept", "name": "Countable Union", "properties": {"description": "A union of a countable number of subsets, where the index set is at most countably infinite.", "keywords": ["countable", "union", "subset", "index", "set"], "source_lectures": ["lecture_106104233_w1_l5"]}}
{"id": "concept_uniform_distribution", "type": "V_concept", "name": "Uniform Distribution", "properties": {"description": "A probability distribution where every possible outcome has an equal probability of occurring.", "keywords": ["distribution", "uniform", "equal", "probability", "continuous", "outcome"], "source_lectures": ["lecture_106104233_w1_l5", "lecture_106108841_w2_l12", "lecture_106104233_w4_l25"]}}
{"id": "concept_countably_infinite_set", "type": "V_concept", "name": "Countably Infinite Set", "properties": {"description": "A set with a countably infinite number of elements, where each element can be put into a one-to-one correspondence with the natural numbers.", "keywords": ["countably", "infinite", "set", "element", "natural"], "source_lectures": ["lecture_106104233_w1_l5"]}}
{"id": "concept_partition_formula", "type": "V_concept", "name": "Partition Formula", "properties": {"description": "A formula used to calculate the probability of an event by partitioning the sample space into disjoint subsets.", "keywords": ["disjoint", "formula", "probability", "partition", "expected", "sample space", "event", "value"], "source_lectures": ["lecture_106104233_w1_l6", "lecture_106104233_w1_l7", "lecture_106104233_w2_l8", "lecture_106104233_w2_l10"]}}
{"id": "concept_relative_probability", "type": "V_concept", "name": "Relative Probability", "properties": {"description": "The probability of an event occurring given that another event has occurred, also known as conditional probability.", "keywords": ["relative", "probability", "conditional", "given"], "source_lectures": ["lecture_106104233_w1_l6"]}}
{"id": "concept_intersection_probability", "type": "V_concept", "name": "Intersection Probability", "properties": {"description": "The probability of two or more events occurring together.", "keywords": ["intersection", "probability", "events", "together"], "source_lectures": ["lecture_106104233_w1_l6"]}}
{"id": "concept_mutually_exclusive_events", "type": "V_concept", "name": "Mutually Exclusive Events", "properties": {"description": "Events that cannot occur together, used in partitioning the sample space.", "keywords": ["mutually", "exclusive", "events", "partitioning"], "source_lectures": ["lecture_106104233_w1_l6"]}}
{"id": "concept_disjoint_union", "type": "V_concept", "name": "Disjoint Union", "properties": {"description": "A union of sets that are mutually exclusive, used in partitioning the sample space.", "keywords": ["disjoint", "union", "sets", "mutually exclusive"], "source_lectures": ["lecture_106104233_w1_l6"]}}
{"id": "concept_conditional_probability_formula", "type": "V_concept", "name": "Conditional Probability Formula", "properties": {"description": "A formula used to calculate the probability of an event given that another event has occurred.", "keywords": ["conditional", "probability", "formula", "given"], "source_lectures": ["lecture_106104233_w1_l6"]}}
{"id": "concept_independent_events", "type": "V_concept", "name": "Independent Events", "properties": {"description": "Events that do not affect the probability of each other occurring.", "keywords": ["independent", "events", "probability", "occurrence"], "source_lectures": ["lecture_106104233_w1_l7"]}}
{"id": "concept_dependent_events", "type": "V_concept", "name": "Dependent Events", "properties": {"description": "Events that affect the probability of each other occurring.", "keywords": ["dependent", "events", "probability", "occurrence"], "source_lectures": ["lecture_106104233_w1_l7"]}}
{"id": "concept_disjoint_events", "type": "V_concept", "name": "Disjoint Events", "properties": {"description": "Events that cannot occur at the same time.", "keywords": ["disjoint", "events", "occurrence", "mutually exclusive"], "source_lectures": ["lecture_106104233_w1_l7"]}}
{"id": "concept_base_rate_fallacy", "type": "V_concept", "name": "Base Rate Fallacy", "properties": {"description": "A fallacy that occurs when the base rate of an event is ignored in favor of more specific information.", "keywords": ["base rate", "fallacy", "probability", "ignoring"], "source_lectures": ["lecture_106104233_w1_l7"]}}
{"id": "concept_hypothesis_testing", "type": "V_concept", "name": "Hypothesis Testing", "properties": {"description": "A statistical technique used to test a hypothesis about a population.", "keywords": ["statistical", "hypothesis testing", "hypothesis", "technique", "testing", "statistical methods"], "source_lectures": ["lecture_106104233_w1_l7", "lecture_106108841_w4_l27"]}}
{"id": "concept_medical_diagnosis", "type": "V_concept", "name": "Medical Diagnosis", "properties": {"description": "The process of determining the presence or absence of a disease or condition.", "keywords": ["medical", "diagnosis", "disease", "condition"], "source_lectures": ["lecture_106104233_w1_l7"]}}
{"id": "concept_rt_pcr_test", "type": "V_concept", "name": "RT-PCR Test", "properties": {"description": "A medical test used to detect the presence of a specific genetic material.", "keywords": ["rt-pcr", "test", "medical", "genetic material"], "source_lectures": ["lecture_106104233_w1_l7"]}}
{"id": "concept_monty_hall_fallacy", "type": "V_concept", "name": "Monty Hall Fallacy", "properties": {"description": "A probability puzzle where a game show contestant has to decide whether to switch their choice of door after the host reveals a goat behind one of the other doors.", "keywords": ["monty hall", "fallacy", "probability", "game show", "puzzle"], "source_lectures": ["lecture_106104233_w2_l8"]}}
{"id": "concept_discrete_random_variable", "type": "V_concept", "name": "Discrete Random Variable", "properties": {"description": "A random variable that takes on a countable number of distinct values.", "keywords": ["values", "discrete", "statistics", "random", "variable", "probability", "countable"], "source_lectures": ["lecture_106104233_w2_l8", "lecture_106108841_w3_l21"]}}
{"id": "concept_independence_of_events", "type": "V_concept", "name": "Independence Of Events", "properties": {"description": "A property of events where the occurrence of one event does not affect the probability of another event.", "keywords": ["independence", "events", "probability", "occurrence"], "source_lectures": ["lecture_106104233_w2_l9"]}}
{"id": "concept_independence_of_random_variables", "type": "V_concept", "name": "Independence Of Random Variables", "properties": {"description": "A property of random variables where the probability distribution of one variable does not depend on the value of another variable.", "keywords": ["independence", "random", "variables", "probability", "distribution"], "source_lectures": ["lecture_106104233_w2_l9"]}}
{"id": "concept_correlation", "type": "V_concept", "name": "Correlation", "properties": {"description": "A measure of the linear relationship between two random variables.", "keywords": ["correlation", "random", "variables", "linear", "relationship"], "source_lectures": ["lecture_106104233_w2_l9"]}}
{"id": "concept_anti_correlation", "type": "V_concept", "name": "Anti-Correlation", "properties": {"description": "A property of random variables where an increase in one variable is associated with a decrease in another variable.", "keywords": ["anti-correlation", "random", "variables", "increase", "decrease"], "source_lectures": ["lecture_106104233_w2_l9"]}}
{"id": "concept_fair_game", "type": "V_concept", "name": "Fair Game", "properties": {"description": "A game where the expected value of the outcome is zero, meaning that neither player has an advantage.", "keywords": ["fair", "game", "expected", "value", "outcome"], "source_lectures": ["lecture_106104233_w2_l9"]}}
{"id": "concept_birthday_problem", "type": "V_concept", "name": "Birthday Problem", "properties": {"description": "A problem that calculates the probability of at least two people sharing the same birthday in a group of people.", "keywords": ["birthday", "problem", "probability", "shared", "birthday"], "source_lectures": ["lecture_106104233_w2_l9"]}}
{"id": "concept_binomial_distribution", "type": "V_concept", "name": "Binomial Distribution", "properties": {"description": "A discrete probability distribution that models the number of successes in a fixed number of independent trials.", "keywords": ["binomial", "distribution", "discrete", "probability", "trials"], "source_lectures": ["lecture_106104233_w2_l9"]}}
{"id": "concept_expected_payoff", "type": "V_concept", "name": "Expected Payoff", "properties": {"description": "The average payoff or return of a random experiment or game.", "keywords": ["expected", "payoff", "average", "return"], "source_lectures": ["lecture_106104233_w2_l10"]}}
{"id": "concept_conditional_expectation", "type": "V_concept", "name": "Conditional Expectation", "properties": {"description": "The expected value of a random variable given that a certain event has occurred.", "keywords": ["event", "value", "expected", "conditional", "expectation", "random", "variable", "information", "given"], "source_lectures": ["lecture_106104233_w2_l10", "lecture_106108841_w2_l12", "lecture_106108841_w3_l18", "lecture_106101360_w10_l49"]}}
{"id": "concept_linearity_of_expectation", "type": "V_concept", "name": "Linearity Of Expectation", "properties": {"description": "The property that the expected value of a sum of random variables is equal to the sum of their expected values.", "keywords": ["variables", "sum", "property", "expected value", "statistics", "expectation", "random variables", "random", "variable", "probability", "mathematics", "linearity"], "source_lectures": ["lecture_106104233_w2_l10", "lecture_106105847_w3_l18", "lecture_106104233_w2_l11", "lecture_106104233_w2_l13", "lecture_106104233_w3_l17", "lecture_106104233_w4_l27", "lecture_106104233_w4_l28", "lecture_106104233_w5_l29"]}}
{"id": "concept_convergent_value", "type": "V_concept", "name": "Convergent Value", "properties": {"description": "A value that a series or sequence approaches as the number of terms increases without bound.", "keywords": ["convergent", "value", "series", "sequence"], "source_lectures": ["lecture_106104233_w2_l10"]}}
{"id": "concept_divergent_series", "type": "V_concept", "name": "Divergent Series", "properties": {"description": "A series whose sum increases without bound as the number of terms increases.", "keywords": ["divergent", "series", "sum", "increases"], "source_lectures": ["lecture_106104233_w2_l10"]}}
{"id": "concept_cloud_computing", "type": "V_concept", "name": "Cloud Computing", "properties": {"description": "A model of delivering computing services over the internet, where resources are provided as a service to users on-demand.", "keywords": ["cloud", "internet", "resources", "computing", "on-demand"], "source_lectures": ["lecture_106104449_w1_l2", "lecture_106104449_w1_l3", "lecture_106104182_w1_l1", "lecture_106104182_w1_l5", "lecture_106104182_w4_l22"]}}
{"id": "concept_client_server_architecture", "type": "V_concept", "name": "Client Server Architecture", "properties": {"description": "A distributed application structure that separates the client, which requests services, from the server, which provides services.", "keywords": ["client", "server", "architecture", "distributed"], "source_lectures": ["lecture_106104449_w1_l2"]}}
{"id": "concept_virtual_machines", "type": "V_concept", "name": "Virtual Machines", "properties": {"description": "A software emulation of a physical computer, allowing multiple operating systems to run on a single physical machine.", "keywords": ["virtual", "machine", "emulation", "operating system"], "source_lectures": ["lecture_106104449_w1_l2"]}}
{"id": "concept_containerization", "type": "V_concept", "name": "Containerization", "properties": {"description": "A lightweight and portable way to deploy applications, where an application and its dependencies are packaged into a single container.", "keywords": ["dependencies", "deployment", "kernel sharing", "docker", "containers", "virtual", "portable", "lightweight", "isolation", "containerization", "machines", "application", "os-level virtualization"], "source_lectures": ["lecture_106104449_w1_l2", "lecture_106104449_w1_l3", "lecture_106104182_w4_l22", "lecture_106104449_w1_l6", "lecture_106104449_w1_l7"]}}
{"id": "concept_content_delivery_network", "type": "V_concept", "name": "Content Delivery Network", "properties": {"description": "A distributed network of servers that cache and distribute content, such as videos and images, to reduce latency and improve performance.", "keywords": ["content", "delivery", "network", "cache", "latency"], "source_lectures": ["lecture_106104449_w1_l2"]}}
{"id": "concept_programmable_network", "type": "V_concept", "name": "Programmable Network", "properties": {"description": "A network that allows software to control and manage network behavior, enabling more flexibility and automation.", "keywords": ["programmable", "network", "software", "control", "automation"], "source_lectures": ["lecture_106104449_w1_l2"]}}
{"id": "concept_edge_computing", "type": "V_concept", "name": "Edge Computing", "properties": {"description": "A distributed computing paradigm that brings computation and data storage closer to the source of the data, reducing latency and improving performance.", "keywords": ["latency", "paradigm", "decentralized", "edge", "computing", "network", "distributed", "iot", "data", "realtime", "performance"], "source_lectures": ["lecture_106104449_w1_l2", "lecture_106104449_w1_l3", "lecture_106104449_w1_l4", "lecture_106104449_w2_l14", "lecture_106104182_w4_l23"]}}
{"id": "concept_round_trip_time", "type": "V_concept", "name": "Round Trip Time", "properties": {"description": "The time it takes for a signal to travel from a device to a server and back, often used to measure network latency.", "keywords": ["round", "trip", "time", "latency", "network"], "source_lectures": ["lecture_106104449_w1_l2"]}}
{"id": "concept_micro_data_center", "type": "V_concept", "name": "Micro Data Center", "properties": {"description": "A small, modular data center that can be deployed at the edge of a network, providing low-latency and high-performance computing.", "keywords": ["micro", "data", "center", "edge", "latency"], "source_lectures": ["lecture_106104449_w1_l2"]}}
{"id": "concept_cloudlet", "type": "V_concept", "name": "Cloudlet", "properties": {"description": "A small, cloud-based data center that provides low-latency and high-performance computing, often used to support edge computing applications.", "keywords": ["cloudlet", "cloud", "edge", "infrastructure", "center", "computing", "mobile", "data"], "source_lectures": ["lecture_106104449_w1_l2", "lecture_106104449_w1_l4", "lecture_106104449_w2_l11"]}}
{"id": "concept_5g_network", "type": "V_concept", "name": "5G Network", "properties": {"description": "A fifth-generation wireless network that provides faster data rates, lower latency, and greater connectivity than previous generations.", "keywords": ["5g", "network", "wireless", "faster", "latency"], "source_lectures": ["lecture_106104449_w1_l2"]}}
{"id": "concept_latency_reduction", "type": "V_concept", "name": "Latency Reduction", "properties": {"description": "The process of minimizing the time it takes for data to travel from a device to a server and back, often used to improve performance and user experience.", "keywords": ["latency", "reduction", "performance", "user", "experience"], "source_lectures": ["lecture_106104449_w1_l2"]}}
{"id": "concept_bandwidth_reduction", "type": "V_concept", "name": "Bandwidth Reduction", "properties": {"description": "The process of minimizing the amount of data that needs to be transmitted over a network, often used to improve performance and reduce costs.", "keywords": ["bandwidth", "reduction", "performance", "cost", "network"], "source_lectures": ["lecture_106104449_w1_l2"]}}
{"id": "concept_operating_cost_reduction", "type": "V_concept", "name": "Operating Cost Reduction", "properties": {"description": "The process of minimizing the costs associated with operating a network or data center, often used to improve efficiency and reduce expenses.", "keywords": ["operating", "cost", "reduction", "efficiency", "expenses"], "source_lectures": ["lecture_106104449_w1_l2"]}}
{"id": "concept_security_enhancement", "type": "V_concept", "name": "Security Enhancement", "properties": {"description": "The process of improving the security of a network or data center, often used to protect against threats and minimize risks.", "keywords": ["security", "enhancement", "network", "data", "center"], "source_lectures": ["lecture_106104449_w1_l2"]}}
{"id": "concept_data_sovereignty", "type": "V_concept", "name": "Data Sovereignty", "properties": {"description": "The concept of having control over one's own data, including where it is stored, processed, and accessed.", "keywords": ["data", "sovereignty", "control", "storage", "processing"], "source_lectures": ["lecture_106104449_w1_l3"]}}
{"id": "concept_edge_node", "type": "V_concept", "name": "Edge Node", "properties": {"description": "A device or server that acts as an entry point for data and applications at the edge of a network, often providing caching, processing, and security functions.", "keywords": ["edge", "node", "device", "server", "network"], "source_lectures": ["lecture_106104449_w1_l3"]}}
{"id": "concept_mqtt_protocol", "type": "V_concept", "name": "MQTT Protocol", "properties": {"description": "A lightweight messaging protocol used for machine-to-machine communication, particularly in IoT applications.", "keywords": ["mqtt", "protocol", "messaging", "machine", "iot"], "source_lectures": ["lecture_106104449_w1_l3"]}}
{"id": "concept_object_storage", "type": "V_concept", "name": "Object Storage", "properties": {"description": "A type of storage that manages data as objects, rather than files or blocks, often used for unstructured data such as images and videos.", "keywords": ["object", "storage", "unstructured", "data", "images"], "source_lectures": ["lecture_106104449_w1_l3"]}}
{"id": "concept_stream_processing", "type": "V_concept", "name": "Stream Processing", "properties": {"description": "A type of data processing that involves analyzing and processing data in real-time, as it flows through a system.", "keywords": ["stream", "processing", "real-time", "data", "analysis"], "source_lectures": ["lecture_106104449_w1_l3"]}}
{"id": "concept_function_as_a_service", "type": "V_concept", "name": "Function as a Service", "properties": {"description": "A cloud computing model that allows developers to run small code snippets or functions without provisioning or managing infrastructure.", "keywords": ["function", "service", "cloud", "computing", "serverless"], "source_lectures": ["lecture_106104449_w1_l3"]}}
{"id": "concept_three_tier_architecture", "type": "V_concept", "name": "Three-Tier Architecture", "properties": {"description": "A software architecture pattern that consists of three layers: presentation, application, and data storage, often used in web applications.", "keywords": ["three-tier", "architecture", "layers", "web", "applications"], "source_lectures": ["lecture_106104449_w1_l3"]}}
{"id": "concept_data_source_tier", "type": "V_concept", "name": "Data Source Tier", "properties": {"description": "The layer of an edge computing architecture that generates data, such as sensors, devices, or applications.", "keywords": ["data", "source", "tier", "edge", "computing"], "source_lectures": ["lecture_106104449_w1_l3"]}}
{"id": "concept_intelligence_tier", "type": "V_concept", "name": "Intelligence Tier", "properties": {"description": "The layer of an edge computing architecture that processes and analyzes data, often using machine learning or other advanced analytics techniques.", "keywords": ["intelligence", "tier", "edge", "computing", "analytics"], "source_lectures": ["lecture_106104449_w1_l3"]}}
{"id": "concept_actionable_insight_tier", "type": "V_concept", "name": "Actionable Insight Tier", "properties": {"description": "The layer of an edge computing architecture that provides insights and recommendations based on analyzed data, often used for decision-making or automation.", "keywords": ["actionable", "insight", "tier", "edge", "computing"], "source_lectures": ["lecture_106104449_w1_l3"]}}
{"id": "concept_thick_edge", "type": "V_concept", "name": "Thick Edge", "properties": {"description": "A type of edge computing that uses full-fledged data centers located at cell towers or on-premise.", "keywords": ["thick", "edge", "data", "center", "cellular"], "source_lectures": ["lecture_106104449_w1_l4"]}}
{"id": "concept_thin_edge", "type": "V_concept", "name": "Thin Edge", "properties": {"description": "A type of edge computing that uses intelligent controllers, networking equipment, and computers located close to the source.", "keywords": ["thin", "edge", "controller", "networking", "computer"], "source_lectures": ["lecture_106104449_w1_l4"]}}
{"id": "concept_micro_edge", "type": "V_concept", "name": "Micro Edge", "properties": {"description": "A type of edge computing that uses intelligent sensors and devices that generate data.", "keywords": ["micro", "edge", "sensor", "device", "iot"], "source_lectures": ["lecture_106104449_w1_l4"]}}
{"id": "concept_fog_computing", "type": "V_concept", "name": "Fog Computing", "properties": {"description": "A distributed computing paradigm that extends cloud computing to the edge of the network.", "keywords": ["distributed", "cloud", "edge", "network", "computing", "fog"], "source_lectures": ["lecture_106104449_w1_l4", "lecture_106104449_w2_l11"]}}
{"id": "concept_mobile_edge_computing", "type": "V_concept", "name": "Mobile Edge Computing", "properties": {"description": "A computing paradigm that provides computing capabilities at the edge of cellular networks.", "keywords": ["cloud", "edge", "network", "computing", "cellular", "mobile"], "source_lectures": ["lecture_106104449_w1_l4", "lecture_106104449_w2_l11"]}}
{"id": "concept_collaborative_edge_computing", "type": "V_concept", "name": "Collaborative Edge Computing", "properties": {"description": "A computing paradigm that combines edge computing and cloud computing to provide optimal computing resources.", "keywords": ["collaborative", "edge", "computing", "cloud", "optimal"], "source_lectures": ["lecture_106104449_w1_l4"]}}
{"id": "concept_edge_cloud_system_architecture", "type": "V_concept", "name": "Edge Cloud System Architecture", "properties": {"description": "A system architecture that supports scheduling and offloading tasks of IoT applications.", "keywords": ["edge", "cloud", "system", "architecture", "iot"], "source_lectures": ["lecture_106104449_w1_l4"]}}
{"id": "concept_latency_model", "type": "V_concept", "name": "Latency Model", "properties": {"description": "A mathematical model that calculates the delay of different offloading scenarios in edge computing.", "keywords": ["latency", "model", "offloading", "edge", "computing"], "source_lectures": ["lecture_106104449_w1_l4"]}}
{"id": "concept_offloading_strategy", "type": "V_concept", "name": "Offloading Strategy", "properties": {"description": "A technique used to allocate tasks between edge devices and cloud servers to minimize latency and optimize resource utilization.", "keywords": ["offloading", "strategy", "edge", "cloud", "latency"], "source_lectures": ["lecture_106104449_w1_l4"]}}
{"id": "concept_edge_controller", "type": "V_concept", "name": "Edge Controller", "properties": {"description": "A centralized component responsible for planning, deploying, and managing application services in the edge cloud system.", "keywords": ["edge", "controller", "centralized", "application", "management"], "source_lectures": ["lecture_106104449_w1_l4"]}}
{"id": "concept_virtualization", "type": "V_concept", "name": "Virtualization", "properties": {"description": "A technology that abstracts physical components into logical objects, allowing multiple virtual machines to run on a single physical server.", "keywords": ["physical machine", "hypervisor", "physical", "cloud", "abstraction", "resource", "virtualization", "sharing", "logical", "vm", "hardware", "operating system"], "source_lectures": ["lecture_106104449_w1_l5", "lecture_106104182_w1_l1", "lecture_106104182_w1_l2", "lecture_106104182_w4_l22", "lecture_106104182_w4_l23"]}}
{"id": "concept_hypervisor", "type": "V_concept", "name": "Hypervisor", "properties": {"description": "A layer of software that allows virtualization, creating a virtual environment for guest operating systems to run on.", "keywords": ["hypervisor", "hardware abstraction", "xen", "virtual", "esxi", "virtual machine", "virtualization", "vm manager", "hardware", "guest os", "software", "management", "vm", "kvm", "machine"], "source_lectures": ["lecture_106104449_w1_l5", "lecture_106104182_w1_l2", "lecture_106104182_w1_l4", "lecture_106104182_w1_l5", "lecture_106104449_w1_l6"]}}
{"id": "concept_virtual_machine", "type": "V_concept", "name": "Virtual Machine", "properties": {"description": "A software emulation of a physical computer, allowing multiple operating systems to run on a single physical server.", "keywords": ["virtual", "virtual machine", "system", "emulation", "vm", "software", "operating", "operating system", "physical computer", "machine"], "source_lectures": ["lecture_106104449_w1_l5", "lecture_106104182_w1_l4", "lecture_106104182_w1_l5"]}}
{"id": "concept_server_virtualization", "type": "V_concept", "name": "Server Virtualization", "properties": {"description": "A technique that allows multiple virtual servers to run on a single physical server, improving resource utilization and reducing costs.", "keywords": ["server virtualization", "hypervisor", "physical server", "resource utilization", "server", "virtualization", "cost reduction", "vm"], "source_lectures": ["lecture_106104449_w1_l5", "lecture_106104182_w1_l4"]}}
{"id": "concept_hardware_virtualization", "type": "V_concept", "name": "Hardware Virtualization", "properties": {"description": "A type of virtualization that provides an abstract execution environment in terms of computer hardware, allowing guest operating systems to run on top of it.", "keywords": ["hardware virtualization", "abstract execution environment", "computer hardware", "guest os"], "source_lectures": ["lecture_106104449_w1_l5"]}}
{"id": "concept_full_virtualization", "type": "V_concept", "name": "Full Virtualization", "properties": {"description": "A type of virtualization that allows a guest operating system to run directly on top of a virtual machine, without modification, as if it were running on raw hardware.", "keywords": ["hypervisor", "privileged instructions", "virtual machine", "full virtualization", "guest os", "raw hardware"], "source_lectures": ["lecture_106104449_w1_l5", "lecture_106104182_w1_l2"]}}
{"id": "concept_paravirtualization", "type": "V_concept", "name": "Paravirtualization", "properties": {"description": "A type of virtualization that requires the guest operating system to be modified to run on a virtual machine, allowing for improved performance and efficiency.", "keywords": ["paravirtualization", "guest os", "virtual machine", "performance", "efficiency"], "source_lectures": ["lecture_106104449_w1_l5"]}}
{"id": "concept_operating_system_level_virtualization", "type": "V_concept", "name": "Operating System Level Virtualization", "properties": {"description": "A type of virtualization that allows multiple isolated user-space instances to run on a single operating system, without the need for a hypervisor.", "keywords": ["operating system level virtualization", "user-space instances", "single operating system", "hypervisor"], "source_lectures": ["lecture_106104449_w1_l5"]}}
{"id": "concept_programming_language_level_virtualization", "type": "V_concept", "name": "Programming Language Level Virtualization", "properties": {"description": "A type of virtualization that allows code to be executed on a virtual machine, providing platform independence and improved security.", "keywords": ["programming language level virtualization", "virtual machine", "platform independence", "security"], "source_lectures": ["lecture_106104449_w1_l5"]}}
{"id": "concept_application_level_virtualization", "type": "V_concept", "name": "Application Level Virtualization", "properties": {"description": "A type of virtualization that allows applications to run on a virtual environment, without the need for a full operating system or hypervisor.", "keywords": ["application level virtualization", "virtual environment", "operating system", "hypervisor"], "source_lectures": ["lecture_106104449_w1_l5"]}}
{"id": "concept_desktop_virtualization", "type": "V_concept", "name": "Desktop Virtualization", "properties": {"description": "A type of virtualization that allows a desktop environment to be accessed remotely, providing a flexible and secure way to work with desktop applications.", "keywords": ["desktop virtualization", "remote access", "desktop environment", "flexibility", "security"], "source_lectures": ["lecture_106104449_w1_l5"]}}
{"id": "concept_storage_virtualization", "type": "V_concept", "name": "Storage Virtualization", "properties": {"description": "A technique that allows multiple storage devices to be managed as a single logical unit, improving storage utilization and reducing costs.", "keywords": ["storage virtualization", "storage devices", "logical unit", "utilization", "cost reduction"], "source_lectures": ["lecture_106104449_w1_l5"]}}
{"id": "concept_network_virtualization", "type": "V_concept", "name": "Network Virtualization", "properties": {"description": "A technique that allows multiple physical networks to be combined into a single logical network, improving network utilization and reducing costs.", "keywords": ["vn", "network virtualization", "virtual", "utilization", "network", "virtualization", "logical network", "cost reduction", "physical networks", "networking"], "source_lectures": ["lecture_106104449_w1_l5", "lecture_106104182_w1_l5"]}}
{"id": "concept_network_function_virtualization", "type": "V_concept", "name": "Network Function Virtualization", "properties": {"description": "A technique that allows network functions to be virtualized, providing a flexible and scalable way to manage network services.", "keywords": ["network functions", "scalability", "virtual", "flexibility", "virtualization", "network", "function", "nfv", "network function virtualization"], "source_lectures": ["lecture_106104449_w1_l5", "lecture_106104182_w1_l5"]}}
{"id": "concept_nosql_database", "type": "V_concept", "name": "NoSQL Database", "properties": {"description": "A flexible database management approach that supports a variety of data models, such as key-value, document, table, and column.", "keywords": ["database", "nosql", "non-relational", "data model", "flexible", "big data", "real-time", "storage"], "source_lectures": ["lecture_106104449_w2_l8", "lecture_106104182_w3_l16", "lecture_106104182_w4_l22"]}}
{"id": "concept_key_value_store", "type": "V_concept", "name": "Key-Value Store", "properties": {"description": "A type of database where data is stored in the form of a key-value pair, with each piece of data associated with a unique identifier.", "keywords": ["value", "database", "nosql", "abstraction", "data model", "key-value", "cassandra", "key", "storage", "store"], "source_lectures": ["lecture_106104449_w2_l8", "lecture_106104182_w3_l16", "lecture_106104182_w4_l23"]}}
{"id": "concept_column_oriented_storage", "type": "V_concept", "name": "Column-Oriented Storage", "properties": {"description": "A storage approach where data is stored in columns instead of rows, allowing for faster range searches and aggregation operations.", "keywords": ["column-oriented", "storage", "database", "performance"], "source_lectures": ["lecture_106104449_w2_l8"]}}
{"id": "concept_apache_cassandra", "type": "V_concept", "name": "Apache Cassandra", "properties": {"description": "A NoSQL distributed database that is designed for large amounts of data, high throughput, and scalability.", "keywords": ["apache", "cassandra", "nosql", "database"], "source_lectures": ["lecture_106104449_w2_l8"]}}
{"id": "concept_cap_theorem", "type": "V_concept", "name": "CAP Theorem", "properties": {"description": "A fundamental principle in distributed systems that states that it is impossible to simultaneously achieve consistency, availability, and partition tolerance.", "keywords": ["systems", "cap theorem", "system", "properties", "distributed", "cap", "partition tolerance", "theorem", "distributed systems", "consistency", "availability"], "source_lectures": ["lecture_106104449_w2_l8", "lecture_106104182_w3_l16", "lecture_106104182_w3_l17", "lecture_106104182_w4_l22"]}}
{"id": "concept_consistency_model", "type": "V_concept", "name": "Consistency Model", "properties": {"description": "A set of rules that define how data is handled in a distributed system, including consistency, availability, and partition tolerance.", "keywords": ["systems", "model", "memory", "system", "shared", "distributed", "data", "consistency"], "source_lectures": ["lecture_106104449_w2_l8", "lecture_106102229_w5_l33", "lecture_106104182_w3_l16"]}}
{"id": "concept_eventual_consistency", "type": "V_concept", "name": "Eventual Consistency", "properties": {"description": "A consistency model that guarantees that all replicas of a data item will eventually converge to the same value, even if there are temporary inconsistencies.", "keywords": ["systems", "model", "nosql", "distributed", "data", "eventual", "consistency"], "source_lectures": ["lecture_106104449_w2_l8", "lecture_106104182_w3_l16", "lecture_106104182_w3_l17"]}}
{"id": "concept_acid_properties", "type": "V_concept", "name": "ACID Properties", "properties": {"description": "A set of properties that ensure the reliability and consistency of database transactions, including atomicity, consistency, isolation, and durability.", "keywords": ["transactions", "database", "reliability", "transaction", "properties", "acid", "consistency"], "source_lectures": ["lecture_106104449_w2_l8", "lecture_106102229_w5_l33", "lecture_106104182_w3_l16"]}}
{"id": "concept_base_properties", "type": "V_concept", "name": "BASE Properties", "properties": {"description": "A set of properties that prioritize availability and partition tolerance over consistency, including basically available, soft-state, and eventually consistent.", "keywords": ["base", "properties", "availability", "partition"], "source_lectures": ["lecture_106104449_w2_l8"]}}
{"id": "concept_gossip_protocol", "type": "V_concept", "name": "Gossip Protocol", "properties": {"description": "A protocol used in distributed systems to disseminate information and maintain cluster membership, including failure detection and recovery.", "keywords": ["gossip", "protocol", "distributed", "system"], "source_lectures": ["lecture_106104449_w2_l8"]}}
{"id": "concept_vector_search", "type": "V_concept", "name": "Vector Search", "properties": {"description": "A technique used in machine learning and data retrieval to find relevant content within large document collections, based on vector embeddings.", "keywords": ["vector", "search", "machine", "learning"], "source_lectures": ["lecture_106104449_w2_l8"]}}
{"id": "concept_quorum", "type": "V_concept", "name": "Quorum", "properties": {"description": "A mechanism used in distributed systems to ensure consistency and availability, by requiring a majority of nodes to agree on a decision.", "keywords": ["systems", "mechanism", "nodes", "quorum", "election", "leader", "system", "distributed", "consensus"], "source_lectures": ["lecture_106104449_w2_l8", "lecture_106104182_w2_l8", "lecture_106104182_w3_l16"]}}
{"id": "concept_causal_consistency", "type": "V_concept", "name": "Causal Consistency", "properties": {"description": "A consistency model that ensures that the order of operations is preserved, based on the causal relationships between them.", "keywords": ["causal", "consistency", "model", "distributed"], "source_lectures": ["lecture_106104449_w2_l8"]}}
{"id": "concept_representation_learning", "type": "V_concept", "name": "Representation Learning", "properties": {"description": "A technique used in machine learning to learn representations of data that can be used for various tasks.", "keywords": ["representation", "abstraction", "features", "embeddings", "learning", "task", "data", "representation learning", "machine"], "source_lectures": ["lecture_106104449_w2_l10", "lecture_106103843_w1_l1"]}}
{"id": "concept_knowledge_distillation", "type": "V_concept", "name": "Knowledge Distillation", "properties": {"description": "A model compression method that transfers knowledge from a large teacher model to a smaller student model.", "keywords": ["knowledge", "distillation", "model", "compression", "teacher"], "source_lectures": ["lecture_106104449_w2_l10"]}}
{"id": "concept_model_compression", "type": "V_concept", "name": "Model Compression", "properties": {"description": "A technique used to reduce the size of a machine learning model while maintaining its performance.", "keywords": ["model", "compression", "size", "performance", "machine"], "source_lectures": ["lecture_106104449_w2_l10"]}}
{"id": "concept_parameter_pruning", "type": "V_concept", "name": "Parameter Pruning", "properties": {"description": "A technique used to remove unnecessary parameters from a machine learning model to reduce its size.", "keywords": ["parameter", "pruning", "model", "size", "machine"], "source_lectures": ["lecture_106104449_w2_l10"]}}
{"id": "concept_low_rank_factorization", "type": "V_concept", "name": "Low Rank Factorization", "properties": {"description": "A technique used to approximate weight matrices in neural networks by decomposing them into low-rank matrices.", "keywords": ["low", "rank", "factorization", "weight", "matrix"], "source_lectures": ["lecture_106104449_w2_l10"]}}
{"id": "concept_federated_learning", "type": "V_concept", "name": "Federated Learning", "properties": {"description": "A machine learning approach that involves training models on decentralized data, without sharing the data itself.", "keywords": ["federated", "learning", "decentralized", "data", "machine"], "source_lectures": ["lecture_106104449_w2_l10"]}}
{"id": "concept_edge_ai", "type": "V_concept", "name": "Edge AI", "properties": {"description": "A field of artificial intelligence that focuses on deploying intelligent models at the edge of the network, closer to the data source.", "keywords": ["model", "edge", "ai", "network", "intelligent", "realtime", "processing", "convergence"], "source_lectures": ["lecture_106104449_w2_l10", "lecture_106104449_w2_l9"]}}
{"id": "concept_model_quantization", "type": "V_concept", "name": "Model Quantization", "properties": {"description": "A technique used to reduce the precision of model weights and activations to reduce memory and computational requirements.", "keywords": ["model", "quantization", "precision", "weight", "activation"], "source_lectures": ["lecture_106104449_w2_l10"]}}
{"id": "concept_knowledge_transfer", "type": "V_concept", "name": "Knowledge Transfer", "properties": {"description": "The process of transferring knowledge from a teacher model to a student model, often used in knowledge distillation.", "keywords": ["knowledge", "transfer", "teacher", "student", "model"], "source_lectures": ["lecture_106104449_w2_l10"]}}
{"id": "concept_response_based_knowledge_distillation", "type": "V_concept", "name": "Response-Based Knowledge Distillation", "properties": {"description": "A type of knowledge distillation that focuses on mimicking the output of the teacher model.", "keywords": ["response", "based", "knowledge", "distillation", "output"], "source_lectures": ["lecture_106104449_w2_l10"]}}
{"id": "concept_feature_based_knowledge_distillation", "type": "V_concept", "name": "Feature-Based Knowledge Distillation", "properties": {"description": "A type of knowledge distillation that focuses on transferring knowledge from intermediate layers of the teacher model.", "keywords": ["feature", "based", "knowledge", "distillation", "intermediate"], "source_lectures": ["lecture_106104449_w2_l10"]}}
{"id": "concept_multi_access_edge_computing", "type": "V_concept", "name": "Multi-Access Edge Computing", "properties": {"description": "An evolution of Mobile Edge Computing that integrates edge computing into the mobile network architecture, supporting multiple access technologies.", "keywords": ["multi-access", "edge", "flexibility", "network", "computing", "multiaccess", "mobile", "technology"], "source_lectures": ["lecture_106104449_w2_l11", "lecture_106104449_w2_l14"]}}
{"id": "concept_task_offloading", "type": "V_concept", "name": "Task Offloading", "properties": {"description": "The process of transferring computational tasks from a mobile device to a remote server, such as an edge server or cloud server, to reduce latency and energy consumption.", "keywords": ["task", "offloading", "mobile", "edge", "cloud"], "source_lectures": ["lecture_106104449_w2_l11"]}}
{"id": "concept_resource_allocation", "type": "V_concept", "name": "Resource Allocation", "properties": {"description": "The process of distributing computing resources, such as CPU and memory, among different applications and services in a multi-access edge computing environment.", "keywords": ["resource", "allocation", "computing", "edge", "network"], "source_lectures": ["lecture_106104449_w2_l11"]}}
{"id": "concept_mobile_cloud_computing", "type": "V_concept", "name": "Mobile Cloud Computing", "properties": {"description": "A computing paradigm that provides cloud computing services to mobile users, where computations and storage take place inside the cloud instead of the mobile device.", "keywords": ["mobile", "cloud", "computing", "paradigm", "network"], "source_lectures": ["lecture_106104449_w2_l11"]}}
{"id": "concept_edge_computing_architecture", "type": "V_concept", "name": "Edge Computing Architecture", "properties": {"description": "A design pattern that integrates edge computing into a mobile network architecture, providing low-latency and high-bandwidth computing services to mobile users.", "keywords": ["edge", "computing", "architecture", "mobile", "network"], "source_lectures": ["lecture_106104449_w2_l11"]}}
{"id": "concept_small_cell_cloud", "type": "V_concept", "name": "Small Cell Cloud", "properties": {"description": "A type of edge computing architecture that provides cloud computing services at the edge of a mobile network, using small cell base stations as computing nodes.", "keywords": ["small", "cell", "cloud", "edge", "computing"], "source_lectures": ["lecture_106104449_w2_l11"]}}
{"id": "concept_mobile_micro_cloud", "type": "V_concept", "name": "Mobile Micro Cloud", "properties": {"description": "A type of edge computing architecture that provides cloud computing services at the edge of a mobile network, using a single mobile micro cloud as a computing node.", "keywords": ["mobile", "micro", "cloud", "edge", "computing"], "source_lectures": ["lecture_106104449_w2_l11"]}}
{"id": "concept_follow_me_cloud", "type": "V_concept", "name": "Follow Me Cloud", "properties": {"description": "A type of edge computing architecture that provides cloud computing services at the edge of a mobile network, where the cloud service follows the mobile user as they move through the network.", "keywords": ["follow", "me", "cloud", "edge", "computing"], "source_lectures": ["lecture_106104449_w2_l11"]}}
{"id": "concept_converged_cloud_and_cellular_systems", "type": "V_concept", "name": "Converged Cloud and Cellular Systems", "properties": {"description": "A type of edge computing architecture that integrates cloud computing and cellular systems, providing a converged platform for computing and communication services.", "keywords": ["converged", "cloud", "cellular", "systems", "edge"], "source_lectures": ["lecture_106104449_w2_l11"]}}
{"id": "concept_mec_server", "type": "V_concept", "name": "MEC Server", "properties": {"description": "A server that provides edge computing services in a multi-access edge computing environment, typically located at the edge of a mobile network.", "keywords": ["mec", "server", "edge", "computing", "network"], "source_lectures": ["lecture_106104449_w2_l11"]}}
{"id": "concept_mec_system_level_management", "type": "V_concept", "name": "MEC System Level Management", "properties": {"description": "A management framework that oversees the operation of a multi-access edge computing system, including resource allocation, application management, and quality of service management.", "keywords": ["mec", "system", "level", "management", "edge"], "source_lectures": ["lecture_106104449_w2_l11"]}}
{"id": "concept_mec_server_level_management", "type": "V_concept", "name": "MEC Server Level Management", "properties": {"description": "A management framework that oversees the operation of a multi-access edge computing server, including resource allocation, virtualization, and application management.", "keywords": ["mec", "server", "level", "management", "edge"], "source_lectures": ["lecture_106104449_w2_l11"]}}
{"id": "concept_cluster_resource_allocation", "type": "V_concept", "name": "Cluster Resource Allocation", "properties": {"description": "A technique used in multi-access edge computing to allocate resources among a cluster of edge servers, aiming to optimize resource utilization and minimize latency.", "keywords": ["cluster", "resource", "allocation", "edge", "computing"], "source_lectures": ["lecture_106104449_w2_l11"]}}
{"id": "concept_successive_cluster_optimization", "type": "V_concept", "name": "Successive Cluster Optimization", "properties": {"description": "A technique used in multi-access edge computing to dynamically adjust the size of a cluster of edge servers based on changing workloads and quality of service requirements.", "keywords": ["successive", "cluster", "optimization", "edge", "computing"], "source_lectures": ["lecture_106104449_w2_l11"]}}
{"id": "concept_joint_cluster_optimization", "type": "V_concept", "name": "Joint Cluster Optimization", "properties": {"description": "A technique used in multi-access edge computing to jointly optimize the allocation of resources among multiple clusters of edge servers, aiming to minimize latency and maximize resource utilization.", "keywords": ["joint", "cluster", "optimization", "edge", "computing"], "source_lectures": ["lecture_106104449_w2_l11"]}}
{"id": "concept_static_clustering", "type": "V_concept", "name": "Static Clustering", "properties": {"description": "A technique used in multi-access edge computing to allocate resources among a cluster of edge servers using a static allocation strategy, which does not change based on changing workloads or quality of service requirements.", "keywords": ["static", "clustering", "edge", "computing", "resource"], "source_lectures": ["lecture_106104449_w2_l11"]}}
{"id": "concept_geo_distributed_data_centers", "type": "V_concept", "name": "Geo Distributed Data Centers", "properties": {"description": "A network of data centers located in different geographic locations, connected through the internet or private networks.", "keywords": ["geo", "distributed", "data", "centers", "network"], "source_lectures": ["lecture_106104449_w2_l12"]}}
{"id": "concept_inter_data_center_traffic", "type": "V_concept", "name": "Inter Data Center Traffic", "properties": {"description": "The flow of data between different data centers, which can be affected by various factors such as network topology and traffic engineering.", "keywords": ["inter", "data", "center", "traffic", "network"], "source_lectures": ["lecture_106104449_w2_l12"]}}
{"id": "concept_multiprotocol_label_switching_mpls", "type": "V_concept", "name": "Multiprotocol Label Switching (MPLS)", "properties": {"description": "A routing technique that directs data packets through a network based on labels, rather than traditional routing methods.", "keywords": ["mpls", "multiprotocol", "label", "switching", "routing"], "source_lectures": ["lecture_106104449_w2_l12"]}}
{"id": "concept_wide_area_network_wan", "type": "V_concept", "name": "Wide Area Network (WAN)", "properties": {"description": "A computer network that spans a large geographic area, often connecting multiple locations or data centers.", "keywords": ["wan", "wide", "area", "network", "geographic"], "source_lectures": ["lecture_106104449_w2_l12"]}}
{"id": "concept_googles_b4_system", "type": "V_concept", "name": "Google's B4 System", "properties": {"description": "A software-defined networking system used by Google to manage traffic between its data centers, optimizing bandwidth utilization and reducing latency.", "keywords": ["google", "b4", "system", "software", "defined"], "source_lectures": ["lecture_106104449_w2_l12"]}}
{"id": "concept_microsoft_swan", "type": "V_concept", "name": "Microsoft Swan", "properties": {"description": "A traffic engineering system used by Microsoft to optimize wide area network traffic flow, minimizing congestion and ensuring high utilization.", "keywords": ["engineering", "swan", "networking", "defined", "traffic", "optimization", "software", "microsoft"], "source_lectures": ["lecture_106104449_w2_l12", "lecture_106104182_w1_l6"]}}
{"id": "concept_software_defined_networking_sdn", "type": "V_concept", "name": "Software Defined Networking (SDN)", "properties": {"description": "An approach to networking that allows for the creation of virtual networks, managed through software, to improve flexibility and scalability.", "keywords": ["sdn", "software", "defined", "networking", "virtual"], "source_lectures": ["lecture_106104449_w2_l12"]}}
{"id": "concept_openflow", "type": "V_concept", "name": "OpenFlow", "properties": {"description": "A protocol used in software-defined networking to manage and direct traffic flow between network devices.", "keywords": ["protocol", "defined", "traffic", "sdn", "software", "networking", "openflow"], "source_lectures": ["lecture_106104449_w2_l12", "lecture_106104182_w1_l5"]}}
{"id": "concept_traffic_engineering", "type": "V_concept", "name": "Traffic Engineering", "properties": {"description": "The process of managing and optimizing network traffic flow to ensure efficient use of network resources and minimize congestion.", "keywords": ["efficiency", "engineering", "resources", "traffic", "network", "optimization", "congestion", "performance"], "source_lectures": ["lecture_106104449_w2_l12", "lecture_106104182_w1_l5", "lecture_106104182_w1_l6"]}}
{"id": "concept_load_balancing", "type": "V_concept", "name": "Load Balancing", "properties": {"description": "A technique used to distribute workload across multiple servers or data centers to ensure efficient use of resources and minimize downtime.", "keywords": ["distribution", "balancing", "efficiency", "processors", "workload", "load", "responsiveness"], "source_lectures": ["lecture_106104449_w2_l12", "lecture_106103359_w2_l8", "lecture_106104449_w1_l7"]}}
{"id": "concept_data_center_interconnection", "type": "V_concept", "name": "Data Center Interconnection", "properties": {"description": "The process of connecting multiple data centers to enable communication and data exchange between them.", "keywords": ["data", "center", "interconnection", "communication", "exchange"], "source_lectures": ["lecture_106104449_w2_l12"]}}
{"id": "concept_hybrid_public_cloud_operation", "type": "V_concept", "name": "Hybrid Public Cloud Operation", "properties": {"description": "A cloud computing model that combines private and public cloud infrastructure to provide a scalable and flexible computing environment.", "keywords": ["hybrid", "public", "cloud", "operation", "scalability"], "source_lectures": ["lecture_106104449_w2_l12"]}}
{"id": "concept_clock_synchronization", "type": "V_concept", "name": "Clock Synchronization", "properties": {"description": "The process of synchronizing clocks in a distributed system to ensure they show the same time.", "keywords": ["system", "clock", "distributed", "synchronization"], "source_lectures": ["lecture_106104449_w2_l13", "lecture_106104182_w2_l10"]}}
{"id": "concept_lamports_logical_clock", "type": "V_concept", "name": "Lamport's Logical Clock", "properties": {"description": "A method of assigning timestamps to events in a distributed system to capture causality.", "keywords": ["lamport", "logical", "clock", "causality"], "source_lectures": ["lecture_106104449_w2_l13"]}}
{"id": "concept_vector_clocks", "type": "V_concept", "name": "Vector Clocks", "properties": {"description": "A method of assigning timestamps to events in a distributed system using vectors to capture causality and concurrency.", "keywords": ["concurrency", "causal relationships", "timestamps", "distributed system", "causality", "clocks", "vector", "vector clocks"], "source_lectures": ["lecture_106104449_w2_l13", "lecture_106104182_w4_l22"]}}
{"id": "concept_christian_algorithm", "type": "V_concept", "name": "Christian Algorithm", "properties": {"description": "An algorithm for synchronizing clocks in a distributed system by compensating for network latency.", "keywords": ["christian", "algorithm", "synchronization", "latency"], "source_lectures": ["lecture_106104449_w2_l13"]}}
{"id": "concept_network_time_protocol", "type": "V_concept", "name": "Network Time Protocol", "properties": {"description": "A protocol for synchronizing clocks in a distributed system using a hierarchical structure.", "keywords": ["network", "time", "protocol", "synchronization"], "source_lectures": ["lecture_106104449_w2_l13"]}}
{"id": "concept_data_center_time_protocol", "type": "V_concept", "name": "Data Center Time Protocol", "properties": {"description": "A protocol for synchronizing clocks in a data center using the physical layer of network devices.", "keywords": ["data", "center", "time", "protocol"], "source_lectures": ["lecture_106104449_w2_l13"]}}
{"id": "concept_clock_drift", "type": "V_concept", "name": "Clock Drift", "properties": {"description": "The relative difference in clock frequency rates between two clocks.", "keywords": ["drift", "system", "clock", "distributed", "rate", "frequency"], "source_lectures": ["lecture_106104449_w2_l13", "lecture_106104182_w2_l10"]}}
{"id": "concept_clock_skew", "type": "V_concept", "name": "Clock Skew", "properties": {"description": "The relative difference in clock values between two clocks.", "keywords": ["skew", "value", "system", "clock", "distributed", "difference"], "source_lectures": ["lecture_106104449_w2_l13", "lecture_106104182_w2_l10"]}}
{"id": "concept_asynchronous_system", "type": "V_concept", "name": "Asynchronous System", "properties": {"description": "A system in which there are no bounds on message delay and processing delay.", "keywords": ["asynchronous", "system", "delay", "processing"], "source_lectures": ["lecture_106104449_w2_l13"]}}
{"id": "concept_causality", "type": "V_concept", "name": "Causality", "properties": {"description": "The relationship between events in a distributed system, where one event happens before another.", "keywords": ["system", "events", "distributed", "causality"], "source_lectures": ["lecture_106104449_w2_l13", "lecture_106104182_w2_l10"]}}
{"id": "concept_concurrent_events", "type": "V_concept", "name": "Concurrent Events", "properties": {"description": "Events in a distributed system that are not causally related and cannot be ordered.", "keywords": ["concurrent", "events", "causality", "order"], "source_lectures": ["lecture_106104449_w2_l13"]}}
{"id": "concept_happened_before_relation", "type": "V_concept", "name": "Happened Before Relation", "properties": {"description": "A relation between events in a distributed system, where one event happens before another.", "keywords": ["happened", "before", "relation", "events"], "source_lectures": ["lecture_106104449_w2_l13"]}}
{"id": "concept_partial_order", "type": "V_concept", "name": "Partial Order", "properties": {"description": "A ordering of events in a distributed system, where not all events are related.", "keywords": ["coherence", "partial", "distributed", "order", "events", "consistency"], "source_lectures": ["lecture_106104449_w2_l13", "lecture_106103359_w4_l24"]}}
{"id": "concept_logical_time_stamp", "type": "V_concept", "name": "Logical Time Stamp", "properties": {"description": "A timestamp assigned to an event in a distributed system to capture causality.", "keywords": ["logical", "time", "stamp", "causality"], "source_lectures": ["lecture_106104449_w2_l13"]}}
{"id": "concept_berkley_algorithm", "type": "V_concept", "name": "Berkley Algorithm", "properties": {"description": "An algorithm for synchronizing clocks in a distributed system by averaging clock values.", "keywords": ["berkley", "algorithm", "synchronization", "average"], "source_lectures": ["lecture_106104449_w2_l13"]}}
{"id": "concept_denial_of_service_attack", "type": "V_concept", "name": "Denial of Service Attack", "properties": {"description": "A type of cyber attack that aims to disrupt the normal services provided by one or more servers, making them unavailable to users.", "keywords": ["denial", "service", "attack", "cyber", "security"], "source_lectures": ["lecture_106104449_w2_l14"]}}
{"id": "concept_flooding_based_attack", "type": "V_concept", "name": "Flooding-Based Attack", "properties": {"description": "A type of denial of service attack that involves sending a large amount of traffic to a network or system, overwhelming its resources.", "keywords": ["flooding", "attack", "denial", "service", "security"], "source_lectures": ["lecture_106104449_w2_l14"]}}
{"id": "concept_zero_day_attack", "type": "V_concept", "name": "Zero-Day Attack", "properties": {"description": "A type of cyber attack that exploits a previously unknown vulnerability in a system or application, making it difficult to defend against.", "keywords": ["zero", "day", "attack", "cyber", "security"], "source_lectures": ["lecture_106104449_w2_l14"]}}
{"id": "concept_side_channel_attack", "type": "V_concept", "name": "Side Channel Attack", "properties": {"description": "A type of attack that compromises user security and privacy by exploiting publicly accessible information, such as communication signals or power consumption.", "keywords": ["side", "channel", "attack", "security", "privacy"], "source_lectures": ["lecture_106104449_w2_l14"]}}
{"id": "concept_malware_injection_attack", "type": "V_concept", "name": "Malware Injection Attack", "properties": {"description": "A type of attack that involves injecting malware into a system or application, compromising its security and integrity.", "keywords": ["malware", "injection", "attack", "security", "integrity"], "source_lectures": ["lecture_106104449_w2_l14"]}}
{"id": "concept_authentication_and_authorization", "type": "V_concept", "name": "Authentication and Authorization", "properties": {"description": "The process of verifying user identities and determining their access rights and privileges in a system or application.", "keywords": ["authentication", "authorization", "security", "access", "privileges"], "source_lectures": ["lecture_106104449_w2_l14"]}}
{"id": "concept_access_control", "type": "V_concept", "name": "Access Control", "properties": {"description": "A security mechanism that regulates access to resources and services, ensuring that only authorized entities can access them.", "keywords": ["access", "control", "security", "mechanism", "authorization"], "source_lectures": ["lecture_106104449_w2_l14"]}}
{"id": "concept_fine_grained_access_control", "type": "V_concept", "name": "Fine-Grained Access Control", "properties": {"description": "A type of access control that provides detailed and specific access permissions, reducing the risk of unauthorized access.", "keywords": ["fine", "grained", "access", "control", "security"], "source_lectures": ["lecture_106104449_w2_l14"]}}
{"id": "concept_coarse_grained_access_control", "type": "V_concept", "name": "Coarse-Grained Access Control", "properties": {"description": "A type of access control that provides broad and general access permissions, increasing the risk of unauthorized access.", "keywords": ["coarse", "grained", "access", "control", "security"], "source_lectures": ["lecture_106104449_w2_l14"]}}
{"id": "concept_data_perturbation", "type": "V_concept", "name": "Data Perturbation", "properties": {"description": "A technique used to protect sensitive data by modifying or perturbing it, making it difficult for attackers to infer or exploit.", "keywords": ["data", "perturbation", "security", "privacy", "protection"], "source_lectures": ["lecture_106104449_w2_l14"]}}
{"id": "concept_k_anonymity", "type": "V_concept", "name": "K-Anonymity", "properties": {"description": "A data perturbation algorithm that modifies identifier information to make it indistinguishable from other data, protecting sensitive information.", "keywords": ["k", "anonymity", "data", "perturbation", "security"], "source_lectures": ["lecture_106104449_w2_l14"]}}
{"id": "concept_edge_computing_security", "type": "V_concept", "name": "Edge Computing Security", "properties": {"description": "The practice of protecting edge computing systems and data from cyber threats and vulnerabilities, ensuring confidentiality, integrity, and availability.", "keywords": ["edge", "computing", "security", "cyber", "threats"], "source_lectures": ["lecture_106104449_w2_l14"]}}
{"id": "concept_cloud_computing_security", "type": "V_concept", "name": "Cloud Computing Security", "properties": {"description": "The practice of protecting cloud computing systems and data from cyber threats and vulnerabilities, ensuring confidentiality, integrity, and availability.", "keywords": ["cloud", "computing", "security", "cyber", "threats"], "source_lectures": ["lecture_106104449_w2_l14"]}}
{"id": "concept_protocol_level_design_flaws", "type": "V_concept", "name": "Protocol Level Design Flaws", "properties": {"description": "Vulnerabilities or weaknesses in the design of communication protocols, making them susceptible to cyber attacks and exploits.", "keywords": ["protocol", "level", "design", "flaws", "security"], "source_lectures": ["lecture_106104449_w2_l14"]}}
{"id": "concept_implementation_level_flaws", "type": "V_concept", "name": "Implementation Level Flaws", "properties": {"description": "Vulnerabilities or weaknesses in the implementation of protocols or systems, making them susceptible to cyber attacks and exploits.", "keywords": ["implementation", "level", "flaws", "security", "vulnerabilities"], "source_lectures": ["lecture_106104449_w2_l14"]}}
{"id": "concept_code_level_vulnerabilities", "type": "V_concept", "name": "Code Level Vulnerabilities", "properties": {"description": "Vulnerabilities or weaknesses in the code of a system or application, making it susceptible to cyber attacks and exploits.", "keywords": ["code", "level", "vulnerabilities", "security", "exploits"], "source_lectures": ["lecture_106104449_w2_l14"]}}
{"id": "concept_image_representation", "type": "V_concept", "name": "Image Representation", "properties": {"description": "The way an image is represented in a computer, such as a matrix of pixel values.", "keywords": ["image", "representation", "matrix", "pixel"], "source_lectures": ["lecture_106108840_w2_l11"]}}
{"id": "concept_pixel_value", "type": "V_concept", "name": "Pixel Value", "properties": {"description": "A numerical value that represents the intensity or color of a pixel in an image.", "keywords": ["pixel", "value", "intensity", "color"], "source_lectures": ["lecture_106108840_w2_l11"]}}
{"id": "concept_channel", "type": "V_concept", "name": "Channel", "properties": {"description": "A component of an image that represents a specific color or intensity, such as red, green, or blue.", "keywords": ["channel", "color", "intensity", "image"], "source_lectures": ["lecture_106108840_w2_l11"]}}
{"id": "concept_rgb_image", "type": "V_concept", "name": "RGB Image", "properties": {"description": "A type of image that uses three color channels (red, green, and blue) to represent colors.", "keywords": ["rgb", "image", "color", "channel"], "source_lectures": ["lecture_106108840_w2_l11"]}}
{"id": "concept_grayscale_image", "type": "V_concept", "name": "Grayscale Image", "properties": {"description": "A type of image that uses a single color channel to represent intensity values.", "keywords": ["grayscale", "image", "intensity", "channel"], "source_lectures": ["lecture_106108840_w2_l11"]}}
{"id": "concept_binary_image", "type": "V_concept", "name": "Binary Image", "properties": {"description": "A type of image that uses a single color channel to represent binary values (0 or 1).", "keywords": ["binary", "image", "channel", "binary"], "source_lectures": ["lecture_106108840_w2_l11"]}}
{"id": "concept_spatial_relationship", "type": "V_concept", "name": "Spatial Relationship", "properties": {"description": "The relationship between pixels in an image, such as their position and proximity to each other.", "keywords": ["spatial", "relationship", "pixel", "image"], "source_lectures": ["lecture_106108840_w2_l11"]}}
{"id": "concept_normalization", "type": "V_concept", "name": "Normalization", "properties": {"description": "A technique used to scale numeric data to a common range, usually between 0 and 1.", "keywords": ["normalization", "scaling", "data", "range"], "source_lectures": ["lecture_106108840_w2_l11"]}}
{"id": "concept_flow_from_directory", "type": "V_concept", "name": "Flow From Directory", "properties": {"description": "A function used to load and store images for training a convolutional neural network.", "keywords": ["flow", "directory", "image", "training"], "source_lectures": ["lecture_106108840_w2_l11"]}}
{"id": "concept_ensemble_learning", "type": "V_concept", "name": "Ensemble Learning", "properties": {"description": "A method of combining multiple models to improve the overall performance and robustness of the predictions.", "keywords": ["ensemble", "learning", "combining", "models", "prediction"], "source_lectures": ["lecture_106108840_w3_l21"]}}
{"id": "concept_stacking_model", "type": "V_concept", "name": "Stacking Model", "properties": {"description": "A type of ensemble learning where the predictions of multiple models are combined using a meta-model.", "keywords": ["stacking", "model", "ensemble", "meta", "learning"], "source_lectures": ["lecture_106108840_w3_l21"]}}
{"id": "concept_hyperparameter_tuning", "type": "V_concept", "name": "Hyperparameter Tuning", "properties": {"description": "The process of adjusting the parameters of a machine learning model to optimize its performance.", "keywords": ["hyperparameter", "tuning", "optimization", "performance", "model"], "source_lectures": ["lecture_106108840_w3_l21"]}}
{"id": "concept_meta_learner", "type": "V_concept", "name": "Meta-Learner", "properties": {"description": "A model that learns to make predictions based on the predictions of other models.", "keywords": ["meta", "learner", "model", "prediction", "ensemble"], "source_lectures": ["lecture_106108840_w3_l21"]}}
{"id": "concept_ground_truth", "type": "V_concept", "name": "Ground Truth", "properties": {"description": "The actual true labels or values for a dataset, used as a reference for evaluating model performance.", "keywords": ["ground", "truth", "label", "value", "evaluation"], "source_lectures": ["lecture_106108840_w3_l21"]}}
{"id": "concept_parametric_functional_form", "type": "V_concept", "name": "Parametric Functional Form", "properties": {"description": "A mathematical function with a fixed number of parameters that can be used to model a distribution.", "keywords": ["parametric", "functional", "form", "model", "distribution"], "source_lectures": ["lecture_106108841_w2_l10"]}}
{"id": "concept_distance_metric", "type": "V_concept", "name": "Distance Metric", "properties": {"description": "A function that measures the distance between two distributions.", "keywords": ["distance", "metric", "distributions", "measure"], "source_lectures": ["lecture_106108841_w2_l10"]}}
{"id": "concept_optimization_problem", "type": "V_concept", "name": "Optimization Problem", "properties": {"description": "A problem that involves finding the best solution among a set of possible solutions, often subject to certain constraints.", "keywords": ["optimization", "problem", "solution", "constraints"], "source_lectures": ["lecture_106108841_w2_l10"]}}
{"id": "concept_risk_minimization_framework", "type": "V_concept", "name": "Risk Minimization Framework", "properties": {"description": "A framework used in machine learning to minimize the risk or loss of a model.", "keywords": ["framework", "hypothesis", "classifier", "machine learning", "learning", "risk", "minimization", "machine"], "source_lectures": ["lecture_106108841_w2_l10", "lecture_106108841_w3_l17", "lecture_106108841_w3_l19", "lecture_106108841_w3_l20"]}}
{"id": "concept_universal_function_approximation", "type": "V_concept", "name": "Universal Function Approximation", "properties": {"description": "The ability of a model to approximate any function to arbitrary closeness.", "keywords": ["universal", "function", "approximation", "model", "arbitrary"], "source_lectures": ["lecture_106108841_w2_l10"]}}
{"id": "concept_law_of_large_numbers", "type": "V_concept", "name": "Law of Large Numbers", "properties": {"description": "A principle in probability theory that states that the average of a large number of independent and identically distributed random variables will converge to the population mean.", "keywords": ["law", "theory", "numbers", "expected value", "statistics", "large", "independent trials", "probability", "average", "law of large numbers", "convergence"], "source_lectures": ["lecture_106108841_w2_l10", "lecture_106108841_w3_l15", "lecture_106104233_w3_l17"]}}
{"id": "concept_jupyter_notebook", "type": "V_concept", "name": "Jupyter Notebook", "properties": {"description": "A web-based interactive computing environment for working with Python code", "keywords": ["jupyter", "notebook", "python", "interactive"], "source_lectures": ["lecture_106108841_w2_l11"]}}
{"id": "concept_python_basics", "type": "V_concept", "name": "Python Basics", "properties": {"description": "Fundamental concepts and syntax of the Python programming language", "keywords": ["python", "basics", "programming", "language"], "source_lectures": ["lecture_106108841_w2_l11"]}}
{"id": "concept_variable_naming_convention", "type": "V_concept", "name": "Variable Naming Convention", "properties": {"description": "Rules for naming variables in Python, including allowed characters and restrictions", "keywords": ["variable", "naming", "convention", "python"], "source_lectures": ["lecture_106108841_w2_l11"]}}
{"id": "concept_list_data_type", "type": "V_concept", "name": "List Data Type", "properties": {"description": "A collection of items that can be of any data type, including strings, integers, and floats", "keywords": ["list", "data", "type", "python"], "source_lectures": ["lecture_106108841_w2_l11"]}}
{"id": "concept_tuple_data_type", "type": "V_concept", "name": "Tuple Data Type", "properties": {"description": "A collection of items that cannot be changed after creation", "keywords": ["haskell", "collection", "python", "data type", "tuple", "data", "type"], "source_lectures": ["lecture_106108841_w2_l11", "lecture_106106931_w2_l12"]}}
{"id": "concept_dictionary_data_type", "type": "V_concept", "name": "Dictionary Data Type", "properties": {"description": "A collection of key-value pairs that can be used to store and retrieve data", "keywords": ["dictionary", "data", "type", "python"], "source_lectures": ["lecture_106108841_w2_l11"]}}
{"id": "concept_set_data_type", "type": "V_concept", "name": "Set Data Type", "properties": {"description": "A collection of unique items that can be used to store and retrieve data", "keywords": ["set", "data", "type", "python"], "source_lectures": ["lecture_106108841_w2_l11"]}}
{"id": "concept_for_loop", "type": "V_concept", "name": "For Loop", "properties": {"description": "A control structure that allows you to execute a block of code repeatedly for a specified number of times", "keywords": ["for", "loop", "python", "control"], "source_lectures": ["lecture_106108841_w2_l11"]}}
{"id": "concept_while_loop", "type": "V_concept", "name": "While Loop", "properties": {"description": "A control structure that allows you to execute a block of code repeatedly while a certain condition is true", "keywords": ["while", "loop", "python", "control"], "source_lectures": ["lecture_106108841_w2_l11"]}}
{"id": "concept_conditional_statement", "type": "V_concept", "name": "Conditional Statement", "properties": {"description": "A statement that allows you to execute different blocks of code based on certain conditions", "keywords": ["conditional", "statement", "python", "control"], "source_lectures": ["lecture_106108841_w2_l11"]}}
{"id": "concept_function", "type": "V_concept", "name": "Function", "properties": {"description": "A block of code that can be called multiple times from different parts of a program", "keywords": ["function", "python", "code", "block"], "source_lectures": ["lecture_106108841_w2_l11"]}}
{"id": "concept_indentation", "type": "V_concept", "name": "Indentation", "properties": {"description": "A way of formatting code in Python using spaces or tabs to denote block-level structure", "keywords": ["indentation", "python", "code", "formatting"], "source_lectures": ["lecture_106108841_w2_l11"]}}
{"id": "concept_modulus_operator", "type": "V_concept", "name": "Modulus Operator", "properties": {"description": "An operator that returns the remainder of an integer division operation", "keywords": ["math", "python", "remainder", "modulus", "division", "operator"], "source_lectures": ["lecture_106108841_w2_l11", "lecture_106106931_w1_l6"]}}
{"id": "concept_linearity_of_expectations", "type": "V_concept", "name": "Linearity Of Expectations", "properties": {"description": "A property of expected values that states the expected value of a sum is the sum of the expected values.", "keywords": ["linearity", "expectations", "expected", "value", "sum"], "source_lectures": ["lecture_106108841_w2_l12"]}}
{"id": "concept_law_of_the_unconscious_statistician", "type": "V_concept", "name": "Law Of The Unconscious Statistician", "properties": {"description": "A theorem that allows the calculation of the expected value of a function of a random variable.", "keywords": ["law", "unconscious", "statistician", "expected", "value"], "source_lectures": ["lecture_106108841_w2_l12"]}}
{"id": "concept_variance_formula", "type": "V_concept", "name": "Variance Formula", "properties": {"description": "A formula that calculates the variance of a random variable as the expected value of the squared difference from the mean.", "keywords": ["variance", "formula", "expected", "value", "squared"], "source_lectures": ["lecture_106108841_w2_l12"]}}
{"id": "concept_covariance", "type": "V_concept", "name": "Covariance", "properties": {"description": "A measure of the linear relationship between two random variables.", "keywords": ["covariance", "linear", "relationship", "random", "variables"], "source_lectures": ["lecture_106108841_w2_l12"]}}
{"id": "concept_standard_normal_distribution", "type": "V_concept", "name": "Standard Normal Distribution", "properties": {"description": "A normal distribution with a mean of 0 and a variance of 1.", "keywords": ["distribution", "gaussian", "normal", "mean", "variance", "standard"], "source_lectures": ["lecture_106108841_w2_l12", "lecture_106108841_w4_l26"]}}
{"id": "concept_gaussian_distribution", "type": "V_concept", "name": "Gaussian Distribution", "properties": {"description": "A continuous probability distribution that is commonly observed in nature.", "keywords": ["distribution", "feature", "nature", "gaussian", "normal", "statistics", "probability", "continuous"], "source_lectures": ["lecture_106108841_w2_l12", "lecture_106108841_w3_l16", "lecture_106108841_w3_l20", "lecture_106108841_w4_l26", "lecture_106108841_w5_l29"]}}
{"id": "concept_parametric_family", "type": "V_concept", "name": "Parametric Family", "properties": {"description": "A set of probability distributions that can be described using a finite number of parameters.", "keywords": ["parametric", "family", "probability", "distribution"], "source_lectures": ["lecture_106108841_w2_l13"]}}
{"id": "concept_divergence_metric", "type": "V_concept", "name": "Divergence Metric", "properties": {"description": "A measure of the difference between two probability distributions.", "keywords": ["divergence", "metric", "probability", "distribution"], "source_lectures": ["lecture_106108841_w2_l13"]}}
{"id": "concept_f_divergence", "type": "V_concept", "name": "F-Divergence", "properties": {"description": "A family of divergence metrics that measure the difference between two probability distributions.", "keywords": ["distribution", "divergence", "measure", "f", "f-divergence", "probability", "kl", "metric"], "source_lectures": ["lecture_106108841_w2_l13", "lecture_106108841_w3_l15"]}}
{"id": "concept_information_theory", "type": "V_concept", "name": "Information Theory", "properties": {"description": "A branch of mathematics that deals with the quantification and analysis of information.", "keywords": ["information", "theory", "mathematics", "quantification"], "source_lectures": ["lecture_106108841_w2_l13"]}}
{"id": "concept_surprisal", "type": "V_concept", "name": "Surprisal", "properties": {"description": "A measure of the information or surprise associated with an event.", "keywords": ["surprisal", "information", "event", "probability"], "source_lectures": ["lecture_106108841_w2_l13"]}}
{"id": "concept_thermodynamic_entropy", "type": "V_concept", "name": "Thermodynamic Entropy", "properties": {"description": "A measure of the disorder or randomness of a physical system.", "keywords": ["thermodynamic", "entropy", "disorder", "randomness"], "source_lectures": ["lecture_106108841_w2_l13"]}}
{"id": "concept_kullback_leibler_divergence", "type": "V_concept", "name": "Kullback-Leibler Divergence", "properties": {"description": "A measure of the difference between two probability distributions", "keywords": ["distribution", "distance", "divergence", "statistics", "kullback", "probability distance", "kullback-leibler", "information theory", "probability", "kl", "leibler", "kl divergence", "difference", "divergence measure"], "source_lectures": ["lecture_106108841_w2_l14", "lecture_106108841_w3_l16", "lecture_106108841_w3_l20", "lecture_106108841_w3_l21", "lecture_106108841_w4_l22", "lecture_106108841_w4_l23", "lecture_106108841_w4_l25"]}}
{"id": "concept_cross_entropy", "type": "V_concept", "name": "Cross Entropy", "properties": {"description": "A measure of the average information that one distribution contains about another", "keywords": ["distribution", "entropy", "loss", "function", "cross", "information", "machine"], "source_lectures": ["lecture_106108841_w2_l14", "lecture_106108841_w3_l16"]}}
{"id": "concept_mass_function", "type": "V_concept", "name": "Mass Function", "properties": {"description": "A function that assigns a probability to each possible value of a discrete random variable", "keywords": ["mass", "function", "discrete", "random", "variable"], "source_lectures": ["lecture_106108841_w2_l14"]}}
{"id": "concept_differential_entropy", "type": "V_concept", "name": "Differential Entropy", "properties": {"description": "A measure of the average information contained in a continuous probability distribution", "keywords": ["differential", "entropy", "continuous", "probability", "distribution"], "source_lectures": ["lecture_106108841_w2_l14"]}}
{"id": "concept_differential_cross_entropy", "type": "V_concept", "name": "Differential Cross Entropy", "properties": {"description": "A measure of the average information that one continuous distribution contains about another", "keywords": ["differential", "cross", "entropy", "continuous", "distribution"], "source_lectures": ["lecture_106108841_w2_l14"]}}
{"id": "concept_asymmetry_property", "type": "V_concept", "name": "Asymmetry Property", "properties": {"description": "The property that a measure or function is not symmetric, meaning that the order of the inputs matters", "keywords": ["asymmetry", "property", "measure", "function"], "source_lectures": ["lecture_106108841_w2_l14"]}}
{"id": "concept_non_negativity_property", "type": "V_concept", "name": "Non-Negativity Property", "properties": {"description": "The property that a measure or function is always non-negative, meaning that it is never negative", "keywords": ["non-negativity", "property", "measure", "function"], "source_lectures": ["lecture_106108841_w2_l14"]}}
{"id": "concept_metric", "type": "V_concept", "name": "Metric", "properties": {"description": "A mathematical function that assigns a distance or similarity measure between two objects", "keywords": ["metric", "distance", "similarity", "measure"], "source_lectures": ["lecture_106108841_w2_l14"]}}
{"id": "concept_kl_divergence", "type": "V_concept", "name": "Kl Divergence", "properties": {"description": "A measure of the difference between two probability distributions", "keywords": ["kl", "divergence", "probability", "distribution"], "source_lectures": ["lecture_106108841_w3_l15"]}}
{"id": "concept_maximum_likelihood_estimator", "type": "V_concept", "name": "Maximum Likelihood Estimator", "properties": {"description": "A statistical estimator that maximizes the likelihood of observing the data given a model", "keywords": ["maximum", "likelihood", "estimator", "statistics", "model"], "source_lectures": ["lecture_106108841_w3_l15"]}}
{"id": "concept_minimal_kl_divergence_estimator", "type": "V_concept", "name": "Minimal Kl Divergence Estimator", "properties": {"description": "An estimator that minimizes the kl divergence between the true distribution and the model distribution", "keywords": ["minimal", "kl", "divergence", "estimator", "distribution"], "source_lectures": ["lecture_106108841_w3_l15"]}}
{"id": "concept_likelihood_function", "type": "V_concept", "name": "Likelihood Function", "properties": {"description": "A function that describes the probability of observing the data given a model", "keywords": ["model", "parameters", "function", "probability", "likelihood"], "source_lectures": ["lecture_106108841_w3_l15", "lecture_106108841_w4_l24"]}}
{"id": "concept_log_likelihood", "type": "V_concept", "name": "Log Likelihood", "properties": {"description": "The logarithm of the likelihood function", "keywords": ["statistics", "convenience", "function", "log", "optimization", "computation", "likelihood"], "source_lectures": ["lecture_106108841_w3_l15", "lecture_106108841_w4_l24", "lecture_106108841_w5_l29"]}}
{"id": "concept_law_of_unconscious_statistician", "type": "V_concept", "name": "Law Of Unconscious Statistician", "properties": {"description": "A theorem that states the expectation of a function of a random variable can be computed using the distribution of the random variable", "keywords": ["law", "unconscious", "statistician", "expectation", "random"], "source_lectures": ["lecture_106108841_w3_l15"]}}
{"id": "concept_maximum_likelihood_estimation", "type": "V_concept", "name": "Maximum Likelihood Estimation", "properties": {"description": "A statistical method for estimating the parameters of a probability distribution by maximizing the likelihood function.", "keywords": ["parameter", "model", "estimation", "mle", "statistics", "likelihood", "maximum", "parameter estimation", "optimization", "probability", "parameters"], "source_lectures": ["lecture_106108841_w3_l16", "lecture_106108841_w3_l18", "lecture_106108841_w3_l20", "lecture_106108841_w3_l21", "lecture_106108841_w4_l22", "lecture_106108841_w4_l23", "lecture_106108841_w4_l24", "lecture_106108841_w5_l29", "lecture_106108841_w5_l30"]}}
{"id": "concept_negative_log_likelihood", "type": "V_concept", "name": "Negative Log Likelihood", "properties": {"description": "A function that measures the difference between the observed data and the predicted data, used in maximum likelihood estimation.", "keywords": ["negative", "log", "likelihood", "loss", "function"], "source_lectures": ["lecture_106108841_w3_l16"]}}
{"id": "concept_canonical_function_approximator", "type": "V_concept", "name": "Canonical Function Approximator", "properties": {"description": "A mathematical function used to approximate the relationship between input and output variables.", "keywords": ["canonical", "function", "approximator", "machine", "learning"], "source_lectures": ["lecture_106108841_w3_l16"]}}
{"id": "concept_supervised_regression", "type": "V_concept", "name": "Supervised Regression", "properties": {"description": "A type of machine learning problem where the goal is to predict a continuous output variable based on one or more input variables.", "keywords": ["supervised", "regression", "machine", "learning", "prediction"], "source_lectures": ["lecture_106108841_w3_l16"]}}
{"id": "concept_least_squares_estimation", "type": "V_concept", "name": "Least Squares Estimation", "properties": {"description": "A statistical method for estimating the parameters of a linear model by minimizing the sum of the squared errors.", "keywords": ["least", "squares", "estimation", "statistics", "linear"], "source_lectures": ["lecture_106108841_w3_l16"]}}
{"id": "concept_bernoulli_distribution", "type": "V_concept", "name": "Bernoulli Distribution", "properties": {"description": "A discrete probability distribution that models a binary random variable.", "keywords": ["bernoulli", "distribution", "probability", "statistics", "binary"], "source_lectures": ["lecture_106108841_w3_l16"]}}
{"id": "concept_true_risk", "type": "V_concept", "name": "True Risk", "properties": {"description": "The expected loss of a hypothesis function over the entire population, which is often unknown.", "keywords": ["true", "population", "loss", "expected", "risk", "expected loss"], "source_lectures": ["lecture_106108841_w3_l17", "lecture_106108841_w3_l18"]}}
{"id": "concept_empirical_risk", "type": "V_concept", "name": "Empirical Risk", "properties": {"description": "An approximation of the true risk, calculated using a sample of data.", "keywords": ["empirical", "risk", "approximation", "sample"], "source_lectures": ["lecture_106108841_w3_l17"]}}
{"id": "concept_generalization_bounds", "type": "V_concept", "name": "Generalization Bounds", "properties": {"description": "Bounds on the difference between the empirical risk and the true risk, used to analyze the performance of machine learning algorithms.", "keywords": ["generalization", "bounds", "empirical risk", "true risk"], "source_lectures": ["lecture_106108841_w3_l17"]}}
{"id": "concept_underfitting", "type": "V_concept", "name": "Underfitting", "properties": {"description": "When a machine learning model is too simple and fails to capture the underlying patterns in the data.", "keywords": ["underfitting", "simplicity", "simple model", "machine learning", "training data", "patterns"], "source_lectures": ["lecture_106108841_w3_l17", "lecture_106103843_w1_l5"]}}
{"id": "concept_statistical_learning_theory", "type": "V_concept", "name": "Statistical Learning Theory", "properties": {"description": "A framework for analyzing the performance of machine learning algorithms, focusing on the trade-off between bias and variance.", "keywords": ["statistical learning theory", "machine learning", "bias", "variance"], "source_lectures": ["lecture_106108841_w3_l17"]}}
{"id": "concept_bayes_classifier", "type": "V_concept", "name": "Bayes Classifier", "properties": {"description": "A classifier that assigns a class label based on the posterior probability of the label given the input data.", "keywords": ["bayes", "classifier", "posterior", "probability"], "source_lectures": ["lecture_106108841_w3_l18"]}}
{"id": "concept_01_loss_function", "type": "V_concept", "name": "01 Loss Function", "properties": {"description": "A loss function that assigns a loss of 0 to correct predictions and 1 to incorrect predictions.", "keywords": ["01", "loss", "function", "binary"], "source_lectures": ["lecture_106108841_w3_l18"]}}
{"id": "concept_expectation_maximization_algorithm", "type": "V_concept", "name": "Expectation Maximization Algorithm", "properties": {"description": "An algorithm for maximum likelihood estimation in the presence of missing or hidden data.", "keywords": ["latent", "mle", "latent variables", "statistics", "expectation", "missing data", "optimization", "variable", "algorithm", "iterative", "maximization", "em algorithm"], "source_lectures": ["lecture_106108841_w3_l18", "lecture_106108841_w4_l22", "lecture_106108841_w4_l23", "lecture_106108841_w4_l24", "lecture_106108841_w4_l25"]}}
{"id": "concept_base_classifier", "type": "V_concept", "name": "Base Classifier", "properties": {"description": "A classifier that assigns a label to an input based on a hypothesis function", "keywords": ["errors", "hypothesis", "optimal", "classifier", "true risk", "function", "weighted sum", "base", "base classifier"], "source_lectures": ["lecture_106108841_w3_l19", "lecture_106108841_w3_l20", "lecture_106108841_w4_l27"]}}
{"id": "concept_0_1_loss", "type": "V_concept", "name": "0-1 Loss", "properties": {"description": "A loss function that assigns a loss of 0 for correct predictions and 1 for incorrect predictions", "keywords": ["0-1", "loss", "function", "prediction"], "source_lectures": ["lecture_106108841_w3_l19"]}}
{"id": "concept_conditional_risk", "type": "V_concept", "name": "Conditional Risk", "properties": {"description": "The expected loss of a classifier given a specific input", "keywords": ["conditional", "risk", "expected", "loss"], "source_lectures": ["lecture_106108841_w3_l19"]}}
{"id": "concept_class_conditional", "type": "V_concept", "name": "Class Conditional", "properties": {"description": "The probability of an input given a label", "keywords": ["class", "conditional", "probability", "input"], "source_lectures": ["lecture_106108841_w3_l19"]}}
{"id": "concept_quadratic_discriminant_function", "type": "V_concept", "name": "Quadratic Discriminant Function", "properties": {"description": "A discriminant function that is quadratic in the input", "keywords": ["quadratic", "discriminant", "function", "input"], "source_lectures": ["lecture_106108841_w3_l19"]}}
{"id": "concept_linear_discriminant_function", "type": "V_concept", "name": "Linear Discriminant Function", "properties": {"description": "A discriminant function that is linear in the input", "keywords": ["linear", "discriminant", "function", "input"], "source_lectures": ["lecture_106108841_w3_l19"]}}
{"id": "concept_optimal_classifier", "type": "V_concept", "name": "Optimal Classifier", "properties": {"description": "A classifier that minimizes the risk or expected loss", "keywords": ["optimal", "classifier", "risk", "loss"], "source_lectures": ["lecture_106108841_w3_l19"]}}
{"id": "concept_class_conditional_density", "type": "V_concept", "name": "Class Conditional Density", "properties": {"description": "The probability density function of a class given a particular input or feature.", "keywords": ["feature", "density", "class", "class conditional density", "conditional", "probability", "probability density function"], "source_lectures": ["lecture_106108841_w3_l20", "lecture_106108841_w4_l26", "lecture_106108841_w4_l27"]}}
{"id": "concept_log_likelihood_function", "type": "V_concept", "name": "Log Likelihood Function", "properties": {"description": "The logarithm of the likelihood function, which is used in maximum likelihood estimation to simplify the optimization problem.", "keywords": ["inference", "model", "mle", "log-likelihood", "statistics", "objective function", "function", "log", "optimization", "probability", "likelihood"], "source_lectures": ["lecture_106108841_w3_l20", "lecture_106108841_w3_l21", "lecture_106108841_w4_l22", "lecture_106108841_w4_l23", "lecture_106108841_w4_l25", "lecture_106108841_w5_l30"]}}
{"id": "concept_maximum_likelihood_estimate", "type": "V_concept", "name": "Maximum Likelihood Estimate", "properties": {"description": "The estimate of the parameters of a probability distribution that maximizes the likelihood function.", "keywords": ["maximum", "likelihood", "estimate", "parameters"], "source_lectures": ["lecture_106108841_w3_l20"]}}
{"id": "concept_one_hot_representation", "type": "V_concept", "name": "One Hot Representation", "properties": {"description": "A method of representing categorical data as a numerical vector, where each category is represented by a binary vector with a single 1 and all other elements 0.", "keywords": ["representation", "categorical", "binary", "one", "hot", "data"], "source_lectures": ["lecture_106108841_w3_l21", "lecture_106108841_w5_l30"]}}
{"id": "concept_lagrangian", "type": "V_concept", "name": "Lagrangian", "properties": {"description": "A mathematical function that combines the objective function and the constraints of an optimization problem.", "keywords": ["lagrangian", "optimization", "constraints", "mathematics"], "source_lectures": ["lecture_106108841_w3_l21"]}}
{"id": "concept_multinomial_distribution", "type": "V_concept", "name": "Multinomial Distribution", "properties": {"description": "A probability distribution that models the number of times each outcome occurs in a fixed number of independent trials.", "keywords": ["multinomial", "distribution", "probability", "statistics"], "source_lectures": ["lecture_106108841_w3_l21"]}}
{"id": "concept_bernoulli_random_variable", "type": "V_concept", "name": "Bernoulli Random Variable", "properties": {"description": "A random variable that takes on only two possible values, often representing a binary outcome.", "keywords": ["coin", "discrete", "bernoulli", "toss", "random", "variable", "probability", "binary"], "source_lectures": ["lecture_106108841_w3_l21", "lecture_106108841_w4_l26", "lecture_106104233_w2_l11", "lecture_106104233_w3_l18"]}}
{"id": "concept_unimodal_distribution", "type": "V_concept", "name": "Unimodal Distribution", "properties": {"description": "A probability distribution with a single peak where the derivative of the density function vanishes.", "keywords": ["unimodal", "distribution", "density", "mode"], "source_lectures": ["lecture_106108841_w4_l22"]}}
{"id": "concept_multimodal_distribution", "type": "V_concept", "name": "Multimodal Distribution", "properties": {"description": "A probability distribution with multiple peaks where the density function's derivative vanishes at several points.", "keywords": ["multimodal", "distribution", "density", "modes"], "source_lectures": ["lecture_106108841_w4_l22"]}}
{"id": "concept_mixture_density", "type": "V_concept", "name": "Mixture Density", "properties": {"description": "A probability density function formed by a linear combination of other density functions.", "keywords": ["mixture", "density", "linear combination", "convex"], "source_lectures": ["lecture_106108841_w4_l22"]}}
{"id": "concept_gaussian_mixture_model", "type": "V_concept", "name": "Gaussian Mixture Model", "properties": {"description": "A mixture model where component densities are Gaussian distributions.", "keywords": ["model", "mixture", "density", "gmm", "gaussian", "density estimation", "mixture model", "clustering", "probability", "gaussian distribution"], "source_lectures": ["lecture_106108841_w4_l22", "lecture_106108841_w4_l23", "lecture_106108841_w4_l25"]}}
{"id": "concept_universal_density_approximator", "type": "V_concept", "name": "Universal Density Approximator", "properties": {"description": "A model capable of approximating any continuous density function arbitrarily closely.", "keywords": ["universal", "approximation", "density", "gmm"], "source_lectures": ["lecture_106108841_w4_l22"]}}
{"id": "concept_curse_of_dimensionality", "type": "V_concept", "name": "Curse of Dimensionality", "properties": {"description": "The problem where data becomes sparse in high-dimensional spaces, complicating model estimation.", "keywords": ["dimensionality", "sparsity", "high-dimensional", "estimation"], "source_lectures": ["lecture_106108841_w4_l22"]}}
{"id": "concept_variational_inference", "type": "V_concept", "name": "Variational Inference", "properties": {"description": "A framework for approximating complex probability distributions using optimization.", "keywords": ["inference", "approximation", "bayesian", "posterior approximation", "posterior", "optimization", "variational", "variational inference"], "source_lectures": ["lecture_106108841_w4_l22", "lecture_106108841_w4_l24", "lecture_106108841_w4_l25"]}}
{"id": "concept_basis_functions", "type": "V_concept", "name": "Basis Functions", "properties": {"description": "Elementary functions whose linear combinations represent more complex functions in a space.", "keywords": ["basis", "functions", "linear combination", "representation"], "source_lectures": ["lecture_106108841_w4_l22"]}}
{"id": "concept_mixture_density_model", "type": "V_concept", "name": "Mixture Density Model", "properties": {"description": "A probabilistic model that represents a density as a mixture of simpler densities", "keywords": ["mixture", "density", "model", "probability", "statistics"], "source_lectures": ["lecture_106108841_w4_l23"]}}
{"id": "concept_latent_variable_model", "type": "V_concept", "name": "Latent Variable Model", "properties": {"description": "A statistical model that includes one or more latent variables, which are not directly observed", "keywords": ["inference", "latent", "model", "statistics", "variable", "probability"], "source_lectures": ["lecture_106108841_w4_l23", "lecture_106108841_w4_l24"]}}
{"id": "concept_information_bottleneck", "type": "V_concept", "name": "Information Bottleneck", "properties": {"description": "A concept in information theory that describes the idea of compressing information while preserving its essential characteristics", "keywords": ["information", "bottleneck", "compression", "theory"], "source_lectures": ["lecture_106108841_w4_l23"]}}
{"id": "concept_evidence_lower_bound", "type": "V_concept", "name": "Evidence Lower Bound", "properties": {"description": "A lower bound on the log likelihood function, used in variational inference and expectation maximization algorithms.", "keywords": ["evidence", "elbo", "lower bound", "bound", "log", "lower", "likelihood", "variational"], "source_lectures": ["lecture_106108841_w4_l24", "lecture_106108841_w4_l25"]}}
{"id": "concept_jensens_inequality", "type": "V_concept", "name": "Jensen's Inequality", "properties": {"description": "A mathematical inequality that relates the expectation of a concave function to the function of the expectation.", "keywords": ["inequality", "convex", "concave", "expectation", "function", "probability", "jensen", "mathematics"], "source_lectures": ["lecture_106108841_w4_l24", "lecture_106106221_w8_l53"]}}
{"id": "concept_latent_variable", "type": "V_concept", "name": "Latent Variable", "properties": {"description": "An unobserved variable in a statistical model that influences observed data.", "keywords": ["latent variable", "unobserved", "statistical model", "hidden state"], "source_lectures": ["lecture_106108841_w4_l25"]}}
{"id": "concept_posterior_distribution", "type": "V_concept", "name": "Posterior Distribution", "properties": {"description": "The conditional probability distribution of latent variables given observed data and model parameters.", "keywords": ["posterior", "conditional distribution", "latent given data", "bayesian"], "source_lectures": ["lecture_106108841_w4_l25"]}}
{"id": "concept_variational_distribution", "type": "V_concept", "name": "Variational Distribution", "properties": {"description": "A simpler distribution used to approximate the true posterior distribution in variational methods.", "keywords": ["variational distribution", "approximation", "q distribution", "proxy"], "source_lectures": ["lecture_106108841_w4_l25"]}}
{"id": "concept_bound_tightness", "type": "V_concept", "name": "Bound Tightness", "properties": {"description": "The property of a lower bound being close to the actual function it approximates.", "keywords": ["tight bound", "approximation quality", "lower bound gap", "optimization"], "source_lectures": ["lecture_106108841_w4_l25"]}}
{"id": "concept_expectation_step", "type": "V_concept", "name": "Expectation Step", "properties": {"description": "The phase in the EM algorithm where the posterior distribution of latent variables is computed.", "keywords": ["e-step", "expectation", "posterior computation", "latent estimation"], "source_lectures": ["lecture_106108841_w4_l25"]}}
{"id": "concept_maximization_step", "type": "V_concept", "name": "Maximization Step", "properties": {"description": "The phase in the EM algorithm where model parameters are updated by maximizing the evidence lower bound.", "keywords": ["m-step", "maximization", "parameter update", "optimization"], "source_lectures": ["lecture_106108841_w4_l25"]}}
{"id": "concept_variational_autoencoder", "type": "V_concept", "name": "Variational Autoencoder", "properties": {"description": "A generative model using variational inference to approximate intractable posterior distributions.", "keywords": ["vae", "generative model", "variational", "autoencoder"], "source_lectures": ["lecture_106108841_w4_l25"]}}
{"id": "concept_iterative_optimization", "type": "V_concept", "name": "Iterative Optimization", "properties": {"description": "A process that repeatedly updates parameters to converge toward an optimal solution.", "keywords": ["iterative", "convergence", "parameter update", "algorithm"], "source_lectures": ["lecture_106108841_w4_l25"]}}
{"id": "concept_minmax_classifier", "type": "V_concept", "name": "Minmax Classifier", "properties": {"description": "A type of classifier that minimizes the maximum risk over all possible priors.", "keywords": ["minmax", "classifier", "risk", "prior"], "source_lectures": ["lecture_106108841_w4_l26"]}}
{"id": "concept_risk_integral", "type": "V_concept", "name": "Risk Integral", "properties": {"description": "A mathematical expression that represents the expected loss or risk of a classifier.", "keywords": ["risk", "integral", "loss", "classifier"], "source_lectures": ["lecture_106108841_w4_l26"]}}
{"id": "concept_minmax_criteria", "type": "V_concept", "name": "Minmax Criteria", "properties": {"description": "A condition that a classifier must satisfy to be considered a minmax classifier.", "keywords": ["minmax", "criteria", "classifier"], "source_lectures": ["lecture_106108841_w4_l26"]}}
{"id": "concept_threshold_value", "type": "V_concept", "name": "Threshold Value", "properties": {"description": "A value that determines the decision boundary of a classifier.", "keywords": ["value", "threshold value", "boundary", "classification", "class conditionals", "threshold", "decision"], "source_lectures": ["lecture_106108841_w4_l26", "lecture_106108841_w4_l27"]}}
{"id": "concept_linear_classifier", "type": "V_concept", "name": "Linear Classifier", "properties": {"description": "A type of classifier that makes predictions based on a linear combination of features.", "keywords": ["linear", "classifier", "features"], "source_lectures": ["lecture_106108841_w4_l26"]}}
{"id": "concept_neyman_pearson_classifier", "type": "V_concept", "name": "Neyman Pearson Classifier", "properties": {"description": "A type of classifier that minimizes the probability of type two error while keeping the probability of type one error below a certain threshold.", "keywords": ["neyman", "pearson", "classifier", "type one error", "type two error"], "source_lectures": ["lecture_106108841_w4_l27"]}}
{"id": "concept_type_one_error", "type": "V_concept", "name": "Type One Error", "properties": {"description": "The error of rejecting a true null hypothesis, also known as a false positive.", "keywords": ["hypothesis", "error", "null hypothesis", "type one error", "null", "one", "false positive", "type"], "source_lectures": ["lecture_106108841_w4_l27", "lecture_106108841_w4_l28"]}}
{"id": "concept_type_two_error", "type": "V_concept", "name": "Type Two Error", "properties": {"description": "The error of failing to reject a false null hypothesis, also known as a false negative.", "keywords": ["hypothesis", "error", "null hypothesis", "two", "type two error", "null", "false negative", "type"], "source_lectures": ["lecture_106108841_w4_l27", "lecture_106108841_w4_l28"]}}
{"id": "concept_roc_curve", "type": "V_concept", "name": "ROC Curve", "properties": {"description": "A graphical representation of the performance of a classifier, plotting the true positive rate against the false positive rate.", "keywords": ["false positive rate", "true positive rate", "tradeoff", "roc", "classifier", "binary", "curve", "classifier performance", "roc curve"], "source_lectures": ["lecture_106108841_w4_l27", "lecture_106108841_w4_l28"]}}
{"id": "concept_neyman_pearson_lemma", "type": "V_concept", "name": "Neyman Pearson Lemma", "properties": {"description": "A mathematical statement that provides a way to construct a most powerful test for a given size, based on the likelihood ratio.", "keywords": ["neyman pearson lemma", "most powerful test", "likelihood ratio"], "source_lectures": ["lecture_106108841_w4_l27"]}}
{"id": "concept_likelihood_ratio", "type": "V_concept", "name": "Likelihood Ratio", "properties": {"description": "The ratio of the probability of an observation under one hypothesis to the probability of the observation under another hypothesis.", "keywords": ["likelihood ratio", "probability", "hypothesis"], "source_lectures": ["lecture_106108841_w4_l27"]}}
{"id": "concept_neiman_pearson_classifier", "type": "V_concept", "name": "Neiman Pearson Classifier", "properties": {"description": "A statistical test used to determine the optimal threshold for a binary classifier", "keywords": ["neiman", "pearson", "classifier", "binary", "threshold"], "source_lectures": ["lecture_106108841_w4_l28"]}}
{"id": "concept_threshold_based_classifier", "type": "V_concept", "name": "Threshold-Based Classifier", "properties": {"description": "A classifier that uses a threshold to determine the class label of a sample", "keywords": ["threshold", "based", "classifier", "binary"], "source_lectures": ["lecture_106108841_w4_l28"]}}
{"id": "concept_false_positive_rate", "type": "V_concept", "name": "False Positive Rate", "properties": {"description": "The probability of predicting a positive class label for a sample that actually belongs to the negative class", "keywords": ["false", "positive", "rate", "binary", "classifier"], "source_lectures": ["lecture_106108841_w4_l28"]}}
{"id": "concept_false_negative_rate", "type": "V_concept", "name": "False Negative Rate", "properties": {"description": "The probability of predicting a negative class label for a sample that actually belongs to the positive class", "keywords": ["false", "negative", "rate", "binary", "classifier"], "source_lectures": ["lecture_106108841_w4_l28"]}}
{"id": "concept_true_positive_rate", "type": "V_concept", "name": "True Positive Rate", "properties": {"description": "The probability of predicting a positive class label for a sample that actually belongs to the positive class", "keywords": ["true", "positive", "rate", "binary", "classifier"], "source_lectures": ["lecture_106108841_w4_l28"]}}
{"id": "concept_true_negative_rate", "type": "V_concept", "name": "True Negative Rate", "properties": {"description": "The probability of predicting a negative class label for a sample that actually belongs to the negative class", "keywords": ["true", "negative", "rate", "binary", "classifier"], "source_lectures": ["lecture_106108841_w4_l28"]}}
{"id": "concept_precision", "type": "V_concept", "name": "Precision", "properties": {"description": "The ratio of true positives to the sum of true positives and false positives", "keywords": ["true", "relevance", "engine", "precision", "search", "classifier", "binary", "positive"], "source_lectures": ["lecture_106108841_w4_l28", "lecture_106106852_w1_l1"]}}
{"id": "concept_recall", "type": "V_concept", "name": "Recall", "properties": {"description": "The ratio of true positives to the sum of true positives and false negatives", "keywords": ["true", "relevance", "engine", "search", "classifier", "binary", "positive", "recall"], "source_lectures": ["lecture_106108841_w4_l28", "lecture_106106852_w1_l1"]}}
{"id": "concept_f1_score", "type": "V_concept", "name": "F1 Score", "properties": {"description": "The harmonic mean of precision and recall", "keywords": ["f1", "score", "binary", "classifier", "precision", "recall"], "source_lectures": ["lecture_106108841_w4_l28"]}}
{"id": "concept_area_under_the_roc_curve", "type": "V_concept", "name": "Area Under the ROC Curve", "properties": {"description": "A measure of the quality of a binary classifier", "keywords": ["area", "under", "roc", "curve", "binary", "classifier"], "source_lectures": ["lecture_106108841_w4_l28"]}}
{"id": "concept_matrix_cookbook", "type": "V_concept", "name": "Matrix Cookbook", "properties": {"description": "A collection of useful matrix identities and formulas, often used in linear algebra and statistics.", "keywords": ["matrix", "cookbook", "linear", "algebra", "statistics"], "source_lectures": ["lecture_106108841_w5_l29"]}}
{"id": "concept_covariance_matrix", "type": "V_concept", "name": "Covariance Matrix", "properties": {"description": "A square matrix that describes the covariance between different variables in a multivariate distribution.", "keywords": ["covariance", "matrix", "statistics", "multivariate", "distribution"], "source_lectures": ["lecture_106108841_w5_l29"]}}
{"id": "concept_trace_of_a_matrix", "type": "V_concept", "name": "Trace of a Matrix", "properties": {"description": "The sum of the diagonal elements of a square matrix, often used in linear algebra and statistics.", "keywords": ["trace", "matrix", "linear", "algebra", "statistics"], "source_lectures": ["lecture_106108841_w5_l29"]}}
{"id": "concept_determinant_of_a_matrix", "type": "V_concept", "name": "Determinant of a Matrix", "properties": {"description": "A scalar value that can be computed from the elements of a square matrix, often used in linear algebra and statistics.", "keywords": ["algebra", "statistics", "determinant", "permutation", "linear algebra", "linear", "matrix"], "source_lectures": ["lecture_106108841_w5_l29", "lecture_106104357_w4_l28"]}}
{"id": "concept_outer_product", "type": "V_concept", "name": "Outer Product", "properties": {"description": "A mathematical operation that computes the product of two vectors, resulting in a matrix.", "keywords": ["outer", "product", "vector", "matrix", "linear"], "source_lectures": ["lecture_106108841_w5_l29"]}}
{"id": "concept_multivariate_gaussian_distribution", "type": "V_concept", "name": "Multivariate Gaussian Distribution", "properties": {"description": "A continuous probability distribution that extends the Gaussian distribution to multiple variables.", "keywords": ["multivariate", "gaussian", "distribution", "probability", "statistics"], "source_lectures": ["lecture_106108841_w5_l29"]}}
{"id": "concept_generalized_discrete_distribution", "type": "V_concept", "name": "Generalized Discrete Distribution", "properties": {"description": "A probability distribution that models discrete random variables with a finite number of possible outcomes.", "keywords": ["generalized", "discrete", "distribution", "probability", "random"], "source_lectures": ["lecture_106108841_w5_l30"]}}
{"id": "concept_constrained_optimization", "type": "V_concept", "name": "Constrained Optimization", "properties": {"description": "A mathematical method for finding the maximum or minimum of a function subject to constraints.", "keywords": ["constrained", "optimization", "mathematics", "constraints", "function"], "source_lectures": ["lecture_106108841_w5_l30"]}}
{"id": "concept_lagrangian_function", "type": "V_concept", "name": "Lagrangian Function", "properties": {"description": "A mathematical function used to solve constrained optimization problems.", "keywords": ["lagrangian", "function", "constrained", "optimization", "mathematics"], "source_lectures": ["lecture_106108841_w5_l30"]}}
{"id": "concept_parameter_estimation", "type": "V_concept", "name": "Parameter Estimation", "properties": {"description": "The process of estimating the parameters of a statistical model from observed data.", "keywords": ["parameter", "estimation", "statistics", "model", "data"], "source_lectures": ["lecture_106108841_w5_l30"]}}
{"id": "concept_extended_reality_xr", "type": "V_concept", "name": "Extended Reality (XR)", "properties": {"description": "An umbrella term encompassing all immersive technologies including virtual reality, augmented reality, and mixed reality.", "keywords": ["xr", "extended reality", "immersive technologies", "umbrella term", "ar vr mr"], "source_lectures": ["lecture_106103842_w1_l1"]}}
{"id": "concept_virtual_reality_vr", "type": "V_concept", "name": "Virtual Reality (VR)", "properties": {"description": "A fully immersive digital environment that replaces the user's real-world surroundings with a computer-generated simulation.", "keywords": ["vr", "virtual reality", "immersive", "headset", "fully digital"], "source_lectures": ["lecture_106103842_w1_l1"]}}
{"id": "concept_augmented_reality_ar", "type": "V_concept", "name": "Augmented Reality (AR)", "properties": {"description": "A technology that overlays digital content onto the real world, enhancing the user's perception of their physical environment.", "keywords": ["augmented reality", "enhancement", "interactive", "digital overlay", "ar", "real world", "virtual overlay"], "source_lectures": ["lecture_106103842_w1_l1", "lecture_106103842_w2_l9"]}}
{"id": "concept_mixed_reality_mr", "type": "V_concept", "name": "Mixed Reality (MR)", "properties": {"description": "A spectrum of technologies blending real and virtual environments where physical and digital objects coexist and interact in real time.", "keywords": ["mr", "mixed reality", "real-virtual blend", "interactive", "hybrid environment"], "source_lectures": ["lecture_106103842_w1_l1"]}}
{"id": "concept_reality_virtuality_continuum", "type": "V_concept", "name": "Reality-Virtuality Continuum", "properties": {"description": "A conceptual scale ranging from the completely real environment to the completely virtual environment, with augmented reality and augmented virtuality in between.", "keywords": ["reality virtuality continuum", "continuum", "real to virtual", "augmented reality", "augmented virtuality"], "source_lectures": ["lecture_106103842_w1_l1"]}}
{"id": "concept_augmented_virtuality", "type": "V_concept", "name": "Augmented Virtuality", "properties": {"description": "The process of integrating real-world elements into a predominantly virtual environment to enhance immersion or realism.", "keywords": ["augmented virtuality", "virtual environment", "real elements", "digital world", "real-world integration"], "source_lectures": ["lecture_106103842_w1_l1"]}}
{"id": "concept_immersive_technology", "type": "V_concept", "name": "Immersive Technology", "properties": {"description": "A technology that creates a perceived experience through sensory input that simulates or replaces reality, making users feel present in the simulated environment.", "keywords": ["interactive", "immersive", "environment", "immersive technology", "immersion", "presence", "sensory experience", "simulation", "simulated environment", "technology"], "source_lectures": ["lecture_106103842_w1_l1", "lecture_106103842_w1_l2"]}}
{"id": "concept_metaverse", "type": "V_concept", "name": "Metaverse", "properties": {"description": "A collective virtual shared space, created by the convergence of virtually enhanced physical and digital reality, enabling natural human interaction in 3D environments.", "keywords": ["3d interaction", "reality", "internet", "persistent virtual space", "augmented", "virtual", "digital society", "virtual world", "metaverse"], "source_lectures": ["lecture_106103842_w1_l1", "lecture_106103842_w1_l6"]}}
{"id": "concept_human_computer_interaction_hci_in_xr", "type": "V_concept", "name": "Human-Computer Interaction (HCI) in XR", "properties": {"description": "The study and design of how users interact with extended reality systems using natural, immersive, and multimodal interfaces.", "keywords": ["hci", "human-computer interaction", "xr interaction", "natural interaction", "immersive interface"], "source_lectures": ["lecture_106103842_w1_l1"]}}
{"id": "concept_cognitive_and_psychological_factors_in_xr", "type": "V_concept", "name": "Cognitive and Psychological Factors in XR", "properties": {"description": "The study of how human perception, cognition, and psychology influence user experience and effectiveness in virtual and augmented reality systems.", "keywords": ["cognitive factors", "psychology", "perception", "user experience", "xr psychology"], "source_lectures": ["lecture_106103842_w1_l1"]}}
{"id": "concept_reality_virtuality_continuum_taxonomy", "type": "V_concept", "name": "Reality Virtuality Continuum (Taxonomy)", "properties": {"description": "A foundational taxonomy introduced by Milgram and Kishino in 1994 classifying mixed reality displays along a continuum from real to virtual environments.", "keywords": ["milgram kishino", "taxonomy", "reality virtuality continuum", "1994 paper", "mixed reality classification"], "source_lectures": ["lecture_106103842_w1_l1"]}}
{"id": "concept_xr_market_growth_projection", "type": "V_concept", "name": "XR Market Growth Projection", "properties": {"description": "The projected exponential increase in the global extended reality market from $20.5 billion in 2021 to $860 billion by 2030.", "keywords": ["xr market", "market growth", "market size", "2030 projection", "economic impact"], "source_lectures": ["lecture_106103842_w1_l1"]}}
{"id": "concept_hardware_vs_software_market_share_in_xr", "type": "V_concept", "name": "Hardware vs Software Market Share in XR", "properties": {"description": "The distribution of extended reality market value, with hardware accounting for approximately 60% and software for 40%.", "keywords": ["xr hardware", "xr software", "market share", "hardware dominance", "software share"], "source_lectures": ["lecture_106103842_w1_l1"]}}
{"id": "concept_digital_heritage_preservation_using_vr", "type": "V_concept", "name": "Digital Heritage Preservation using VR", "properties": {"description": "A use case application of virtual reality to digitally reconstruct, preserve, and experience historical sites or artifacts in immersive environments.", "keywords": ["digital heritage", "vr preservation", "cultural heritage", "virtual reconstruction", "historical simulation"], "source_lectures": ["lecture_106103842_w1_l1"]}}
{"id": "concept_game_engines_in_xr_development", "type": "V_concept", "name": "Game Engines in XR Development", "properties": {"description": "Software frameworks such as Unity or Unreal Engine used to build interactive virtual and augmented reality applications with 3D rendering and physics simulation.", "keywords": ["game engine", "unity", "unreal engine", "xr development", "3d rendering"], "source_lectures": ["lecture_106103842_w1_l1"]}}
{"id": "concept_sdks_in_xr_development", "type": "V_concept", "name": "SDKs in XR Development", "properties": {"description": "Software development kits that provide tools, libraries, and APIs for building applications for virtual, augmented, or mixed reality platforms.", "keywords": ["sdk", "software development kit", "xr sdk", "api", "development tools"], "source_lectures": ["lecture_106103842_w1_l1"]}}
{"id": "concept_sensory_immersion_in_xr", "type": "V_concept", "name": "Sensory Immersion in XR", "properties": {"description": "The use of visual, auditory, haptic, and sometimes olfactory stimuli to create a convincing perception of presence in a simulated environment.", "keywords": ["sensory immersion", "presence", "multi-sensory", "vr immersion", "sensory feedback"], "source_lectures": ["lecture_106103842_w1_l1"]}}
{"id": "concept_emerging_technology_area", "type": "V_concept", "name": "Emerging Technology Area", "properties": {"description": "A field of technological innovation recognized by governments and industries as having high growth potential and strategic importance, such as XR, AI, and drones.", "keywords": ["emerging technology", "strategic technology", "national priority", "technology growth", "future tech"], "source_lectures": ["lecture_106103842_w1_l1"]}}
{"id": "concept_3d_movie_experience_vs_vr", "type": "V_concept", "name": "3D Movie Experience vs VR", "properties": {"description": "A passive audiovisual experience in a theater, distinct from interactive virtual reality which requires user agency and sensory immersion.", "keywords": ["3d movie", "4d movie", "passive experience", "not vr", "cinematic immersion"], "source_lectures": ["lecture_106103842_w1_l1"]}}
{"id": "concept_pok\u00e9mon_go_as_ar_example", "type": "V_concept", "name": "Pok\u00e9mon Go as AR Example", "properties": {"description": "A mobile-based augmented reality game that overlays virtual creatures onto the real-world environment through a smartphone camera.", "keywords": ["pokemon go", "mobile ar", "location-based ar", "augmented reality game", "smartphone ar"], "source_lectures": ["lecture_106103842_w1_l1"]}}
{"id": "concept_xr_skill_demand", "type": "V_concept", "name": "XR Skill Demand", "properties": {"description": "The growing need for skilled professionals in computer science and engineering to design, develop, and deploy extended reality systems across industries.", "keywords": ["xr skills", "skill demand", "workforce need", "xr jobs", "technical workforce"], "source_lectures": ["lecture_106103842_w1_l1"]}}
{"id": "concept_immersive_experience_perception", "type": "V_concept", "name": "Immersive Experience Perception", "properties": {"description": "The psychological state in which users perceive a simulated environment as real, failing to distinguish it from the physical world.", "keywords": ["immersive perception", "presence", "reality illusion", "perceived realism", "sensory fidelity"], "source_lectures": ["lecture_106103842_w1_l1"]}}
{"id": "concept_mixed_reality_broad_definition", "type": "V_concept", "name": "Mixed Reality (Broad Definition)", "properties": {"description": "An informal term often used to describe the entire spectrum between real and virtual environments, encompassing both augmented reality and augmented virtuality.", "keywords": ["mixed reality", "broad definition", "ar vr spectrum", "reality continuum", "hybrid reality"], "source_lectures": ["lecture_106103842_w1_l1"]}}
{"id": "concept_digital_content_overlay", "type": "V_concept", "name": "Digital Content Overlay", "properties": {"description": "The process of superimposing computer-generated images, data, or objects onto a user's view of the physical world in augmented reality systems.", "keywords": ["digital overlay", "content overlay", "ar display", "virtual object", "real-time rendering"], "source_lectures": ["lecture_106103842_w1_l1"]}}
{"id": "concept_headset_based_vr", "type": "V_concept", "name": "Headset-Based VR", "properties": {"description": "A common implementation of virtual reality where users wear a head-mounted display that blocks external visual input and presents a fully digital environment.", "keywords": ["headset", "vr headset", "hmd", "immersive vr", "visual blocking"], "source_lectures": ["lecture_106103842_w1_l1"]}}
{"id": "concept_xr_applications_in_healthcare", "type": "V_concept", "name": "XR Applications in Healthcare", "properties": {"description": "The use of extended reality technologies in medical training, surgical visualization, patient therapy, and rehabilitation.", "keywords": ["healthcare xr", "medical vr", "surgical simulation", "xr therapy", "medical training"], "source_lectures": ["lecture_106103842_w1_l1"]}}
{"id": "concept_xr_applications_in_retail", "type": "V_concept", "name": "XR Applications in Retail", "properties": {"description": "The use of augmented and virtual reality for virtual try-ons, product visualization, and immersive shopping experiences in physical or digital stores.", "keywords": ["retail xr", "virtual try-on", "product visualization", "immersive shopping", "ar retail"], "source_lectures": ["lecture_106103842_w1_l1"]}}
{"id": "concept_xr_applications_in_engineering", "type": "V_concept", "name": "XR Applications in Engineering", "properties": {"description": "The use of extended reality for design visualization, prototyping, remote collaboration, and maintenance training in industrial and mechanical engineering contexts.", "keywords": ["engineering xr", "design visualization", "virtual prototyping", "ar maintenance", "industrial xr"], "source_lectures": ["lecture_106103842_w1_l1"]}}
{"id": "concept_xr_applications_in_live_events", "type": "V_concept", "name": "XR Applications in Live Events", "properties": {"description": "The integration of extended reality into concerts, sports, and theater to enhance audience experience with virtual elements and interactive features.", "keywords": ["live events xr", "concert vr", "ar sports", "immersive events", "virtual audience"], "source_lectures": ["lecture_106103842_w1_l1"]}}
{"id": "concept_virtual_reality", "type": "V_concept", "name": "Virtual Reality", "properties": {"description": "A computer-generated simulation of a three-dimensional environment that can be experienced and interacted with in a seemingly real or physical way.", "keywords": ["reality", "immersive", "environment", "virtual", "simulation", "vr", "sensory", "artificial"], "source_lectures": ["lecture_106103842_w1_l2", "lecture_106103842_w1_l3", "lecture_106103842_w1_l6", "lecture_106103842_w1_l7", "lecture_106103842_w2_l8", "lecture_106103220_w6_l40"]}}
{"id": "concept_augmented_reality", "type": "V_concept", "name": "Augmented Reality", "properties": {"description": "A technology that superimposes digital information and images onto the real world, using a device's camera and display.", "keywords": ["reality", "augmented", "overlay", "ar", "real world", "computer", "digital", "technology", "information"], "source_lectures": ["lecture_106103842_w1_l2", "lecture_106103842_w1_l3", "lecture_106103842_w1_l7", "lecture_106103842_w2_l8"]}}
{"id": "concept_extended_reality", "type": "V_concept", "name": "Extended Reality", "properties": {"description": "A term that encompasses virtual reality, augmented reality, and mixed reality, referring to the use of technology to create immersive and interactive experiences.", "keywords": ["reality", "augmented", "extended", "virtual", "mixed"], "source_lectures": ["lecture_106103842_w1_l2", "lecture_106103842_w1_l3"]}}
{"id": "concept_non_immersive_vr", "type": "V_concept", "name": "Non-Immersive VR", "properties": {"description": "A type of virtual reality that does not block the user's senses, allowing them to interact with a virtual environment while still being aware of their physical surroundings.", "keywords": ["non-immersive", "vr", "virtual", "environment", "interactive"], "source_lectures": ["lecture_106103842_w1_l2"]}}
{"id": "concept_semi_immersive_vr", "type": "V_concept", "name": "Semi-Immersive VR", "properties": {"description": "A type of virtual reality that partially blocks the user's senses, providing a partial immersive experience.", "keywords": ["semi-immersive", "vr", "virtual", "environment", "partial"], "source_lectures": ["lecture_106103842_w1_l2"]}}
{"id": "concept_fully_immersive_vr", "type": "V_concept", "name": "Fully Immersive VR", "properties": {"description": "A type of virtual reality that completely blocks the user's senses, providing a fully immersive experience.", "keywords": ["fully", "immersive", "vr", "virtual", "environment"], "source_lectures": ["lecture_106103842_w1_l2"]}}
{"id": "concept_virtual_tours", "type": "V_concept", "name": "Virtual Tours", "properties": {"description": "A type of virtual reality experience that allows users to explore a virtual environment, often used for travel and tourism.", "keywords": ["virtual", "tours", "travel", "tourism", "exploration"], "source_lectures": ["lecture_106103842_w1_l2"]}}
{"id": "concept_digital_heritage_preservation", "type": "V_concept", "name": "Digital Heritage Preservation", "properties": {"description": "The use of technology to preserve and protect cultural and historical heritage sites, often through virtual reality experiences.", "keywords": ["digital", "heritage", "preservation", "cultural", "historical"], "source_lectures": ["lecture_106103842_w1_l2"]}}
{"id": "concept_mixed_reality", "type": "V_concept", "name": "Mixed Reality", "properties": {"description": "A technology that combines elements of virtual reality and augmented reality, allowing users to interact with both virtual and real-world objects.", "keywords": ["hybrid", "reality", "interactive", "augmented", "virtual", "mixed", "digital"], "source_lectures": ["lecture_106103842_w1_l2", "lecture_106103842_w1_l3", "lecture_106103842_w2_l8"]}}
{"id": "concept_marker_based_tracking", "type": "V_concept", "name": "Marker-Based Tracking", "properties": {"description": "A method of tracking the position and orientation of a device using visual markers, such as QR codes or fiducial markers.", "keywords": ["fiducial", "ar", "tracking", "qr", "based", "visual", "marker"], "source_lectures": ["lecture_106103842_w1_l3", "lecture_106103842_w3_l15"]}}
{"id": "concept_markerless_tracking", "type": "V_concept", "name": "Markerless Tracking", "properties": {"description": "A method of tracking the position and orientation of a device without the use of visual markers, using computer vision techniques.", "keywords": ["markerless", "vision", "ar", "tracking", "sensors", "computer", "sensor"], "source_lectures": ["lecture_106103842_w1_l3", "lecture_106103842_w3_l15"]}}
{"id": "concept_location_based_augmentation", "type": "V_concept", "name": "Location-Based Augmentation", "properties": {"description": "A type of augmented reality that uses location-based information to provide relevant digital content to the user.", "keywords": ["location", "based", "augmentation", "gps", "sensor"], "source_lectures": ["lecture_106103842_w1_l3"]}}
{"id": "concept_superimposition_based_augmentation", "type": "V_concept", "name": "Superimposition-Based Augmentation", "properties": {"description": "A type of augmented reality that uses computer vision techniques to recognize objects in the real world and superimpose digital content onto them.", "keywords": ["superimposition", "augmentation", "computer", "vision", "object"], "source_lectures": ["lecture_106103842_w1_l3"]}}
{"id": "concept_projection_based_augmentation", "type": "V_concept", "name": "Projection-Based Augmentation", "properties": {"description": "A type of augmented reality that uses light projectors to project digital graphics onto real-world objects or surfaces.", "keywords": ["projection", "augmentation", "light", "projector", "holographic"], "source_lectures": ["lecture_106103842_w1_l3"]}}
{"id": "concept_outlining_based_augmentation", "type": "V_concept", "name": "Outlining-Based Augmentation", "properties": {"description": "A type of augmented reality that uses object recognition to recreate the user's immediate surroundings and provide additional information or context.", "keywords": ["outlining", "augmentation", "object", "recognition", "context"], "source_lectures": ["lecture_106103842_w1_l3"]}}
{"id": "concept_immersive_experience", "type": "V_concept", "name": "Immersive Experience", "properties": {"description": "A state of being fully engaged and surrounded by a virtual or simulated environment, often used to describe the experience of using virtual reality technology.", "keywords": ["immersive", "experience", "virtual", "simulated", "engagement"], "source_lectures": ["lecture_106103842_w1_l3"]}}
{"id": "concept_stereoscopic_vision", "type": "V_concept", "name": "Stereoscopic Vision", "properties": {"description": "The ability of the human brain to process two-dimensional images from each eye and combine them to create a single, three-dimensional image.", "keywords": ["stereoscopic", "vision", "3d", "image", "brain"], "source_lectures": ["lecture_106103842_w1_l6"]}}
{"id": "concept_head_mounted_display", "type": "V_concept", "name": "Head-Mounted Display", "properties": {"description": "A wearable device that displays a virtual environment or image in front of the user's eyes, providing an immersive experience.", "keywords": ["hmd", "environment", "wearable", "head-mounted", "virtual", "device", "display", "mounted", "head"], "source_lectures": ["lecture_106103842_w1_l6", "lecture_106103842_w1_l7", "lecture_106103842_w2_l14", "lecture_106103842_w3_l15"]}}
{"id": "concept_haptic_feedback", "type": "V_concept", "name": "Haptic Feedback", "properties": {"description": "A technology that provides tactile sensations to the user, allowing them to feel virtual objects or environments.", "keywords": ["haptic", "feedback", "tactile", "sensations", "virtual"], "source_lectures": ["lecture_106103842_w1_l6"]}}
{"id": "concept_artificial_reality", "type": "V_concept", "name": "Artificial Reality", "properties": {"description": "An early term used to describe virtual reality, referring to a simulated environment that is not real but can be experienced as if it were.", "keywords": ["artificial", "reality", "simulated", "environment", "virtual"], "source_lectures": ["lecture_106103842_w1_l6"]}}
{"id": "concept_sensorama", "type": "V_concept", "name": "Sensorama", "properties": {"description": "A device developed in the 1960s that provided a multi-sensory experience, including 3D vision, sound, and tactile sensations.", "keywords": ["sensorama", "multi-sensory", "3d", "vision", "sound"], "source_lectures": ["lecture_106103842_w1_l6"]}}
{"id": "concept_data_glove", "type": "V_concept", "name": "Data Glove", "properties": {"description": "A wearable device that tracks the user's hand movements and provides input to a virtual environment.", "keywords": ["data", "glove", "wearable", "input", "virtual"], "source_lectures": ["lecture_106103842_w1_l6"]}}
{"id": "concept_cave_system", "type": "V_concept", "name": "Cave System", "properties": {"description": "A virtual reality system that uses a room-sized environment to provide an immersive experience, with images projected onto the walls and floor.", "keywords": ["cave", "system", "virtual", "reality", "immersive"], "source_lectures": ["lecture_106103842_w1_l6"]}}
{"id": "concept_vrml", "type": "V_concept", "name": "VRML", "properties": {"description": "A modeling language used to create three-dimensional models and virtual environments for virtual reality applications.", "keywords": ["vrml", "modeling", "language", "3d", "virtual"], "source_lectures": ["lecture_106103842_w1_l6"]}}
{"id": "concept_oculus_rift", "type": "V_concept", "name": "Oculus Rift", "properties": {"description": "A virtual reality headset developed by Pal Lucky and later acquired by Facebook, providing an affordable and accessible virtual reality experience.", "keywords": ["oculus", "rift", "virtual", "reality", "headset"], "source_lectures": ["lecture_106103842_w1_l6"]}}
{"id": "concept_tracking_system", "type": "V_concept", "name": "Tracking System", "properties": {"description": "A technology used to track the user's movements and register virtual information in 3D space.", "keywords": ["movement", "tracking", "ar", "3d", "system", "registration", "vr"], "source_lectures": ["lecture_106103842_w1_l7", "lecture_106103842_w3_l16"]}}
{"id": "concept_experimental_phase", "type": "V_concept", "name": "Experimental Phase", "properties": {"description": "The initial stage of development in a field, characterized by experimentation and exploration of new ideas.", "keywords": ["experimental", "phase", "development", "innovation", "research"], "source_lectures": ["lecture_106103842_w1_l7"]}}
{"id": "concept_basic_research_phase", "type": "V_concept", "name": "Basic Research Phase", "properties": {"description": "A stage of development focused on fundamental research and understanding of a field, laying the groundwork for future applications.", "keywords": ["basic", "research", "phase", "fundamental", "development"], "source_lectures": ["lecture_106103842_w1_l7"]}}
{"id": "concept_tools_and_applications_phase", "type": "V_concept", "name": "Tools and Applications Phase", "properties": {"description": "A stage of development where practical tools and applications are created, building on the foundation of previous research.", "keywords": ["tools", "applications", "phase", "development", "implementation"], "source_lectures": ["lecture_106103842_w1_l7"]}}
{"id": "concept_commercial_application_phase", "type": "V_concept", "name": "Commercial Application Phase", "properties": {"description": "The final stage of development, where a technology is widely adopted and used in commercial applications.", "keywords": ["commercial", "application", "phase", "adoption", "industry"], "source_lectures": ["lecture_106103842_w1_l7"]}}
{"id": "concept_ar_toolkit", "type": "V_concept", "name": "AR Toolkit", "properties": {"description": "A software library that provides tools and functions for building augmented reality applications.", "keywords": ["development", "ar", "library", "software", "toolkit"], "source_lectures": ["lecture_106103842_w1_l7", "lecture_106103842_w3_l21"]}}
{"id": "concept_viewpoint_tracking", "type": "V_concept", "name": "Viewpoint Tracking", "properties": {"description": "A technology used to track the user's viewpoint and register virtual information in 3D space.", "keywords": ["viewpoint", "tracking", "technology", "registration", "3d"], "source_lectures": ["lecture_106103842_w1_l7"]}}
{"id": "concept_wearable_computing", "type": "V_concept", "name": "Wearable Computing", "properties": {"description": "A field of study that focuses on the design and development of computer systems that can be worn on the body.", "keywords": ["wearable", "computing", "field", "study", "design"], "source_lectures": ["lecture_106103842_w1_l7"]}}
{"id": "concept_mobile_ar", "type": "V_concept", "name": "Mobile AR", "properties": {"description": "A type of augmented reality that uses mobile devices to superimpose computer-generated information on the real world.", "keywords": ["mobile", "ar", "augmented", "reality", "device"], "source_lectures": ["lecture_106103842_w1_l7"]}}
{"id": "concept_holographic_projection", "type": "V_concept", "name": "Holographic Projection", "properties": {"description": "A technology that uses lasers and other devices to create three-dimensional images that appear to float in space.", "keywords": ["holographic", "projection", "technology", "lasers", "3d"], "source_lectures": ["lecture_106103842_w1_l7"]}}
{"id": "concept_ivan_sutherland", "type": "V_concept", "name": "Ivan Sutherland", "properties": {"description": "A computer scientist who made significant contributions to the development of virtual and augmented reality technologies.", "keywords": ["ivan", "sutherland", "computer", "scientist", "contributions"], "source_lectures": ["lecture_106103842_w1_l7"]}}
{"id": "concept_tom_caudell", "type": "V_concept", "name": "Tom Caudell", "properties": {"description": "A computer scientist who coined the term 'augmented reality' and made significant contributions to the field.", "keywords": ["tom", "caudell", "computer", "scientist", "contributions"], "source_lectures": ["lecture_106103842_w1_l7"]}}
{"id": "concept_immersion", "type": "V_concept", "name": "Immersion", "properties": {"description": "The objective degree to which a VR system projects stimuli onto a user's sensory receptors.", "keywords": ["stimuli", "immersion", "receptors", "technology", "vr", "sensory"], "source_lectures": ["lecture_106103842_w2_l8", "lecture_106103842_w2_l9"]}}
{"id": "concept_presence", "type": "V_concept", "name": "Presence", "properties": {"description": "A psychological state where a user fails to distinguish between virtual and real-world experiences.", "keywords": ["psychological", "psychology", "real world", "virtual", "state", "perception", "presence", "realism", "vr"], "source_lectures": ["lecture_106103842_w2_l8", "lecture_106103842_w2_l9"]}}
{"id": "concept_extensive", "type": "V_concept", "name": "Extensive", "properties": {"description": "A quality of immersion referring to the range of sensory modalities presented to a user.", "keywords": ["extensive", "immersion", "sensory", "modalities", "range"], "source_lectures": ["lecture_106103842_w2_l8"]}}
{"id": "concept_matching", "type": "V_concept", "name": "Matching", "properties": {"description": "A quality of immersion referring to the congruence between sensory modalities.", "keywords": ["graph", "edges", "matching", "immersion", "vertices", "modalities", "congruence", "sensory"], "source_lectures": ["lecture_106103842_w2_l8", "lecture_106104233_w5_l30"]}}
{"id": "concept_surrounding", "type": "V_concept", "name": "Surrounding", "properties": {"description": "A quality of immersion referring to the extent of cues being panoramic.", "keywords": ["surrounding", "immersion", "cues", "panoramic", "extent"], "source_lectures": ["lecture_106103842_w2_l8"]}}
{"id": "concept_vivid", "type": "V_concept", "name": "Vivid", "properties": {"description": "A quality of immersion referring to the quality of energy stimulated within a particular modality.", "keywords": ["vivid", "immersion", "energy", "modality", "quality"], "source_lectures": ["lecture_106103842_w2_l8"]}}
{"id": "concept_interactive", "type": "V_concept", "name": "Interactive", "properties": {"description": "A quality of immersion referring to a user's ability to make changes to a virtual environment.", "keywords": ["interactive", "immersion", "user", "changes", "virtual environment"], "source_lectures": ["lecture_106103842_w2_l8"]}}
{"id": "concept_plot_informing", "type": "V_concept", "name": "Plot Informing", "properties": {"description": "A quality of immersion referring to a user's ability to understand the overall story or script of a virtual experience.", "keywords": ["plot informing", "immersion", "story", "script", "virtual experience"], "source_lectures": ["lecture_106103842_w2_l8"]}}
{"id": "concept_uncanny_valley_effect", "type": "V_concept", "name": "Uncanny Valley Effect", "properties": {"description": "A phenomenon where human-like digital representations that are nearly realistic evoke feelings of unease or eeriness due to subtle imperfections.", "keywords": ["uncanny valley", "human likeness", "unease", "digital representation", "perception"], "source_lectures": ["lecture_106103842_w2_l9"]}}
{"id": "concept_representational_fidelity", "type": "V_concept", "name": "Representational Fidelity", "properties": {"description": "The degree to which a VR experience accurately reflects or exploits familiarity with real-world places or environments.", "keywords": ["representational fidelity", "vr", "realism", "environment", "photorealism"], "source_lectures": ["lecture_106103842_w2_l9"]}}
{"id": "concept_interaction_fidelity", "type": "V_concept", "name": "Interaction Fidelity", "properties": {"description": "The degree to which physical actions in a virtual task correspond to equivalent physical actions in the real world.", "keywords": ["interaction fidelity", "vr", "physical action", "input", "real-world correspondence"], "source_lectures": ["lecture_106103842_w2_l9"]}}
{"id": "concept_experiential_fidelity", "type": "V_concept", "name": "Experiential Fidelity", "properties": {"description": "The degree to which a user's personal experience in a virtual environment matches the intended experience designed by the creator.", "keywords": ["experiential fidelity", "vr", "user experience", "intended experience", "constraints"], "source_lectures": ["lecture_106103842_w2_l9"]}}
{"id": "concept_3d_registration", "type": "V_concept", "name": "3D Registration", "properties": {"description": "The process of anchoring virtual objects to specific locations in the real world so they appear seamlessly integrated.", "keywords": ["ar", "real world", "3d", "virtual content", "registration", "alignment", "3d registration", "anchoring"], "source_lectures": ["lecture_106103842_w2_l9", "lecture_106103842_w3_l21"]}}
{"id": "concept_pose_tracking", "type": "V_concept", "name": "Pose Tracking", "properties": {"description": "The continuous updating of a user's position and orientation during AR usage to maintain alignment between virtual and real-world content.", "keywords": ["pose tracking", "ar", "real-time", "motion", "update"], "source_lectures": ["lecture_106103842_w2_l9"]}}
{"id": "concept_display_technology_arvr", "type": "V_concept", "name": "Display Technology (AR/VR)", "properties": {"description": "Hardware systems used to present visual content to users in augmented or virtual reality environments.", "keywords": ["display technology", "ar", "vr", "headset", "visual output"], "source_lectures": ["lecture_106103842_w2_l9"]}}
{"id": "concept_input_modalities_arvr", "type": "V_concept", "name": "Input Modalities (AR/VR)", "properties": {"description": "The various methods by which users interact with virtual or augmented environments, such as gestures, controllers, or voice.", "keywords": ["input modalities", "ar", "vr", "interaction", "input devices"], "source_lectures": ["lecture_106103842_w2_l9"]}}
{"id": "concept_cyber_sickness", "type": "V_concept", "name": "Cyber Sickness", "properties": {"description": "A form of motion sickness induced by virtual reality environments due to sensory conflicts between visual and vestibular inputs.", "keywords": ["sickness", "reality", "physical", "motion", "motion sickness", "discomfort", "cyber sickness", "conflicting", "virtual", "sensory conflict", "cyber", "vims", "signals", "vr", "nausea"], "source_lectures": ["lecture_106103842_w2_l9", "lecture_106103842_w2_l10", "lecture_106103842_w2_l11", "lecture_106103842_w2_l12", "lecture_106103842_w3_l19"]}}
{"id": "concept_human_likeness_spectrum", "type": "V_concept", "name": "Human Likeness Spectrum", "properties": {"description": "A continuum measuring how closely an artificial object resembles a human, used to analyze the uncanny valley effect.", "keywords": ["human likeness", "uncanny valley", "similarity", "digital human", "perception"], "source_lectures": ["lecture_106103842_w2_l9"]}}
{"id": "concept_real_world_experience_as_reality_benchmark", "type": "V_concept", "name": "Real-World Experience (as Reality Benchmark)", "properties": {"description": "The baseline of sensory and perceptual experiences derived from everyday physical reality, used to evaluate virtual environments.", "keywords": ["real world experience", "reality", "benchmark", "perception", "vr"], "source_lectures": ["lecture_106103842_w2_l9"]}}
{"id": "concept_beyond_reality_design_vr", "type": "V_concept", "name": "Beyond-Reality Design (VR)", "properties": {"description": "An approach to virtual reality design that intentionally exceeds or alters real-world experiences to create novel, enhanced realities.", "keywords": ["beyond reality", "vr", "design", "enhanced reality", "non-mimetic"], "source_lectures": ["lecture_106103842_w2_l9"]}}
{"id": "concept_registration_phase_ar", "type": "V_concept", "name": "Registration Phase (AR)", "properties": {"description": "The initial one-time process of determining a user\u2019s pose relative to a real-world anchor point in an AR system.", "keywords": ["registration phase", "ar", "pose", "anchor", "initialization"], "source_lectures": ["lecture_106103842_w2_l9"]}}
{"id": "concept_tracking_phase_ar", "type": "V_concept", "name": "Tracking Phase (AR)", "properties": {"description": "The continuous process of updating a user\u2019s pose during AR usage to maintain alignment as the user moves.", "keywords": ["tracking phase", "ar", "pose update", "motion tracking", "real-time"], "source_lectures": ["lecture_106103842_w2_l9"]}}
{"id": "concept_photorealism", "type": "V_concept", "name": "Photorealism", "properties": {"description": "The quality of a digital representation that closely mimics the visual appearance of real-world objects and lighting.", "keywords": ["photorealism", "vr", "visual realism", "rendering", "image quality"], "source_lectures": ["lecture_106103842_w2_l9"]}}
{"id": "concept_sensory_match_vr", "type": "V_concept", "name": "Sensory Match (VR)", "properties": {"description": "The alignment between sensory stimuli generated by technology and the psychological perception of reality by the user.", "keywords": ["sensory match", "vr", "immersion", "presence", "perception"], "source_lectures": ["lecture_106103842_w2_l9"]}}
{"id": "concept_azumas_definition_of_ar", "type": "V_concept", "name": "Azuma's Definition of AR", "properties": {"description": "A foundational definition stating that AR must combine real and virtual worlds, be interactive in real time, and be registered in 3D.", "keywords": ["azuma", "ar definition", "three requirements", "real-time", "registration"], "source_lectures": ["lecture_106103842_w2_l9"]}}
{"id": "concept_fidelity_trade_off_vr", "type": "V_concept", "name": "Fidelity Trade-off (VR)", "properties": {"description": "The balance between increasing realism in VR and avoiding negative perceptual effects such as the uncanny valley.", "keywords": ["fidelity trade-off", "vr", "realism", "uncanny valley", "user experience"], "source_lectures": ["lecture_106103842_w2_l9"]}}
{"id": "concept_non_photorealistic_vr", "type": "V_concept", "name": "Non-Photorealistic VR", "properties": {"description": "Virtual reality experiences that achieve presence without relying on photorealistic visuals, using abstract or stylized cues instead.", "keywords": ["non-photorealistic", "vr", "presence", "abstract", "cues"], "source_lectures": ["lecture_106103842_w2_l9"]}}
{"id": "concept_virtual_content_overlay", "type": "V_concept", "name": "Virtual Content Overlay", "properties": {"description": "The process of superimposing digital information or objects onto a live view of the physical environment in augmented reality.", "keywords": ["virtual content overlay", "ar", "augmentation", "digital overlay", "real-time"], "source_lectures": ["lecture_106103842_w2_l9"]}}
{"id": "concept_anchor_point_ar", "type": "V_concept", "name": "Anchor Point (AR)", "properties": {"description": "A fixed reference point in the real world used to register and stabilize virtual content in an augmented reality system.", "keywords": ["anchor point", "ar", "registration", "real-world reference", "stabilization"], "source_lectures": ["lecture_106103842_w2_l9"]}}
{"id": "concept_sensory_conflict_theory", "type": "V_concept", "name": "Sensory Conflict Theory", "properties": {"description": "A theory explaining cyber sickness as arising from discrepancies between visual motion cues and vestibular system inputs.", "keywords": ["sensory conflict", "cyber sickness", "vestibular", "visual", "motion"], "source_lectures": ["lecture_106103842_w2_l9"]}}
{"id": "concept_user_centered_reality_design", "type": "V_concept", "name": "User-Centered Reality Design", "properties": {"description": "An approach to VR/AR design that prioritizes the user's subjective perception and expectations of reality over technical realism.", "keywords": ["user-centered", "reality design", "vr", "ar", "perception"], "source_lectures": ["lecture_106103842_w2_l9"]}}
{"id": "concept_real_time_interaction_arvr", "type": "V_concept", "name": "Real-Time Interaction (AR/VR)", "properties": {"description": "The requirement that user actions and system responses occur with minimal delay to maintain immersion or presence.", "keywords": ["real-time interaction", "ar", "vr", "latency", "responsiveness"], "source_lectures": ["lecture_106103842_w2_l9"]}}
{"id": "concept_stylized_representation_vr", "type": "V_concept", "name": "Stylized Representation (VR)", "properties": {"description": "A design choice in virtual environments that uses non-realistic or abstract visuals to avoid the uncanny valley and enhance presence.", "keywords": ["stylized representation", "vr", "uncanny valley", "non-realistic", "presence"], "source_lectures": ["lecture_106103842_w2_l9"]}}
{"id": "concept_constraint_based_experience_design", "type": "V_concept", "name": "Constraint-Based Experience Design", "properties": {"description": "Designing virtual experiences with real-world physical constraints to increase experiential fidelity and reduce cognitive dissonance.", "keywords": ["constraint-based", "experience design", "experiential fidelity", "vr", "real-world constraints"], "source_lectures": ["lecture_106103842_w2_l9"]}}
{"id": "concept_visually_induced_motion_sickness", "type": "V_concept", "name": "Visually Induced Motion Sickness", "properties": {"description": "A condition that affects individuals when they interact with virtual reality technology, causing symptoms such as nausea, headache, and dizziness.", "keywords": ["visually", "induced", "motion", "sickness", "vims"], "source_lectures": ["lecture_106103842_w2_l10"]}}
{"id": "concept_internal_factors", "type": "V_concept", "name": "Internal Factors", "properties": {"description": "Individual characteristics and conditions that can contribute to an increased likelihood of experiencing cyber sickness, such as age, gender, and motion sickness susceptibility.", "keywords": ["internal", "factors", "individual", "characteristics", "conditions"], "source_lectures": ["lecture_106103842_w2_l10"]}}
{"id": "concept_external_factors", "type": "V_concept", "name": "External Factors", "properties": {"description": "Factors that are not subjective to users' mental or physical conditions, such as hardware and content, that can contribute to cyber sickness.", "keywords": ["external", "factors", "hardware", "content", "environmental"], "source_lectures": ["lecture_106103842_w2_l10"]}}
{"id": "concept_motion_sickness_susceptibility", "type": "V_concept", "name": "Motion Sickness Susceptibility", "properties": {"description": "A condition that occurs when the brain receives conflicting signals from various sensory organs, causing symptoms such as nausea and dizziness.", "keywords": ["motion", "sickness", "susceptibility", "ms", "conflicting"], "source_lectures": ["lecture_106103842_w2_l10"]}}
{"id": "concept_jitter", "type": "V_concept", "name": "Jitter", "properties": {"description": "The variability in latency, causing irregularities in the timing of the delivery of data.", "keywords": ["jitter", "variability", "latency", "irregularities", "timing"], "source_lectures": ["lecture_106103842_w2_l10"]}}
{"id": "concept_display_resolution", "type": "V_concept", "name": "Display Resolution", "properties": {"description": "The number of pixels that can be displayed on a screen, affecting the quality of the virtual reality experience.", "keywords": ["display", "resolution", "pixels", "quality", "virtual"], "source_lectures": ["lecture_106103842_w2_l10"]}}
{"id": "concept_type_of_display", "type": "V_concept", "name": "Type of Display", "properties": {"description": "The type of device used to display virtual reality content, such as head-mounted displays or conventional monitors.", "keywords": ["type", "display", "device", "virtual", "reality"], "source_lectures": ["lecture_106103842_w2_l10"]}}
{"id": "concept_input_method", "type": "V_concept", "name": "Input Method", "properties": {"description": "The way in which a user interacts with a virtual reality system, such as using hand controllers or motion sensors.", "keywords": ["input", "method", "interaction", "virtual", "reality"], "source_lectures": ["lecture_106103842_w2_l10"]}}
{"id": "concept_interpupillary_distance", "type": "V_concept", "name": "Interpupillary Distance", "properties": {"description": "The distance between the centers of the pupils of the eyes, affecting the quality of the stereoscopic vision in virtual reality.", "keywords": ["interpupillary", "distance", "pupils", "eyes", "stereoscopic"], "source_lectures": ["lecture_106103842_w2_l10"]}}
{"id": "concept_retinal_eccentricity", "type": "V_concept", "name": "Retinal Eccentricity", "properties": {"description": "The angle between the line of sight and the edge of the retina, affecting the quality of the visual perception in virtual reality.", "keywords": ["retinal", "eccentricity", "angle", "line", "sight"], "source_lectures": ["lecture_106103842_w2_l10"]}}
{"id": "concept_body_awareness", "type": "V_concept", "name": "Body Awareness", "properties": {"description": "The ability of the user to attend to and perceive bodily sensations, affecting the quality of the virtual reality experience.", "keywords": ["body", "awareness", "bodily", "sensations", "perception"], "source_lectures": ["lecture_106103842_w2_l10"]}}
{"id": "concept_emotional_conditions", "type": "V_concept", "name": "Emotional Conditions", "properties": {"description": "The emotional state of the user, such as anxiety or stress, affecting the quality of the virtual reality experience.", "keywords": ["emotional", "conditions", "state", "anxiety", "stress"], "source_lectures": ["lecture_106103842_w2_l10"]}}
{"id": "concept_visual_motion", "type": "V_concept", "name": "Visual Motion", "properties": {"description": "The movement experienced by a user in a virtual environment, which can contribute to cyber sickness.", "keywords": ["visual", "motion", "virtual", "environment", "cyber"], "source_lectures": ["lecture_106103842_w2_l11"]}}
{"id": "concept_vection", "type": "V_concept", "name": "Vection", "properties": {"description": "The sensation of self-motion, which can be induced by visual motion in a virtual environment.", "keywords": ["vection", "self-motion", "visual", "motion", "virtual"], "source_lectures": ["lecture_106103842_w2_l11"]}}
{"id": "concept_means_of_locomotion", "type": "V_concept", "name": "Means Of Locomotion", "properties": {"description": "The way a user moves in a virtual environment, which can affect cyber sickness.", "keywords": ["locomotion", "virtual", "environment", "cyber", "sickness"], "source_lectures": ["lecture_106103842_w2_l11"]}}
{"id": "concept_field_of_view", "type": "V_concept", "name": "Field Of View", "properties": {"description": "The extent to which a user's field of vision is captured by a display in a virtual environment.", "keywords": ["field", "view", "virtual", "environment", "display"], "source_lectures": ["lecture_106103842_w2_l11"]}}
{"id": "concept_type_of_content", "type": "V_concept", "name": "Type Of Content", "properties": {"description": "The type of content presented in a virtual environment, which can affect cyber sickness.", "keywords": ["content", "virtual", "environment", "cyber", "sickness"], "source_lectures": ["lecture_106103842_w2_l11"]}}
{"id": "concept_duration_of_exposure", "type": "V_concept", "name": "Duration Of Exposure", "properties": {"description": "The length of time a user is exposed to a virtual environment, which can affect cyber sickness.", "keywords": ["duration", "exposure", "virtual", "environment", "cyber"], "source_lectures": ["lecture_106103842_w2_l11"]}}
{"id": "concept_visual_complexity", "type": "V_concept", "name": "Visual Complexity", "properties": {"description": "The complexity of visual stimuli in a virtual environment, which can contribute to cyber sickness.", "keywords": ["visual", "complexity", "virtual", "environment", "cyber"], "source_lectures": ["lecture_106103842_w2_l11"]}}
{"id": "concept_simulator_sickness_questionnaire", "type": "V_concept", "name": "Simulator Sickness Questionnaire", "properties": {"description": "A questionnaire used to measure the severity of cyber sickness.", "keywords": ["simulator", "sickness", "questionnaire", "cyber", "measurement"], "source_lectures": ["lecture_106103842_w2_l11"]}}
{"id": "concept_physiological_input", "type": "V_concept", "name": "Physiological Input", "properties": {"description": "Biometric data used to measure cyber sickness, such as heart rate and galvanic skin response.", "keywords": ["physiological", "input", "biometric", "cyber", "sickness"], "source_lectures": ["lecture_106103842_w2_l11"]}}
{"id": "concept_behavioral_input", "type": "V_concept", "name": "Behavioral Input", "properties": {"description": "Behavioral cues used to measure cyber sickness, such as blink rate and head movement.", "keywords": ["behavioral", "input", "cyber", "sickness", "measurement"], "source_lectures": ["lecture_106103842_w2_l11"]}}
{"id": "concept_content_based_input", "type": "V_concept", "name": "Content-Based Input", "properties": {"description": "Features of virtual environment content used to measure cyber sickness, such as optical flow and depth cues.", "keywords": ["content-based", "input", "cyber", "sickness", "measurement"], "source_lectures": ["lecture_106103842_w2_l11"]}}
{"id": "concept_manual_evaluation", "type": "V_concept", "name": "Manual Evaluation", "properties": {"description": "A method of measuring cyber sickness that relies on human intervention, such as administering questionnaires.", "keywords": ["manual", "evaluation", "cyber", "sickness", "measurement"], "source_lectures": ["lecture_106103842_w2_l11"]}}
{"id": "concept_machine_learning_based_evaluation", "type": "V_concept", "name": "Machine Learning-Based Evaluation", "properties": {"description": "A method of measuring cyber sickness that uses automated algorithms to analyze input data.", "keywords": ["machine", "learning", "evaluation", "cyber", "sickness"], "source_lectures": ["lecture_106103842_w2_l11"]}}
{"id": "concept_transparent_models", "type": "V_concept", "name": "Transparent Models", "properties": {"description": "Machine learning models that provide clear insight into their decision-making process, used to measure cyber sickness.", "keywords": ["models", "interpretable", "cyber", "learning", "transparent", "machine"], "source_lectures": ["lecture_106103842_w2_l11", "lecture_106103842_w2_l12"]}}
{"id": "concept_evaluation_techniques", "type": "V_concept", "name": "Evaluation Techniques", "properties": {"description": "Methods used to measure and assess the severity of cyber sickness, including manual and automated approaches.", "keywords": ["evaluation", "techniques", "measurement", "assessment", "cyber"], "source_lectures": ["lecture_106103842_w2_l12"]}}
{"id": "concept_interpretable_models", "type": "V_concept", "name": "Interpretable Models", "properties": {"description": "Machine learning models that offer flexibility in customization and provide precise details about the relationships between input and output.", "keywords": ["interpretable", "models", "machine", "learning", "customization"], "source_lectures": ["lecture_106103842_w2_l12"]}}
{"id": "concept_blackbox_models", "type": "V_concept", "name": "Blackbox Models", "properties": {"description": "Machine learning models that are difficult to understand and interpret, with their decision-making process being unclear.", "keywords": ["blackbox", "models", "machine", "learning", "unclear"], "source_lectures": ["lecture_106103842_w2_l12"]}}
{"id": "concept_field_of_view_adjustment", "type": "V_concept", "name": "Field Of View Adjustment", "properties": {"description": "A technique used to mitigate cyber sickness by adjusting the amount of virtual environment visible at any moment.", "keywords": ["field", "view", "adjustment", "mitigation", "cyber"], "source_lectures": ["lecture_106103842_w2_l12"]}}
{"id": "concept_dynamic_visual_blur", "type": "V_concept", "name": "Dynamic Visual Blur", "properties": {"description": "A technique used to reduce the possibility of cyber sickness by applying blur effects to the virtual environment.", "keywords": ["dynamic", "visual", "blur", "reduction", "cyber"], "source_lectures": ["lecture_106103842_w2_l12"]}}
{"id": "concept_rest_frames", "type": "V_concept", "name": "Rest Frames", "properties": {"description": "Fixed elements within a virtual environment that remain stationary relative to the real world, used to reduce cyber sickness.", "keywords": ["rest", "frames", "stationary", "virtual", "environment"], "source_lectures": ["lecture_106103842_w2_l12"]}}
{"id": "concept_optical_flow_manipulation", "type": "V_concept", "name": "Optical Flow Manipulation", "properties": {"description": "A technique used to reduce cyber sickness by manipulating the optical flow patterns in the virtual environment.", "keywords": ["optical", "flow", "manipulation", "reduction", "cyber"], "source_lectures": ["lecture_106103842_w2_l12"]}}
{"id": "concept_habituation", "type": "V_concept", "name": "Habituation", "properties": {"description": "A process of repeated exposure to a virtual environment to reduce the intensity of cyber sickness symptoms.", "keywords": ["habituation", "repeated", "exposure", "reduction", "cyber"], "source_lectures": ["lecture_106103842_w2_l12"]}}
{"id": "concept_mitigation_strategies", "type": "V_concept", "name": "Mitigation Strategies", "properties": {"description": "Techniques used to reduce or eliminate cyber sickness, including developer and user perspectives.", "keywords": ["mitigation", "strategies", "reduction", "elimination", "cyber"], "source_lectures": ["lecture_106103842_w2_l12"]}}
{"id": "concept_symmetric_mask", "type": "V_concept", "name": "Symmetric Mask", "properties": {"description": "A technique used to adjust the field of view by occluding the periphery in reaction to translational and angular velocity.", "keywords": ["symmetric", "mask", "field", "view", "adjustment"], "source_lectures": ["lecture_106103842_w2_l12"]}}
{"id": "concept_asymmetric_mask", "type": "V_concept", "name": "Asymmetric Mask", "properties": {"description": "A technique used to adjust the field of view by obscuring the periphery with higher optical flow during virtual locomotion.", "keywords": ["asymmetric", "mask", "field", "view", "adjustment"], "source_lectures": ["lecture_106103842_w2_l12"]}}
{"id": "concept_ground_visible_restrictor", "type": "V_concept", "name": "Ground Visible Restrictor", "properties": {"description": "A technique used to adjust the field of view by keeping the ground plane visible during movement.", "keywords": ["ground", "visible", "restructor", "field", "view"], "source_lectures": ["lecture_106103842_w2_l12"]}}
{"id": "concept_sparse_peripheral_display", "type": "V_concept", "name": "Sparse Peripheral Display", "properties": {"description": "A hardware-level alteration used to reduce cyber sickness by expanding the HMD periphery with a colorful LED matrix.", "keywords": ["sparse", "peripheral", "display", "hardware", "reduction"], "source_lectures": ["lecture_106103842_w2_l12"]}}
{"id": "concept_locomotion_techniques", "type": "V_concept", "name": "Locomotion Techniques", "properties": {"description": "Methods used to move within a virtual environment, which can be modified or manipulated to reduce cyber sickness.", "keywords": ["locomotion", "techniques", "movement", "virtual", "environment"], "source_lectures": ["lecture_106103842_w2_l12"]}}
{"id": "concept_teleportation", "type": "V_concept", "name": "Teleportation", "properties": {"description": "A locomotion technique used to move within a virtual environment by instantly transporting the user from one location to another.", "keywords": ["teleportation", "locomotion", "technique", "virtual", "environment"], "source_lectures": ["lecture_106103842_w2_l12"]}}
{"id": "concept_viewpoint_snapping", "type": "V_concept", "name": "Viewpoint Snapping", "properties": {"description": "A technique used to render moving pictures in discrete chunks during rotation, reducing cyber sickness.", "keywords": ["viewpoint", "snapping", "rendering", "discrete", "chunks"], "source_lectures": ["lecture_106103842_w2_l12"]}}
{"id": "concept_virtual_reality_system", "type": "V_concept", "name": "Virtual Reality System", "properties": {"description": "A system that combines hardware and software to create an immersive experience for the user.", "keywords": ["virtual", "reality", "system", "hardware", "software"], "source_lectures": ["lecture_106103842_w2_l13"]}}
{"id": "concept_vr_hardware", "type": "V_concept", "name": "VR Hardware", "properties": {"description": "The physical components used to create a virtual reality experience, including displays, sensors, and computers.", "keywords": ["vr", "hardware", "display", "sensor", "computer"], "source_lectures": ["lecture_106103842_w2_l13"]}}
{"id": "concept_head_tracking", "type": "V_concept", "name": "Head Tracking", "properties": {"description": "The process of monitoring the movement of a user's head to adjust the virtual environment accordingly.", "keywords": ["head", "tracking", "movement", "virtual", "environment"], "source_lectures": ["lecture_106103842_w2_l13"]}}
{"id": "concept_hand_input_devices", "type": "V_concept", "name": "Hand Input Devices", "properties": {"description": "Devices used to capture input from a user's hands, such as controllers, gloves, and bare hand tracking systems.", "keywords": ["hand", "input", "device", "controller", "glove"], "source_lectures": ["lecture_106103842_w2_l13"]}}
{"id": "concept_non_hand_input_devices", "type": "V_concept", "name": "Non-Hand Input Devices", "properties": {"description": "Devices used to capture input from parts of the body other than the hands, such as head tracking and eye tracking systems.", "keywords": ["non-hand", "input", "device", "head", "eye"], "source_lectures": ["lecture_106103842_w2_l13"]}}
{"id": "concept_data_gloves", "type": "V_concept", "name": "Data Gloves", "properties": {"description": "A type of hand input device that uses sensors to track hand movements and gestures.", "keywords": ["data", "glove", "hand", "movement", "gesture"], "source_lectures": ["lecture_106103842_w2_l13"]}}
{"id": "concept_bend_sensing_gloves", "type": "V_concept", "name": "Bend Sensing Gloves", "properties": {"description": "A type of data glove that uses sensors to track hand postures and gestures by detecting bends in the fingers.", "keywords": ["bend", "sensing", "glove", "hand", "posture"], "source_lectures": ["lecture_106103842_w2_l13"]}}
{"id": "concept_pinch_gloves", "type": "V_concept", "name": "Pinch Gloves", "properties": {"description": "A type of data glove that uses sensors to track hand movements by detecting pinching gestures.", "keywords": ["pinch", "glove", "hand", "movement", "gesture"], "source_lectures": ["lecture_106103842_w2_l13"]}}
{"id": "concept_eye_tracking", "type": "V_concept", "name": "Eye Tracking", "properties": {"description": "The process of monitoring the movement of a user's eyes to infer their intentions and adjust the virtual environment accordingly.", "keywords": ["movement", "tracking", "virtual", "technique", "intention", "eye", "gaze", "analysis", "user", "measurement", "optical"], "source_lectures": ["lecture_106103842_w2_l13", "lecture_106103842_w3_l18", "lecture_106103220_w6_l37"]}}
{"id": "concept_midas_touch_problem", "type": "V_concept", "name": "Midas Touch Problem", "properties": {"description": "A problem that occurs when an eye tracking system incorrectly interprets a user's gaze as an intentional action.", "keywords": ["midas", "touch", "problem", "eye", "tracking"], "source_lectures": ["lecture_106103842_w2_l13"]}}
{"id": "concept_multimodal_input", "type": "V_concept", "name": "Multimodal Input", "properties": {"description": "The use of multiple input methods, such as hand tracking and eye tracking, to interact with a virtual environment.", "keywords": ["multimodal", "input", "hand", "eye", "tracking"], "source_lectures": ["lecture_106103842_w2_l13"]}}
{"id": "concept_full_body_tracking", "type": "V_concept", "name": "Full Body Tracking", "properties": {"description": "A technology used to track the movement of a person's entire body in a virtual environment.", "keywords": ["full", "body", "tracking", "motion", "capture"], "source_lectures": ["lecture_106103842_w2_l14"]}}
{"id": "concept_motion_capture_suit", "type": "V_concept", "name": "Motion Capture Suit", "properties": {"description": "A wearable device that uses sensors to capture the movement of a person's body.", "keywords": ["motion", "capture", "suit", "mocap", "sensor"], "source_lectures": ["lecture_106103842_w2_l14"]}}
{"id": "concept_camera_based_tracking", "type": "V_concept", "name": "Camera Based Tracking", "properties": {"description": "A method of tracking movement using cameras and fiducial markers.", "keywords": ["camera", "tracking", "fiducial", "marker", "motion"], "source_lectures": ["lecture_106103842_w2_l14"]}}
{"id": "concept_graphics_processing_unit", "type": "V_concept", "name": "Graphics Processing Unit", "properties": {"description": "A computer chip that is designed to handle graphics and compute tasks.", "keywords": ["graphics", "processing", "unit", "gpu", "compute"], "source_lectures": ["lecture_106103842_w2_l14"]}}
{"id": "concept_multi_core_processor", "type": "V_concept", "name": "Multi-Core Processor", "properties": {"description": "A type of computer processor that has multiple cores to increase processing power.", "keywords": ["compute", "processor", "chip", "parallel", "cpu", "multi", "core"], "source_lectures": ["lecture_106103842_w2_l14", "lecture_106103359_w1_l2"]}}
{"id": "concept_haptic_rendering", "type": "V_concept", "name": "Haptic Rendering", "properties": {"description": "A technology that simulates the sense of touch in a virtual environment.", "keywords": ["haptic", "rendering", "touch", "virtual", "sensation"], "source_lectures": ["lecture_106103842_w2_l14"]}}
{"id": "concept_active_haptics", "type": "V_concept", "name": "Active Haptics", "properties": {"description": "A type of haptic technology that uses physical feedback controlled by a computer.", "keywords": ["active", "haptics", "physical", "feedback", "computer"], "source_lectures": ["lecture_106103842_w2_l14"]}}
{"id": "concept_passive_haptics", "type": "V_concept", "name": "Passive Haptics", "properties": {"description": "A type of haptic technology that uses static physical objects to simulate touch.", "keywords": ["passive", "haptics", "static", "physical", "object"], "source_lectures": ["lecture_106103842_w2_l14"]}}
{"id": "concept_motion_platform", "type": "V_concept", "name": "Motion Platform", "properties": {"description": "A device that simulates physical motion and gravity in a virtual environment.", "keywords": ["motion", "platform", "physical", "gravity", "virtual"], "source_lectures": ["lecture_106103842_w2_l14"]}}
{"id": "concept_treadmill", "type": "V_concept", "name": "Treadmill", "properties": {"description": "A device that simulates walking or running in a virtual environment.", "keywords": ["treadmill", "walking", "running", "virtual", "motion"], "source_lectures": ["lecture_106103842_w2_l14"]}}
{"id": "concept_world_fixed_display", "type": "V_concept", "name": "World Fixed Display", "properties": {"description": "A type of display that renders graphics onto a fixed surface.", "keywords": ["world", "fixed", "display", "graphics", "surface"], "source_lectures": ["lecture_106103842_w2_l14"]}}
{"id": "concept_regular_display", "type": "V_concept", "name": "Regular Display", "properties": {"description": "A type of display that is used for non-immersive virtual reality experiences.", "keywords": ["regular", "display", "non", "immersive", "virtual"], "source_lectures": ["lecture_106103842_w2_l14"]}}
{"id": "concept_audio_output", "type": "V_concept", "name": "Audio Output", "properties": {"description": "A type of output that simulates sound in a virtual environment.", "keywords": ["audio", "output", "sound", "virtual", "simulation"], "source_lectures": ["lecture_106103842_w2_l14"]}}
{"id": "concept_inertial_measurement_unit", "type": "V_concept", "name": "Inertial Measurement Unit", "properties": {"description": "A sensor that measures the acceleration and orientation of an object.", "keywords": ["inertial", "sensors", "imu", "acceleration", "measurement", "sensor", "unit"], "source_lectures": ["lecture_106103842_w2_l14", "lecture_106103842_w3_l17"]}}
{"id": "concept_fiducial_marker", "type": "V_concept", "name": "Fiducial Marker", "properties": {"description": "A visual marker that is used to track movement in a virtual environment.", "keywords": ["fiducial", "marker", "visual", "tracking", "movement"], "source_lectures": ["lecture_106103842_w2_l14"]}}
{"id": "concept_augmented_reality_hardware", "type": "V_concept", "name": "Augmented Reality Hardware", "properties": {"description": "Refers to the physical devices and equipment used to create and experience augmented reality environments.", "keywords": ["augmented", "reality", "hardware", "ar", "devices"], "source_lectures": ["lecture_106103842_w3_l15"]}}
{"id": "concept_smart_glasses", "type": "V_concept", "name": "Smart Glasses", "properties": {"description": "A type of wearable device that resembles regular eyeglasses but has the ability to display digital information and interact with the user.", "keywords": ["smart", "glasses", "wearable", "ar", "display"], "source_lectures": ["lecture_106103842_w3_l15"]}}
{"id": "concept_handheld_devices", "type": "V_concept", "name": "Handheld Devices", "properties": {"description": "Portable devices such as smartphones and tablets that can be used to experience augmented reality environments.", "keywords": ["handheld", "devices", "smartphones", "tablets", "ar"], "source_lectures": ["lecture_106103842_w3_l15"]}}
{"id": "concept_projection_based_systems", "type": "V_concept", "name": "Projection-Based Systems", "properties": {"description": "Augmented reality systems that use projectors to display digital information onto physical objects or surfaces.", "keywords": ["projection", "based", "systems", "ar", "projectors"], "source_lectures": ["lecture_106103842_w3_l15"]}}
{"id": "concept_special_augmented_reality_devices", "type": "V_concept", "name": "Special Augmented Reality Devices", "properties": {"description": "Devices that use advanced technologies such as projectors, sensors, and displays to create immersive augmented reality experiences.", "keywords": ["special", "augmented", "reality", "devices", "ar"], "source_lectures": ["lecture_106103842_w3_l15"]}}
{"id": "concept_head_up_display", "type": "V_concept", "name": "Head-Up Display", "properties": {"description": "A transparent display that projects information onto a surface, often used in vehicles and aircraft.", "keywords": ["head", "up", "display", "hud", "transparent"], "source_lectures": ["lecture_106103842_w3_l15"]}}
{"id": "concept_ar_contact_lenses", "type": "V_concept", "name": "AR Contact Lenses", "properties": {"description": "A type of wearable device that resembles regular contact lenses but has the ability to display digital information and interact with the user.", "keywords": ["ar", "contact", "lenses", "wearable", "display"], "source_lectures": ["lecture_106103842_w3_l15"]}}
{"id": "concept_interactive_projectors", "type": "V_concept", "name": "Interactive Projectors", "properties": {"description": "Projectors that can detect user input and interact with the user, often used in augmented reality applications.", "keywords": ["interactive", "projectors", "ar", "input", "interaction"], "source_lectures": ["lecture_106103842_w3_l15"]}}
{"id": "concept_ar_sandboxes", "type": "V_concept", "name": "AR Sandboxes", "properties": {"description": "A type of augmented reality system that uses a projector and sensors to create an interactive environment, often used in education and training.", "keywords": ["ar", "sandboxes", "projector", "sensors", "interactive"], "source_lectures": ["lecture_106103842_w3_l15"]}}
{"id": "concept_projection_mapping", "type": "V_concept", "name": "Projection Mapping", "properties": {"description": "A technique used to project digital information onto physical objects or surfaces, often used in augmented reality applications.", "keywords": ["projection", "mapping", "ar", "digital", "physical"], "source_lectures": ["lecture_106103842_w3_l15"]}}
{"id": "concept_inside_out_tracking", "type": "V_concept", "name": "Inside Out Tracking", "properties": {"description": "A tracking method where the sensors or cameras are located within the device itself, such as a head-mounted display.", "keywords": ["inside-out", "out", "tracking", "sensors", "device", "cameras", "inside"], "source_lectures": ["lecture_106103842_w3_l16", "lecture_106103842_w3_l17"]}}
{"id": "concept_outside_in_tracking", "type": "V_concept", "name": "Outside In Tracking", "properties": {"description": "A tracking method where the sensors or cameras are external to the device, such as markers or cameras placed in the environment.", "keywords": ["in", "environment", "tracking", "sensors", "cameras", "outside", "outside-in"], "source_lectures": ["lecture_106103842_w3_l16", "lecture_106103842_w3_l17"]}}
{"id": "concept_calibration", "type": "V_concept", "name": "Calibration", "properties": {"description": "The process of adjusting the output of sensors to match the real-world values as closely as possible.", "keywords": ["sensors", "adjustment", "real-world", "output", "ideal", "calibration"], "source_lectures": ["lecture_106103842_w3_l16", "lecture_106103842_w3_l17"]}}
{"id": "concept_registration", "type": "V_concept", "name": "Registration", "properties": {"description": "The process of determining the initial position and orientation of a sensor or tracker.", "keywords": ["pose", "initial", "orientation", "registration", "sensor", "position"], "source_lectures": ["lecture_106103842_w3_l16", "lecture_106103842_w3_l17"]}}
{"id": "concept_integration", "type": "V_concept", "name": "Integration", "properties": {"description": "The process of combining sensory measurements from multiple sources to estimate the position, orientation, or movement of an object or user.", "keywords": ["integration", "measurements", "orientation", "sensory", "data", "sensor", "position"], "source_lectures": ["lecture_106103842_w3_l16", "lecture_106103842_w3_l17"]}}
{"id": "concept_drift_correction", "type": "V_concept", "name": "Drift Correction", "properties": {"description": "The process of compensating for errors in estimation between the tracked position or orientation and the actual real-world values.", "keywords": ["correction", "errors", "estimation", "drift", "real-world"], "source_lectures": ["lecture_106103842_w3_l16", "lecture_106103842_w3_l17"]}}
{"id": "concept_sense_organ_tracking", "type": "V_concept", "name": "Sense Organ Tracking", "properties": {"description": "The process of tracking the position, orientation, and movement of a user's sense organs, such as eyes or ears.", "keywords": ["sense", "organ", "tracking", "eyes", "ears"], "source_lectures": ["lecture_106103842_w3_l16"]}}
{"id": "concept_body_part_tracking", "type": "V_concept", "name": "Body Part Tracking", "properties": {"description": "The process of tracking the position, orientation, and movement of a user's body parts, such as hands or fingers.", "keywords": ["body", "part", "tracking", "hands", "fingers"], "source_lectures": ["lecture_106103842_w3_l16"]}}
{"id": "concept_environment_tracking", "type": "V_concept", "name": "Environment Tracking", "properties": {"description": "The process of tracking the position, orientation, and movement of objects or features in the environment.", "keywords": ["environment", "tracking", "objects", "features"], "source_lectures": ["lecture_106103842_w3_l16"]}}
{"id": "concept_gyroscope", "type": "V_concept", "name": "Gyroscope", "properties": {"description": "A sensor that captures the angular velocity of an object.", "keywords": ["gyroscope", "angular", "velocity", "sensor"], "source_lectures": ["lecture_106103842_w3_l17"]}}
{"id": "concept_accelerometer", "type": "V_concept", "name": "Accelerometer", "properties": {"description": "A sensor that captures the linear acceleration of an object along multiple axes.", "keywords": ["accelerometer", "linear", "acceleration", "sensor"], "source_lectures": ["lecture_106103842_w3_l17"]}}
{"id": "concept_magnetometer", "type": "V_concept", "name": "Magnetometer", "properties": {"description": "A sensor that captures the magnetic field strength along multiple axes.", "keywords": ["magnetometer", "magnetic", "field", "sensor"], "source_lectures": ["lecture_106103842_w3_l17"]}}
{"id": "concept_linear_least_squares", "type": "V_concept", "name": "Linear Least Squares", "properties": {"description": "A mathematical technique used to optimize the relationship between measured and actual values.", "keywords": ["linear", "least", "squares", "optimization"], "source_lectures": ["lecture_106103842_w3_l17"]}}
{"id": "concept_gain_parameter", "type": "V_concept", "name": "Gain Parameter", "properties": {"description": "A normalized value used to combine sensor data from multiple sources.", "keywords": ["gain", "parameter", "sensor", "data"], "source_lectures": ["lecture_106103842_w3_l17"]}}
{"id": "concept_electromechanical_trackers", "type": "V_concept", "name": "Electromechanical Trackers", "properties": {"description": "Trackers that use a serial or parallel kinematic structure composed of links with sensors to track movement.", "keywords": ["electromechanical", "trackers", "kinematic", "sensors"], "source_lectures": ["lecture_106103842_w3_l18"]}}
{"id": "concept_electromagnetic_trackers", "type": "V_concept", "name": "Electromagnetic Trackers", "properties": {"description": "Trackers that use a magnetic field to determine the position of a moving receiver element.", "keywords": ["electromagnetic", "trackers", "magnetic", "field"], "source_lectures": ["lecture_106103842_w3_l18"]}}
{"id": "concept_acoustic_tracking", "type": "V_concept", "name": "Acoustic Tracking", "properties": {"description": "A tracking method that uses ultrasonic signals to determine the position of an object.", "keywords": ["acoustic", "tracking", "ultrasonic", "signals"], "source_lectures": ["lecture_106103842_w3_l18"]}}
{"id": "concept_vision_based_tracking", "type": "V_concept", "name": "Vision Based Tracking", "properties": {"description": "A tracking method that uses optical sensors, such as cameras, to determine the pose of an object.", "keywords": ["vision", "based", "tracking", "optical", "sensors"], "source_lectures": ["lecture_106103842_w3_l18"]}}
{"id": "concept_inertial_trackers", "type": "V_concept", "name": "Inertial Trackers", "properties": {"description": "Self-contained sensors that measure the rate of change in object orientation, translation velocity, or acceleration.", "keywords": ["inertial", "trackers", "sensors", "orientation", "velocity"], "source_lectures": ["lecture_106103842_w3_l18"]}}
{"id": "concept_infrared_tracking", "type": "V_concept", "name": "Infrared Tracking", "properties": {"description": "A tracking method that uses infrared sensors to detect targets that emit or reflect light.", "keywords": ["infrared", "tracking", "sensors", "targets"], "source_lectures": ["lecture_106103842_w3_l18"]}}
{"id": "concept_fiducial_tracking", "type": "V_concept", "name": "Fiducial Tracking", "properties": {"description": "A tracking method that uses artificial landmarks added to the environment to aid in registration and tracking.", "keywords": ["fiducial", "tracking", "landmarks", "registration"], "source_lectures": ["lecture_106103842_w3_l18"]}}
{"id": "concept_natural_feature_tracking", "type": "V_concept", "name": "Natural Feature Tracking", "properties": {"description": "A tracking method that uses features present in the natural environment to register camera pose in real-time.", "keywords": ["natural", "feature", "tracking", "environment", "camera"], "source_lectures": ["lecture_106103842_w3_l18"]}}
{"id": "concept_model_based_tracking", "type": "V_concept", "name": "Model Based Tracking", "properties": {"description": "A tracking method that uses techniques such as SLAM to create and update a map of the environment while localizing positions within it.", "keywords": ["model", "based", "tracking", "SLAM", "environment"], "source_lectures": ["lecture_106103842_w3_l18"]}}
{"id": "concept_3d_structure_tracking", "type": "V_concept", "name": "3D Structure Tracking", "properties": {"description": "A tracking method that uses sensors to detect 3D structure information from the environment.", "keywords": ["3D", "structure", "tracking", "sensors", "environment"], "source_lectures": ["lecture_106103842_w3_l18"]}}
{"id": "concept_slam_technique", "type": "V_concept", "name": "SLAM Technique", "properties": {"description": "A technique that allows simultaneous localization and mapping of an environment.", "keywords": ["SLAM", "technique", "localization", "mapping", "environment"], "source_lectures": ["lecture_106103842_w3_l18"]}}
{"id": "concept_ptam_technique", "type": "V_concept", "name": "PTAM Technique", "properties": {"description": "A technique that allows parallel tracking and mapping of an environment, specifically designed for augmented reality.", "keywords": ["PTAM", "technique", "tracking", "mapping", "augmented reality"], "source_lectures": ["lecture_106103842_w3_l18"]}}
{"id": "concept_gps_tracking", "type": "V_concept", "name": "GPS Tracking", "properties": {"description": "A tracking method that uses GPS signals to determine the position of an object, particularly useful in outdoor environments.", "keywords": ["GPS", "tracking", "signals", "position", "outdoor"], "source_lectures": ["lecture_106103842_w3_l18"]}}
{"id": "concept_rtk_technology", "type": "V_concept", "name": "RTK Technology", "properties": {"description": "A technology that uses GPS signals' carrier wave for measurement to improve detection accuracy.", "keywords": ["RTK", "technology", "GPS", "signals", "accuracy"], "source_lectures": ["lecture_106103842_w3_l18"]}}
{"id": "concept_motion_capture", "type": "V_concept", "name": "Motion Capture", "properties": {"description": "A technique of digitally recording movements of real objects, usually humans, using various tracking methods.", "keywords": ["motion", "capture", "tracking", "movements", "humans"], "source_lectures": ["lecture_106103842_w3_l18"]}}
{"id": "concept_hybrid_trackers", "type": "V_concept", "name": "Hybrid Trackers", "properties": {"description": "Trackers that combine multiple basic tracking systems or approaches to achieve better performance.", "keywords": ["hybrid", "trackers", "tracking", "systems", "performance"], "source_lectures": ["lecture_106103842_w3_l18"]}}
{"id": "concept_virtual_reality_software", "type": "V_concept", "name": "Virtual Reality Software", "properties": {"description": "Software that drives virtual reality hardware to generate immersive experiences utilizing user senses.", "keywords": ["vr", "software", "immersive", "experience", "hardware"], "source_lectures": ["lecture_106103842_w3_l19"]}}
{"id": "concept_virtual_world_generation", "type": "V_concept", "name": "Virtual World Generation", "properties": {"description": "The process of creating a virtual world that appears real to the user.", "keywords": ["virtual", "world", "generation", "vwg", "reality"], "source_lectures": ["lecture_106103842_w3_l19"]}}
{"id": "concept_virtual_world_generator_abstraction", "type": "V_concept", "name": "Virtual World Generator Abstraction", "properties": {"description": "A black box abstraction that receives input from low-level systems and maintains internal reality.", "keywords": ["vwg", "abstraction", "black", "box", "reality"], "source_lectures": ["lecture_106103842_w3_l19"]}}
{"id": "concept_matched_motion", "type": "V_concept", "name": "Matched Motion", "properties": {"description": "The correspondence between user motions in the real and virtual world.", "keywords": ["matched", "motion", "real", "virtual", "world"], "source_lectures": ["lecture_106103842_w3_l19"]}}
{"id": "concept_matched_zone", "type": "V_concept", "name": "Matched Zone", "properties": {"description": "A region where real and virtual worlds perfectly align, allowing user movement translation.", "keywords": ["matched", "zone", "real", "virtual", "world"], "source_lectures": ["lecture_106103842_w3_l19"]}}
{"id": "concept_texture_mapping", "type": "V_concept", "name": "Texture Mapping", "properties": {"description": "A computer graphics operation that maps camera images onto synthetic objects in a virtual world.", "keywords": ["texture", "mapping", "computer", "graphics", "virtual"], "source_lectures": ["lecture_106103842_w3_l19"]}}
{"id": "concept_simultaneous_localization_and_mapping", "type": "V_concept", "name": "Simultaneous Localization and Mapping", "properties": {"description": "A technique used to capture and map real-world environments for virtual reality applications.", "keywords": ["slam", "localization", "mapping", "real", "world"], "source_lectures": ["lecture_106103842_w3_l19"]}}
{"id": "concept_user_locomotion", "type": "V_concept", "name": "User Locomotion", "properties": {"description": "The ability of a user to move within a virtual world, often using controllers or other input devices.", "keywords": ["user", "locomotion", "virtual", "world", "movement"], "source_lectures": ["lecture_106103842_w3_l19"]}}
{"id": "concept_software_development_kit", "type": "V_concept", "name": "Software Development Kit", "properties": {"description": "A set of tools and libraries that enable developers to build applications for specific platforms.", "keywords": ["sdk", "software", "development", "kit", "platform"], "source_lectures": ["lecture_106103842_w3_l19"]}}
{"id": "concept_game_engine", "type": "V_concept", "name": "Game Engine", "properties": {"description": "A software framework that enables developers to build games and other interactive applications.", "keywords": ["development", "interactive", "framework", "engine", "xr", "software", "game"], "source_lectures": ["lecture_106103842_w3_l19", "lecture_106103842_w3_l20"]}}
{"id": "concept_virtual_reality_experience", "type": "V_concept", "name": "Virtual Reality Experience", "properties": {"description": "An immersive and interactive experience that simulates a virtual world or environment.", "keywords": ["vr", "experience", "immersive", "interactive", "virtual"], "source_lectures": ["lecture_106103842_w3_l19"]}}
{"id": "concept_virtual_environment", "type": "V_concept", "name": "Virtual Environment", "properties": {"description": "A simulated environment that is generated by a computer and presented to a user.", "keywords": ["virtual", "environment", "simulated", "computer", "user"], "source_lectures": ["lecture_106103842_w3_l19"]}}
{"id": "concept_stereoscopic_view", "type": "V_concept", "name": "Stereoscopic View", "properties": {"description": "A technique used to create the illusion of a three-dimensional image by presenting a different image to each eye.", "keywords": ["stereoscopic", "view", "3d", "image", "illusion"], "source_lectures": ["lecture_106103842_w3_l19"]}}
{"id": "concept_rendering", "type": "V_concept", "name": "Rendering", "properties": {"description": "The process of generating an image or video from a virtual environment or scene.", "keywords": ["rendering", "image", "video", "virtual", "environment"], "source_lectures": ["lecture_106103842_w3_l19"]}}
{"id": "concept_virtual_world_generator", "type": "V_concept", "name": "Virtual World Generator", "properties": {"description": "A software component that generates a virtual world, taking input from devices and producing output to stimulate sensory organs.", "keywords": ["world", "generator", "virtual", "software", "vr"], "source_lectures": ["lecture_106103842_w3_l20", "lecture_106103842_w3_l21"]}}
{"id": "concept_physics_support", "type": "V_concept", "name": "Physics Support", "properties": {"description": "A component of a virtual world generator that simulates the laws of physics, including collisions and motion.", "keywords": ["physics", "support", "simulation", "collision", "motion"], "source_lectures": ["lecture_106103842_w3_l20"]}}
{"id": "concept_collision_detection", "type": "V_concept", "name": "Collision Detection", "properties": {"description": "An algorithm that determines whether two or more objects are intersecting in a virtual world.", "keywords": ["collision", "detection", "algorithm", "intersection", "objects"], "source_lectures": ["lecture_106103842_w3_l20"]}}
{"id": "concept_rendering_engine", "type": "V_concept", "name": "Rendering Engine", "properties": {"description": "A component of a game engine that generates animated 3D graphics using various rendering techniques.", "keywords": ["rendering", "engine", "graphics", "3d", "animation"], "source_lectures": ["lecture_106103842_w3_l20"]}}
{"id": "concept_audio_engine", "type": "V_concept", "name": "Audio Engine", "properties": {"description": "A component of a game engine that handles audio-related tasks, such as loading, modifying, and generating sound.", "keywords": ["audio", "engine", "sound", "loading", "modification"], "source_lectures": ["lecture_106103842_w3_l20"]}}
{"id": "concept_physics_engine", "type": "V_concept", "name": "Physics Engine", "properties": {"description": "A component of a game engine that simulates physical forces and collisions in a virtual world.", "keywords": ["physics", "engine", "simulation", "forces", "collisions"], "source_lectures": ["lecture_106103842_w3_l20"]}}
{"id": "concept_software_development_kit_sdk", "type": "V_concept", "name": "Software Development Kit (SDK)", "properties": {"description": "A collection of software development tools for building applications on a specific platform or hardware.", "keywords": ["sdk", "software", "development", "kit", "platform"], "source_lectures": ["lecture_106103842_w3_l20"]}}
{"id": "concept_native_deployment", "type": "V_concept", "name": "Native Deployment", "properties": {"description": "The process of deploying an application on a specific platform or hardware using an SDK.", "keywords": ["native", "deployment", "sdk", "platform", "hardware"], "source_lectures": ["lecture_106103842_w3_l20"]}}
{"id": "concept_web_deployment", "type": "V_concept", "name": "Web Deployment", "properties": {"description": "The process of deploying an application over the web, accessible through a browser or other web-based interface.", "keywords": ["web", "deployment", "browser", "interface", "online"], "source_lectures": ["lecture_106103842_w3_l20"]}}
{"id": "concept_cloud_hosting", "type": "V_concept", "name": "Cloud Hosting", "properties": {"description": "A service that provides remote hosting and rendering of applications over a network.", "keywords": ["cloud", "hosting", "remote", "rendering", "network"], "source_lectures": ["lecture_106103842_w3_l20"]}}
{"id": "concept_webxr", "type": "V_concept", "name": "WebXR", "properties": {"description": "A set of APIs and technologies that enable the creation of immersive web experiences, including VR and AR.", "keywords": ["webxr", "api", "immersive", "vr", "ar"], "source_lectures": ["lecture_106103842_w3_l20"]}}
{"id": "concept_unity_3d", "type": "V_concept", "name": "Unity 3D", "properties": {"description": "A popular game engine and development environment for building 2D and 3D applications, including VR and AR experiences.", "keywords": ["unity", "3d", "game", "engine", "development"], "source_lectures": ["lecture_106103842_w3_l20"]}}
{"id": "concept_unreal_engine", "type": "V_concept", "name": "Unreal Engine", "properties": {"description": "A game engine and development environment for building high-performance, visually stunning applications, including VR and AR experiences.", "keywords": ["unreal", "engine", "game", "development", "high-performance"], "source_lectures": ["lecture_106103842_w3_l20"]}}
{"id": "concept_augmented_reality_software", "type": "V_concept", "name": "Augmented Reality Software", "properties": {"description": "Software used to create and develop augmented reality applications", "keywords": ["augmented", "reality", "software", "ar"], "source_lectures": ["lecture_106103842_w3_l21"]}}
{"id": "concept_low_level_software_libraries", "type": "V_concept", "name": "Low-Level Software Libraries", "properties": {"description": "Libraries that provide core functionality for building augmented reality applications", "keywords": ["low-level", "libraries", "ar", "software"], "source_lectures": ["lecture_106103842_w3_l21"]}}
{"id": "concept_scene_graph_management", "type": "V_concept", "name": "Scene Graph Management", "properties": {"description": "A technique for managing complex graphics scenes in augmented reality applications", "keywords": ["scene", "graph", "management", "graphics"], "source_lectures": ["lecture_106103842_w3_l21"]}}
{"id": "concept_openscenegraph", "type": "V_concept", "name": "OpenSceneGraph", "properties": {"description": "An open-source library for scene graph management", "keywords": ["openscenegraph", "library", "scene", "graph"], "source_lectures": ["lecture_106103842_w3_l21"]}}
{"id": "concept_rapid_prototyping_tools", "type": "V_concept", "name": "Rapid Prototyping Tools", "properties": {"description": "Tools used to quickly create and test augmented reality prototypes", "keywords": ["rapid", "prototyping", "tools", "ar"], "source_lectures": ["lecture_106103842_w3_l21"]}}
{"id": "concept_fl_toolkit", "type": "V_concept", "name": "FL Toolkit", "properties": {"description": "A version of the AR Toolkit ported to Flash", "keywords": ["fl", "toolkit", "ar", "flash"], "source_lectures": ["lecture_106103842_w3_l21"]}}
{"id": "concept_fl_manager", "type": "V_concept", "name": "FL Manager", "properties": {"description": "A framework that combines AR tracking and graphics libraries for prototyping", "keywords": ["fl", "manager", "ar", "prototyping"], "source_lectures": ["lecture_106103842_w3_l21"]}}
{"id": "concept_computer_vision_based_tracking", "type": "V_concept", "name": "Computer Vision Based Tracking", "properties": {"description": "A technique for tracking objects in augmented reality applications using computer vision", "keywords": ["computer", "vision", "tracking", "ar"], "source_lectures": ["lecture_106103842_w3_l21"]}}
{"id": "concept_skill_based_categorization", "type": "V_concept", "name": "Skill-Based Categorization", "properties": {"description": "A method of categorizing augmented reality software based on the level of programming skill required", "keywords": ["skill-based", "categorization", "ar", "software"], "source_lectures": ["lecture_106103842_w3_l21"]}}
{"id": "concept_platform_based_categorization", "type": "V_concept", "name": "Platform-Based Categorization", "properties": {"description": "A method of categorizing augmented reality software based on the target platform", "keywords": ["platform-based", "categorization", "ar", "software"], "source_lectures": ["lecture_106103842_w3_l21"]}}
{"id": "concept_technology_based_categorization", "type": "V_concept", "name": "Technology-Based Categorization", "properties": {"description": "A method of categorizing augmented reality software based on the underlying technology", "keywords": ["technology-based", "categorization", "ar", "software"], "source_lectures": ["lecture_106103842_w3_l21"]}}
{"id": "concept_self_supervised_learning", "type": "V_concept", "name": "Self-Supervised Learning", "properties": {"description": "An unsupervised approach where models derive supervisory signals from inherent data properties.", "keywords": ["self-supervised", "pretext task", "representation", "unsupervised"], "source_lectures": ["lecture_106103843_w1_l1"]}}
{"id": "concept_pretext_task", "type": "V_concept", "name": "Pretext Task", "properties": {"description": "A surrogate task used in self-supervised learning to generate training signals from unlabeled data.", "keywords": ["pretext task", "self-supervised", "signal", "training"], "source_lectures": ["lecture_106103843_w1_l1"]}}
{"id": "concept_linear_separability", "type": "V_concept", "name": "Linear Separability", "properties": {"description": "A property where classes can be divided by a straight line in feature space.", "keywords": ["linear separability", "classification", "separator", "geometry"], "source_lectures": ["lecture_106103843_w1_l1"]}}
{"id": "concept_downstream_task", "type": "V_concept", "name": "Downstream Task", "properties": {"description": "The target application task enhanced by pre-trained models or learned representations.", "keywords": ["downstream task", "application", "fine-tuning", "transfer"], "source_lectures": ["lecture_106103843_w1_l1"]}}
{"id": "concept_agent", "type": "V_concept", "name": "Agent", "properties": {"description": "An entity that makes decisions by interacting with an environment in reinforcement learning.", "keywords": ["agent", "reinforcement", "decision", "interaction"], "source_lectures": ["lecture_106103843_w1_l1"]}}
{"id": "concept_reward_signal", "type": "V_concept", "name": "Reward Signal", "properties": {"description": "Feedback indicating the quality of an action taken by an agent in reinforcement learning.", "keywords": ["reward", "feedback", "reinforcement", "action"], "source_lectures": ["lecture_106103843_w1_l1"]}}
{"id": "concept_policy", "type": "V_concept", "name": "Policy", "properties": {"description": "A strategy determining an agent's actions based on states in reinforcement learning.", "keywords": ["policy", "strategy", "action", "reinforcement"], "source_lectures": ["lecture_106103843_w1_l1"]}}
{"id": "concept_hubel_and_wiesel_experiment", "type": "V_concept", "name": "Hubel and Wiesel Experiment", "properties": {"description": "A foundational study revealing neuronal responses to primitive visual patterns like lines and edges.", "keywords": ["hubel", "wiesel", "visual cortex", "neuronal response"], "source_lectures": ["lecture_106103843_w1_l1"]}}
{"id": "concept_primary_visual_cortex", "type": "V_concept", "name": "Primary Visual Cortex", "properties": {"description": "The brain region where initial visual processing occurs, responding to basic geometric patterns.", "keywords": ["visual cortex", "brain", "processing", "neurons"], "source_lectures": ["lecture_106103843_w1_l1"]}}
{"id": "concept_label_space", "type": "V_concept", "name": "Label Space", "properties": {"description": "The set of possible values for the target variable in supervised learning.", "keywords": ["label space", "target", "values", "output"], "source_lectures": ["lecture_106103843_w1_l2"]}}
{"id": "concept_training_dataset", "type": "V_concept", "name": "Training Dataset", "properties": {"description": "A collection of labeled input-output pairs used to train machine learning models.", "keywords": ["training data", "dataset", "labeled", "samples"], "source_lectures": ["lecture_106103843_w1_l2"]}}
{"id": "concept_univariate_linear_regression", "type": "V_concept", "name": "Univariate Linear Regression", "properties": {"description": "Linear regression performed with a single input feature variable.", "keywords": ["univariate", "linear regression", "single feature"], "source_lectures": ["lecture_106103843_w1_l2"]}}
{"id": "concept_cost_function", "type": "V_concept", "name": "Cost Function", "properties": {"description": "A function that quantifies the error between predicted values and actual target values.", "keywords": ["cost function", "error", "loss", "optimization"], "source_lectures": ["lecture_106103843_w1_l2"]}}
{"id": "concept_model_parameters", "type": "V_concept", "name": "Model Parameters", "properties": {"description": "Coefficients in a model that are optimized during training to minimize prediction error.", "keywords": ["parameters", "coefficients", "weights", "optimization"], "source_lectures": ["lecture_106103843_w1_l2"]}}
{"id": "concept_squared_error_loss", "type": "V_concept", "name": "Squared Error Loss", "properties": {"description": "An error metric that penalizes larger prediction errors more heavily due to squaring.", "keywords": ["squared error", "loss", "penalty", "differentiable"], "source_lectures": ["lecture_106103843_w1_l2"]}}
{"id": "concept_feature_space", "type": "V_concept", "name": "Feature Space", "properties": {"description": "The multidimensional space defined by the input variables of a machine learning model.", "keywords": ["feature space", "input", "dimensions", "variables"], "source_lectures": ["lecture_106103843_w1_l2"]}}
{"id": "concept_bias_variance_tradeoff", "type": "V_concept", "name": "Bias-Variance Tradeoff", "properties": {"description": "A fundamental concept in machine learning that refers to the tradeoff between the error introduced by simplifying a model (bias) and the error introduced by fitting a model too closely to the training data (variance).", "keywords": ["bias", "variance", "tradeoff", "machine learning"], "source_lectures": ["lecture_106103843_w1_l5"]}}
{"id": "concept_k_fold_cross_validation", "type": "V_concept", "name": "K-Fold Cross Validation", "properties": {"description": "A technique used to evaluate the performance of a machine learning model by dividing the available data into k subsets and training the model on k-1 subsets while testing on the remaining subset.", "keywords": ["k-fold", "cross validation", "machine learning", "evaluation"], "source_lectures": ["lecture_106103843_w1_l5"]}}
{"id": "concept_bias", "type": "V_concept", "name": "Bias", "properties": {"description": "The error introduced by simplifying a model, resulting in a difference between the model's predictions and the true values.", "keywords": ["bias", "error", "machine learning", "simplification"], "source_lectures": ["lecture_106103843_w1_l5"]}}
{"id": "concept_variance", "type": "V_concept", "name": "Variance", "properties": {"description": "The error introduced by fitting a model too closely to the training data, resulting in a difference between the model's predictions and the true values.", "keywords": ["error", "machine learning", "random variable", "mean", "overfitting", "variance", "dispersion"], "source_lectures": ["lecture_106103843_w1_l5", "lecture_106104233_w3_l15"]}}
{"id": "concept_linear_decision_boundary", "type": "V_concept", "name": "Linear Decision Boundary", "properties": {"description": "A boundary that separates the input space into different classes, used by a single layer perceptron to make predictions.", "keywords": ["linear decision boundary", "single layer perceptron", "classification"], "source_lectures": ["lecture_106103843_w1_l6"]}}
{"id": "concept_linearly_separable", "type": "V_concept", "name": "Linearly Separable", "properties": {"description": "A property of a dataset where the classes can be separated by a single hyperplane, making it suitable for a single layer perceptron.", "keywords": ["linearly separable", "dataset", "hyperplane", "single layer perceptron"], "source_lectures": ["lecture_106103843_w1_l6"]}}
{"id": "concept_hidden_layers", "type": "V_concept", "name": "Hidden Layers", "properties": {"description": "Intermediate computational layers in a neural network that transform input data into increasingly abstract and hierarchical features.", "keywords": ["hidden", "layers", "neural", "network", "abstraction"], "source_lectures": ["lecture_106103843_w2_l9"]}}
{"id": "concept_vanishing_gradients", "type": "V_concept", "name": "Vanishing Gradients", "properties": {"description": "A problem in training deep neural networks where the error gradient decays as it is backpropagated through the layers.", "keywords": ["vanishing", "gradients", "deep", "neural", "networks"], "source_lectures": ["lecture_106103843_w2_l9"]}}
{"id": "concept_feature_detection", "type": "V_concept", "name": "Feature Detection", "properties": {"description": "The process of identifying and extracting relevant features from input data, such as images or text.", "keywords": ["feature", "detection", "input", "data", "images"], "source_lectures": ["lecture_106103843_w2_l10"]}}
{"id": "concept_hidden_layer", "type": "V_concept", "name": "Hidden Layer", "properties": {"description": "A layer in a neural network that is not directly connected to the input or output, used for processing and transforming data.", "keywords": ["hidden", "layer", "neural", "network", "processing"], "source_lectures": ["lecture_106103843_w2_l10"]}}
{"id": "concept_pattern_recognition", "type": "V_concept", "name": "Pattern Recognition", "properties": {"description": "The process of identifying and classifying patterns in data, such as images or speech.", "keywords": ["pattern", "recognition", "data", "images", "speech"], "source_lectures": ["lecture_106103843_w2_l10"]}}
{"id": "concept_hierarchical_representation", "type": "V_concept", "name": "Hierarchical Representation", "properties": {"description": "A way of representing data in a hierarchical structure, with early layers representing simple features and later layers representing more complex features.", "keywords": ["hierarchical", "representation", "data", "structure", "features"], "source_lectures": ["lecture_106103843_w2_l10"]}}
{"id": "concept_nonlinearity", "type": "V_concept", "name": "Nonlinearity", "properties": {"description": "A property of a function or system that allows it to model complex relationships between inputs and outputs.", "keywords": ["nonlinearity", "function", "system", "complex", "relationships"], "source_lectures": ["lecture_106103843_w2_l10"]}}
{"id": "concept_weight_sharing", "type": "V_concept", "name": "Weight Sharing", "properties": {"description": "A technique where the same filter weights are applied across different spatial locations to reduce parameters and improve generalization.", "keywords": ["weight sharing", "parameter reduction", "cnn efficiency"], "source_lectures": ["lecture_106103843_w2_l14"]}}
{"id": "concept_local_contrast_normalization", "type": "V_concept", "name": "Local Contrast Normalization", "properties": {"description": "A normalization technique that adjusts pixel intensities to handle illumination variations and enhance feature consistency.", "keywords": ["normalization", "contrast adjustment", "illumination robustness"], "source_lectures": ["lecture_106103843_w2_l14"]}}
{"id": "concept_hierarchical_feature_learning", "type": "V_concept", "name": "Hierarchical Feature Learning", "properties": {"description": "The process where CNN layers progressively extract features at increasing levels of abstraction.", "keywords": ["feature hierarchy", "abstraction levels", "deep learning"], "source_lectures": ["lecture_106103843_w2_l14"]}}
{"id": "concept_filter_kernel", "type": "V_concept", "name": "Filter Kernel", "properties": {"description": "A small matrix used in convolutional layers to detect specific patterns through element-wise multiplication.", "keywords": ["kernel", "filter", "convolution operation"], "source_lectures": ["lecture_106103843_w2_l14"]}}
{"id": "concept_activation_map", "type": "V_concept", "name": "Activation Map", "properties": {"description": "The output feature map generated by applying a filter kernel to input data.", "keywords": ["feature map", "convolution output", "response map"], "source_lectures": ["lecture_106103843_w2_l14"]}}
{"id": "concept_credit_assignment_problem", "type": "V_concept", "name": "Credit Assignment Problem", "properties": {"description": "A challenge in deep neural networks where it is difficult to determine which specific neurons or connections are responsible for the overall error.", "keywords": ["credit", "assignment", "deep", "neural", "networks"], "source_lectures": ["lecture_106103843_w3_l16"]}}
{"id": "concept_rectified_linear_unit_relu", "type": "V_concept", "name": "Rectified Linear Unit (ReLU)", "properties": {"description": "A type of activation function used in neural networks, defined as f(x) = max(0, x).", "keywords": ["relu", "activation", "function", "neural", "networks"], "source_lectures": ["lecture_106103843_w3_l16"]}}
{"id": "concept_leaky_relu", "type": "V_concept", "name": "Leaky ReLU", "properties": {"description": "A variation of the ReLU activation function that introduces a small slope for negative inputs, defined as f(x) = max(alpha*x, x).", "keywords": ["leaky", "relu", "activation", "function", "neural"], "source_lectures": ["lecture_106103843_w3_l16"]}}
{"id": "concept_dying_relu_problem", "type": "V_concept", "name": "Dying ReLU Problem", "properties": {"description": "A problem that occurs when neurons using the ReLU activation function output zero and have zero gradient, causing them to stop contributing to the learning process.", "keywords": ["dying", "relu", "problem", "neural", "networks"], "source_lectures": ["lecture_106103843_w3_l16"]}}
{"id": "concept_residual_connection", "type": "V_concept", "name": "Residual Connection", "properties": {"description": "A technique used in deep neural networks where the input to a layer is added to the output of the layer, which can help to alleviate the vanishing gradient problem.", "keywords": ["residual", "connection", "deep", "neural", "networks"], "source_lectures": ["lecture_106103843_w3_l16"]}}
{"id": "concept_machine_independence", "type": "V_concept", "name": "Machine Independence", "properties": {"description": "The idea that an algorithm's running time should be independent of the machine it is running on", "keywords": ["machine", "independence", "algorithm", "running", "time"], "source_lectures": ["lecture_106105847_w1_l3"]}}
{"id": "concept_divide_and_conquer_strategy", "type": "V_concept", "name": "Divide And Conquer Strategy", "properties": {"description": "An algorithmic technique to solve problems by dividing them into smaller sub-problems, solving each sub-problem, and combining the solutions.", "keywords": ["divide", "conquer", "algorithm", "sub-problems"], "source_lectures": ["lecture_106105847_w1_l7"]}}
{"id": "concept_master_method_recurrence", "type": "V_concept", "name": "Master Method Recurrence", "properties": {"description": "A mathematical formula used to solve recurrence relations of the form T(n) = aT(n/b) + f(n).", "keywords": ["master", "method", "recurrence", "relation"], "source_lectures": ["lecture_106105847_w1_l7"]}}
{"id": "concept_merge_sort_algorithm", "type": "V_concept", "name": "Merge Sort Algorithm", "properties": {"description": "A sorting algorithm that uses the divide and conquer strategy to sort an array of elements.", "keywords": ["merge", "sort", "algorithm", "divide", "conquer"], "source_lectures": ["lecture_106105847_w1_l7"]}}
{"id": "concept_binary_search_algorithm", "type": "V_concept", "name": "Binary Search Algorithm", "properties": {"description": "A searching algorithm that uses the divide and conquer strategy to find an element in a sorted array.", "keywords": ["binary", "search", "algorithm", "divide", "conquer"], "source_lectures": ["lecture_106105847_w1_l7"]}}
{"id": "concept_powering_a_number", "type": "V_concept", "name": "Powering A Number", "properties": {"description": "A mathematical operation that raises a number to a given power.", "keywords": ["powering", "number", "exponentiation"], "source_lectures": ["lecture_106105847_w1_l7"]}}
{"id": "concept_divide_step", "type": "V_concept", "name": "Divide Step", "properties": {"description": "The first step in the divide and conquer strategy, where a problem is divided into smaller sub-problems.", "keywords": ["divide", "step", "sub-problems"], "source_lectures": ["lecture_106105847_w1_l7"]}}
{"id": "concept_conquer_step", "type": "V_concept", "name": "Conquer Step", "properties": {"description": "The second step in the divide and conquer strategy, where each sub-problem is solved recursively.", "keywords": ["conquer", "step", "recursive", "sub-problems"], "source_lectures": ["lecture_106105847_w1_l7"]}}
{"id": "concept_combine_step", "type": "V_concept", "name": "Combine Step", "properties": {"description": "The third step in the divide and conquer strategy, where the solutions to the sub-problems are combined to solve the original problem.", "keywords": ["combine", "step", "solutions", "sub-problems"], "source_lectures": ["lecture_106105847_w1_l7"]}}
{"id": "concept_quicksort_algorithm", "type": "V_concept", "name": "Quicksort Algorithm", "properties": {"description": "A divide-and-conquer algorithm for sorting arrays of elements.", "keywords": ["quicksort", "sorting", "algorithm", "divide", "conquer"], "source_lectures": ["lecture_106105847_w2_l9"]}}
{"id": "concept_pivot_element", "type": "V_concept", "name": "Pivot Element", "properties": {"description": "An element chosen from an array to serve as a reference point for partitioning.", "keywords": ["pivot", "element", "array", "partitioning", "reference"], "source_lectures": ["lecture_106105847_w2_l9"]}}
{"id": "concept_worst_case_scenario", "type": "V_concept", "name": "Worst-Case Scenario", "properties": {"description": "The most unfavorable input for an algorithm, resulting in the longest running time or highest memory usage.", "keywords": ["worst-case", "scenario", "algorithm", "input", "running"], "source_lectures": ["lecture_106105847_w2_l9"]}}
{"id": "concept_best_case_scenario", "type": "V_concept", "name": "Best-Case Scenario", "properties": {"description": "The most favorable input for an algorithm, resulting in the shortest running time or lowest memory usage.", "keywords": ["best-case", "scenario", "algorithm", "input", "running"], "source_lectures": ["lecture_106105847_w2_l9"]}}
{"id": "concept_radic_sort", "type": "V_concept", "name": "Radic Sort", "properties": {"description": "A non-comparative sorting algorithm that sorts data by processing individual digits (or by radix) which shares the same basic concept as the counting sort.", "keywords": ["radic", "sort", "non-comparative", "algorithm", "digit"], "source_lectures": ["lecture_106105847_w2_l13"]}}
{"id": "concept_bucket_sort", "type": "V_concept", "name": "Bucket Sort", "properties": {"description": "A comparison sort that operates on elements by dividing them into different buckets and then sorting these buckets individually.", "keywords": ["bucket", "sort", "comparison", "algorithm", "distribution"], "source_lectures": ["lecture_106105847_w2_l13"]}}
{"id": "concept_stability_in_sorting", "type": "V_concept", "name": "Stability in Sorting", "properties": {"description": "A property of sorting algorithms that maintains the relative order of equal elements after sorting.", "keywords": ["stability", "sorting", "algorithm", "property", "equal"], "source_lectures": ["lecture_106105847_w2_l13"]}}
{"id": "concept_non_comparison_sorting", "type": "V_concept", "name": "Non-Comparison Sorting", "properties": {"description": "A type of sorting algorithm that does not compare elements to determine their order, often achieving better time complexity than comparison-based sorting.", "keywords": ["non-comparison", "sorting", "algorithm", "time complexity", "efficiency"], "source_lectures": ["lecture_106105847_w2_l13"]}}
{"id": "concept_order_statistics_problem", "type": "V_concept", "name": "Order Statistics Problem", "properties": {"description": "A problem of finding the ith smallest element in an unsorted array of n elements.", "keywords": ["selection", "ith smallest", "statistics", "order statistics", "element", "order", "array", "unsorted", "smallest"], "source_lectures": ["lecture_106105847_w2_l14", "lecture_106105847_w3_l15"]}}
{"id": "concept_select_algorithm", "type": "V_concept", "name": "Select Algorithm", "properties": {"description": "A divide-and-conquer algorithm used to find the ith smallest element in an unsorted array.", "keywords": ["select", "algorithm", "smallest", "element", "array"], "source_lectures": ["lecture_106105847_w2_l14"]}}
{"id": "concept_partition_algorithm", "type": "V_concept", "name": "Partition Algorithm", "properties": {"description": "A subroutine used in the select algorithm to partition the array around a pivot element.", "keywords": ["partition", "element", "array", "pivot", "quicksort", "array rearrangement", "algorithm"], "source_lectures": ["lecture_106105847_w2_l14", "lecture_106105847_w3_l15"]}}
{"id": "concept_randomized_select_algorithm", "type": "V_concept", "name": "Randomized Select Algorithm", "properties": {"description": "A variation of the select algorithm that chooses the pivot element randomly to improve average-case performance.", "keywords": ["averagecase", "randomized select", "selection", "randomized", "random choice", "pivot", "algorithm", "select"], "source_lectures": ["lecture_106105847_w2_l14", "lecture_106105847_w3_l15"]}}
{"id": "concept_rank_of_an_element", "type": "V_concept", "name": "Rank Of An Element", "properties": {"description": "The position of an element in a sorted array.", "keywords": ["rank", "element", "sorted", "array", "position"], "source_lectures": ["lecture_106105847_w2_l14"]}}
{"id": "concept_linear_time_complexity", "type": "V_concept", "name": "Linear Time Complexity", "properties": {"description": "A time complexity of O(n), where n is the size of the input.", "keywords": ["linear", "time", "complexity", "on", "input"], "source_lectures": ["lecture_106105847_w2_l14"]}}
{"id": "concept_quadratic_time_complexity", "type": "V_concept", "name": "Quadratic Time Complexity", "properties": {"description": "A time complexity of O(n^2), where n is the size of the input.", "keywords": ["quadratic", "time", "complexity", "on2", "input"], "source_lectures": ["lecture_106105847_w2_l14"]}}
{"id": "concept_rank_of_element", "type": "V_concept", "name": "Rank of Element", "properties": {"description": "The position of an element in the sorted ordering of an array.", "keywords": ["rank", "sorted position", "element order", "index"], "source_lectures": ["lecture_106105847_w3_l15"]}}
{"id": "concept_median_of_medians", "type": "V_concept", "name": "Median of Medians", "properties": {"description": "A pivot selection method that guarantees balanced partitions by recursively computing medians of subgroups.", "keywords": ["median of medians", "pivot selection", "subgroups", "recursive"], "source_lectures": ["lecture_106105847_w3_l15"]}}
{"id": "concept_master_theorem", "type": "V_concept", "name": "Master Theorem", "properties": {"description": "A method for solving recurrence relations of the form T(n) = aT(n/b) + f(n) to determine asymptotic complexity.", "keywords": ["master theorem", "recurrence", "asymptotic analysis", "divide and conquer"], "source_lectures": ["lecture_106105847_w3_l15"]}}
{"id": "concept_good_pivot", "type": "V_concept", "name": "Good Pivot", "properties": {"description": "A pivot element that ensures neither partition in a divide-and-conquer algorithm contains a high fraction of elements.", "keywords": ["good pivot", "balanced partition", "selection efficiency", "guarantee"], "source_lectures": ["lecture_106105847_w3_l15"]}}
{"id": "concept_blum_floyd_pratt_rivest_tarjan_algorithm", "type": "V_concept", "name": "Blum Floyd Pratt Rivest Tarjan Algorithm", "properties": {"description": "A worst-case linear time algorithm for order statistics using median-of-medians pivot selection.", "keywords": ["blum floyd pratt rivest tarjan", "worst-case linear", "median of medians", "selection"], "source_lectures": ["lecture_106105847_w3_l15"]}}
{"id": "concept_recursive_algorithm", "type": "V_concept", "name": "Recursive Algorithm", "properties": {"description": "An algorithm that solves problems by reducing them to smaller instances of the same problem.", "keywords": ["recursive", "recursion", "base case", "self-similar"], "source_lectures": ["lecture_106105847_w3_l15"]}}
{"id": "concept_symbol_table_problem", "type": "V_concept", "name": "Symbol Table Problem", "properties": {"description": "A problem of maintaining a table of records, where each record is associated with a key, and performing operations such as insertion, deletion, and search.", "keywords": ["record", "data structure", "set", "search", "keys", "symbol table", "problem", "records", "table", "key", "dynamic", "operations", "symbol"], "source_lectures": ["lecture_106105847_w3_l16", "lecture_106105847_w3_l17", "lecture_106105847_w3_l18"]}}
{"id": "concept_direct_access_table", "type": "V_concept", "name": "Direct Access Table", "properties": {"description": "A data structure that uses an array to store records, where each index in the array corresponds to a key value.", "keywords": ["direct", "access", "table", "array", "key"], "source_lectures": ["lecture_106105847_w3_l16"]}}
{"id": "concept_collision", "type": "V_concept", "name": "Collision", "properties": {"description": "A situation that occurs when two or more keys are mapped to the same index by a hash function.", "keywords": ["slot", "hashing", "keys", "hash", "function", "collision", "index", "key", "conflict"], "source_lectures": ["lecture_106105847_w3_l16", "lecture_106105847_w3_l17", "lecture_106105847_w3_l19"]}}
{"id": "concept_chaining_method", "type": "V_concept", "name": "Chaining Method", "properties": {"description": "A technique used to handle collisions in a hash table, where a linked list is used to store records that collide at the same index.", "keywords": ["slot", "method", "chaining", "collision resolution", "hash", "collision", "table", "linked list"], "source_lectures": ["lecture_106105847_w3_l16", "lecture_106105847_w3_l17", "lecture_106105847_w3_l19"]}}
{"id": "concept_load_factor", "type": "V_concept", "name": "Load Factor", "properties": {"description": "A measure of the average number of records stored in each index of a hash table, used to evaluate the efficiency of the hash function.", "keywords": ["efficiency", "factor", "occupancy", "density", "load factor", "hashing", "performance", "hash", "load", "table", "alpha"], "source_lectures": ["lecture_106105847_w3_l16", "lecture_106105847_w3_l17", "lecture_106105847_w3_l18", "lecture_106105847_w3_l19"]}}
{"id": "concept_division_method", "type": "V_concept", "name": "Division Method", "properties": {"description": "A simple hash function that uses the modulo operator to map a key to an index, often used when the table size is prime.", "keywords": ["division", "method", "hash", "function", "modulo"], "source_lectures": ["lecture_106105847_w3_l16"]}}
{"id": "concept_multiplication_method", "type": "V_concept", "name": "Multiplication Method", "properties": {"description": "A hash function that uses multiplication and shifting to map a key to an index, often used when the table size is a power of 2.", "keywords": ["multiplication", "method", "hash", "function", "shifting"], "source_lectures": ["lecture_106105847_w3_l16"]}}
{"id": "concept_uniform_hashing", "type": "V_concept", "name": "Uniform Hashing", "properties": {"description": "A property of a hash function that distributes keys uniformly across the indices of a hash table, minimizing collisions and improving efficiency.", "keywords": ["distribution", "uniform", "uniform hashing", "efficiency", "hashing", "keys", "hash", "slots", "function", "hash function"], "source_lectures": ["lecture_106105847_w3_l16", "lecture_106105847_w3_l17"]}}
{"id": "concept_simple_uniform_hashing", "type": "V_concept", "name": "Simple Uniform Hashing", "properties": {"description": "A assumption that a hash function distributes keys uniformly and independently across the indices of a hash table, used to analyze the performance of hash tables.", "keywords": ["distribution", "uniform", "slot", "hashing", "simple", "hash", "function", "key"], "source_lectures": ["lecture_106105847_w3_l16", "lecture_106105847_w3_l18"]}}
{"id": "concept_open_addressing", "type": "V_concept", "name": "Open Addressing", "properties": {"description": "A collision resolution method that stores all keys within the hash table itself without external storage.", "keywords": ["probing", "collision resolution", "hash table", "open addressing", "internal storage"], "source_lectures": ["lecture_106105847_w3_l17", "lecture_106105847_w3_l19"]}}
{"id": "concept_probe_sequence", "type": "V_concept", "name": "Probe Sequence", "properties": {"description": "A systematic sequence of slot checks used in open addressing to find an empty position.", "keywords": ["probe sequence", "probing", "open addressing", "slot", "search"], "source_lectures": ["lecture_106105847_w3_l17"]}}
{"id": "concept_linear_probing", "type": "V_concept", "name": "Linear Probing", "properties": {"description": "A probing strategy that checks consecutive slots in sequence when resolving collisions.", "keywords": ["linear probing", "probing", "open addressing", "collision", "sequential"], "source_lectures": ["lecture_106105847_w3_l17"]}}
{"id": "concept_double_probing", "type": "V_concept", "name": "Double Probing", "properties": {"description": "A probing strategy using two hash functions to determine the sequence of slots to check.", "keywords": ["double probing", "probing", "hash function", "collision", "open addressing"], "source_lectures": ["lecture_106105847_w3_l17"]}}
{"id": "concept_deletion_handling", "type": "V_concept", "name": "Deletion Handling", "properties": {"description": "The method of marking deleted slots to avoid disrupting search operations in open addressing.", "keywords": ["deletion", "open addressing", "marking", "slot", "search"], "source_lectures": ["lecture_106105847_w3_l17"]}}
{"id": "concept_expected_probes_for_unsuccessful_search", "type": "V_concept", "name": "Expected Probes for Unsuccessful Search", "properties": {"description": "The average number of slot checks required to confirm a key is absent in open addressing, given by 1/(1 - alpha).", "keywords": ["expected probes", "unsuccessful search", "open addressing", "analysis", "performance"], "source_lectures": ["lecture_106105847_w3_l17"]}}
{"id": "concept_collision_hashing", "type": "V_concept", "name": "Collision (Hashing)", "properties": {"description": "An event where two distinct keys are mapped to the same slot by a hash function.", "keywords": ["collision", "hash", "key", "slot", "conflict"], "source_lectures": ["lecture_106105847_w3_l18"]}}
{"id": "concept_division_method_hashing", "type": "V_concept", "name": "Division Method (Hashing)", "properties": {"description": "A hash function technique that computes the hash value as the remainder of dividing the key by the table size.", "keywords": ["division", "method", "hash", "modulus", "prime"], "source_lectures": ["lecture_106105847_w3_l18"]}}
{"id": "concept_adversarial_input_hashing", "type": "V_concept", "name": "Adversarial Input (Hashing)", "properties": {"description": "A maliciously constructed set of keys designed to maximize collisions in a known hash function.", "keywords": ["adversary", "input", "collision", "hash", "attack"], "source_lectures": ["lecture_106105847_w3_l18"]}}
{"id": "concept_universal_hashing", "type": "V_concept", "name": "Universal Hashing", "properties": {"description": "A technique that selects a hash function randomly from a family of functions to guarantee low collision probability against any input.", "keywords": ["collection", "hashing", "universal", "randomized", "collision", "random", "universal hashing", "probability", "hash function"], "source_lectures": ["lecture_106105847_w3_l18", "lecture_106104357_w5_l32"]}}
{"id": "concept_universal_hash_function_collection", "type": "V_concept", "name": "Universal Hash Function Collection", "properties": {"description": "A finite set of hash functions where, for any two distinct keys, the probability of collision is at most 1/m, where m is the number of slots.", "keywords": ["universal", "collection", "hash", "function", "probability"], "source_lectures": ["lecture_106105847_w3_l18"]}}
{"id": "concept_collision_probability_universal_hashing", "type": "V_concept", "name": "Collision Probability (Universal Hashing)", "properties": {"description": "The probability that two distinct keys collide under a randomly selected hash function from a universal collection, which is at most 1/m.", "keywords": ["collision", "probability", "universal", "hash", "1bym"], "source_lectures": ["lecture_106105847_w3_l18"]}}
{"id": "concept_indicator_random_variable_hashing", "type": "V_concept", "name": "Indicator Random Variable (Hashing)", "properties": {"description": "A binary random variable that indicates whether a collision occurs between two specific keys in a hash table.", "keywords": ["indicator", "random", "variable", "collision", "hash"], "source_lectures": ["lecture_106105847_w3_l18"]}}
{"id": "concept_expected_number_of_collisions", "type": "V_concept", "name": "Expected Number of Collisions", "properties": {"description": "The average number of keys that collide with a given key in a hash table under universal hashing, bounded by (n-1)/m.", "keywords": ["expected", "collision", "number", "hash", "universal"], "source_lectures": ["lecture_106105847_w3_l18"]}}
{"id": "concept_prime_modulus_hashing", "type": "V_concept", "name": "Prime Modulus (Hashing)", "properties": {"description": "The practice of choosing the hash table size as a prime number to minimize patterns and improve uniformity in hash distribution.", "keywords": ["prime", "modulus", "hash", "table", "size"], "source_lectures": ["lecture_106105847_w3_l18"]}}
{"id": "concept_key_decomposition_universal_hashing", "type": "V_concept", "name": "Key Decomposition (Universal Hashing)", "properties": {"description": "The process of breaking a key into multiple smaller components (blocks) to enable construction of universal hash functions.", "keywords": ["decomposition", "key", "block", "universal", "hash"], "source_lectures": ["lecture_106105847_w3_l18"]}}
{"id": "concept_inner_product_hash_function", "type": "V_concept", "name": "Inner Product Hash Function", "properties": {"description": "A universal hash function formed by computing the modular inner product of a key vector and a randomly chosen coefficient vector.", "keywords": ["inner", "product", "hash", "universal", "modular"], "source_lectures": ["lecture_106105847_w3_l18"]}}
{"id": "concept_bad_portion_universal_hashing", "type": "V_concept", "name": "Bad Portion (Universal Hashing)", "properties": {"description": "The subset of hash functions in a universal collection that cause a collision between two specific keys.", "keywords": ["bad", "portion", "universal", "hash", "collision"], "source_lectures": ["lecture_106105847_w3_l18"]}}
{"id": "concept_modular_arithmetic_hashing", "type": "V_concept", "name": "Modular Arithmetic (Hashing)", "properties": {"description": "Arithmetic operations performed under modulo m, commonly used in hash functions to map keys into a fixed range.", "keywords": ["modular", "arithmetic", "modulo", "hash", "remainder"], "source_lectures": ["lecture_106105847_w3_l18"]}}
{"id": "concept_randomized_hash_function_selection", "type": "V_concept", "name": "Randomized Hash Function Selection", "properties": {"description": "The practice of selecting a hash function at random at runtime to prevent adversarial exploitation of deterministic functions.", "keywords": ["randomized", "selection", "hash", "function", "adversary"], "source_lectures": ["lecture_106105847_w3_l18"]}}
{"id": "concept_hash_function_family", "type": "V_concept", "name": "Hash Function Family", "properties": {"description": "A set of multiple hash functions from which one is chosen randomly to implement universal hashing.", "keywords": ["family", "hash", "function", "collection", "universal"], "source_lectures": ["lecture_106105847_w3_l18"]}}
{"id": "concept_coefficient_vector_universal_hashing", "type": "V_concept", "name": "Coefficient Vector (Universal Hashing)", "properties": {"description": "A randomly chosen vector of coefficients used in the inner product computation to define a hash function in a universal collection.", "keywords": ["coefficient", "vector", "universal", "hash", "inner"], "source_lectures": ["lecture_106105847_w3_l18"]}}
{"id": "concept_hash_table", "type": "V_concept", "name": "Hash Table", "properties": {"description": "A data structure that stores key-value pairs using a hash function to map keys to array indices for efficient access.", "keywords": ["hash", "table", "data", "structure", "key-value"], "source_lectures": ["lecture_106105847_w3_l18"]}}
{"id": "concept_key_universe", "type": "V_concept", "name": "Key Universe", "properties": {"description": "The complete set of all possible keys that a hash function may be applied to, typically much larger than the hash table size.", "keywords": ["universe", "key", "hash", "domain", "possible"], "source_lectures": ["lecture_106105847_w3_l18"]}}
{"id": "concept_chaining_collision_resolution", "type": "V_concept", "name": "Chaining (Collision Resolution)", "properties": {"description": "A method of resolving hash collisions by storing colliding keys in linked lists at the same hash table slot.", "keywords": ["chaining", "collision", "resolution", "linked", "list"], "source_lectures": ["lecture_106105847_w3_l18"]}}
{"id": "concept_open_addressing_collision_resolution", "type": "V_concept", "name": "Open Addressing (Collision Resolution)", "properties": {"description": "A collision resolution technique where colliding keys are stored in alternative slots within the hash table itself.", "keywords": ["open", "addressing", "collision", "resolution", "probing"], "source_lectures": ["lecture_106105847_w3_l18"]}}
{"id": "concept_modular_inverse", "type": "V_concept", "name": "Modular Inverse", "properties": {"description": "The multiplicative inverse of a number under modulo m, used in algebraic proofs of universal hashing properties.", "keywords": ["modular", "inverse", "algebra", "hash", "prime"], "source_lectures": ["lecture_106105847_w3_l18"]}}
{"id": "concept_perfect_hashing", "type": "V_concept", "name": "Perfect Hashing", "properties": {"description": "A static hashing technique that guarantees no collisions and constant-time search using a two-level hash table structure.", "keywords": ["perfect hashing", "static", "collision-free", "constant-time"], "source_lectures": ["lecture_106105847_w3_l19"]}}
{"id": "concept_universal_hash_function", "type": "V_concept", "name": "Universal Hash Function", "properties": {"description": "A randomly selected hash function from a collection designed to minimize collision probability for any pair of distinct keys.", "keywords": ["universal hashing", "hash function", "random", "collision probability"], "source_lectures": ["lecture_106105847_w3_l19"]}}
{"id": "concept_universal_collection", "type": "V_concept", "name": "Universal Collection", "properties": {"description": "A set of hash functions where the fraction causing collisions for any two distinct keys is at most 1/m, with m being the table size.", "keywords": ["universal collection", "hash functions", "collision guarantee"], "source_lectures": ["lecture_106105847_w3_l19"]}}
{"id": "concept_two_level_hashing", "type": "V_concept", "name": "Two-Level Hashing", "properties": {"description": "A hashing technique using a primary hash table and secondary hash tables to resolve collisions without chaining.", "keywords": ["two-level hashing", "primary", "secondary", "collision resolution"], "source_lectures": ["lecture_106105847_w3_l19"]}}
{"id": "concept_static_arrangement", "type": "V_concept", "name": "Static Arrangement", "properties": {"description": "A data structure design where the set of keys is fixed and no insertions or deletions occur after construction.", "keywords": ["static", "fixed keys", "no dynamic operations"], "source_lectures": ["lecture_106105847_w3_l19"]}}
{"id": "concept_markovs_inequality", "type": "V_concept", "name": "Markov's Inequality", "properties": {"description": "A probability theorem stating that for a non-negative random variable, the probability it exceeds a value is at most its expected value divided by that value.", "keywords": ["inequality", "expected", "non-negative", "markov inequality", "expected value", "markov", "random variable", "bound", "random", "probability", "probability bound"], "source_lectures": ["lecture_106105847_w3_l19", "lecture_106104357_w6_l37", "lecture_106104233_w3_l17"]}}
{"id": "concept_modulo_operation", "type": "V_concept", "name": "Modulo Operation", "properties": {"description": "An arithmetic operation that finds the remainder when one integer is divided by another.", "keywords": ["modulo", "remainder", "arithmetic", "congruence"], "source_lectures": ["lecture_106105847_w3_l19"]}}
{"id": "concept_dot_product_hash", "type": "V_concept", "name": "Dot Product Hash", "properties": {"description": "A universal hash function construction using the dot product of a key vector and a random constant vector modulo a prime.", "keywords": ["dot product", "hash function", "universal", "modulo prime"], "source_lectures": ["lecture_106105847_w3_l19"]}}
{"id": "concept_min_heap_property", "type": "V_concept", "name": "Min Heap Property", "properties": {"description": "A property of a heap where every node is less than or equal to its children.", "keywords": ["min heap", "property", "heap", "node"], "source_lectures": ["lecture_106105847_w3_l20"]}}
{"id": "concept_minify_operation", "type": "V_concept", "name": "Minify Operation", "properties": {"description": "An operation that ensures the min heap property is maintained for a given subtree.", "keywords": ["minify", "operation", "min heap", "subtree"], "source_lectures": ["lecture_106105847_w3_l20"]}}
{"id": "concept_build_min_heap", "type": "V_concept", "name": "Build Min Heap", "properties": {"description": "An algorithm that constructs a min heap from an arbitrary array.", "keywords": ["build min heap", "algorithm", "min heap", "array"], "source_lectures": ["lecture_106105847_w3_l20"]}}
{"id": "concept_extract_min_operation", "type": "V_concept", "name": "Extract Min Operation", "properties": {"description": "An operation that removes and returns the minimum element from a min heap.", "keywords": ["extract min", "operation", "min heap", "minimum"], "source_lectures": ["lecture_106105847_w3_l20"]}}
{"id": "concept_decrease_key_operation", "type": "V_concept", "name": "Decrease Key Operation", "properties": {"description": "An operation that decreases the key of a given element in a min heap.", "keywords": ["decrease key", "operation", "min heap", "key"], "source_lectures": ["lecture_106105847_w3_l20"]}}
{"id": "concept_fibonacci_heap", "type": "V_concept", "name": "Fibonacci Heap", "properties": {"description": "A advanced data structure used for graph algorithms, consisting of a collection of rooted trees that obey the min heap property.", "keywords": ["fibonacci heap", "data structure", "graph algorithm", "min heap"], "source_lectures": ["lecture_106105847_w3_l20"]}}
{"id": "concept_functional_programming", "type": "V_concept", "name": "Functional Programming", "properties": {"description": "A style of programming that emphasizes the use of pure functions, immutability, and the avoidance of changing state", "keywords": ["programming", "functional", "function", "style", "paradigm", "pure"], "source_lectures": ["lecture_106106931_w1_l1", "lecture_106106931_w1_l4"]}}
{"id": "concept_imperative_programming", "type": "V_concept", "name": "Imperative Programming", "properties": {"description": "A style of programming that emphasizes the use of statements to change the state of a program", "keywords": ["imperative", "programming", "paradigm", "style"], "source_lectures": ["lecture_106106931_w1_l1"]}}
{"id": "concept_haskell_programming_language", "type": "V_concept", "name": "Haskell Programming Language", "properties": {"description": "A statically typed, purely functional programming language", "keywords": ["haskell", "programming", "functional", "language"], "source_lectures": ["lecture_106106931_w1_l1", "lecture_106106931_w1_l4"]}}
{"id": "concept_function_definition", "type": "V_concept", "name": "Function Definition", "properties": {"description": "A declaration of a function that specifies its name, arguments, and return value", "keywords": ["programming", "declaration", "definition", "function", "output", "parameters"], "source_lectures": ["lecture_106106931_w1_l1", "lecture_106106931_w1_l2"]}}
{"id": "concept_type_specification", "type": "V_concept", "name": "Type Specification", "properties": {"description": "A way to specify the type of a function or variable in a programming language", "keywords": ["type", "specification", "programming", "language"], "source_lectures": ["lecture_106106931_w1_l1"]}}
{"id": "concept_ghci", "type": "V_concept", "name": "GHCI", "properties": {"description": "The Glasgow Haskell Compiler's interactive environment", "keywords": ["haskell", "ghci", "compiler", "interactive"], "source_lectures": ["lecture_106106931_w1_l1", "lecture_106106931_w1_l4"]}}
{"id": "concept_standalone_haskell_program", "type": "V_concept", "name": "Standalone Haskell Program", "properties": {"description": "A Haskell program that can be compiled and run independently of the GHCI environment", "keywords": ["standalone", "haskell", "program", "compilation"], "source_lectures": ["lecture_106106931_w1_l1"]}}
{"id": "concept_main_function", "type": "V_concept", "name": "Main Function", "properties": {"description": "The entry point of a standalone Haskell program", "keywords": ["main", "entry point", "function", "point", "execution", "entry"], "source_lectures": ["lecture_106106931_w1_l1", "lecture_106106931_w2_l9"]}}
{"id": "concept_integer_type", "type": "V_concept", "name": "Integer Type", "properties": {"description": "A type of data that represents whole numbers", "keywords": ["integer", "type", "data", "whole"], "source_lectures": ["lecture_106106931_w1_l1"]}}
{"id": "concept_boolean_type", "type": "V_concept", "name": "Boolean Type", "properties": {"description": "A type of data that represents true or false values", "keywords": ["true", "false", "boolean", "data", "type"], "source_lectures": ["lecture_106106931_w1_l1", "lecture_106106931_w1_l2"]}}
{"id": "concept_relational_operators", "type": "V_concept", "name": "Relational Operators", "properties": {"description": "Operators used to compare values, such as equal to, less than, and greater than", "keywords": ["relational", "operators", "comparison", "values"], "source_lectures": ["lecture_106106931_w1_l1"]}}
{"id": "concept_function_application", "type": "V_concept", "name": "Function Application", "properties": {"description": "The process of applying a function to its arguments", "keywords": ["function", "application", "arguments", "programming"], "source_lectures": ["lecture_106106931_w1_l1"]}}
{"id": "concept_type_declaration", "type": "V_concept", "name": "Type Declaration", "properties": {"description": "A statement that specifies the data type of a variable or function parameter.", "keywords": ["type", "declaration", "variable", "parameter"], "source_lectures": ["lecture_106106931_w1_l2"]}}
{"id": "concept_if_then_else_expression", "type": "V_concept", "name": "If-Then-Else Expression", "properties": {"description": "A conditional expression that evaluates to one of two values based on a boolean condition.", "keywords": ["if", "then", "else", "conditional"], "source_lectures": ["lecture_106106931_w1_l2"]}}
{"id": "concept_pattern_matching", "type": "V_concept", "name": "Pattern Matching", "properties": {"description": "A technique for defining functions by specifying multiple patterns and corresponding output values.", "keywords": ["haskell", "functional programming", "programming", "matching", "data handling", "functional", "pattern matching", "definition", "decomposition", "function", "recursion", "pattern", "data"], "source_lectures": ["lecture_106106931_w1_l2", "lecture_106106931_w1_l3", "lecture_106106931_w1_l4", "lecture_106106931_w1_l5", "lecture_106106931_w2_l8", "lecture_106106931_w2_l9", "lecture_106106931_w2_l10", "lecture_106106931_w2_l11", "lecture_106106931_w2_l12", "lecture_106106931_w2_l13"]}}
{"id": "concept_function_composition", "type": "V_concept", "name": "Function Composition", "properties": {"description": "The process of combining two or more functions to create a new function.", "keywords": ["haskell", "functional programming", "composition", "dot", "compose", "combination", "function", "function composition", "operator"], "source_lectures": ["lecture_106106931_w1_l2", "lecture_106106931_w1_l6", "lecture_106106931_w2_l14", "lecture_106106931_w3_l17"]}}
{"id": "concept_operator_section", "type": "V_concept", "name": "Operator Section", "properties": {"description": "A syntax for turning an operator into a function by surrounding it with parentheses.", "keywords": ["operator", "section", "function"], "source_lectures": ["lecture_106106931_w1_l2"]}}
{"id": "concept_partial_application", "type": "V_concept", "name": "Partial Application", "properties": {"description": "The process of applying a function to some, but not all, of its arguments.", "keywords": ["partial", "application", "function", "arguments"], "source_lectures": ["lecture_106106931_w1_l2"]}}
{"id": "concept_exor_function", "type": "V_concept", "name": "Exor Function", "properties": {"description": "A boolean function that returns true if and only if its two input values are different.", "keywords": ["exor", "function", "boolean", "input"], "source_lectures": ["lecture_106106931_w1_l2"]}}
{"id": "concept_haskell_syntax", "type": "V_concept", "name": "Haskell Syntax", "properties": {"description": "The set of rules that define the structure and syntax of the Haskell programming language.", "keywords": ["haskell", "syntax", "programming", "language"], "source_lectures": ["lecture_106106931_w1_l2"]}}
{"id": "concept_guarded_definition", "type": "V_concept", "name": "Guarded Definition", "properties": {"description": "A way of defining functions in Haskell where a definition is given for a specific condition or guard.", "keywords": ["guarded", "definition", "haskell", "function"], "source_lectures": ["lecture_106106931_w1_l3"]}}
{"id": "concept_currying", "type": "V_concept", "name": "Currying", "properties": {"description": "The process of transforming a function that takes multiple arguments into a sequence of functions, each taking a single argument.", "keywords": ["haskell", "transformation", "partial", "function", "currying", "application"], "source_lectures": ["lecture_106106931_w1_l3", "lecture_106106931_w3_l17"]}}
{"id": "concept_function_arity", "type": "V_concept", "name": "Function Arity", "properties": {"description": "The number of arguments a function takes.", "keywords": ["arity", "function", "haskell", "argument"], "source_lectures": ["lecture_106106931_w1_l3"]}}
{"id": "concept_type_signature", "type": "V_concept", "name": "Type Signature", "properties": {"description": "A declaration of the types of a function's inputs and outputs.", "keywords": ["type", "signature", "haskell", "function"], "source_lectures": ["lecture_106106931_w1_l3"]}}
{"id": "concept_right_associativity", "type": "V_concept", "name": "Right Associativity", "properties": {"description": "A property of operators where the operator is applied from right to left.", "keywords": ["right", "associativity", "operator", "haskell"], "source_lectures": ["lecture_106106931_w1_l3"]}}
{"id": "concept_left_associativity", "type": "V_concept", "name": "Left Associativity", "properties": {"description": "A property of operators where the operator is applied from left to right.", "keywords": ["left", "associativity", "operator", "haskell"], "source_lectures": ["lecture_106106931_w1_l3"]}}
{"id": "concept_sectioning", "type": "V_concept", "name": "Sectioning", "properties": {"description": "A way of creating a new function by fixing one or more arguments of a binary function.", "keywords": ["sectioning", "function", "haskell", "binary"], "source_lectures": ["lecture_106106931_w1_l3"]}}
{"id": "concept_recursive_definition", "type": "V_concept", "name": "Recursive Definition", "properties": {"description": "A way of defining a function in terms of itself, often used for functions with a recursive structure.", "keywords": ["recursive", "definition", "haskell", "function"], "source_lectures": ["lecture_106106931_w1_l3"]}}
{"id": "concept_base_case", "type": "V_concept", "name": "Base Case", "properties": {"description": "A case in a recursive definition that provides a stopping point for the recursion.", "keywords": ["haskell", "stopping", "recursive", "base", "recursion", "case"], "source_lectures": ["lecture_106106931_w1_l3", "lecture_106106931_w1_l5"]}}
{"id": "concept_error_function", "type": "V_concept", "name": "Error Function", "properties": {"description": "A function in Haskell that can be used to indicate an error and provide an error message.", "keywords": ["error", "function", "haskell", "message"], "source_lectures": ["lecture_106106931_w1_l3"]}}
{"id": "concept_case_expression", "type": "V_concept", "name": "Case Expression", "properties": {"description": "A way of defining a function in Haskell using a case expression, similar to a switch statement in other languages.", "keywords": ["case", "expression", "haskell", "function"], "source_lectures": ["lecture_106106931_w1_l3"]}}
{"id": "concept_guards", "type": "V_concept", "name": "Guards", "properties": {"description": "Conditions in a Haskell function definition that determine which definition to use.", "keywords": ["guards", "haskell", "function", "condition"], "source_lectures": ["lecture_106106931_w1_l3"]}}
{"id": "concept_read_evaluate_print_loop", "type": "V_concept", "name": "Read Evaluate Print Loop", "properties": {"description": "A mechanism for interactively executing expressions and displaying results.", "keywords": ["repl", "read", "evaluate", "print", "loop"], "source_lectures": ["lecture_106106931_w1_l4"]}}
{"id": "concept_haskell_extension", "type": "V_concept", "name": "Haskell Extension", "properties": {"description": "A plugin for Visual Studio Code that provides Haskell language support.", "keywords": ["haskell", "extension", "visual", "studio", "code"], "source_lectures": ["lecture_106106931_w1_l4"]}}
{"id": "concept_recursive_function", "type": "V_concept", "name": "Recursive Function", "properties": {"description": "A function that calls itself in its own definition.", "keywords": ["definition", "iteration", "function", "recursive", "calls", "self-reference", "recursion", "itself", "call", "solve"], "source_lectures": ["lecture_106106931_w1_l4", "lecture_106106931_w1_l5", "lecture_106106931_w1_l6", "lecture_106106931_w2_l8"]}}
{"id": "concept_integer_data_type", "type": "V_concept", "name": "Integer Data Type", "properties": {"description": "A data type that represents whole numbers without fractional parts.", "keywords": ["integer", "data", "type", "whole", "number"], "source_lectures": ["lecture_106106931_w1_l4"]}}
{"id": "concept_float_data_type", "type": "V_concept", "name": "Float Data Type", "properties": {"description": "A data type that represents numbers with fractional parts.", "keywords": ["float", "data", "type", "fractional", "number"], "source_lectures": ["lecture_106106931_w1_l4"]}}
{"id": "concept_double_data_type", "type": "V_concept", "name": "Double Data Type", "properties": {"description": "A data type that represents numbers with higher precision than float.", "keywords": ["double", "data", "type", "precision", "number"], "source_lectures": ["lecture_106106931_w1_l4"]}}
{"id": "concept_character_data_type", "type": "V_concept", "name": "Character Data Type", "properties": {"description": "A data type that represents single characters.", "keywords": ["character", "haskell", "symbol", "single", "data type", "char", "data", "type"], "source_lectures": ["lecture_106106931_w1_l4", "lecture_106106931_w2_l12"]}}
{"id": "concept_string_data_type", "type": "V_concept", "name": "String Data Type", "properties": {"description": "A data type that represents sequences of characters.", "keywords": ["character", "haskell", "string", "data type", "sequence", "data", "type"], "source_lectures": ["lecture_106106931_w1_l4", "lecture_106106931_w2_l12"]}}
{"id": "concept_list_data_structure", "type": "V_concept", "name": "List Data Structure", "properties": {"description": "A data structure that represents ordered collections of elements.", "keywords": ["list", "data", "structure", "ordered", "collection"], "source_lectures": ["lecture_106106931_w1_l4"]}}
{"id": "concept_type_inference", "type": "V_concept", "name": "Type Inference", "properties": {"description": "The ability of a programming language to automatically determine the data type of an expression.", "keywords": ["haskell", "inference", "programming", "language", "data", "type"], "source_lectures": ["lecture_106106931_w1_l4", "lecture_106106931_w2_l13", "lecture_106106931_w3_l15"]}}
{"id": "concept_factorial_function", "type": "V_concept", "name": "Factorial Function", "properties": {"description": "A mathematical function that calculates the product of all positive integers up to a given number.", "keywords": ["factorial", "function", "mathematics", "product"], "source_lectures": ["lecture_106106931_w1_l5"]}}
{"id": "concept_fibonacci_sequence", "type": "V_concept", "name": "Fibonacci Sequence", "properties": {"description": "A series of numbers in which each number is the sum of the two preceding numbers, often used to model population growth and other phenomena.", "keywords": ["fibonacci", "sequence", "series", "numbers"], "source_lectures": ["lecture_106106931_w1_l5"]}}
{"id": "concept_guarded_definitions", "type": "V_concept", "name": "Guarded Definitions", "properties": {"description": "A way of defining functions in Haskell that allows for multiple clauses with conditional expressions.", "keywords": ["haskell", "programming", "guarded", "conditional", "definitions"], "source_lectures": ["lecture_106106931_w1_l5", "lecture_106106931_w2_l13"]}}
{"id": "concept_euclids_algorithm", "type": "V_concept", "name": "Euclid's Algorithm", "properties": {"description": "A method for calculating the greatest common divisor of two integers, based on the principle that the GCD of two numbers does not change if the larger number is replaced by its difference with the smaller number.", "keywords": ["euclid", "algorithm", "gcd", "method"], "source_lectures": ["lecture_106106931_w1_l5"]}}
{"id": "concept_absolute_value_function", "type": "V_concept", "name": "Absolute Value Function", "properties": {"description": "A function that returns the non-negative value of a given number, regardless of its sign.", "keywords": ["absolute", "value", "function", "non-negative"], "source_lectures": ["lecture_106106931_w1_l5"]}}
{"id": "concept_power_of_five_function", "type": "V_concept", "name": "Power of Five Function", "properties": {"description": "A function that checks whether a given integer is a power of five.", "keywords": ["power", "five", "function", "integer"], "source_lectures": ["lecture_106106931_w1_l5"]}}
{"id": "concept_lazy_evaluation", "type": "V_concept", "name": "Lazy Evaluation", "properties": {"description": "A technique used in Haskell to delay the evaluation of an expression until its value is actually needed.", "keywords": ["haskell", "evaluation", "lazy", "strategy", "expression", "delayed"], "source_lectures": ["lecture_106106931_w1_l5", "lecture_106106931_w3_l16"]}}
{"id": "concept_local_definition", "type": "V_concept", "name": "Local Definition", "properties": {"description": "A definition that is only accessible within a specific scope, such as a function or module.", "keywords": ["local", "definition", "scope", "accessibility"], "source_lectures": ["lecture_106106931_w1_l6"]}}
{"id": "concept_helper_function", "type": "V_concept", "name": "Helper Function", "properties": {"description": "A function that is used to assist in the execution of another function, often performing a specific task or calculation.", "keywords": ["helper", "function", "auxiliary", "assistance"], "source_lectures": ["lecture_106106931_w1_l6"]}}
{"id": "concept_top_level_definition", "type": "V_concept", "name": "Top-Level Definition", "properties": {"description": "A definition that is accessible from anywhere in a program, typically defined at the highest level of scope.", "keywords": ["top-level", "definition", "global", "accessibility"], "source_lectures": ["lecture_106106931_w1_l6"]}}
{"id": "concept_where_clause", "type": "V_concept", "name": "Where Clause", "properties": {"description": "A clause used to define local variables or functions in a Haskell program, introduced by the 'where' keyword.", "keywords": ["haskell", "programming", "clause", "definition", "where", "local"], "source_lectures": ["lecture_106106931_w1_l6", "lecture_106106931_w2_l13"]}}
{"id": "concept_let_expression", "type": "V_concept", "name": "Let Expression", "properties": {"description": "An expression used to define local variables or functions in a Haskell program, introduced by the 'let' keyword.", "keywords": ["haskell", "programming", "definition", "expression", "local", "let"], "source_lectures": ["lecture_106106931_w1_l6", "lecture_106106931_w2_l13"]}}
{"id": "concept_div_mod_function", "type": "V_concept", "name": "Div Mod Function", "properties": {"description": "A function that returns a pair containing the quotient and remainder of an integer division operation.", "keywords": ["div", "mod", "function", "quotient", "remainder"], "source_lectures": ["lecture_106106931_w1_l6"]}}
{"id": "concept_integer_reversal", "type": "V_concept", "name": "Integer Reversal", "properties": {"description": "The process of reversing the digits of an integer, often used as an example of a recursive function.", "keywords": ["integer", "reversal", "recursion", "example"], "source_lectures": ["lecture_106106931_w1_l6"]}}
{"id": "concept_accumulator", "type": "V_concept", "name": "Accumulator", "properties": {"description": "A variable used to accumulate a value during the execution of a recursive function, often used to build up a result.", "keywords": ["accumulator", "result", "function", "recursion", "variable"], "source_lectures": ["lecture_106106931_w1_l6", "lecture_106106931_w2_l9"]}}
{"id": "concept_haskell_list", "type": "V_concept", "name": "Haskell List", "properties": {"description": "A homogeneous collection of elements implemented as a singly linked list in Haskell.", "keywords": ["collection", "haskell", "data structure", "list", "linked list"], "source_lectures": ["lecture_106106931_w1_l7", "lecture_106106931_w2_l10"]}}
{"id": "concept_homogeneous_list_constraint", "type": "V_concept", "name": "Homogeneous List Constraint", "properties": {"description": "The requirement that all elements in a Haskell list must share the same data type.", "keywords": ["homogeneous", "type constraint", "list elements", "type safety"], "source_lectures": ["lecture_106106931_w1_l7"]}}
{"id": "concept_empty_list", "type": "V_concept", "name": "Empty List", "properties": {"description": "A list with zero elements, represented as [] in Haskell and polymorphic over all types.", "keywords": ["empty list", "base case", "terminator", "list", "nil", "empty", "initialization", "polymorphic"], "source_lectures": ["lecture_106106931_w1_l7", "lecture_106106931_w2_l10"]}}
{"id": "concept_colon_operator", "type": "V_concept", "name": "Colon Operator", "properties": {"description": "The (:) operator that prepends an element to the beginning of a list in Haskell.", "keywords": ["colon operator", "prepend", "list constructor", "cons"], "source_lectures": ["lecture_106106931_w1_l7"]}}
{"id": "concept_head_function", "type": "V_concept", "name": "Head Function", "properties": {"description": "A function that returns the first element of a non-empty list.", "keywords": ["accessor", "first element", "list", "element", "unsafe function", "list access", "head"], "source_lectures": ["lecture_106106931_w1_l7", "lecture_106106931_w2_l10"]}}
{"id": "concept_tail_function", "type": "V_concept", "name": "Tail Function", "properties": {"description": "A function that returns all elements except the first in a non-empty list.", "keywords": ["sublist", "remainder", "tail", "rest of list", "list", "unsafe function", "list remainder"], "source_lectures": ["lecture_106106931_w1_l7", "lecture_106106931_w2_l10"]}}
{"id": "concept_null_function", "type": "V_concept", "name": "Null Function", "properties": {"description": "A function that checks whether a list is empty, returning a boolean value.", "keywords": ["null", "empty check", "list predicate", "boolean"], "source_lectures": ["lecture_106106931_w1_l7"]}}
{"id": "concept_structural_recursion", "type": "V_concept", "name": "Structural Recursion", "properties": {"description": "A recursive technique where functions are defined by handling base cases and decomposing data structures.", "keywords": ["structural recursion", "programming", "inductive case", "technique", "base case", "structural", "recursion"], "source_lectures": ["lecture_106106931_w1_l7", "lecture_106106931_w2_l8"]}}
{"id": "concept_runtime_error", "type": "V_concept", "name": "Runtime Error", "properties": {"description": "An error occurring during program execution, such as applying head to an empty list.", "keywords": ["runtime error", "exception", "program crash", "unsafe operation"], "source_lectures": ["lecture_106106931_w1_l7"]}}
{"id": "concept_compile_time_error", "type": "V_concept", "name": "Compile Time Error", "properties": {"description": "An error detected during code compilation before execution.", "keywords": ["compile error", "type error", "syntax error", "static checking"], "source_lectures": ["lecture_106106931_w1_l7"]}}
{"id": "concept_pattern_matching_decomposition", "type": "V_concept", "name": "Pattern Matching Decomposition", "properties": {"description": "A safe technique to extract list components using patterns like (x:xs) instead of head/tail.", "keywords": ["pattern matching", "decomposition", "safe access", "list patterns"], "source_lectures": ["lecture_106106931_w1_l7"]}}
{"id": "concept_singly_linked_list", "type": "V_concept", "name": "Singly Linked List", "properties": {"description": "The underlying implementation structure of Haskell lists with head nodes and recursive tails.", "keywords": ["singly", "internal representation", "singly linked", "node structure", "linked", "list", "structure", "data", "linked list"], "source_lectures": ["lecture_106106931_w1_l7", "lecture_106106931_w2_l8"]}}
{"id": "concept_polymorphic_empty_list", "type": "V_concept", "name": "Polymorphic Empty List", "properties": {"description": "The property that [] can represent an empty list for any data type in Haskell.", "keywords": ["polymorphic", "empty list", "type variable", "generic"], "source_lectures": ["lecture_106106931_w1_l7"]}}
{"id": "concept_type_variable", "type": "V_concept", "name": "Type Variable", "properties": {"description": "A placeholder like 'a' in type signatures that represents any possible type.", "keywords": ["type variable", "generic type", "polymorphism", "type parameter"], "source_lectures": ["lecture_106106931_w1_l7"]}}
{"id": "concept_list_append", "type": "V_concept", "name": "List Append", "properties": {"description": "An operation that adds an element to the end of a list.", "keywords": ["list", "append", "add", "element", "end"], "source_lectures": ["lecture_106106931_w2_l8"]}}
{"id": "concept_list_indexing", "type": "V_concept", "name": "List Indexing", "properties": {"description": "A way to access elements in a list by their position or index.", "keywords": ["indexing", "access", "list", "element", "elements", "position"], "source_lectures": ["lecture_106106931_w2_l8", "lecture_106106931_w2_l11"]}}
{"id": "concept_array_indexing", "type": "V_concept", "name": "Array Indexing", "properties": {"description": "A way to access elements in an array by their position or index.", "keywords": ["array", "indexing", "access", "elements", "position"], "source_lectures": ["lecture_106106931_w2_l8"]}}
{"id": "concept_bang_operator", "type": "V_concept", "name": "Bang Operator", "properties": {"description": "An operator used in Haskell to access elements in a list by their index.", "keywords": ["bang", "operator", "haskell", "access", "elements"], "source_lectures": ["lecture_106106931_w2_l8"]}}
{"id": "concept_list_reversal", "type": "V_concept", "name": "List Reversal", "properties": {"description": "The process of reversing the order of elements in a list.", "keywords": ["list", "reversal", "reverse", "order", "elements"], "source_lectures": ["lecture_106106931_w2_l8"]}}
{"id": "concept_accumulator_technique", "type": "V_concept", "name": "Accumulator Technique", "properties": {"description": "A programming technique used to solve problems by accumulating solutions to smaller sub-problems.", "keywords": ["accumulator", "technique", "programming", "solve", "problems"], "source_lectures": ["lecture_106106931_w2_l8"]}}
{"id": "concept_standalone_program", "type": "V_concept", "name": "Standalone Program", "properties": {"description": "A program that can be compiled and run independently without the need for an interpreter or other external dependencies.", "keywords": ["standalone", "program", "compilation", "execution"], "source_lectures": ["lecture_106106931_w2_l9"]}}
{"id": "concept_input_output", "type": "V_concept", "name": "Input Output", "properties": {"description": "The process of interacting with the outside world by receiving input and producing output.", "keywords": ["input", "output", "io", "interaction"], "source_lectures": ["lecture_106106931_w2_l9"]}}
{"id": "concept_guarded_notation", "type": "V_concept", "name": "Guarded Notation", "properties": {"description": "A way of defining functions using multiple equations with guards that determine which equation to use.", "keywords": ["guarded", "notation", "function", "definition"], "source_lectures": ["lecture_106106931_w2_l9"]}}
{"id": "concept_list", "type": "V_concept", "name": "List", "properties": {"description": "A data structure consisting of a sequence of elements.", "keywords": ["list", "data structure", "sequence", "elements"], "source_lectures": ["lecture_106106931_w2_l9"]}}
{"id": "concept_append", "type": "V_concept", "name": "Append", "properties": {"description": "A function that combines two lists into a single list.", "keywords": ["append", "function", "list", "combination"], "source_lectures": ["lecture_106106931_w2_l9"]}}
{"id": "concept_reverse", "type": "V_concept", "name": "Reverse", "properties": {"description": "A function that reverses the order of elements in a list.", "keywords": ["reverse", "function", "list", "order"], "source_lectures": ["lecture_106106931_w2_l9"]}}
{"id": "concept_fibonacci_numbers", "type": "V_concept", "name": "Fibonacci Numbers", "properties": {"description": "A sequence of numbers in which each number is the sum of the two preceding numbers.", "keywords": ["fibonacci", "numbers", "sequence", "recursion"], "source_lectures": ["lecture_106106931_w2_l9"]}}
{"id": "concept_infix_notation", "type": "V_concept", "name": "Infix Notation", "properties": {"description": "A way of writing expressions where the operator is placed between the operands.", "keywords": ["infix", "notation", "operator", "operands"], "source_lectures": ["lecture_106106931_w2_l9"]}}
{"id": "concept_cons_operator", "type": "V_concept", "name": "Cons Operator", "properties": {"description": "The colon (:) operator that prepends an element to an existing list.", "keywords": ["colon", "operator", "prepend", "construction"], "source_lectures": ["lecture_106106931_w2_l10"]}}
{"id": "concept_length_function", "type": "V_concept", "name": "Length Function", "properties": {"description": "A function that computes the number of elements in a list.", "keywords": ["length", "count", "size", "list"], "source_lectures": ["lecture_106106931_w2_l10"]}}
{"id": "concept_sum_function", "type": "V_concept", "name": "Sum Function", "properties": {"description": "A function that calculates the total of all elements in a numeric list.", "keywords": ["sum", "addition", "numeric", "aggregation"], "source_lectures": ["lecture_106106931_w2_l10"]}}
{"id": "concept_last_function", "type": "V_concept", "name": "Last Function", "properties": {"description": "A function that retrieves the final element of a non-empty list.", "keywords": ["last", "element", "accessor", "list"], "source_lectures": ["lecture_106106931_w2_l10"]}}
{"id": "concept_init_function", "type": "V_concept", "name": "Init Function", "properties": {"description": "A function that returns all elements except the last in a non-empty list.", "keywords": ["init", "sublist", "prefix", "list"], "source_lectures": ["lecture_106106931_w2_l10"]}}
{"id": "concept_take_function", "type": "V_concept", "name": "Take Function", "properties": {"description": "A function that returns the first n elements of a list.", "keywords": ["haskell", "programming", "extraction", "prefix", "function", "take", "subsequence"], "source_lectures": ["lecture_106106931_w2_l10", "lecture_106106931_w2_l13"]}}
{"id": "concept_drop_function", "type": "V_concept", "name": "Drop Function", "properties": {"description": "A function that removes the first n elements and returns the remaining list.", "keywords": ["haskell", "programming", "suffix", "drop", "function", "subsequence", "removal"], "source_lectures": ["lecture_106106931_w2_l10", "lecture_106106931_w2_l13"]}}
{"id": "concept_concatenation_operator", "type": "V_concept", "name": "Concatenation Operator", "properties": {"description": "The (++) operator that combines two lists into a single list.", "keywords": ["concatenation", "operator", "append", "list"], "source_lectures": ["lecture_106106931_w2_l10"]}}
{"id": "concept_splitat_function", "type": "V_concept", "name": "SplitAt Function", "properties": {"description": "A function that divides a list into two parts at a specified index.", "keywords": ["split", "index", "partition", "list"], "source_lectures": ["lecture_106106931_w2_l10"]}}
{"id": "concept_local_definition_optimization", "type": "V_concept", "name": "Local Definition Optimization", "properties": {"description": "Using let or where clauses to avoid redundant computation in recursive functions.", "keywords": ["optimization", "recursion", "efficiency", "computation"], "source_lectures": ["lecture_106106931_w2_l10"]}}
{"id": "concept_list_homogeneity", "type": "V_concept", "name": "List Homogeneity", "properties": {"description": "The requirement that all elements in a Haskell list must share the same type.", "keywords": ["homogeneous", "type", "constraint", "list"], "source_lectures": ["lecture_106106931_w2_l10"]}}
{"id": "concept_recursive_list_processing", "type": "V_concept", "name": "Recursive List Processing", "properties": {"description": "The paradigm of defining list operations using base cases and recursive steps.", "keywords": ["recursion", "list", "processing", "algorithm"], "source_lectures": ["lecture_106106931_w2_l10"]}}
{"id": "concept_list_notation", "type": "V_concept", "name": "List Notation", "properties": {"description": "A way to represent lists in Haskell using square brackets and commas.", "keywords": ["list", "notation", "haskell", "syntax"], "source_lectures": ["lecture_106106931_w2_l11"]}}
{"id": "concept_bang_bang_operator", "type": "V_concept", "name": "Bang Bang Operator", "properties": {"description": "A built-in operator in Haskell that returns the value at a given position in a list.", "keywords": ["bang", "operator", "haskell", "list"], "source_lectures": ["lecture_106106931_w2_l11"]}}
{"id": "concept_arithmetic_progression", "type": "V_concept", "name": "Arithmetic Progression", "properties": {"description": "A sequence of numbers in which the difference between consecutive terms is constant.", "keywords": ["arithmetic", "progression", "sequence", "numbers"], "source_lectures": ["lecture_106106931_w2_l11"]}}
{"id": "concept_list_comprehension", "type": "V_concept", "name": "List Comprehension", "properties": {"description": "A way to create lists in Haskell by specifying a pattern and a condition.", "keywords": ["haskell", "programming", "generator", "list", "filter", "pattern", "comprehension"], "source_lectures": ["lecture_106106931_w2_l11", "lecture_106106931_w2_l13", "lecture_106106931_w3_l17"]}}
{"id": "concept_generator", "type": "V_concept", "name": "Generator", "properties": {"description": "A part of a list comprehension that specifies the values to be used in the list.", "keywords": ["generator", "list", "comprehension", "values"], "source_lectures": ["lecture_106106931_w2_l11"]}}
{"id": "concept_filter", "type": "V_concept", "name": "Filter", "properties": {"description": "A condition in a list comprehension that determines which values to include in the list.", "keywords": ["filter", "list", "comprehension", "condition"], "source_lectures": ["lecture_106106931_w2_l11"]}}
{"id": "concept_pythagorean_triple", "type": "V_concept", "name": "Pythagorean Triple", "properties": {"description": "A set of three numbers that satisfy the Pythagorean theorem.", "keywords": ["pythagorean", "triple", "numbers", "theorem"], "source_lectures": ["lecture_106106931_w2_l11"]}}
{"id": "concept_concat_function", "type": "V_concept", "name": "Concat Function", "properties": {"description": "A function in Haskell that concatenates a list of lists into a single list.", "keywords": ["concat", "function", "haskell", "list"], "source_lectures": ["lecture_106106931_w2_l11"]}}
{"id": "concept_as_pattern", "type": "V_concept", "name": "As Pattern", "properties": {"description": "A way to give an alias to a pattern in Haskell.", "keywords": ["as", "pattern", "haskell", "alias"], "source_lectures": ["lecture_106106931_w2_l11"]}}
{"id": "concept_ord_function", "type": "V_concept", "name": "Ord Function", "properties": {"description": "A function that returns the index of a character in the character table.", "keywords": ["ord", "function", "haskell", "character table"], "source_lectures": ["lecture_106106931_w2_l12"]}}
{"id": "concept_chr_function", "type": "V_concept", "name": "Chr Function", "properties": {"description": "A function that returns the character corresponding to a given index in the character table.", "keywords": ["chr", "function", "haskell", "character table"], "source_lectures": ["lecture_106106931_w2_l12"]}}
{"id": "concept_to_upper_function", "type": "V_concept", "name": "To Upper Function", "properties": {"description": "A function that converts a lowercase letter to uppercase.", "keywords": ["to upper", "function", "haskell", "case conversion"], "source_lectures": ["lecture_106106931_w2_l12"]}}
{"id": "concept_maybe_type", "type": "V_concept", "name": "Maybe Type", "properties": {"description": "A type that represents a value that may or may not be present, used for handling errors and exceptions.", "keywords": ["haskell", "error handling", "programming", "maybe", "type"], "source_lectures": ["lecture_106106931_w2_l12", "lecture_106106931_w2_l13"]}}
{"id": "concept_either_type", "type": "V_concept", "name": "Either Type", "properties": {"description": "A type that represents a value that can be one of two possible types, used for handling errors and exceptions.", "keywords": ["either", "type", "haskell", "error handling"], "source_lectures": ["lecture_106106931_w2_l12"]}}
{"id": "concept_list_concatenation", "type": "V_concept", "name": "List Concatenation", "properties": {"description": "The operation of combining two or more lists into a single list.", "keywords": ["list", "concatenation", "haskell", "programming"], "source_lectures": ["lecture_106106931_w2_l13"]}}
{"id": "concept_reverse_function", "type": "V_concept", "name": "Reverse Function", "properties": {"description": "A function in Haskell that returns a list with its elements in reverse order.", "keywords": ["reverse", "function", "haskell", "programming"], "source_lectures": ["lecture_106106931_w2_l13"]}}
{"id": "concept_map_function", "type": "V_concept", "name": "Map Function", "properties": {"description": "A function in Haskell that applies a given function to each element of a list.", "keywords": ["haskell", "transformation", "programming", "input", "intermediate key-value", "list", "transform", "function", "output", "map", "apply"], "source_lectures": ["lecture_106106931_w2_l13", "lecture_106106931_w2_l14", "lecture_106106931_w3_l15", "lecture_106106931_w3_l17", "lecture_106104182_w3_l19"]}}
{"id": "concept_if_expression", "type": "V_concept", "name": "If Expression", "properties": {"description": "A way to express conditional logic in Haskell using an if-then-else statement.", "keywords": ["if", "expression", "haskell", "programming"], "source_lectures": ["lecture_106106931_w2_l13"]}}
{"id": "concept_higher_order_function", "type": "V_concept", "name": "Higher Order Function", "properties": {"description": "A function that takes another function as an argument or returns a function as a result.", "keywords": ["haskell", "result", "functional programming", "argument", "parameter", "functional", "higher order", "function", "higher-order"], "source_lectures": ["lecture_106106931_w2_l14", "lecture_106106931_w3_l15", "lecture_106106931_w3_l17"]}}
{"id": "concept_filter_function", "type": "V_concept", "name": "Filter Function", "properties": {"description": "A higher-order function that selects elements from a list based on a predicate.", "keywords": ["haskell", "list", "function", "filter", "predicate", "select"], "source_lectures": ["lecture_106106931_w2_l14", "lecture_106106931_w3_l15", "lecture_106106931_w3_l17"]}}
{"id": "concept_take_while_function", "type": "V_concept", "name": "Take While Function", "properties": {"description": "A function that returns the longest prefix of a list that satisfies a given predicate.", "keywords": ["take while", "function", "list", "predicate", "haskell"], "source_lectures": ["lecture_106106931_w2_l14"]}}
{"id": "concept_drop_while_function", "type": "V_concept", "name": "Drop While Function", "properties": {"description": "A function that removes the longest prefix of a list that satisfies a given predicate.", "keywords": ["drop while", "function", "list", "predicate", "haskell"], "source_lectures": ["lecture_106106931_w2_l14"]}}
{"id": "concept_zip_function", "type": "V_concept", "name": "Zip Function", "properties": {"description": "A function that combines two lists into a list of pairs.", "keywords": ["haskell", "pair", "combine", "list", "function", "zip"], "source_lectures": ["lecture_106106931_w2_l14", "lecture_106106931_w3_l17"]}}
{"id": "concept_zip_with_function", "type": "V_concept", "name": "Zip With Function", "properties": {"description": "A function that combines two lists into a list by applying a given function to corresponding elements.", "keywords": ["zip with", "function", "list", "apply", "haskell"], "source_lectures": ["lecture_106106931_w2_l14"]}}
{"id": "concept_apply_function", "type": "V_concept", "name": "Apply Function", "properties": {"description": "A higher-order function that applies a given function to a value.", "keywords": ["apply", "function", "haskell", "apply"], "source_lectures": ["lecture_106106931_w2_l14"]}}
{"id": "concept_lambda_abstraction", "type": "V_concept", "name": "Lambda Abstraction", "properties": {"description": "A way to define small, anonymous functions in Haskell.", "keywords": ["lambda abstraction", "haskell", "functional programming", "anonymous function"], "source_lectures": ["lecture_106106931_w2_l14"]}}
{"id": "concept_fold_function", "type": "V_concept", "name": "Fold Function", "properties": {"description": "A higher-order function that applies a given function to all items in a list, accumulating a result.", "keywords": ["fold", "function", "accumulation", "list"], "source_lectures": ["lecture_106106931_w3_l15"]}}
{"id": "concept_right_fold", "type": "V_concept", "name": "Right Fold", "properties": {"description": "A fold function that accumulates results from right to left.", "keywords": ["right", "fold", "accumulation", "list"], "source_lectures": ["lecture_106106931_w3_l15"]}}
{"id": "concept_left_fold", "type": "V_concept", "name": "Left Fold", "properties": {"description": "A fold function that accumulates results from left to right.", "keywords": ["left", "fold", "accumulation", "list"], "source_lectures": ["lecture_106106931_w3_l15"]}}
{"id": "concept_anonymous_function", "type": "V_concept", "name": "Anonymous Function", "properties": {"description": "A function defined without a name, often used as an argument to higher-order functions.", "keywords": ["anonymous", "function", "lambda", "higher-order"], "source_lectures": ["lecture_106106931_w3_l15"]}}
{"id": "concept_lambda_expression", "type": "V_concept", "name": "Lambda Expression", "properties": {"description": "A notation for defining anonymous functions, using the lambda symbol.", "keywords": ["haskell", "anonymous", "syntax", "function", "expression", "lambda"], "source_lectures": ["lecture_106106931_w3_l15", "lecture_106106931_w3_l17"]}}
{"id": "concept_foldr1_function", "type": "V_concept", "name": "Foldr1 Function", "properties": {"description": "A variant of the fold function that only works on non-empty lists.", "keywords": ["foldr1", "function", "non-empty", "list"], "source_lectures": ["lecture_106106931_w3_l15"]}}
{"id": "concept_fold_right", "type": "V_concept", "name": "Fold Right", "properties": {"description": "A function that combines the elements of a list from right to left using a combining function and an initial value.", "keywords": ["haskell", "foldr", "right", "fold", "combine", "list", "recursive"], "source_lectures": ["lecture_106106931_w3_l16", "lecture_106106931_w3_l17"]}}
{"id": "concept_fold_left", "type": "V_concept", "name": "Fold Left", "properties": {"description": "A function that combines the elements of a list from left to right using a combining function and an initial value.", "keywords": ["haskell", "left", "fold", "foldl", "combine", "list", "recursive"], "source_lectures": ["lecture_106106931_w3_l16", "lecture_106106931_w3_l17"]}}
{"id": "concept_foldr1", "type": "V_concept", "name": "Foldr1", "properties": {"description": "A variant of foldr that uses the last element of the list as the initial value.", "keywords": ["foldr1", "fold", "last", "element", "haskell"], "source_lectures": ["lecture_106106931_w3_l16"]}}
{"id": "concept_foldl", "type": "V_concept", "name": "Foldl'", "properties": {"description": "A strict version of foldl that evaluates the accumulator immediately.", "keywords": ["foldl'", "foldl", "strict", "accumulator", "haskell"], "source_lectures": ["lecture_106106931_w3_l16"]}}
{"id": "concept_scanr", "type": "V_concept", "name": "Scanr", "properties": {"description": "A function that produces a list of all the partial values of a foldr operation.", "keywords": ["scanr", "foldr", "partial", "values", "haskell"], "source_lectures": ["lecture_106106931_w3_l16"]}}
{"id": "concept_scanl", "type": "V_concept", "name": "Scanl", "properties": {"description": "A function that produces a list of all the partial values of a foldl operation.", "keywords": ["scanl", "foldl", "partial", "values", "haskell"], "source_lectures": ["lecture_106106931_w3_l16"]}}
{"id": "concept_flip", "type": "V_concept", "name": "Flip", "properties": {"description": "A function that takes a function and returns a new function with the arguments in the opposite order.", "keywords": ["flip", "function", "arguments", "order", "haskell"], "source_lectures": ["lecture_106106931_w3_l16"]}}
{"id": "concept_const", "type": "V_concept", "name": "Const", "properties": {"description": "A function that takes a value and returns a function that ignores its argument and returns the original value.", "keywords": ["const", "function", "value", "ignore", "haskell"], "source_lectures": ["lecture_106106931_w3_l16"]}}
{"id": "concept_higher_order_functions", "type": "V_concept", "name": "Higher Order Functions", "properties": {"description": "Functions that take other functions as arguments or return functions as output.", "keywords": ["higher", "order", "functions", "haskell", "functional"], "source_lectures": ["lecture_106106931_w3_l16"]}}
{"id": "concept_dollar_operator", "type": "V_concept", "name": "Dollar Operator", "properties": {"description": "An infix operator in Haskell that applies a function to its argument, used to avoid parentheses by changing precedence.", "keywords": ["dollar", "operator", "haskell", "apply", "precedence"], "source_lectures": ["lecture_106106931_w3_l17"]}}
{"id": "concept_zipwith_function", "type": "V_concept", "name": "ZipWith Function", "properties": {"description": "A function that applies a binary function to corresponding elements of two lists and returns a list of results.", "keywords": ["zipwith", "binary", "function", "list", "haskell"], "source_lectures": ["lecture_106106931_w3_l17"]}}
{"id": "concept_fold_left_prime", "type": "V_concept", "name": "Fold Left Prime", "properties": {"description": "An strict version of fold left that evaluates the accumulator at each step to avoid building up large thunks.", "keywords": ["foldl'", "fold", "strict", "accumulator", "haskell"], "source_lectures": ["lecture_106106931_w3_l17"]}}
{"id": "concept_scan_left", "type": "V_concept", "name": "Scan Left", "properties": {"description": "A function that returns a list of successive accumulated values from left to right using a binary function and an initial value.", "keywords": ["scanl", "scan", "accumulate", "prefix", "haskell"], "source_lectures": ["lecture_106106931_w3_l17"]}}
{"id": "concept_scan_right", "type": "V_concept", "name": "Scan Right", "properties": {"description": "A function that returns a list of successive accumulated values from right to left using a binary function and an initial value.", "keywords": ["scanr", "scan", "accumulate", "suffix", "haskell"], "source_lectures": ["lecture_106106931_w3_l17"]}}
{"id": "concept_string_to_number_conversion", "type": "V_concept", "name": "String to Number Conversion", "properties": {"description": "A process of converting a string of digits into its corresponding integer value, often implemented using fold left.", "keywords": ["string", "number", "convert", "fold", "haskell"], "source_lectures": ["lecture_106106931_w3_l17"]}}
{"id": "concept_digit_to_integer", "type": "V_concept", "name": "Digit to Integer", "properties": {"description": "A function that converts a single character digit into its corresponding integer value.", "keywords": ["digit", "to", "integer", "convert", "haskell"], "source_lectures": ["lecture_106106931_w3_l17"]}}
{"id": "concept_precedence_in_haskell", "type": "V_concept", "name": "Precedence in Haskell", "properties": {"description": "The rules that determine the order in which operators and functions are evaluated in expressions.", "keywords": ["precedence", "operator", "evaluation", "haskell", "order"], "source_lectures": ["lecture_106106931_w3_l17"]}}
{"id": "concept_at_pattern", "type": "V_concept", "name": "At-Pattern", "properties": {"description": "A pattern-matching syntax in Haskell that binds a variable to the entire pattern while also allowing access to its components.", "keywords": ["at-pattern", "pattern", "match", "haskell", "syntax"], "source_lectures": ["lecture_106106931_w3_l17"]}}
{"id": "concept_take_while", "type": "V_concept", "name": "Take While", "properties": {"description": "A function that returns the longest prefix of a list where all elements satisfy a given predicate.", "keywords": ["takewhile", "prefix", "predicate", "list", "haskell"], "source_lectures": ["lecture_106106931_w3_l17"]}}
{"id": "concept_drop_while", "type": "V_concept", "name": "Drop While", "properties": {"description": "A function that removes elements from the beginning of a list as long as they satisfy a given predicate.", "keywords": ["dropwhile", "suffix", "predicate", "list", "haskell"], "source_lectures": ["lecture_106106931_w3_l17"]}}
{"id": "concept_list_of_functions", "type": "V_concept", "name": "List of Functions", "properties": {"description": "A list in Haskell where each element is a function, enabling functional programming patterns like applying multiple functions to a single value.", "keywords": ["list", "functions", "higher-order", "apply", "haskell"], "source_lectures": ["lecture_106106931_w3_l17"]}}
{"id": "concept_stack_overflow_haskell_context", "type": "V_concept", "name": "Stack Overflow (Haskell Context)", "properties": {"description": "A runtime error caused by excessive recursion or unevaluated thunks that exhaust the call stack memory.", "keywords": ["stack", "overflow", "thunk", "recursion", "haskell"], "source_lectures": ["lecture_106106931_w3_l17"]}}
{"id": "concept_thunk", "type": "V_concept", "name": "Thunk", "properties": {"description": "A delayed computation in Haskell that is stored unevaluated until its value is needed.", "keywords": ["thunk", "lazy", "evaluation", "delayed", "haskell"], "source_lectures": ["lecture_106106931_w3_l17"]}}
{"id": "concept_prefix_sum", "type": "V_concept", "name": "Prefix Sum", "properties": {"description": "A sequence of cumulative sums from the start of a list up to each position.", "keywords": ["prefix", "sum", "cumulative", "scanl", "haskell"], "source_lectures": ["lecture_106106931_w3_l17"]}}
{"id": "concept_suffix_sum", "type": "V_concept", "name": "Suffix Sum", "properties": {"description": "A sequence of cumulative sums from the end of a list down to each position.", "keywords": ["suffix", "sum", "cumulative", "scanr", "haskell"], "source_lectures": ["lecture_106106931_w3_l17"]}}
{"id": "concept_import_statement_haskell", "type": "V_concept", "name": "Import Statement (Haskell)", "properties": {"description": "A directive in Haskell that makes functions and types from external modules available in the current scope.", "keywords": ["import", "module", "haskell", "namespace", "scope"], "source_lectures": ["lecture_106106931_w3_l17"]}}
{"id": "concept_type_annotation", "type": "V_concept", "name": "Type Annotation", "properties": {"description": "An explicit declaration of a function's or expression's type in Haskell, used to guide type inference or resolve ambiguity.", "keywords": ["type", "annotation", "haskell", "infer", "signature"], "source_lectures": ["lecture_106106931_w3_l17"]}}
{"id": "concept_pure_function", "type": "V_concept", "name": "Pure Function", "properties": {"description": "A function that always produces the same output for the same input and has no side effects.", "keywords": ["pure", "function", "side-effect", "haskell", "referential"], "source_lectures": ["lecture_106106931_w3_l17"]}}
{"id": "concept_immutable_data", "type": "V_concept", "name": "Immutable Data", "properties": {"description": "Data in Haskell that cannot be modified after creation; all operations produce new values instead of altering existing ones.", "keywords": ["immutable", "data", "haskell", "functional", "update"], "source_lectures": ["lecture_106106931_w3_l17"]}}
{"id": "concept_indexing", "type": "V_concept", "name": "Indexing", "properties": {"description": "The process of organizing and representing documents in a way that computers can understand them for rapid searching.", "keywords": ["lucene", "search", "data structure", "organization", "documents", "inverted index", "structure", "text retrieval", "indexing", "data", "storage", "retrieval"], "source_lectures": ["lecture_106106852_w1_l1", "lecture_106106852_w1_l3", "lecture_106106852_w1_l4", "lecture_106106852_w2_l11", "lecture_106106852_w3_l18"]}}
{"id": "concept_querying", "type": "V_concept", "name": "Querying", "properties": {"description": "The process of formulating a query to retrieve relevant information from a collection of documents.", "keywords": ["querying", "search", "query", "information"], "source_lectures": ["lecture_106106852_w1_l1"]}}
{"id": "concept_ranking", "type": "V_concept", "name": "Ranking", "properties": {"description": "The process of ordering retrieved documents based on their relevance to a user's query.", "keywords": ["ranking", "relevance", "search", "documents"], "source_lectures": ["lecture_106106852_w1_l1"]}}
{"id": "concept_evaluation", "type": "V_concept", "name": "Evaluation", "properties": {"description": "The process of assessing the performance of an information retrieval system.", "keywords": ["evaluation", "performance", "search", "system"], "source_lectures": ["lecture_106106852_w1_l1"]}}
{"id": "concept_vector_space_model", "type": "V_concept", "name": "Vector Space Model", "properties": {"description": "A mathematical model used to represent documents and queries as vectors in a high-dimensional space.", "keywords": ["model", "representation", "search", "space", "vector", "document"], "source_lectures": ["lecture_106106852_w1_l1", "lecture_106106852_w1_l2"]}}
{"id": "concept_term_frequency_inverse_document_frequency", "type": "V_concept", "name": "Term Frequency-Inverse Document Frequency", "properties": {"description": "A weighting scheme used to calculate the importance of a term in a document.", "keywords": ["term", "frequency", "inverse", "document"], "source_lectures": ["lecture_106106852_w1_l1"]}}
{"id": "concept_bm25_model", "type": "V_concept", "name": "BM25 Model", "properties": {"description": "A probabilistic model used to rank documents based on their relevance to a query.", "keywords": ["bm25", "model", "probabilistic", "ranking"], "source_lectures": ["lecture_106106852_w1_l1"]}}
{"id": "concept_f_measure", "type": "V_concept", "name": "F-Measure", "properties": {"description": "A measure that combines precision and recall to evaluate the performance of a search engine.", "keywords": ["f-measure", "precision", "recall", "search"], "source_lectures": ["lecture_106106852_w1_l1"]}}
{"id": "concept_relevance_feedback", "type": "V_concept", "name": "Relevance Feedback", "properties": {"description": "A technique used to improve the performance of a search engine by incorporating user feedback.", "keywords": ["relevance", "feedback", "search", "engine"], "source_lectures": ["lecture_106106852_w1_l1"]}}
{"id": "concept_pagerank", "type": "V_concept", "name": "PageRank", "properties": {"description": "A link analysis algorithm used to rank web pages based on their importance.", "keywords": ["pagerank", "link", "analysis", "web"], "source_lectures": ["lecture_106106852_w1_l1"]}}
{"id": "concept_learning_to_rank", "type": "V_concept", "name": "Learning to Rank", "properties": {"description": "A machine learning technique used to improve the performance of a search engine.", "keywords": ["learning", "rank", "machine", "search"], "source_lectures": ["lecture_106106852_w1_l1"]}}
{"id": "concept_latent_semantic_indexing", "type": "V_concept", "name": "Latent Semantic Indexing", "properties": {"description": "A technique used to analyze the relationship between words and their contexts in a document.", "keywords": ["latent", "semantic", "indexing", "document"], "source_lectures": ["lecture_106106852_w1_l1"]}}
{"id": "concept_word_embedding", "type": "V_concept", "name": "Word Embedding", "properties": {"description": "A technique used to represent words as vectors in a high-dimensional space.", "keywords": ["word", "embedding", "vector", "space"], "source_lectures": ["lecture_106106852_w1_l1"]}}
{"id": "concept_unstructured_data", "type": "V_concept", "name": "Unstructured Data", "properties": {"description": "Data that does not have a predefined format or organization, such as free-form text.", "keywords": ["unstructured", "data", "text", "format", "organization"], "source_lectures": ["lecture_106106852_w1_l2"]}}
{"id": "concept_structured_data", "type": "V_concept", "name": "Structured Data", "properties": {"description": "Data that has a predefined format or organization, such as records in a database.", "keywords": ["structured", "data", "database", "format", "organization"], "source_lectures": ["lecture_106106852_w1_l2"]}}
{"id": "concept_query", "type": "V_concept", "name": "Query", "properties": {"description": "A user's expression of their information need, used to search for relevant documents.", "keywords": ["query", "search", "information", "need", "expression"], "source_lectures": ["lecture_106106852_w1_l2"]}}
{"id": "concept_relevance_judgment", "type": "V_concept", "name": "Relevance Judgment", "properties": {"description": "A human-assessed list of documents that are relevant to a given query.", "keywords": ["relevance", "judgment", "human", "assessment", "query"], "source_lectures": ["lecture_106106852_w1_l2"]}}
{"id": "concept_ad_hoc_retrieval", "type": "V_concept", "name": "Ad Hoc Retrieval", "properties": {"description": "A type of information retrieval where a search system is evaluated using a predefined set of queries.", "keywords": ["ad", "hoc", "retrieval", "search", "evaluation"], "source_lectures": ["lecture_106106852_w1_l2"]}}
{"id": "concept_cranfield_method", "type": "V_concept", "name": "Cranfield Method", "properties": {"description": "A methodology for evaluating the performance of information retrieval systems using a benchmark dataset.", "keywords": ["cranfield", "method", "evaluation", "benchmark", "dataset"], "source_lectures": ["lecture_106106852_w1_l2"]}}
{"id": "concept_benchmark_dataset", "type": "V_concept", "name": "Benchmark Dataset", "properties": {"description": "A standardized dataset used to evaluate the performance of information retrieval systems.", "keywords": ["benchmark", "dataset", "evaluation", "standardized", "performance"], "source_lectures": ["lecture_106106852_w1_l2"]}}
{"id": "concept_retrieval_model", "type": "V_concept", "name": "Retrieval Model", "properties": {"description": "A mathematical model used to rank documents in response to a query.", "keywords": ["retrieval", "model", "ranking", "query", "document"], "source_lectures": ["lecture_106106852_w1_l2"]}}
{"id": "concept_information_need", "type": "V_concept", "name": "Information Need", "properties": {"description": "The user's intent or goal when searching for information.", "keywords": ["information", "need", "user", "intent", "goal"], "source_lectures": ["lecture_106106852_w1_l2"]}}
{"id": "concept_uncertainty_principle", "type": "V_concept", "name": "Uncertainty Principle", "properties": {"description": "The idea that users often don't know exactly what they want or how to ask for it, making information retrieval challenging.", "keywords": ["uncertainty", "principle", "user", "information", "retrieval"], "source_lectures": ["lecture_106106852_w1_l2"]}}
{"id": "concept_bag_of_words_model", "type": "V_concept", "name": "Bag Of Words Model", "properties": {"description": "A model that represents documents and queries as a set of terms or keywords, and measures the overlap between them to determine relevance.", "keywords": ["bag", "model", "representation", "bagofwords", "text", "words", "retrieval"], "source_lectures": ["lecture_106106852_w1_l3", "lecture_106106852_w1_l4"]}}
{"id": "concept_term_overlap", "type": "V_concept", "name": "Term Overlap", "properties": {"description": "A measure of the similarity between two sets of terms, used to determine the relevance of a document to a query.", "keywords": ["term", "overlap", "similarity", "relevance"], "source_lectures": ["lecture_106106852_w1_l3"]}}
{"id": "concept_document_representation", "type": "V_concept", "name": "Document Representation", "properties": {"description": "The process of transforming a document into a structured representation, such as a list of keywords, to facilitate efficient retrieval.", "keywords": ["document", "representation", "indexing", "retrieval"], "source_lectures": ["lecture_106106852_w1_l3"]}}
{"id": "concept_text_processing", "type": "V_concept", "name": "Text Processing", "properties": {"description": "The process of cleaning, normalizing, and refining raw text data to prepare it for indexing and retrieval.", "keywords": ["text", "processing", "cleaning", "normalization"], "source_lectures": ["lecture_106106852_w1_l3"]}}
{"id": "concept_controlled_vocabulary", "type": "V_concept", "name": "Controlled Vocabulary", "properties": {"description": "A structured system of predefined terms or concepts used to describe the content of a document or dataset.", "keywords": ["controlled", "vocabulary", "taxonomy", "ontology"], "source_lectures": ["lecture_106106852_w1_l3"]}}
{"id": "concept_free_text_vocabulary", "type": "V_concept", "name": "Free Text Vocabulary", "properties": {"description": "A approach to document representation that uses all the words in a document to represent its content, without relying on a predefined vocabulary.", "keywords": ["free", "freetext", "vocabulary", "text", "document", "indexing", "words"], "source_lectures": ["lecture_106106852_w1_l3", "lecture_106106852_w1_l4"]}}
{"id": "concept_term_selection", "type": "V_concept", "name": "Term Selection", "properties": {"description": "The process of selecting the most relevant terms or keywords to represent a document or query.", "keywords": ["term", "selection", "keyword", "extraction"], "source_lectures": ["lecture_106106852_w1_l3"]}}
{"id": "concept_term_filtering", "type": "V_concept", "name": "Term Filtering", "properties": {"description": "The process of removing or filtering out irrelevant or unnecessary terms from a document or query representation.", "keywords": ["stopwords", "selection", "filtering", "stemming", "document", "term", "words", "termfiltering"], "source_lectures": ["lecture_106106852_w1_l3", "lecture_106106852_w1_l4"]}}
{"id": "concept_down_casing", "type": "V_concept", "name": "Down Casing", "properties": {"description": "The process of converting all text to lowercase to reduce variation.", "keywords": ["downcasing", "case", "folding", "text"], "source_lectures": ["lecture_106106852_w1_l4"]}}
{"id": "concept_stop_word_removal", "type": "V_concept", "name": "Stop Word Removal", "properties": {"description": "The process of removing common words that do not contribute to the meaning of a document.", "keywords": ["word", "meaning", "stopwords", "stop word", "common", "filtering", "text", "stopword", "nlp", "stop", "ir", "processing", "text preprocessing", "removal"], "source_lectures": ["lecture_106106852_w1_l4", "lecture_106106852_w1_l5", "lecture_106106852_w3_l18", "lecture_106106852_w3_l21"]}}
{"id": "concept_lemmatization", "type": "V_concept", "name": "Lemmatization", "properties": {"description": "A process of reducing words to their base or dictionary form.", "keywords": ["lemmatization", "linguistic", "processing", "words"], "source_lectures": ["lecture_106106852_w1_l4"]}}
{"id": "concept_porter_stemmer", "type": "V_concept", "name": "Porter Stemmer", "properties": {"description": "A rule-based stemming algorithm for the English language.", "keywords": ["stemmer", "inflection", "porter", "porter stemmer", "stemming", "english", "word root", "rulebased"], "source_lectures": ["lecture_106106852_w1_l4", "lecture_106106852_w3_l18"]}}
{"id": "concept_linguistic_processing", "type": "V_concept", "name": "Linguistic Processing", "properties": {"description": "The process of analyzing and understanding the linguistic structure of text.", "keywords": ["linguistic", "processing", "text", "analysis"], "source_lectures": ["lecture_106106852_w1_l4"]}}
{"id": "concept_term_document_incidence_matrix", "type": "V_concept", "name": "Term Document Incidence Matrix", "properties": {"description": "A matrix that records the presence or absence of terms in a collection of documents", "keywords": ["incidence", "matrix", "term", "document", "indexing"], "source_lectures": ["lecture_106106852_w1_l5"]}}
{"id": "concept_boolean_retrieval_model", "type": "V_concept", "name": "Boolean Retrieval Model", "properties": {"description": "A retrieval model that uses boolean constraints to represent a user's information need", "keywords": ["boolean", "retrieval", "model", "query", "logic"], "source_lectures": ["lecture_106106852_w1_l5"]}}
{"id": "concept_term_incidence_vector", "type": "V_concept", "name": "Term Incidence Vector", "properties": {"description": "A vector that represents the presence or absence of a term in a collection of documents", "keywords": ["incidence", "vector", "document", "term", "indexing", "information"], "source_lectures": ["lecture_106106852_w1_l5", "lecture_106106852_w1_l7"]}}
{"id": "concept_document_incidence_vector", "type": "V_concept", "name": "Document Incidence Vector", "properties": {"description": "A vector that represents the terms present in a document", "keywords": ["incidence", "vector", "document", "term", "indexing"], "source_lectures": ["lecture_106106852_w1_l5"]}}
{"id": "concept_proximity_query", "type": "V_concept", "name": "Proximity Query", "properties": {"description": "A type of query that searches for terms within a certain distance of each other", "keywords": ["distance", "information retrieval", "proximity", "search", "query", "nearness search", "proximity query", "term", "position-based", "term distance"], "source_lectures": ["lecture_106106852_w1_l5", "lecture_106106852_w2_l9"]}}
{"id": "concept_ranked_retrieval", "type": "V_concept", "name": "Ranked Retrieval", "properties": {"description": "The process of returning search results in a ranked order of relevance", "keywords": ["ranked", "retrieval", "search", "result", "relevance"], "source_lectures": ["lecture_106106852_w1_l5"]}}
{"id": "concept_forward_index", "type": "V_concept", "name": "Forward Index", "properties": {"description": "A data structure that maps documents to their contents", "keywords": ["forward", "index", "documents", "contents"], "source_lectures": ["lecture_106106852_w1_l6"]}}
{"id": "concept_dictionary", "type": "V_concept", "name": "Dictionary", "properties": {"description": "A sorted list of distinct terms in a collection", "keywords": ["code", "word", "instruction", "dictionary", "list", "structure", "sorted", "terms", "information", "data", "retrieval"], "source_lectures": ["lecture_106106852_w1_l6", "lecture_106106852_w1_l7", "lecture_106102229_w1_l7"]}}
{"id": "concept_posting_list", "type": "V_concept", "name": "Posting List", "properties": {"description": "A list of document IDs where a term appears", "keywords": ["posting list", "document ids", "posting", "id", "inverted index", "list", "ids", "document", "term", "information", "term occurrences", "retrieval"], "source_lectures": ["lecture_106106852_w1_l6", "lecture_106106852_w1_l7", "lecture_106106852_w2_l8", "lecture_106106852_w2_l9", "lecture_106106852_w2_l10"]}}
{"id": "concept_binary_search", "type": "V_concept", "name": "Binary Search", "properties": {"description": "An efficient algorithm for finding an item in a sorted list", "keywords": ["binary", "search", "algorithm", "sorted", "list"], "source_lectures": ["lecture_106106852_w1_l6"]}}
{"id": "concept_skip_pointers", "type": "V_concept", "name": "Skip Pointers", "properties": {"description": "A technique for speeding up the merging of posting lists", "keywords": ["skip", "pointers", "merging", "posting", "lists"], "source_lectures": ["lecture_106106852_w1_l6"]}}
{"id": "concept_term_document_mapping", "type": "V_concept", "name": "Term-Document Mapping", "properties": {"description": "A mapping of terms to the documents that contain them", "keywords": ["term", "document", "mapping", "inverted", "index"], "source_lectures": ["lecture_106106852_w1_l6"]}}
{"id": "concept_document_id", "type": "V_concept", "name": "Document ID", "properties": {"description": "A unique identifier for a document in a collection", "keywords": ["document", "id", "unique", "identifier"], "source_lectures": ["lecture_106106852_w1_l6"]}}
{"id": "concept_collection_frequency", "type": "V_concept", "name": "Collection Frequency", "properties": {"description": "The total number of times a term appears in a corpus", "keywords": ["collection", "cf", "corpus", "inverted index", "term count", "collection frequency", "information", "total occurrences", "frequency", "retrieval"], "source_lectures": ["lecture_106106852_w1_l7", "lecture_106106852_w2_l9"]}}
{"id": "concept_lexographical_sorting", "type": "V_concept", "name": "Lexographical Sorting", "properties": {"description": "A method of sorting words or terms in alphabetical order", "keywords": ["lexographical", "sorting", "alphabetical", "order", "information"], "source_lectures": ["lecture_106106852_w1_l7"]}}
{"id": "concept_boolean_retrieval", "type": "V_concept", "name": "Boolean Retrieval", "properties": {"description": "A method of information retrieval that returns documents based on the presence or absence of specific terms", "keywords": ["presence/absence", "boolean retrieval", "absence", "presence", "boolean", "exact match", "binary search", "ir model", "information", "retrieval"], "source_lectures": ["lecture_106106852_w1_l7", "lecture_106106852_w2_l9"]}}
{"id": "concept_primary_memory", "type": "V_concept", "name": "Primary Memory", "properties": {"description": "The fastest and most volatile type of computer memory, also known as RAM.", "keywords": ["primary", "memory", "ram", "volatile", "fast"], "source_lectures": ["lecture_106106852_w2_l8"]}}
{"id": "concept_secondary_memory", "type": "V_concept", "name": "Secondary Memory", "properties": {"description": "A type of computer memory that is non-volatile and used for long-term storage, such as hard drives or solid-state drives.", "keywords": ["secondary", "memory", "nonvolatile", "storage", "disk"], "source_lectures": ["lecture_106106852_w2_l8"]}}
{"id": "concept_in_memory_index_construction", "type": "V_concept", "name": "In-Memory Index Construction", "properties": {"description": "A method of building an inverted index entirely in primary memory.", "keywords": ["inmemory", "index", "construction", "primary", "memory"], "source_lectures": ["lecture_106106852_w2_l8"]}}
{"id": "concept_disk_based_index_construction", "type": "V_concept", "name": "Disk-Based Index Construction", "properties": {"description": "A method of building an inverted index using secondary storage.", "keywords": ["diskbased", "index", "construction", "secondary", "storage"], "source_lectures": ["lecture_106106852_w2_l8"]}}
{"id": "concept_sorting", "type": "V_concept", "name": "Sorting", "properties": {"description": "The process of arranging data in a specific order, such as lexicographical order.", "keywords": ["sorting", "data", "order", "lexicographical", "arranging"], "source_lectures": ["lecture_106106852_w2_l8"]}}
{"id": "concept_merging", "type": "V_concept", "name": "Merging", "properties": {"description": "The process of combining multiple sorted lists into a single sorted list.", "keywords": ["merging", "sorted", "lists", "combining", "processing"], "source_lectures": ["lecture_106106852_w2_l8"]}}
{"id": "concept_hash_based_dictionary", "type": "V_concept", "name": "Hash-Based Dictionary", "properties": {"description": "A data structure that uses a hash function to map terms to their locations in a dictionary.", "keywords": ["hashbased", "dictionary", "hash", "function", "mapping"], "source_lectures": ["lecture_106106852_w2_l8"]}}
{"id": "concept_sort_based_dictionary", "type": "V_concept", "name": "Sort-Based Dictionary", "properties": {"description": "A data structure that stores terms in a sorted order, allowing for efficient lookup using binary search.", "keywords": ["sortbased", "dictionary", "sorted", "binary", "search"], "source_lectures": ["lecture_106106852_w2_l8"]}}
{"id": "concept_term_id", "type": "V_concept", "name": "Term ID", "properties": {"description": "A unique identifier assigned to each term in a dictionary.", "keywords": ["term", "id", "identifier", "dictionary", "unique"], "source_lectures": ["lecture_106106852_w2_l8"]}}
{"id": "concept_external_sorting", "type": "V_concept", "name": "External Sorting", "properties": {"description": "A technique used to sort large datasets that do not fit in primary memory.", "keywords": ["external", "sorting", "large", "datasets", "primary"], "source_lectures": ["lecture_106106852_w2_l8"]}}
{"id": "concept_blocked_sort_based_indexing", "type": "V_concept", "name": "Blocked Sort-Based Indexing", "properties": {"description": "A method of building an inverted index by processing documents in blocks and sorting them before merging.", "keywords": ["blocked", "sortbased", "indexing", "documents", "blocks"], "source_lectures": ["lecture_106106852_w2_l8"]}}
{"id": "concept_single_pass_in_memory_indexing", "type": "V_concept", "name": "Single Pass In-Memory Indexing", "properties": {"description": "A method of building an inverted index by creating posting lists on the fly using a hash-based dictionary.", "keywords": ["single", "pass", "inmemory", "indexing", "hashbased"], "source_lectures": ["lecture_106106852_w2_l8"]}}
{"id": "concept_dictionary_lexicon", "type": "V_concept", "name": "Dictionary (Lexicon)", "properties": {"description": "The component of an inverted index that contains all unique terms in the vocabulary along with metadata such as document frequency and collection frequency.", "keywords": ["dictionary", "lexicon", "vocabulary", "term metadata", "document frequency"], "source_lectures": ["lecture_106106852_w2_l9"]}}
{"id": "concept_phrase_query", "type": "V_concept", "name": "Phrase Query", "properties": {"description": "A query that retrieves documents containing a specific sequence of terms in a given order, often enabled by storing term positions in the inverted index.", "keywords": ["phrase query", "ordered terms", "term sequence", "position-based search", "information retrieval"], "source_lectures": ["lecture_106106852_w2_l9"]}}
{"id": "concept_term_position_offset", "type": "V_concept", "name": "Term Position Offset", "properties": {"description": "The location (e.g., word index) of a term within a document, stored in the posting list to support phrase and proximity queries.", "keywords": ["term position", "offset", "word index", "position storage", "inverted index"], "source_lectures": ["lecture_106106852_w2_l9"]}}
{"id": "concept_corpus", "type": "V_concept", "name": "Corpus", "properties": {"description": "The complete set of documents in an information retrieval system, used as the source for indexing and querying.", "keywords": ["text corpus", "corpus", "dataset", "document collection", "ir collection", "ir"], "source_lectures": ["lecture_106106852_w2_l9", "lecture_106106852_w3_l18"]}}
{"id": "concept_query_term", "type": "V_concept", "name": "Query Term", "properties": {"description": "An individual term within a user's search query that is used to match against terms in the inverted index.", "keywords": ["query term", "q", "search term", "query component", "information retrieval"], "source_lectures": ["lecture_106106852_w2_l9"]}}
{"id": "concept_binary_search_in_dictionary", "type": "V_concept", "name": "Binary Search in Dictionary", "properties": {"description": "An efficient search algorithm used to locate a term in a sorted dictionary of an inverted index.", "keywords": ["binary search", "sorted dictionary", "term lookup", "index search", "information retrieval"], "source_lectures": ["lecture_106106852_w2_l9"]}}
{"id": "concept_hash_based_dictionary_lookup", "type": "V_concept", "name": "Hash-Based Dictionary Lookup", "properties": {"description": "A method for quickly locating a term in the dictionary using a hash function, typically used when the dictionary is not sorted.", "keywords": ["hash lookup", "dictionary search", "term retrieval", "hash function", "inverted index"], "source_lectures": ["lecture_106106852_w2_l9"]}}
{"id": "concept_merging_posting_lists", "type": "V_concept", "name": "Merging Posting Lists", "properties": {"description": "The process of intersecting multiple posting lists to find documents containing all query terms, commonly used in boolean retrieval.", "keywords": ["merging", "posting list intersection", "boolean AND", "query processing", "information retrieval"], "source_lectures": ["lecture_106106852_w2_l9"]}}
{"id": "concept_relevance_ranking_by_term_frequency", "type": "V_concept", "name": "Relevance Ranking by Term Frequency", "properties": {"description": "The assumption that documents with higher term frequency for a query term are more relevant to that query.", "keywords": ["relevance ranking", "term frequency", "relevance signal", "ranking assumption", "information retrieval"], "source_lectures": ["lecture_106106852_w2_l9"]}}
{"id": "concept_index_compression", "type": "V_concept", "name": "Index Compression", "properties": {"description": "The process of reducing the storage size of an inverted index to save memory and improve search efficiency.", "keywords": ["index compression", "storage optimization", "memory efficiency", "inverted index", "information retrieval"], "source_lectures": ["lecture_106106852_w2_l9"]}}
{"id": "concept_document_identifier_docid", "type": "V_concept", "name": "Document Identifier (DocID)", "properties": {"description": "A unique identifier assigned to each document in a collection for referencing in posting lists.", "keywords": ["docid", "document id", "unique identifier", "posting list entry", "inverted index"], "source_lectures": ["lecture_106106852_w2_l9"]}}
{"id": "concept_lossy_compression", "type": "V_concept", "name": "Lossy Compression", "properties": {"description": "A type of compression that discards some data to reduce the size of the compressed file.", "keywords": ["lossy", "compression", "data", "reduction"], "source_lectures": ["lecture_106106852_w2_l10"]}}
{"id": "concept_lossless_compression", "type": "V_concept", "name": "Lossless Compression", "properties": {"description": "A type of compression that preserves all the original data and allows for exact reconstruction.", "keywords": ["lossless", "compression", "preservation", "reconstruction"], "source_lectures": ["lecture_106106852_w2_l10"]}}
{"id": "concept_vocabulary_mismatch", "type": "V_concept", "name": "Vocabulary Mismatch", "properties": {"description": "A challenge in information retrieval where the same concept can be expressed in different words or phrases.", "keywords": ["vocabulary", "mismatch", "information", "retrieval"], "source_lectures": ["lecture_106106852_w2_l10"]}}
{"id": "concept_zipfs_law", "type": "V_concept", "name": "Zipf's Law", "properties": {"description": "A statistical property of text that states the frequency of a word is inversely proportional to its rank.", "keywords": ["zipf", "law", "statistical", "property"], "source_lectures": ["lecture_106106852_w2_l10"]}}
{"id": "concept_dictionary_compression", "type": "V_concept", "name": "Dictionary Compression", "properties": {"description": "The process of reducing the size of a dictionary or vocabulary in an information retrieval system.", "keywords": ["dictionary", "compression", "information", "retrieval"], "source_lectures": ["lecture_106106852_w2_l10"]}}
{"id": "concept_zips_law", "type": "V_concept", "name": "Zip's Law", "properties": {"description": "A mathematical principle that describes the relationship between the frequency of a term and its rank in a collection of text", "keywords": ["zip's law", "frequency", "rank", "text analysis"], "source_lectures": ["lecture_106106852_w2_l11"]}}
{"id": "concept_heaps_law", "type": "V_concept", "name": "Heap's Law", "properties": {"description": "A mathematical principle that describes the relationship between the size of a collection and the growth of its vocabulary", "keywords": ["heap's law", "vocabulary growth", "text analysis"], "source_lectures": ["lecture_106106852_w2_l11"]}}
{"id": "concept_mandelbrots_law", "type": "V_concept", "name": "Mandelbrot's Law", "properties": {"description": "A modification of Zip's Law that captures the behavior of rare terms in a collection of text", "keywords": ["mandelbrot's law", "rare terms", "text analysis"], "source_lectures": ["lecture_106106852_w2_l11"]}}
{"id": "concept_rank_based_analysis", "type": "V_concept", "name": "Rank-Based Analysis", "properties": {"description": "A method of analyzing text data based on the rank of terms in a collection", "keywords": ["rank-based analysis", "text analysis", "rank"], "source_lectures": ["lecture_106106852_w2_l11"]}}
{"id": "concept_vocabulary_size", "type": "V_concept", "name": "Vocabulary Size", "properties": {"description": "The number of unique words in a collection of text", "keywords": ["vocabulary size", "text analysis", "unique words"], "source_lectures": ["lecture_106106852_w2_l11"]}}
{"id": "concept_corpus_growth", "type": "V_concept", "name": "Corpus Growth", "properties": {"description": "The process of adding new text data to an existing collection", "keywords": ["corpus growth", "text analysis", "collection growth"], "source_lectures": ["lecture_106106852_w2_l11"]}}
{"id": "concept_whitespace_analyzer", "type": "V_concept", "name": "Whitespace Analyzer", "properties": {"description": "A Lucene analyzer that tokenizes text solely based on whitespace characters, without lowercasing, stop word removal, or stemming.", "keywords": ["whitespace analyzer", "lucene", "tokenization", "whitespace", "no preprocessing"], "source_lectures": ["lecture_106106852_w3_l18"]}}
{"id": "concept_custom_stop_word_list", "type": "V_concept", "name": "Custom Stop Word List", "properties": {"description": "A user-defined set of words to be excluded during text analysis, overriding default stop word lists in analyzers like EnglishAnalyzer.", "keywords": ["configuration", "custom", "stop word list", "custom stop words", "list", "stopword", "analysis", "text", "analyzer tuning", "text preprocessing"], "source_lectures": ["lecture_106106852_w3_l18", "lecture_106106852_w3_l21"]}}
{"id": "concept_chararrayset", "type": "V_concept", "name": "CharArraySet", "properties": {"description": "A Lucene data structure used to store collections of strings (e.g., stop words) with options for case sensitivity and efficient lookup.", "keywords": ["chararrayset", "lucene", "stop words", "set", "case insensitive"], "source_lectures": ["lecture_106106852_w3_l18"]}}
{"id": "concept_stringreader", "type": "V_concept", "name": "StringReader", "properties": {"description": "A Java class used to wrap a string as an input stream for text analysis in Lucene, enabling tokenization by analyzers.", "keywords": ["stringreader", "java", "input stream", "text input", "lucene"], "source_lectures": ["lecture_106106852_w3_l18"]}}
{"id": "concept_tokenstream", "type": "V_concept", "name": "TokenStream", "properties": {"description": "A Lucene class that represents a sequence of tokens produced by an analyzer, used to iterate through processed text elements.", "keywords": ["tokenstream", "lucene", "token", "analysis", "iteration"], "source_lectures": ["lecture_106106852_w3_l18"]}}
{"id": "concept_termattribute", "type": "V_concept", "name": "TermAttribute", "properties": {"description": "A Lucene attribute interface that provides access to the textual content of a token during analysis.", "keywords": ["termattribute", "lucene", "token", "attribute", "text content"], "source_lectures": ["lecture_106106852_w3_l18"]}}
{"id": "concept_indexwriter", "type": "V_concept", "name": "IndexWriter", "properties": {"description": "A Lucene class responsible for creating and updating an inverted index by applying analyzers to documents and storing results in a directory.", "keywords": ["indexwriter", "lucene", "inverted index", "indexing", "document storage"], "source_lectures": ["lecture_106106852_w3_l18"]}}
{"id": "concept_indexwriterconfig", "type": "V_concept", "name": "IndexWriterConfig", "properties": {"description": "A Lucene configuration class that defines analyzer and other settings used by IndexWriter to process and index documents.", "keywords": ["indexwriterconfig", "lucene", "analyzer", "index configuration", "indexing settings"], "source_lectures": ["lecture_106106852_w3_l18"]}}
{"id": "concept_fsdirectory", "type": "V_concept", "name": "FSDirectory", "properties": {"description": "A Lucene class that represents a file system-based directory for storing persistent inverted indexes.", "keywords": ["fsdirectory", "lucene", "file system", "index storage", "persistent"], "source_lectures": ["lecture_106106852_w3_l18"]}}
{"id": "concept_ramdirectory", "type": "V_concept", "name": "RAMDirectory", "properties": {"description": "A Lucene class that represents an in-memory directory for storing temporary or volatile inverted indexes.", "keywords": ["ramdirectory", "lucene", "in memory", "index storage", "volatile"], "source_lectures": ["lecture_106106852_w3_l18"]}}
{"id": "concept_language_specific_analyzer", "type": "V_concept", "name": "Language-Specific Analyzer", "properties": {"description": "A Lucene analyzer designed for a specific natural language (e.g., English, German, Hindi) with tailored tokenization, stop word, and stemming rules.", "keywords": ["language analyzer", "characteristics", "linguistic", "language specific", "lucene", "specific", "multilingual", "analyzer", "language", "text processing"], "source_lectures": ["lecture_106106852_w3_l18", "lecture_106106852_w3_l21"]}}
{"id": "concept_case_folding", "type": "V_concept", "name": "Case Folding", "properties": {"description": "The process of converting all text to a uniform case (typically lowercase) to ensure case-insensitive matching during text analysis.", "keywords": ["case folding", "lowercase", "case insensitive", "text normalization", "tokenization"], "source_lectures": ["lecture_106106852_w3_l18"]}}
{"id": "concept_hindi_analyzer", "type": "V_concept", "name": "Hindi Analyzer", "properties": {"description": "A Lucene analyzer designed to process Hindi text, supporting Unicode and language-specific tokenization and normalization rules.", "keywords": ["language specific", "lucene", "analyzer", "hindi", "hindi analyzer", "language", "unicode"], "source_lectures": ["lecture_106106852_w3_l18", "lecture_106106852_w4_l25"]}}
{"id": "concept_bengali_analyzer", "type": "V_concept", "name": "Bengali Analyzer", "properties": {"description": "A Lucene analyzer tailored for Bengali text, enabling tokenization and processing of Unicode-based Bengali script.", "keywords": ["bengali analyzer", "lucene", "bengali", "unicode", "language specific"], "source_lectures": ["lecture_106106852_w3_l18"]}}
{"id": "concept_analyzer_configuration", "type": "V_concept", "name": "Analyzer Configuration", "properties": {"description": "The process of selecting and customizing a Lucene analyzer (e.g., stop words, stemming, case handling) to match the language and requirements of a document corpus.", "keywords": ["analyzer configuration", "lucene", "text processing", "customization", "indexing"], "source_lectures": ["lecture_106106852_w3_l18"]}}
{"id": "concept_document_parsing", "type": "V_concept", "name": "Document Parsing", "properties": {"description": "The initial step in information retrieval where raw documents are read and prepared for analysis, often using libraries like pandas.", "keywords": ["document parsing", "text extraction", "data preparation", "pandas", "corpus"], "source_lectures": ["lecture_106106852_w3_l18"]}}
{"id": "concept_lucene", "type": "V_concept", "name": "Lucene", "properties": {"description": "An open-source Java library for full-text search and information retrieval, widely used for building search engines and indexing systems.", "keywords": ["lucene", "search engine", "information retrieval", "java", "text indexing"], "source_lectures": ["lecture_106106852_w3_l18"]}}
{"id": "concept_unicode_support", "type": "V_concept", "name": "Unicode Support", "properties": {"description": "The ability of a system to process and store text in multiple languages using the Unicode standard, essential for multilingual text analysis.", "keywords": ["unicode", "multilingual", "text encoding", "utf-8", "internationalization"], "source_lectures": ["lecture_106106852_w3_l18"]}}
{"id": "concept_case_sensitivity", "type": "V_concept", "name": "Case Sensitivity", "properties": {"description": "A property of text processing where uppercase and lowercase letters are treated as distinct characters, often disabled in IR systems for robust matching.", "keywords": ["case sensitivity", "case insensitive", "text matching", "tokenization", "normalization"], "source_lectures": ["lecture_106106852_w3_l18"]}}
{"id": "concept_analyzer_pipeline", "type": "V_concept", "name": "Analyzer Pipeline", "properties": {"description": "The sequence of processing steps (tokenization, lowercasing, stop word removal, stemming) applied by a Lucene analyzer to transform raw text into indexed tokens.", "keywords": ["analyzer pipeline", "text processing", "lucene", "tokenization", "stemming"], "source_lectures": ["lecture_106106852_w3_l18"]}}
{"id": "concept_language_analyzer", "type": "V_concept", "name": "Language Analyzer", "properties": {"description": "A tool used to analyze text in a specific language, handling tasks such as tokenization, stemming, and stop word removal.", "keywords": ["language", "analyzer", "tokenization", "stemming", "stopword"], "source_lectures": ["lecture_106106852_w3_l21"]}}
{"id": "concept_apache_lucene", "type": "V_concept", "name": "Apache Lucene", "properties": {"description": "A Java library used for information retrieval and text analysis, providing a wide range of tools and techniques for searching and indexing data.", "keywords": ["lucene", "apache", "information", "retrieval", "text"], "source_lectures": ["lecture_106106852_w3_l21"]}}
{"id": "concept_multilingual_indexing", "type": "V_concept", "name": "Multilingual Indexing", "properties": {"description": "The process of creating an index that can handle text data in multiple languages, allowing for more efficient searching and retrieval.", "keywords": ["multilingual", "indexing", "text", "data", "searching"], "source_lectures": ["lecture_106106852_w3_l21"]}}
{"id": "concept_analyzer_initialization", "type": "V_concept", "name": "Analyzer Initialization", "properties": {"description": "The process of setting up an analyzer to work with a specific language or set of languages, involving the importation of language-specific packages and classes.", "keywords": ["analyzer", "initialization", "language", "package", "class"], "source_lectures": ["lecture_106106852_w3_l21"]}}
{"id": "concept_indexing_phase", "type": "V_concept", "name": "Indexing Phase", "properties": {"description": "The process of organizing and storing data in a way that allows for efficient retrieval", "keywords": ["indexing", "data", "retrieval", "organization"], "source_lectures": ["lecture_106106852_w4_l25"]}}
{"id": "concept_lucene_analyzer", "type": "V_concept", "name": "Lucene Analyzer", "properties": {"description": "A component of the Lucene search engine library that analyzes text and breaks it down into individual words or tokens", "keywords": ["lucene", "analyzer", "text", "tokenization"], "source_lectures": ["lecture_106106852_w4_l25"]}}
{"id": "concept_pandas_library", "type": "V_concept", "name": "Pandas Library", "properties": {"description": "A Python library used for data manipulation and analysis", "keywords": ["pandas", "library", "python", "data"], "source_lectures": ["lecture_106106852_w4_l25"]}}
{"id": "concept_stringio_package", "type": "V_concept", "name": "StringIO Package", "properties": {"description": "A Python package that allows for reading and writing strings as if they were files", "keywords": ["stringio", "package", "python", "strings"], "source_lectures": ["lecture_106106852_w4_l25"]}}
{"id": "concept_csv_format", "type": "V_concept", "name": "CSV Format", "properties": {"description": "A file format used for storing tabular data, with values separated by commas", "keywords": ["csv", "format", "tabular", "data"], "source_lectures": ["lecture_106106852_w4_l25"]}}
{"id": "concept_field_store", "type": "V_concept", "name": "Field Store", "properties": {"description": "A parameter in the Lucene search engine library that determines whether a field's value is stored in the index", "keywords": ["field", "store", "lucene", "index"], "source_lectures": ["lecture_106106852_w4_l25"]}}
{"id": "concept_encryption_scheme", "type": "V_concept", "name": "Encryption Scheme", "properties": {"description": "A set of algorithms used to encrypt and decrypt data, ensuring the confidentiality and integrity of the information.", "keywords": ["privacy", "security", "encryption", "scheme", "algorithm", "cryptography"], "source_lectures": ["lecture_106108229_w1_l1", "lecture_106108229_w3_l15"]}}
{"id": "concept_privacy_preserving_computation", "type": "V_concept", "name": "Privacy Preserving Computation", "properties": {"description": "A technique that enables computations to be performed on private data without revealing the data itself, ensuring the confidentiality and privacy of the information.", "keywords": ["privacy", "preserving", "computation", "cryptography", "security"], "source_lectures": ["lecture_106108229_w1_l1"]}}
{"id": "concept_confidentiality", "type": "V_concept", "name": "Confidentiality", "properties": {"description": "The property of ensuring that information is only accessible to authorized parties, protecting it from unauthorized access or disclosure.", "keywords": ["confidentiality", "privacy", "security", "cryptography", "access"], "source_lectures": ["lecture_106108229_w1_l1"]}}
{"id": "concept_authenticity", "type": "V_concept", "name": "Authenticity", "properties": {"description": "The property of ensuring that the information received is genuine and has not been tampered with or altered during transmission.", "keywords": ["authenticity", "security", "cryptography", "integrity", "verification"], "source_lectures": ["lecture_106108229_w1_l1"]}}
{"id": "concept_integrity", "type": "V_concept", "name": "Integrity", "properties": {"description": "The property of ensuring that the information received is accurate and has not been modified or tampered with during transmission.", "keywords": ["integrity", "security", "cryptography", "authenticity", "verification"], "source_lectures": ["lecture_106108229_w1_l1"]}}
{"id": "concept_publicly_known_function", "type": "V_concept", "name": "Publicly Known Function", "properties": {"description": "A mathematical function whose details are publicly available, used in secure multi-party computation to perform computations on private data.", "keywords": ["publicly", "known", "function", "cryptography", "computation"], "source_lectures": ["lecture_106108229_w1_l1"]}}
{"id": "concept_mutually_distrusting_parties", "type": "V_concept", "name": "Mutually Distrusting Parties", "properties": {"description": "Parties that do not trust each other, requiring secure protocols to perform computations on their private data without revealing their inputs.", "keywords": ["mutually", "distrusting", "parties", "cryptography", "security"], "source_lectures": ["lecture_106108229_w1_l1"]}}
{"id": "concept_secure_online_dating", "type": "V_concept", "name": "Secure Online Dating", "properties": {"description": "A system that enables individuals to find compatible matches while keeping their personal information private.", "keywords": ["secure", "online", "dating", "privacy", "system"], "source_lectures": ["lecture_106108229_w1_l2"]}}
{"id": "concept_homomorphic_encryption", "type": "V_concept", "name": "Homomorphic Encryption", "properties": {"description": "A form of encryption that allows computations to be performed on ciphertext without decrypting it first.", "keywords": ["homomorphic", "encryption", "ciphertext", "computation", "security"], "source_lectures": ["lecture_106108229_w1_l2"]}}
{"id": "concept_distributed_computing", "type": "V_concept", "name": "Distributed Computing", "properties": {"description": "A model of computing where multiple computers or nodes work together to achieve a common goal.", "keywords": ["nodes", "computing", "parallel", "network", "distributed"], "source_lectures": ["lecture_106108229_w1_l2", "lecture_106104182_w1_l1"]}}
{"id": "concept_secure_computation_protocol", "type": "V_concept", "name": "Secure Computation Protocol", "properties": {"description": "A set of rules and procedures that enable secure computation on private data.", "keywords": ["private", "privacy", "multi-party", "protocol", "secure computation", "computation", "secure", "data"], "source_lectures": ["lecture_106108229_w1_l2", "lecture_106108229_w4_l23"]}}
{"id": "concept_private_data_analysis", "type": "V_concept", "name": "Private Data Analysis", "properties": {"description": "A technique that enables analysis of private data without compromising the privacy of the individuals involved.", "keywords": ["private", "data", "analysis", "privacy", "technique"], "source_lectures": ["lecture_106108229_w1_l2"]}}
{"id": "concept_symmetric_encryption", "type": "V_concept", "name": "Symmetric Encryption", "properties": {"description": "A type of encryption where the same key is used for both encryption and decryption.", "keywords": ["cryptographic", "symmetric", "security", "encryption", "secure", "key", "cryptography"], "source_lectures": ["lecture_106108229_w1_l6", "lecture_106108229_w7_l49"]}}
{"id": "concept_asymmetric_encryption", "type": "V_concept", "name": "Asymmetric Encryption", "properties": {"description": "A type of encryption where a pair of keys is used, one for encryption and another for decryption.", "keywords": ["asymmetric", "encryption", "key", "security", "cryptography"], "source_lectures": ["lecture_106108229_w1_l6"]}}
{"id": "concept_cryptography_primitive", "type": "V_concept", "name": "Cryptography Primitive", "properties": {"description": "A basic building block of a cryptographic system, such as encryption or decryption.", "keywords": ["cryptography", "primitive", "security", "encryption", "decryption"], "source_lectures": ["lecture_106108229_w1_l6"]}}
{"id": "concept_private_key", "type": "V_concept", "name": "Private Key", "properties": {"description": "A secret key used for decryption in asymmetric encryption.", "keywords": ["private", "cryptography", "security", "encryption", "authentication", "asymmetric", "key"], "source_lectures": ["lecture_106108229_w1_l6", "lecture_106108229_w7_l48"]}}
{"id": "concept_public_key_infrastructure", "type": "V_concept", "name": "Public Key Infrastructure", "properties": {"description": "A system for managing public-private key pairs and digital certificates.", "keywords": ["public", "security", "infrastructure", "authentication", "key exchange", "public key", "key", "cryptography"], "source_lectures": ["lecture_106108229_w1_l6", "lecture_106106221_w6_l39", "lecture_106106221_w8_l51"]}}
{"id": "concept_access_structure", "type": "V_concept", "name": "Access Structure", "properties": {"description": "A collection of authorized subsets of parties that are allowed to access a shared secret.", "keywords": ["subsets", "parties", "secret", "authorized", "access", "structure", "sharing"], "source_lectures": ["lecture_106108229_w1_l7", "lecture_106108229_w2_l8", "lecture_106108229_w2_l14"]}}
{"id": "concept_forbidden_structure", "type": "V_concept", "name": "Forbidden Structure", "properties": {"description": "A collection of unauthorized subsets of parties that are not allowed to access a shared secret.", "keywords": ["unauthorized", "subsets", "parties", "secret", "forbidden", "structure", "sharing"], "source_lectures": ["lecture_106108229_w1_l7", "lecture_106108229_w2_l8"]}}
{"id": "concept_threshold_secret_sharing", "type": "V_concept", "name": "Threshold Secret Sharing", "properties": {"description": "A special case of secret sharing where the access structure consists of all subsets of t or more parties.", "keywords": ["cryptographic", "out", "cryptography", "security", "adversary", "secret", "sharing", "scheme", "n", "threshold", "of", "t"], "source_lectures": ["lecture_106108229_w1_l7", "lecture_106108229_w2_l8", "lecture_106108229_w2_l11", "lecture_106108229_w2_l13", "lecture_106108229_w2_l14", "lecture_106106221_w8_l56"]}}
{"id": "concept_sharing_algorithm", "type": "V_concept", "name": "Sharing Algorithm", "properties": {"description": "An algorithm used to distribute a secret among a group of parties.", "keywords": ["distribution", "parties", "secret", "sharing", "reconstruction", "algorithm"], "source_lectures": ["lecture_106108229_w1_l7", "lecture_106108229_w2_l8"]}}
{"id": "concept_reconstruction_algorithm", "type": "V_concept", "name": "Reconstruction Algorithm", "properties": {"description": "An algorithm used to reconstruct a shared secret from the shares held by a subset of parties.", "keywords": ["parties", "secret", "shares", "sharing", "reconstruction", "algorithm"], "source_lectures": ["lecture_106108229_w1_l7", "lecture_106108229_w2_l8"]}}
{"id": "concept_kerckhoffss_principle", "type": "V_concept", "name": "Kerckhoffs's Principle", "properties": {"description": "A principle in cryptography that states that the security of a system should not rely on the secrecy of the algorithm.", "keywords": ["kerckhoffs", "principle", "cryptography", "security", "algorithm"], "source_lectures": ["lecture_106108229_w1_l7"]}}
{"id": "concept_correctness_property", "type": "V_concept", "name": "Correctness Property", "properties": {"description": "A property of a secret sharing scheme that ensures authorized subsets of parties can reconstruct the shared secret.", "keywords": ["identification", "secret", "property", "sharing", "scheme", "transcript", "honest", "correctness"], "source_lectures": ["lecture_106108229_w1_l7", "lecture_106108229_w2_l14", "lecture_106106221_w8_l53"]}}
{"id": "concept_privacy_condition", "type": "V_concept", "name": "Privacy Condition", "properties": {"description": "A property of a secret sharing scheme that ensures unauthorized subsets of parties learn nothing about the shared secret.", "keywords": ["privacy", "condition", "secret", "sharing", "scheme"], "source_lectures": ["lecture_106108229_w1_l7"]}}
{"id": "concept_additive_secret_sharing", "type": "V_concept", "name": "Additive Secret Sharing", "properties": {"description": "A type of secret-sharing scheme where the secret is divided into shares such that the sum of the shares equals the secret.", "keywords": ["distribution", "value", "reconstruct", "secret", "sharing", "scheme", "additive", "cryptography"], "source_lectures": ["lecture_106108229_w2_l8", "lecture_106108229_w2_l13", "lecture_106108229_w2_l14", "lecture_106108229_w5_l29", "lecture_106108229_w8_l52", "lecture_106106221_w8_l56"]}}
{"id": "concept_n_minus_1_out_of_n_secret_sharing", "type": "V_concept", "name": "N Minus 1 Out Of N Secret Sharing", "properties": {"description": "A special case of threshold secret sharing where the threshold is equal to n minus 1, meaning all parties must combine their shares to reconstruct the secret.", "keywords": ["n", "minus", "1", "out", "of", "n", "secret", "sharing"], "source_lectures": ["lecture_106108229_w2_l8"]}}
{"id": "concept_abstract_group", "type": "V_concept", "name": "Abstract Group", "properties": {"description": "A mathematical structure consisting of a set and an operation that satisfies certain properties, such as closure, associativity, and the existence of an identity element and inverse elements.", "keywords": ["abstract", "group", "mathematics", "structure"], "source_lectures": ["lecture_106108229_w2_l8"]}}
{"id": "concept_additive_inverse", "type": "V_concept", "name": "Additive Inverse", "properties": {"description": "An element that, when combined with another element using the group operation, results in the identity element.", "keywords": ["additive", "inverse", "group", "mathematics"], "source_lectures": ["lecture_106108229_w2_l8"]}}
{"id": "concept_bitwise_xor_operation", "type": "V_concept", "name": "Bitwise XOR Operation", "properties": {"description": "A binary operation that takes two bits and produces an output bit based on the rules of exclusive or.", "keywords": ["bitwise", "xor", "operation", "binary"], "source_lectures": ["lecture_106108229_w2_l8"]}}
{"id": "concept_zm_group", "type": "V_concept", "name": "Zm Group", "properties": {"description": "A group consisting of integers from 0 to m-1, with the operation being addition modulo m.", "keywords": ["zm", "group", "integers", "modulus"], "source_lectures": ["lecture_106108229_w2_l8"]}}
{"id": "concept_polynomial_over_field", "type": "V_concept", "name": "Polynomial Over Field", "properties": {"description": "A polynomial whose coefficients are elements of a field, with operations performed using the field's addition and multiplication rules.", "keywords": ["polynomial", "field", "coefficients", "algebra"], "source_lectures": ["lecture_106108229_w2_l10"]}}
{"id": "concept_lagranges_interpolation", "type": "V_concept", "name": "Lagrange's Interpolation", "properties": {"description": "A method for finding a polynomial that passes through a given set of points, using a linear combination of basis polynomials.", "keywords": ["polynomial", "interpolation", "basis", "lagrange", "reconstruction", "mathematical"], "source_lectures": ["lecture_106108229_w2_l10", "lecture_106108229_w2_l11", "lecture_106108229_w3_l21"]}}
{"id": "concept_root_of_polynomial", "type": "V_concept", "name": "Root Of Polynomial", "properties": {"description": "An element of a field that, when substituted into a polynomial, results in the zero element of the field.", "keywords": ["root", "polynomial", "field", "zero"], "source_lectures": ["lecture_106108229_w2_l10"]}}
{"id": "concept_degree_of_polynomial", "type": "V_concept", "name": "Degree Of Polynomial", "properties": {"description": "The highest power of the variable in a polynomial, which determines the maximum number of roots it can have.", "keywords": ["degree", "polynomial", "power", "roots"], "source_lectures": ["lecture_106108229_w2_l10"]}}
{"id": "concept_field_operations", "type": "V_concept", "name": "Field Operations", "properties": {"description": "The abstract addition and multiplication operations defined on a field, which satisfy certain properties such as commutativity and distributivity.", "keywords": ["multiplication", "addition", "field", "algebraic", "operations"], "source_lectures": ["lecture_106108229_w2_l10", "lecture_106108229_w2_l11"]}}
{"id": "concept_polynomial_evaluation", "type": "V_concept", "name": "Polynomial Evaluation", "properties": {"description": "The process of substituting a value into a polynomial to obtain the corresponding output value.", "keywords": ["evaluation", "cryptography", "security", "polynomial", "substitution", "generation", "share", "output", "point", "mathematics"], "source_lectures": ["lecture_106108229_w2_l10", "lecture_106108229_w2_l11", "lecture_106106221_w4_l26", "lecture_106106221_w8_l56"]}}
{"id": "concept_delta_polynomial", "type": "V_concept", "name": "Delta Polynomial", "properties": {"description": "A basis polynomial used in Lagrange's interpolation, which has a specific root structure and is used to construct the interpolating polynomial.", "keywords": ["delta", "polynomial", "basis", "interpolation"], "source_lectures": ["lecture_106108229_w2_l10"]}}
{"id": "concept_shamirs_experiment", "type": "V_concept", "name": "Shamir's Experiment", "properties": {"description": "A random experiment that generates a polynomial with a secret constant term, and evaluates it at publicly known points to produce output values.", "keywords": ["shamir", "experiment", "polynomial", "secret"], "source_lectures": ["lecture_106108229_w2_l10"]}}
{"id": "concept_polynomial_uniqueness", "type": "V_concept", "name": "Polynomial Uniqueness", "properties": {"description": "The property that a polynomial of degree t is uniquely determined by t+1 distinct points, and that there can be only one such polynomial passing through these points.", "keywords": ["polynomial", "uniqueness", "degree", "points"], "source_lectures": ["lecture_106108229_w2_l10"]}}
{"id": "concept_shamir_secret_sharing", "type": "V_concept", "name": "Shamir Secret-Sharing", "properties": {"description": "A secret-sharing scheme that divides a secret into shares and distributes them among parties, allowing a threshold number of parties to reconstruct the secret", "keywords": ["cryptographic", "cryptography", "polynomial", "equations", "interpolation", "secret", "parties", "secure computation", "sharing", "scheme", "secret sharing", "threshold", "shamir"], "source_lectures": ["lecture_106108229_w2_l11", "lecture_106108229_w2_l12", "lecture_106108229_w2_l13", "lecture_106108229_w2_l14", "lecture_106108229_w3_l19", "lecture_106108229_w3_l20", "lecture_106108229_w3_l21", "lecture_106108229_w4_l22", "lecture_106108229_w4_l23", "lecture_106108229_w4_l24"]}}
{"id": "concept_finite_field", "type": "V_concept", "name": "Finite Field", "properties": {"description": "A mathematical structure consisting of a set of elements with two operations, addition and multiplication, that satisfy certain properties", "keywords": ["algebra", "cryptography", "finite", "structure", "field", "algebraic", "mathematical", "zp", "mathematics"], "source_lectures": ["lecture_106108229_w2_l11", "lecture_106106221_w4_l26", "lecture_106106221_w8_l56"]}}
{"id": "concept_secret_reconstruction", "type": "V_concept", "name": "Secret Reconstruction", "properties": {"description": "The process of reconstructing a secret from shares, used in Shamir's secret-sharing scheme to recover the original secret", "keywords": ["secret", "reconstruction", "share", "recovery", "cryptographic"], "source_lectures": ["lecture_106108229_w2_l11"]}}
{"id": "concept_evaluation_points", "type": "V_concept", "name": "Evaluation Points", "properties": {"description": "The points at which a polynomial is evaluated, used in Shamir's secret-sharing scheme to generate shares", "keywords": ["evaluation", "points", "polynomial", "share", "generation"], "source_lectures": ["lecture_106108229_w2_l11"]}}
{"id": "concept_linear_secret_sharing", "type": "V_concept", "name": "Linear Secret-Sharing", "properties": {"description": "A method of secret-sharing where the shares are computed as a linear function of the secret and randomness.", "keywords": ["secret", "sharing", "scheme", "linear", "randomness"], "source_lectures": ["lecture_106108229_w2_l12", "lecture_106108229_w2_l13"]}}
{"id": "concept_linearity_property", "type": "V_concept", "name": "Linearity Property", "properties": {"description": "A property of secret-sharing schemes where certain operations can be performed on the shares without revealing the secret.", "keywords": ["secret", "property", "sharing", "scheme", "computation", "shamir", "linearity"], "source_lectures": ["lecture_106108229_w2_l12", "lecture_106108229_w2_l13", "lecture_106108229_w2_l14", "lecture_106108229_w3_l19", "lecture_106108229_w5_l29", "lecture_106108229_w5_l32", "lecture_106108229_w5_l33"]}}
{"id": "concept_vandermonde_matrix", "type": "V_concept", "name": "Vandermonde Matrix", "properties": {"description": "A matrix with a special structure, used in linear algebra and secret-sharing schemes.", "keywords": ["vandermonde", "matrix", "linear", "algebra"], "source_lectures": ["lecture_106108229_w2_l12"]}}
{"id": "concept_lagranges_interpolation_formula", "type": "V_concept", "name": "Lagrange's Interpolation Formula", "properties": {"description": "A method for interpolating a polynomial from a set of points.", "keywords": ["lagrange", "interpolation", "polynomial", "points"], "source_lectures": ["lecture_106108229_w2_l12"]}}
{"id": "concept_linear_function", "type": "V_concept", "name": "Linear Function", "properties": {"description": "A function that can be expressed as a linear combination of its inputs.", "keywords": ["algebra", "inputs", "combination", "straight", "function", "computation", "linear", "mathematics"], "source_lectures": ["lecture_106108229_w2_l12", "lecture_106108229_w2_l13", "lecture_106108229_w3_l19", "lecture_106108229_w4_l22", "lecture_106108229_w4_l24", "lecture_106108229_w5_l35"]}}
{"id": "concept_publicly_known_element", "type": "V_concept", "name": "Publicly Known Element", "properties": {"description": "An element that is known to all parties in a secret-sharing scheme.", "keywords": ["public", "element", "secret", "sharing"], "source_lectures": ["lecture_106108229_w2_l12"]}}
{"id": "concept_random_polynomial", "type": "V_concept", "name": "Random Polynomial", "properties": {"description": "A polynomial chosen randomly from a set of possible polynomials.", "keywords": ["polynomial", "secret", "sharing", "random", "possible", "set"], "source_lectures": ["lecture_106108229_w2_l12", "lecture_106108229_w3_l21"]}}
{"id": "concept_degree_of_sharing", "type": "V_concept", "name": "Degree of Sharing", "properties": {"description": "The degree of the polynomial used in a secret-sharing scheme.", "keywords": ["degree", "sharing", "polynomial", "secret"], "source_lectures": ["lecture_106108229_w2_l12"]}}
{"id": "concept_lagranges_coefficients", "type": "V_concept", "name": "Lagrange's Coefficients", "properties": {"description": "Coefficients used in Lagrange's interpolation formula.", "keywords": ["lagrange", "coefficients", "interpolation", "formula"], "source_lectures": ["lecture_106108229_w2_l12"]}}
{"id": "concept_publicly_known_linear_function", "type": "V_concept", "name": "Publicly Known Linear Function", "properties": {"description": "A linear function whose coefficients are publicly known.", "keywords": ["publicly", "known", "linear", "function"], "source_lectures": ["lecture_106108229_w2_l13"]}}
{"id": "concept_secret_sharing_scheme", "type": "V_concept", "name": "Secret-Sharing Scheme", "properties": {"description": "A method for sharing a secret among multiple parties such that only authorized subsets of parties can reconstruct the secret.", "keywords": ["distribution", "security", "secret", "sharing", "scheme", "cryptography"], "source_lectures": ["lecture_106108229_w2_l13", "lecture_106108229_w2_l14", "lecture_106108229_w5_l29"]}}
{"id": "concept_multiparty_computation", "type": "V_concept", "name": "Multiparty Computation", "properties": {"description": "A protocol that enables multiple parties to jointly perform computations on private data without revealing their individual inputs.", "keywords": ["security", "protocol", "multiparty", "computation", "cryptography"], "source_lectures": ["lecture_106108229_w2_l13", "lecture_106106221_w9_l58"]}}
{"id": "concept_linear_combination", "type": "V_concept", "name": "Linear Combination", "properties": {"description": "An expression that combines multiple inputs using linear coefficients.", "keywords": ["linear", "combination", "mathematics"], "source_lectures": ["lecture_106108229_w2_l13"]}}
{"id": "concept_adversary_structure", "type": "V_concept", "name": "Adversary Structure", "properties": {"description": "A collection of unauthorized subsets of parties that cannot reconstruct a secret in a secret sharing scheme.", "keywords": ["adversary", "structure", "unauthorized", "subsets", "parties"], "source_lectures": ["lecture_106108229_w2_l14"]}}
{"id": "concept_non_threshold_adversary", "type": "V_concept", "name": "Non-Threshold Adversary", "properties": {"description": "An adversary structure where the cardinality of individual subsets is not upper bounded by a fixed threshold.", "keywords": ["corrupt", "subsets", "cardinality", "adversary", "parties", "structure", "non-threshold"], "source_lectures": ["lecture_106108229_w2_l14", "lecture_106108229_w5_l29"]}}
{"id": "concept_monotone_structure", "type": "V_concept", "name": "Monotone Structure", "properties": {"description": "A property of access and adversary structures where any superset of an authorized subset is also authorized, and any proper subset of an unauthorized subset is also unauthorized.", "keywords": ["monotone", "structure", "access", "adversary", "property"], "source_lectures": ["lecture_106108229_w2_l14"]}}
{"id": "concept_privacy_property", "type": "V_concept", "name": "Privacy Property", "properties": {"description": "A property of a secret sharing scheme where unauthorized subsets of parties cannot reconstruct the secret.", "keywords": ["privacy", "secret", "property", "sharing", "scheme", "computation", "secure", "cryptography"], "source_lectures": ["lecture_106108229_w2_l14", "lecture_106108229_w4_l24"]}}
{"id": "concept_perfectly_secure_message_transmission", "type": "V_concept", "name": "Perfectly Secure Message Transmission", "properties": {"description": "A method of transmitting messages in a way that ensures the message cannot be intercepted or read by unauthorized parties.", "keywords": ["secure", "message", "transmission", "cryptography", "privacy"], "source_lectures": ["lecture_106108229_w3_l15"]}}
{"id": "concept_secret_sharing_protocol", "type": "V_concept", "name": "Secret Sharing Protocol", "properties": {"description": "A protocol that allows a secret to be divided into multiple parts, which can then be shared among multiple parties.", "keywords": ["secret", "sharing", "protocol", "cryptography", "security"], "source_lectures": ["lecture_106108229_w3_l15"]}}
{"id": "concept_intermediary_node", "type": "V_concept", "name": "Intermediary Node", "properties": {"description": "A node in a network that acts as an intermediary between the sender and receiver of a message.", "keywords": ["intermediary", "node", "network", "communication", "security"], "source_lectures": ["lecture_106108229_w3_l15"]}}
{"id": "concept_private_channel", "type": "V_concept", "name": "Private Channel", "properties": {"description": "A communication channel that is secure and private, where only authorized parties can access the data.", "keywords": ["privacy", "private", "security", "channel", "communication"], "source_lectures": ["lecture_106108229_w3_l15", "lecture_106108229_w3_l16"]}}
{"id": "concept_one_time_password", "type": "V_concept", "name": "One-Time Password", "properties": {"description": "A password that is only valid for a single use, providing an additional layer of security.", "keywords": ["one-time", "password", "security", "authentication", "privacy"], "source_lectures": ["lecture_106108229_w3_l15"]}}
{"id": "concept_secure_communication_protocol", "type": "V_concept", "name": "Secure Communication Protocol", "properties": {"description": "A protocol that ensures secure communication between two or more parties, protecting the data from interception or eavesdropping.", "keywords": ["secure", "communication", "protocol", "security", "privacy"], "source_lectures": ["lecture_106108229_w3_l15"]}}
{"id": "concept_network_control", "type": "V_concept", "name": "Network Control", "properties": {"description": "The ability to control and manage a network, including the flow of data and access to resources.", "keywords": ["network", "control", "management", "security", "communication"], "source_lectures": ["lecture_106108229_w3_l15"]}}
{"id": "concept_secure_addition", "type": "V_concept", "name": "Secure Addition", "properties": {"description": "A specific type of multi-party computation that securely computes the sum of private inputs from multiple parties.", "keywords": ["secure", "addition", "multi-party", "computation"], "source_lectures": ["lecture_106108229_w3_l16"]}}
{"id": "concept_trusted_third_party", "type": "V_concept", "name": "Trusted Third Party", "properties": {"description": "An entity that is trusted by all parties involved in a computation to perform a task, such as computing a sum, without revealing individual inputs.", "keywords": ["trusted", "third", "party", "security"], "source_lectures": ["lecture_106108229_w3_l16"]}}
{"id": "concept_one_time_pad_encryption", "type": "V_concept", "name": "One-Time Pad Encryption", "properties": {"description": "A type of encryption where a random key is used to encrypt and decrypt a message, providing perfect secrecy.", "keywords": ["time", "security", "one-time", "encryption", "secrecy", "one", "pad"], "source_lectures": ["lecture_106108229_w3_l16", "lecture_106108229_w5_l31"]}}
{"id": "concept_modulus_operation", "type": "V_concept", "name": "Modulus Operation", "properties": {"description": "A mathematical operation that returns the remainder of an integer division operation.", "keywords": ["modulus", "operation", "mathematics", "arithmetic"], "source_lectures": ["lecture_106108229_w3_l16"]}}
{"id": "concept_public_modulus", "type": "V_concept", "name": "Public Modulus", "properties": {"description": "A publicly agreed-upon modulus value used in cryptographic protocols to ensure secure computation.", "keywords": ["public", "modulus", "security", "cryptography"], "source_lectures": ["lecture_106108229_w3_l16"]}}
{"id": "concept_view_of_a_party", "type": "V_concept", "name": "View of a Party", "properties": {"description": "The information learned by a party during the execution of a protocol, including inputs, random coins, and messages received and sent.", "keywords": ["view", "party", "information", "protocol"], "source_lectures": ["lecture_106108229_w3_l16"]}}
{"id": "concept_ideal_solution", "type": "V_concept", "name": "Ideal Solution", "properties": {"description": "A hypothetical solution to a problem that assumes the existence of a trusted third party or other idealized conditions.", "keywords": ["ideal", "solution", "hypothetical", "trusted"], "source_lectures": ["lecture_106108229_w3_l16"]}}
{"id": "concept_single_point_of_failure", "type": "V_concept", "name": "Single Point of Failure", "properties": {"description": "A situation where a single entity or component is critical to the functioning of a system, and its failure can cause the entire system to fail.", "keywords": ["single", "point", "failure", "security", "reliability"], "source_lectures": ["lecture_106108229_w3_l16"]}}
{"id": "concept_bgw_mpc_protocol", "type": "V_concept", "name": "BGW MPC Protocol", "properties": {"description": "A secure multi-party computation protocol used for secure computation.", "keywords": ["mpc", "protocol", "bgw", "secure", "secure computation", "linear functions", "secret sharing", "computation"], "source_lectures": ["lecture_106108229_w3_l18", "lecture_106108229_w3_l19", "lecture_106108229_w3_l20", "lecture_106108229_w3_l21"]}}
{"id": "concept_multiplication_gate", "type": "V_concept", "name": "Multiplication Gate", "properties": {"description": "A basic component in digital circuits used for multiplication operations.", "keywords": ["gate", "multiplication", "operation", "secure", "circuit", "logic", "computation", "digital"], "source_lectures": ["lecture_106108229_w3_l18", "lecture_106108229_w5_l31", "lecture_106108229_w5_l32"]}}
{"id": "concept_addition_gate", "type": "V_concept", "name": "Addition Gate", "properties": {"description": "A basic component in digital circuits used for addition operations.", "keywords": ["addition", "gate", "digital", "circuit", "operation"], "source_lectures": ["lecture_106108229_w3_l18"]}}
{"id": "concept_private_function", "type": "V_concept", "name": "Private Function", "properties": {"description": "A function that is computed privately, without revealing the inputs or intermediate results.", "keywords": ["private", "function", "computation", "secure", "privacy"], "source_lectures": ["lecture_106108229_w3_l18"]}}
{"id": "concept_public_function", "type": "V_concept", "name": "Public Function", "properties": {"description": "A function that is computed publicly, with the inputs and outputs being publicly visible.", "keywords": ["public", "function", "computation", "visible", "output"], "source_lectures": ["lecture_106108229_w3_l18"]}}
{"id": "concept_deterministic_function", "type": "V_concept", "name": "Deterministic Function", "properties": {"description": "A function that always produces the same output for a given input.", "keywords": ["deterministic", "function", "output", "input", "predictable"], "source_lectures": ["lecture_106108229_w3_l18"]}}
{"id": "concept_shared_circuit_evaluation", "type": "V_concept", "name": "Shared Circuit Evaluation", "properties": {"description": "A method of secure multi-party computation that involves evaluating a circuit on private data, where each party holds a share of the input.", "keywords": ["evaluation", "model", "private", "preprocessing", "shared", "circuit", "computation", "secure"], "source_lectures": ["lecture_106108229_w3_l19", "lecture_106108229_w4_l26", "lecture_106108229_w5_l29", "lecture_106108229_w5_l31"]}}
{"id": "concept_private_channel_model", "type": "V_concept", "name": "Private Channel Model", "properties": {"description": "A model of secure communication where parties can communicate privately and securely.", "keywords": ["private", "channel", "model", "secure", "communication"], "source_lectures": ["lecture_106108229_w3_l19"]}}
{"id": "concept_lagrange_interpolation", "type": "V_concept", "name": "Lagrange Interpolation", "properties": {"description": "A method of polynomial interpolation that can be used to reconstruct a secret from its shares.", "keywords": ["polynomial", "secret", "interpolation", "sharing", "points", "lagrange", "mathematics"], "source_lectures": ["lecture_106108229_w3_l19", "lecture_106108229_w4_l23", "lecture_106106221_w8_l56"]}}
{"id": "concept_round_complexity", "type": "V_concept", "name": "Round Complexity", "properties": {"description": "The number of rounds required to complete a secure multi-party computation protocol.", "keywords": ["round", "complexity", "secure", "computation"], "source_lectures": ["lecture_106108229_w3_l19"]}}
{"id": "concept_communication_complexity", "type": "V_concept", "name": "Communication Complexity", "properties": {"description": "The amount of communication required to complete a secure multi-party computation protocol.", "keywords": ["multi-party", "secure", "complexity", "computation", "communication"], "source_lectures": ["lecture_106108229_w3_l19", "lecture_106108229_w5_l32", "lecture_106108229_w5_l33"]}}
{"id": "concept_threshold_security_model", "type": "V_concept", "name": "Threshold Security Model", "properties": {"description": "A security model where an adversary can corrupt up to t parties, but cannot learn more than what is revealed by the function output and corrupt inputs.", "keywords": ["threshold", "security", "corrupt parties", "t-out-of-n", "privacy"], "source_lectures": ["lecture_106108229_w3_l20"]}}
{"id": "concept_view_of_an_adversary", "type": "V_concept", "name": "View of an Adversary", "properties": {"description": "The complete set of inputs, random coins, sent and received messages, and outputs observed by a corrupt party or set of parties during protocol execution.", "keywords": ["view", "adversary", "protocol view", "corrupt parties", "messages"], "source_lectures": ["lecture_106108229_w3_l20"]}}
{"id": "concept_simulator_in_mpc", "type": "V_concept", "name": "Simulator in MPC", "properties": {"description": "A hypothetical algorithm that reproduces the adversary's view using only the corrupt parties' inputs and the function output, without interacting with honest parties.", "keywords": ["simulator", "mpc", "privacy", "view simulation", "ideal model"], "source_lectures": ["lecture_106108229_w3_l20"]}}
{"id": "concept_privacy_in_mpc", "type": "V_concept", "name": "Privacy in MPC", "properties": {"description": "The property that an adversary learns nothing beyond the inputs of corrupt parties and the function output.", "keywords": ["privacy", "mpc", "information leakage", "secure computation", "no additional info"], "source_lectures": ["lecture_106108229_w3_l20"]}}
{"id": "concept_degree_t_polynomial_sharing", "type": "V_concept", "name": "Degree-t Polynomial Sharing", "properties": {"description": "The use of random polynomials of degree t to secret-share inputs in BGW protocol, ensuring that any t shares reveal no information about the secret.", "keywords": ["polynomial", "degree-t", "secret sharing", "random polynomial", "bgw"], "source_lectures": ["lecture_106108229_w3_l20"]}}
{"id": "concept_output_interpolation_in_bgw", "type": "V_concept", "name": "Output Interpolation in BGW", "properties": {"description": "The process of reconstructing the final output by interpolating the shares of the result polynomial computed by all parties.", "keywords": ["interpolation", "output reconstruction", "bgw", "polynomial", "shares"], "source_lectures": ["lecture_106108229_w3_l20"]}}
{"id": "concept_linear_function_evaluation_in_mpc", "type": "V_concept", "name": "Linear Function Evaluation in MPC", "properties": {"description": "The secure computation of functions that are linear combinations of inputs, such as summation, using additive secret-sharing and local computation.", "keywords": ["linear function", "mpc", "additive", "secure evaluation", "summation"], "source_lectures": ["lecture_106108229_w3_l20"]}}
{"id": "concept_honest_but_curious_adversary", "type": "V_concept", "name": "Honest-But-Curious Adversary", "properties": {"description": "An adversary that follows the protocol correctly but attempts to learn additional information from messages received during execution.", "keywords": ["honest but curious", "passive adversary", "semi-honest", "mpc threat model", "privacy"], "source_lectures": ["lecture_106108229_w3_l20"]}}
{"id": "concept_field_arithmetic_in_mpc", "type": "V_concept", "name": "Field Arithmetic in MPC", "properties": {"description": "Performing all computations in a finite field (e.g., Z_p) to ensure mathematical properties like uniform randomness and polynomial interpolation hold.", "keywords": ["finite field", "modular arithmetic", "z_p", "field operations", "mpc math"], "source_lectures": ["lecture_106108229_w3_l20"]}}
{"id": "concept_random_coins_in_mpc", "type": "V_concept", "name": "Random Coins in MPC", "properties": {"description": "Internal random values used by parties to generate secret shares and ensure probabilistic security in the protocol.", "keywords": ["random coins", "randomness", "secret sharing", "mpc", "probabilistic"], "source_lectures": ["lecture_106108229_w3_l20"]}}
{"id": "concept_share_aggregation_in_bgw", "type": "V_concept", "name": "Share Aggregation in BGW", "properties": {"description": "The step where each party locally adds its shares of all inputs to compute its share of the output, using field addition.", "keywords": ["share aggregation", "add shares", "bgw", "local computation", "linear function"], "source_lectures": ["lecture_106108229_w3_l20"]}}
{"id": "concept_simulatability", "type": "V_concept", "name": "Simulatability", "properties": {"description": "The ability to reproduce an adversary's view using only corrupt inputs and output, proving the protocol reveals no additional information.", "keywords": ["simulatability", "privacy proof", "simulator", "mpc", "view equivalence"], "source_lectures": ["lecture_106108229_w3_l20"]}}
{"id": "concept_polynomial_interpolation_for_reconstruction", "type": "V_concept", "name": "Polynomial Interpolation for Reconstruction", "properties": {"description": "The mathematical technique used to recover the constant term of a polynomial from t+1 evaluation points, used to reconstruct the output in BGW.", "keywords": ["interpolation", "polynomial", "reconstruction", "lagrange", "constant term"], "source_lectures": ["lecture_106108229_w3_l20"]}}
{"id": "concept_input_privacy_guarantee", "type": "V_concept", "name": "Input Privacy Guarantee", "properties": {"description": "The assurance that the inputs of honest parties cannot be inferred by an adversary beyond what is derivable from the corrupt inputs and the function output.", "keywords": ["input privacy", "honest parties", "mpc", "information leakage", "security"], "source_lectures": ["lecture_106108229_w3_l20"]}}
{"id": "concept_public_share_announcement", "type": "V_concept", "name": "Public Share Announcement", "properties": {"description": "The step in BGW where each party broadcasts its computed share of the output to all other parties for final interpolation.", "keywords": ["public share", "broadcast", "output share", "bgw", "interpolation"], "source_lectures": ["lecture_106108229_w3_l20"]}}
{"id": "concept_uniform_random_polynomial_selection", "type": "V_concept", "name": "Uniform Random Polynomial Selection", "properties": {"description": "The process of choosing a random polynomial of degree t with a fixed constant term to ensure uniform distribution of shares.", "keywords": ["random polynomial", "uniform distribution", "secret sharing", "bgw", "degree-t"], "source_lectures": ["lecture_106108229_w3_l20"]}}
{"id": "concept_adversarial_view_consistency", "type": "V_concept", "name": "Adversarial View Consistency", "properties": {"description": "The property that an adversary's observed messages are consistent with multiple possible input configurations, preventing unique inference.", "keywords": ["view consistency", "adversary", "multiple inputs", "indistinguishability", "bgw"], "source_lectures": ["lecture_106108229_w3_l20"]}}
{"id": "concept_linear_gate", "type": "V_concept", "name": "Linear Gate", "properties": {"description": "A type of gate in a circuit that performs a linear operation, such as addition or multiplication by a constant.", "keywords": ["linear", "gate", "circuit", "operation"], "source_lectures": ["lecture_106108229_w3_l21"]}}
{"id": "concept_non_linear_gate", "type": "V_concept", "name": "Non-Linear Gate", "properties": {"description": "A type of gate in a circuit that performs a non-linear operation, such as multiplication of two variables.", "keywords": ["non-linear", "gate", "circuit", "operation"], "source_lectures": ["lecture_106108229_w3_l21"]}}
{"id": "concept_bgw_gate_invariant", "type": "V_concept", "name": "BGW Gate-Invariant", "properties": {"description": "A property of the BGW MPC protocol that ensures the output of a gate is secret-shared in the same way as the inputs.", "keywords": ["bgw", "gate-invariant", "protocol", "secure"], "source_lectures": ["lecture_106108229_w3_l21"]}}
{"id": "concept_irreducible_polynomial", "type": "V_concept", "name": "Irreducible Polynomial", "properties": {"description": "A polynomial that cannot be factored into non-trivial polynomials, used in the context of the BGW MPC protocol.", "keywords": ["irreducible", "polynomial", "factorization"], "source_lectures": ["lecture_106108229_w3_l21"]}}
{"id": "concept_redundancy_in_secret_sharing", "type": "V_concept", "name": "Redundancy in Secret Sharing", "properties": {"description": "A situation where the degree of a secret-shared polynomial increases, making it difficult to reconstruct the original value.", "keywords": ["redundancy", "secret", "sharing", "degree"], "source_lectures": ["lecture_106108229_w3_l21"]}}
{"id": "concept_privacy_breach_in_mpc", "type": "V_concept", "name": "Privacy Breach in MPC", "properties": {"description": "A situation where an adversary can learn more information about the inputs than intended, compromising the security of the MPC protocol.", "keywords": ["privacy", "breach", "mpc", "security"], "source_lectures": ["lecture_106108229_w3_l21"]}}
{"id": "concept_degree_reduction_problem", "type": "V_concept", "name": "Degree Reduction Problem", "properties": {"description": "A problem in secure computation where the degree of a shared polynomial needs to be reduced while maintaining secrecy.", "keywords": ["degree", "reduction", "polynomial", "secret", "sharing"], "source_lectures": ["lecture_106108229_w4_l22"]}}
{"id": "concept_honest_majority", "type": "V_concept", "name": "Honest Majority", "properties": {"description": "A condition in secure computation where the number of honest parties is greater than the number of corrupt parties.", "keywords": ["honest", "majority", "secure", "computation", "parties"], "source_lectures": ["lecture_106108229_w4_l22"]}}
{"id": "concept_grr_degree_reduction_method", "type": "V_concept", "name": "GRR Degree Reduction Method", "properties": {"description": "A method for degree reduction in secure computation, attributed to Gennaro, Rabin, and Rabin.", "keywords": ["degree", "grr", "polynomial", "method", "secure computation", "computation", "reduction", "secure", "degree reduction"], "source_lectures": ["lecture_106108229_w4_l22", "lecture_106108229_w4_l23", "lecture_106108229_w4_l24", "lecture_106108229_w4_l27"]}}
{"id": "concept_polynomial_sharing", "type": "V_concept", "name": "Polynomial Sharing", "properties": {"description": "A method for sharing secrets among multiple parties using polynomial equations.", "keywords": ["polynomial", "sharing", "secrets", "parties", "equations"], "source_lectures": ["lecture_106108229_w4_l22"]}}
{"id": "concept_truncation", "type": "V_concept", "name": "Truncation", "properties": {"description": "A process of reducing the degree of a polynomial by removing its higher-order coefficients.", "keywords": ["truncation", "polynomial", "degree", "reduction", "coefficients"], "source_lectures": ["lecture_106108229_w4_l22"]}}
{"id": "concept_degree_reduction", "type": "V_concept", "name": "Degree Reduction", "properties": {"description": "A process for reducing the degree of a polynomial", "keywords": ["degree reduction", "polynomial", "secure computation"], "source_lectures": ["lecture_106108229_w4_l23"]}}
{"id": "concept_lagrange_coefficients", "type": "V_concept", "name": "Lagrange Coefficients", "properties": {"description": "Coefficients used in Lagrange interpolation", "keywords": ["lagrange coefficients", "interpolation", "polynomial"], "source_lectures": ["lecture_106108229_w4_l23"]}}
{"id": "concept_delta_polynomials", "type": "V_concept", "name": "Delta Polynomials", "properties": {"description": "Polynomials used in Lagrange interpolation", "keywords": ["delta polynomials", "interpolation", "polynomial"], "source_lectures": ["lecture_106108229_w4_l23"]}}
{"id": "concept_complexity_analysis", "type": "V_concept", "name": "Complexity Analysis", "properties": {"description": "The study of the resources required to solve a computational problem, including time and communication complexity.", "keywords": ["complexity", "analysis", "time", "communication", "computation"], "source_lectures": ["lecture_106108229_w4_l24"]}}
{"id": "concept_security_analysis", "type": "V_concept", "name": "Security Analysis", "properties": {"description": "The evaluation of a system or protocol to determine its vulnerability to security threats.", "keywords": ["security", "analysis", "vulnerability", "threats", "cryptography"], "source_lectures": ["lecture_106108229_w4_l24"]}}
{"id": "concept_mpc_protocol", "type": "V_concept", "name": "Mpc Protocol", "properties": {"description": "A protocol that enables multiple parties to jointly perform a computation on private data without revealing their individual inputs.", "keywords": ["mpc", "protocol", "secure", "computation", "cryptography"], "source_lectures": ["lecture_106108229_w4_l24"]}}
{"id": "concept_simulator", "type": "V_concept", "name": "Simulator", "properties": {"description": "A tool used in cryptography to simulate the behavior of a real-world system or protocol.", "keywords": ["simulator", "cryptography", "secure", "computation", "protocol"], "source_lectures": ["lecture_106108229_w4_l24"]}}
{"id": "concept_preprocessing_model", "type": "V_concept", "name": "Preprocessing Model", "properties": {"description": "A model used for preprocessing data or inputs before further processing.", "keywords": ["model", "security", "input", "preprocessing", "data", "processing"], "source_lectures": ["lecture_106108229_w4_l26", "lecture_106108229_w5_l35"]}}
{"id": "concept_multiplication_table", "type": "V_concept", "name": "Multiplication Table", "properties": {"description": "A table used to display the results of multiplication operations.", "keywords": ["multiplication", "table", "math", "operation", "result"], "source_lectures": ["lecture_106108229_w4_l26"]}}
{"id": "concept_random_number_generation", "type": "V_concept", "name": "Random Number Generation", "properties": {"description": "A process of generating numbers randomly.", "keywords": ["random", "number", "generation", "process", "algorithm"], "source_lectures": ["lecture_106108229_w4_l26"]}}
{"id": "concept_polynomial_equation", "type": "V_concept", "name": "Polynomial Equation", "properties": {"description": "An equation consisting of variables and coefficients combined using only addition, subtraction, and multiplication.", "keywords": ["polynomial", "equation", "variable", "coefficient", "math"], "source_lectures": ["lecture_106108229_w4_l26"]}}
{"id": "concept_independent_component", "type": "V_concept", "name": "Independent Component", "properties": {"description": "A component that operates independently of other components.", "keywords": ["independent", "component", "operation", "system", "design"], "source_lectures": ["lecture_106108229_w4_l26"]}}
{"id": "concept_data_structure", "type": "V_concept", "name": "Data Structure", "properties": {"description": "A way of organizing and storing data in a computer.", "keywords": ["data", "structure", "organization", "storage", "computer"], "source_lectures": ["lecture_106108229_w4_l26"]}}
{"id": "concept_communication_protocol", "type": "V_concept", "name": "Communication Protocol", "properties": {"description": "A set of rules and standards that govern communication between devices or systems.", "keywords": ["communication", "protocol", "rule", "standard", "device"], "source_lectures": ["lecture_106108229_w4_l26"]}}
{"id": "concept_corruption_bound", "type": "V_concept", "name": "Corruption Bound", "properties": {"description": "The maximum number of parties that can be corrupted without compromising the security of a multi-party computation protocol.", "keywords": ["corruption", "bound", "security", "multi-party"], "source_lectures": ["lecture_106108229_w4_l27"]}}
{"id": "concept_protocol_transcript", "type": "V_concept", "name": "Protocol Transcript", "properties": {"description": "The sequence of messages exchanged between parties during the execution of a protocol.", "keywords": ["protocol", "transcript", "messages", "execution"], "source_lectures": ["lecture_106108229_w4_l27"]}}
{"id": "concept_lagrange_linear_combiners", "type": "V_concept", "name": "Lagrange Linear Combiners", "properties": {"description": "A method used to combine shares in a secret sharing scheme.", "keywords": ["lagrange", "linear", "combiners", "secret", "sharing"], "source_lectures": ["lecture_106108229_w4_l27"]}}
{"id": "concept_computational_unbounded_adversary", "type": "V_concept", "name": "Computational Unbounded Adversary", "properties": {"description": "An adversary with unlimited computational power, used to model the strongest possible attacker in a security proof.", "keywords": ["computational", "unbounded", "adversary", "security"], "source_lectures": ["lecture_106108229_w4_l27"]}}
{"id": "concept_two_party_protocol", "type": "V_concept", "name": "Two-Party Protocol", "properties": {"description": "A protocol that involves only two parties, often used as a building block for more complex multi-party protocols.", "keywords": ["two-party", "protocol", "multi-party"], "source_lectures": ["lecture_106108229_w4_l27"]}}
{"id": "concept_impossibility_result", "type": "V_concept", "name": "Impossibility Result", "properties": {"description": "A proof that a certain task or protocol is impossible to achieve, often used to establish limits on what can be accomplished in a given security model.", "keywords": ["impossibility", "result", "proof", "security"], "source_lectures": ["lecture_106108229_w4_l27"]}}
{"id": "concept_ito_et_al_secret_sharing_scheme", "type": "V_concept", "name": "Ito Et Al Secret Sharing Scheme", "properties": {"description": "A secret sharing scheme that satisfies the linearity property and allows for non-interactive computation of linear functions of secret shared inputs.", "keywords": ["ito", "secret", "sharing", "scheme", "linearity"], "source_lectures": ["lecture_106108229_w5_l29"]}}
{"id": "concept_q2_condition", "type": "V_concept", "name": "Q2 Condition", "properties": {"description": "A condition that ensures the set of parties satisfies a certain property, necessary for the Ito et al secret sharing scheme to work.", "keywords": ["q2", "condition", "parties", "property"], "source_lectures": ["lecture_106108229_w5_l29"]}}
{"id": "concept_monotone_adversary_structure", "type": "V_concept", "name": "Monotone Adversary Structure", "properties": {"description": "An adversary structure where any subset of a forbidden set is also a forbidden set.", "keywords": ["monotone", "adversary", "structure", "forbidden"], "source_lectures": ["lecture_106108229_w5_l29"]}}
{"id": "concept_multi_party_computation_mpc_protocol", "type": "V_concept", "name": "Multi-Party Computation (MPC) Protocol", "properties": {"description": "A protocol that enables multiple parties to jointly perform a computation on private data without revealing their individual inputs.", "keywords": ["multi-party", "computation", "protocol", "private", "data"], "source_lectures": ["lecture_106108229_w5_l29"]}}
{"id": "concept_additive_sharing", "type": "V_concept", "name": "Additive Sharing", "properties": {"description": "A method of sharing a value among parties such that the sum of the shares equals the original value.", "keywords": ["value", "privacy", "security", "parties", "secret", "sharing", "additive"], "source_lectures": ["lecture_106108229_w5_l29", "lecture_106108229_w5_l31"]}}
{"id": "concept_perfectly_secure_3pc", "type": "V_concept", "name": "Perfectly Secure 3PC", "properties": {"description": "A protocol for secure three-party computation with one corruption, ensuring the privacy of inputs and outputs.", "keywords": ["secure", "computation", "3pc", "privacy", "corruption"], "source_lectures": ["lecture_106108229_w5_l31"]}}
{"id": "concept_replicated_secret_sharing", "type": "V_concept", "name": "Replicated Secret Sharing", "properties": {"description": "A method of secret sharing where each party holds a share of the secret, and the secret can be reconstructed by combining the shares.", "keywords": ["privacy", "security", "parties", "secret", "sharing", "scheme", "replicated", "data", "cryptography"], "source_lectures": ["lecture_106108229_w5_l31", "lecture_106108229_w5_l32", "lecture_106108229_w5_l33", "lecture_106106221_w8_l56"]}}
{"id": "concept_random_zero_sharing", "type": "V_concept", "name": "Random Zero Sharing", "properties": {"description": "A method of sharing a zero value among parties, used in secure computation protocols to maintain privacy.", "keywords": ["random", "zero", "sharing", "privacy", "security"], "source_lectures": ["lecture_106108229_w5_l31"]}}
{"id": "concept_grr_degree_reduction", "type": "V_concept", "name": "GRR Degree Reduction", "properties": {"description": "A method used in secure computation protocols to reduce the degree of a polynomial, enabling more efficient computation.", "keywords": ["grr", "degree", "reduction", "secure", "computation"], "source_lectures": ["lecture_106108229_w5_l31"]}}
{"id": "concept_beavers_circuit_randomization", "type": "V_concept", "name": "Beaver's Circuit Randomization", "properties": {"description": "A method used in secure computation protocols to randomize the inputs and outputs of a circuit, maintaining privacy.", "keywords": ["beaver", "circuit", "randomization", "privacy", "security"], "source_lectures": ["lecture_106108229_w5_l31"]}}
{"id": "concept_three_party_computation", "type": "V_concept", "name": "Three-Party Computation", "properties": {"description": "A type of secure multi-party computation involving three parties, typically a distributor and two evaluators.", "keywords": ["computation", "distributor", "evaluators", "three-party"], "source_lectures": ["lecture_106108229_w5_l32", "lecture_106108229_w5_l33"]}}
{"id": "concept_mss_secret_sharing", "type": "V_concept", "name": "MSS Secret Sharing", "properties": {"description": "A secret sharing scheme used in secure multi-party computation, where a secret is divided into shares among multiple parties.", "keywords": ["secret", "mss", "sharing", "scheme", "computation", "secure"], "source_lectures": ["lecture_106108229_w5_l32", "lecture_106108229_w5_l33"]}}
{"id": "concept_circuit_evaluation_phase", "type": "V_concept", "name": "Circuit Evaluation Phase", "properties": {"description": "A phase in secure multi-party computation where the evaluators perform computations on the shared data.", "keywords": ["evaluation", "phase", "evaluators", "circuit", "computation"], "source_lectures": ["lecture_106108229_w5_l32", "lecture_106108229_w5_l33"]}}
{"id": "concept_otp_encryption", "type": "V_concept", "name": "OTP Encryption", "properties": {"description": "A type of encryption that uses a one-time pad to secure the data.", "keywords": ["otp", "encryption", "one-time", "pad", "secure"], "source_lectures": ["lecture_106108229_w5_l33"]}}
{"id": "concept_gamma_value", "type": "V_concept", "name": "Gamma Value", "properties": {"description": "A value computed by the distributor as the product of the pads associated with the inputs of a multiplication gate.", "keywords": ["gamma", "value", "distributor", "pads", "multiplication"], "source_lectures": ["lecture_106108229_w5_l33"]}}
{"id": "concept_gmw_mpc_protocol", "type": "V_concept", "name": "GMW MPC Protocol", "properties": {"description": "A secure multi-party computation protocol used for secure computation.", "keywords": ["gmw", "mpc", "protocol", "secure", "computation"], "source_lectures": ["lecture_106108229_w5_l35"]}}
{"id": "concept_multiplication_protocol", "type": "V_concept", "name": "Multiplication Protocol", "properties": {"description": "A protocol used for secure multiplication in multi-party computation.", "keywords": ["multiplication", "protocol", "secure", "computation"], "source_lectures": ["lecture_106108229_w5_l35"]}}
{"id": "concept_1_out_of_2_oblivious_transfer", "type": "V_concept", "name": "1 Out Of 2 Oblivious Transfer", "properties": {"description": "A variant of oblivious transfer where the sender has two messages and the receiver has a choice bit, and the receiver receives the message corresponding to their choice bit.", "keywords": ["1outof2", "oblivious", "transfer", "cryptography"], "source_lectures": ["lecture_106108229_w6_l36"]}}
{"id": "concept_rabins_oblivious_transfer", "type": "V_concept", "name": "Rabin's Oblivious Transfer", "properties": {"description": "The original formulation of oblivious transfer by Michael Rabin, where the sender has one message and the receiver has a 50% chance of receiving the message or a null output.", "keywords": ["rabin", "oblivious", "transfer", "cryptography"], "source_lectures": ["lecture_106108229_w6_l36"]}}
{"id": "concept_sender_security", "type": "V_concept", "name": "Sender Security", "properties": {"description": "A security property that ensures the sender does not learn any information about the receiver's choice bit or the message that was not transferred.", "keywords": ["sender", "security", "oblivious", "transfer"], "source_lectures": ["lecture_106108229_w6_l36"]}}
{"id": "concept_receiver_security", "type": "V_concept", "name": "Receiver Security", "properties": {"description": "A security property that ensures the receiver only learns the message that they are interested in and does not learn any information about the other message.", "keywords": ["receiver", "security", "oblivious", "transfer"], "source_lectures": ["lecture_106108229_w6_l36"]}}
{"id": "concept_1_out_of_n_oblivious_transfer", "type": "V_concept", "name": "1 Out Of N Oblivious Transfer", "properties": {"description": "A generalization of 1 out of 2 oblivious transfer, where the sender has N messages and the receiver has a choice index, and the receiver receives the message corresponding to their choice index.", "keywords": ["1outofn", "oblivious", "transfer", "cryptography"], "source_lectures": ["lecture_106108229_w6_l36"]}}
{"id": "concept_k_out_of_n_oblivious_transfer", "type": "V_concept", "name": "K Out Of N Oblivious Transfer", "properties": {"description": "A further generalization of 1 out of N oblivious transfer, where the sender has N messages and the receiver has K choice indices, and the receiver receives the K messages corresponding to their choice indices.", "keywords": ["koutofn", "oblivious", "transfer", "cryptography"], "source_lectures": ["lecture_106108229_w6_l36"]}}
{"id": "concept_pseudorandom_function", "type": "V_concept", "name": "Pseudorandom Function", "properties": {"description": "A keyed function that imitates a true random function, used for encryption and other cryptographic applications.", "keywords": ["unpredictable", "prf", "pseudorandom", "encryption", "function", "random", "cryptography"], "source_lectures": ["lecture_106108229_w6_l36", "lecture_106108229_w8_l53", "lecture_106106221_w4_l24"]}}
{"id": "concept_ot_protocol_construction", "type": "V_concept", "name": "OT Protocol Construction", "properties": {"description": "A method for constructing oblivious transfer protocols, using techniques such as pseudorandom functions and encryption.", "keywords": ["ot", "protocol", "construction", "cryptography"], "source_lectures": ["lecture_106108229_w6_l36"]}}
{"id": "concept_zn_star_set", "type": "V_concept", "name": "ZN Star Set", "properties": {"description": "The set of integers modulo N that are relatively prime to N, forming a multiplicative group under modulo N arithmetic.", "keywords": ["zn star", "modulo", "coprime", "multiplicative group", "number theory"], "source_lectures": ["lecture_106108229_w6_l37"]}}
{"id": "concept_eulers_totient_function", "type": "V_concept", "name": "Euler's Totient Function", "properties": {"description": "A function \u03c6(N) that counts the number of integers less than N that are relatively prime to N.", "keywords": ["coprime", "totient", "phi", "euler totient", "function", "count", "number theory", "euler"], "source_lectures": ["lecture_106108229_w6_l37", "lecture_106106221_w7_l45"]}}
{"id": "concept_multiplicative_inverse_modulo_n", "type": "V_concept", "name": "Multiplicative Inverse Modulo N", "properties": {"description": "For an element a in ZN*, the multiplicative inverse is the unique element b such that (a * b) mod N = 1.", "keywords": ["zn star", "integer", "product", "inverse", "modulo", "multiplicative inverse", "extended euclid", "modulus", "multiplicative"], "source_lectures": ["lecture_106108229_w6_l37", "lecture_106106221_w8_l55"]}}
{"id": "concept_extended_euclidean_algorithm", "type": "V_concept", "name": "Extended Euclidean Algorithm", "properties": {"description": "An efficient algorithm to compute the greatest common divisor and the multiplicative inverse of two integers.", "keywords": ["extended euclid", "gcd", "inverse", "modular arithmetic", "algorithm"], "source_lectures": ["lecture_106108229_w6_l37"]}}
{"id": "concept_eulers_theorem", "type": "V_concept", "name": "Euler's Theorem", "properties": {"description": "For any integer a coprime to N, a^\u03c6(N) \u2261 1 (mod N), where \u03c6(N) is Euler's totient function.", "keywords": ["euler theorem", "modular exponentiation", "phi", "coprime", "number theory"], "source_lectures": ["lecture_106108229_w6_l37"]}}
{"id": "concept_rsa_permutation", "type": "V_concept", "name": "RSA Permutation", "properties": {"description": "A bijection from ZN* to ZN* defined by exponentiation modulo N using a public exponent e coprime to \u03c6(N).", "keywords": ["zn star", "rsa", "mapping", "modular arithmetic", "exponentiation", "permutation", "rsa permutation", "bijection", "exponent"], "source_lectures": ["lecture_106108229_w6_l37", "lecture_106106221_w7_l45"]}}
{"id": "concept_rsa_public_exponent", "type": "V_concept", "name": "RSA Public Exponent", "properties": {"description": "An integer e > 2 that is coprime to \u03c6(N) and used as the public key in RSA encryption.", "keywords": ["rsa public exponent", "e", "public key", "coprime", "phi"], "source_lectures": ["lecture_106108229_w6_l37"]}}
{"id": "concept_rsa_private_exponent", "type": "V_concept", "name": "RSA Private Exponent", "properties": {"description": "The multiplicative inverse d of the public exponent e modulo \u03c6(N), used for decryption in RSA.", "keywords": ["rsa private exponent", "d", "private key", "inverse", "phi"], "source_lectures": ["lecture_106108229_w6_l37"]}}
{"id": "concept_rsa_problem", "type": "V_concept", "name": "RSA Problem", "properties": {"description": "The computational problem of finding the eth root of a random element y in ZN* given only N and e, without knowledge of \u03c6(N) or the prime factors of N.", "keywords": ["rsa", "rsa problem", "modular root", "security", "computational", "inversion", "modular", "problem", "eth root", "cryptanalysis", "factoring", "hard problem"], "source_lectures": ["lecture_106108229_w6_l37", "lecture_106106221_w7_l46", "lecture_106106221_w8_l52"]}}
{"id": "concept_rsa_assumption", "type": "V_concept", "name": "RSA Assumption", "properties": {"description": "The assumption that no probabilistic polynomial-time algorithm can solve the RSA problem with non-negligible probability without knowledge of the prime factors of N.", "keywords": ["rsa", "rsa problem", "assumption", "security", "hardness", "computational", "cryptographic assumption", "rsa assumption", "cryptography"], "source_lectures": ["lecture_106108229_w6_l37", "lecture_106108229_w6_l38", "lecture_106106221_w7_l45", "lecture_106106221_w7_l46", "lecture_106106221_w8_l50"]}}
{"id": "concept_rsa_hard_core_predicate", "type": "V_concept", "name": "RSA Hard-Core Predicate", "properties": {"description": "A bit function (e.g., LSB of x) that is computationally hard to predict from the RSA output y = x^e mod N, even when N and e are known.", "keywords": ["rsa hard-core", "hard-core predicate", "lsb", "predictability", "one-way function"], "source_lectures": ["lecture_106108229_w6_l37"]}}
{"id": "concept_least_significant_bit_lsb_as_hard_core_bit", "type": "V_concept", "name": "Least Significant Bit (LSB) as Hard-Core Bit", "properties": {"description": "The least significant bit of the input x is a hard-core predicate of the RSA function, meaning it cannot be predicted with probability significantly better than 1/2 from y = x^e mod N.", "keywords": ["lsb", "hard-core bit", "rsa", "predict", "bit security"], "source_lectures": ["lecture_106108229_w6_l37"]}}
{"id": "concept_genrsa_algorithm", "type": "V_concept", "name": "GenRSA Algorithm", "properties": {"description": "A probabilistic algorithm that generates RSA parameters: two random \u03bb-bit primes p and q, modulus N = p*q, public exponent e, and private exponent d.", "keywords": ["rsa", "modulus", "algorithm", "exponent", "parameters", "prime generation", "rsa key generation", "genrsa"], "source_lectures": ["lecture_106108229_w6_l37", "lecture_106106221_w7_l45"]}}
{"id": "concept_bijection_in_rsa", "type": "V_concept", "name": "Bijection in RSA", "properties": {"description": "The RSA function f_e(x) = x^e mod N is a bijection over ZN*, meaning it is both injective and surjective.", "keywords": ["bijection", "rsa function", "injective", "surjective", "zn star"], "source_lectures": ["lecture_106108229_w6_l37"]}}
{"id": "concept_rsa_security_game", "type": "V_concept", "name": "RSA Security Game", "properties": {"description": "A formal experiment where an adversary tries to solve the RSA problem given N, e, and y, and wins if they output x such that x^e \u2261 y mod N.", "keywords": ["rsa security game", "adversary", "experiment", "challenge", "cryptographic security"], "source_lectures": ["lecture_106108229_w6_l37"]}}
{"id": "concept_hard_core_predicate_experiment", "type": "V_concept", "name": "Hard-Core Predicate Experiment", "properties": {"description": "A security game where an adversary attempts to predict the hard-core bit (e.g., LSB) of x given only the RSA output y = x^e mod N.", "keywords": ["hard-core experiment", "adversary", "bit prediction", "rsa", "negligible advantage"], "source_lectures": ["lecture_106108229_w6_l37"]}}
{"id": "concept_probabilistic_polynomial_time_adversary", "type": "V_concept", "name": "Probabilistic Polynomial-Time Adversary", "properties": {"description": "A computational model for an attacker in cryptography who can run in polynomial time and use randomness.", "keywords": ["ppt adversary", "probabilistic", "polynomial time", "attacker", "cryptographic model"], "source_lectures": ["lecture_106108229_w6_l37"]}}
{"id": "concept_one_way_trapdoor_permutation", "type": "V_concept", "name": "One-Way Trapdoor Permutation", "properties": {"description": "A permutation that is easy to compute in one direction but hard to invert without a special trapdoor information", "keywords": ["one-way", "cryptographic", "codomain", "trapdoor", "public-key", "permutation", "function", "domain"], "source_lectures": ["lecture_106108229_w6_l38", "lecture_106106221_w6_l37", "lecture_106106221_w7_l46"]}}
{"id": "concept_goldreich_levin_theorem", "type": "V_concept", "name": "Goldreich-Levin Theorem", "properties": {"description": "States that any one-way function can be converted into a one-way function with a hardcore predicate", "keywords": ["one-way", "way", "function", "one", "goldreich", "theorem", "levin", "cryptography"], "source_lectures": ["lecture_106108229_w6_l38", "lecture_106106221_w2_l11", "lecture_106106221_w3_l18"]}}
{"id": "concept_bit_ot_protocol", "type": "V_concept", "name": "Bit OT Protocol", "properties": {"description": "A protocol for oblivious transfer of one bit", "keywords": ["bit", "ot", "protocol", "cryptography"], "source_lectures": ["lecture_106108229_w6_l38"]}}
{"id": "concept_rsa_hardcore_bit", "type": "V_concept", "name": "RSA Hardcore Bit", "properties": {"description": "A hardcore predicate based on the RSA assumption", "keywords": ["rsa", "hardcore", "bit", "cryptography"], "source_lectures": ["lecture_106108229_w6_l38"]}}
{"id": "concept_one_way_function", "type": "V_concept", "name": "One-Way Function", "properties": {"description": "A function that is easy to compute in one direction but hard to invert", "keywords": ["one-way", "invert", "security", "inversion", "way", "function", "one", "easy", "hard", "cryptography"], "source_lectures": ["lecture_106108229_w6_l38", "lecture_106106221_w2_l11", "lecture_106106221_w3_l18", "lecture_106106221_w6_l36", "lecture_106106221_w6_l37", "lecture_106106221_w7_l45", "lecture_106106221_w9_l62"]}}
{"id": "concept_trapdoor_information", "type": "V_concept", "name": "Trapdoor Information", "properties": {"description": "Additional information that allows to invert a one-way trapdoor permutation", "keywords": ["trapdoor", "information", "cryptography", "security"], "source_lectures": ["lecture_106108229_w6_l38"]}}
{"id": "concept_parameter_generation_algorithm", "type": "V_concept", "name": "Parameter Generation Algorithm", "properties": {"description": "An algorithm that generates public and secret parameters for a cryptographic scheme", "keywords": ["parameter", "generation", "algorithm", "cryptography"], "source_lectures": ["lecture_106108229_w6_l38"]}}
{"id": "concept_cyclic_group", "type": "V_concept", "name": "Cyclic Group", "properties": {"description": "A group that can be generated by a single element, with a finite number of elements.", "keywords": ["algebra", "generator", "finite", "cyclic group", "modular", "group operation", "group", "element", "finite group", "mathematical", "cyclic", "mathematics"], "source_lectures": ["lecture_106108229_w6_l39", "lecture_106106221_w6_l39", "lecture_106106221_w6_l40", "lecture_106106221_w6_l41", "lecture_106106221_w6_l42", "lecture_106106221_w7_l43", "lecture_106106221_w8_l53"]}}
{"id": "concept_discrete_logarithm", "type": "V_concept", "name": "Discrete Logarithm", "properties": {"description": "The power to which a generator must be raised to produce a given element in a cyclic group.", "keywords": ["generator", "logarithm", "discrete", "group", "cyclic"], "source_lectures": ["lecture_106108229_w6_l39", "lecture_106106221_w6_l42"]}}
{"id": "concept_discrete_logarithm_assumption", "type": "V_concept", "name": "Discrete Logarithm Assumption", "properties": {"description": "The assumption that the discrete logarithm problem is computationally infeasible.", "keywords": ["computationally", "cryptographic", "assumption", "hardness", "logarithm", "discrete", "discrete log assumption", "cyclic group", "group", "cyclic", "dlog assumption", "infeasible"], "source_lectures": ["lecture_106108229_w6_l39", "lecture_106106221_w6_l39", "lecture_106106221_w8_l53"]}}
{"id": "concept_diffie_hellman_problem", "type": "V_concept", "name": "Diffie-Hellman Problem", "properties": {"description": "The problem of distinguishing a Diffie-Hellman triple from a random triple in a cyclic group.", "keywords": ["diffie", "hellman", "problem", "cyclic", "group"], "source_lectures": ["lecture_106108229_w6_l39"]}}
{"id": "concept_diffie_hellman_assumption", "type": "V_concept", "name": "Diffie-Hellman Assumption", "properties": {"description": "The assumption that the Diffie-Hellman problem is computationally infeasible.", "keywords": ["diffie", "hellman", "assumption", "computationally", "infeasible"], "source_lectures": ["lecture_106108229_w6_l39"]}}
{"id": "concept_decisional_diffie_hellman_problem", "type": "V_concept", "name": "Decisional Diffie-Hellman Problem", "properties": {"description": "The problem of distinguishing a Diffie-Hellman triple from a random triple in a cyclic group.", "keywords": ["hellman", "decisional", "cyclic group", "triplet", "problem", "group", "distinguish", "ddh", "diffie", "cyclic", "decisional diffie-hellman"], "source_lectures": ["lecture_106108229_w6_l39", "lecture_106106221_w6_l39"]}}
{"id": "concept_ddh_assumption", "type": "V_concept", "name": "DDH Assumption", "properties": {"description": "The assumption that the decisional Diffie-Hellman problem is computationally infeasible.", "keywords": ["computationally", "assumption", "cyclic group", "diffie-hellman", "cryptographic assumption", "ddh", "decisional diffie-hellman", "infeasible"], "source_lectures": ["lecture_106108229_w6_l39", "lecture_106108229_w7_l44"]}}
{"id": "concept_preprocessing_phase", "type": "V_concept", "name": "Preprocessing Phase", "properties": {"description": "A phase in the GMW protocol where additively shared random multiplication triples are generated.", "keywords": ["preprocessing", "gmw", "protocol", "multiplication", "triples"], "source_lectures": ["lecture_106108229_w6_l41"]}}
{"id": "concept_additively_shared_random_multiplication_triples", "type": "V_concept", "name": "Additively Shared Random Multiplication Triples", "properties": {"description": "A data structure where three random values are shared among parties such that the product of the first two values equals the third value.", "keywords": ["additively", "shared", "random", "multiplication", "triples"], "source_lectures": ["lecture_106108229_w6_l41"]}}
{"id": "concept_boolean_ring", "type": "V_concept", "name": "Boolean Ring", "properties": {"description": "A mathematical structure with two elements, 0 and 1, where the addition operation is XOR and the multiplication operation is AND.", "keywords": ["boolean", "ring", "xor", "and", "mathematics"], "source_lectures": ["lecture_106108229_w6_l41"]}}
{"id": "concept_rand_extract_protocol", "type": "V_concept", "name": "Rand-Extract Protocol", "properties": {"description": "A protocol used to generate additively shared random values among parties.", "keywords": ["rand-extract", "protocol", "random", "additively", "shared"], "source_lectures": ["lecture_106108229_w6_l41"]}}
{"id": "concept_one_out_of_two_oblivious_transfer", "type": "V_concept", "name": "One-Out-Of-Two Oblivious Transfer", "properties": {"description": "A type of oblivious transfer where the receiver can choose one of two messages to receive.", "keywords": ["one-out-of-two", "oblivious", "transfer", "cryptographic", "protocol"], "source_lectures": ["lecture_106108229_w6_l41"]}}
{"id": "concept_one_out_of_four_oblivious_transfer", "type": "V_concept", "name": "One-Out-Of-Four Oblivious Transfer", "properties": {"description": "A type of oblivious transfer where the receiver can choose one of four messages to receive.", "keywords": ["one-out-of-four", "oblivious", "transfer", "cryptographic", "protocol"], "source_lectures": ["lecture_106108229_w6_l41"]}}
{"id": "concept_dishonest_majority_setting", "type": "V_concept", "name": "Dishonest Majority Setting", "properties": {"description": "A scenario in secure computation where the majority of parties may be dishonest or malicious.", "keywords": ["dishonest", "majority", "setting", "secure", "computation"], "source_lectures": ["lecture_106108229_w6_l41"]}}
{"id": "concept_additive_secret_sharing_over_rings", "type": "V_concept", "name": "Additive Secret Sharing over Rings", "properties": {"description": "A method of distributing a secret value among parties such that the sum of shares equals the original value, using addition operations in a general ring rather than XOR in Boolean rings.", "keywords": ["additive secret sharing", "ring", "secret sharing", "addition", "ring elements"], "source_lectures": ["lecture_106108229_w7_l43"]}}
{"id": "concept_multiplication_triple", "type": "V_concept", "name": "Multiplication Triple", "properties": {"description": "A triplet of values (a, b, c) where c = a \u00d7 b, used in secure computation to enable multiplication of secret-shared values without revealing inputs.", "keywords": ["mpc", "b", "c", "secure computation", "multiplication triple", "triple", "secret sharing", "pre-processing", "a"], "source_lectures": ["lecture_106108229_w7_l43", "lecture_106108229_w7_l44"]}}
{"id": "concept_gilboas_multiplication_protocol", "type": "V_concept", "name": "Gilboa's Multiplication Protocol", "properties": {"description": "A secure two-party protocol for computing the product of two secret-shared ring elements using oblivious transfer to mask and reconstruct the result.", "keywords": ["gilboa", "multiplication protocol", "oblivious transfer", "ring multiplication", "secure computation"], "source_lectures": ["lecture_106108229_w7_l43"]}}
{"id": "concept_oblivious_transfer_ot", "type": "V_concept", "name": "Oblivious Transfer (OT)", "properties": {"description": "A cryptographic protocol where a receiver obtains one of several messages from a sender without the sender learning which message was chosen.", "keywords": ["cryptographic protocol", "privacy", "ot", "oblivious transfer", "cryptographic primitive", "receiver", "sender"], "source_lectures": ["lecture_106108229_w7_l43", "lecture_106108229_w7_l44", "lecture_106108229_w7_l46"]}}
{"id": "concept_ring_element_representation", "type": "V_concept", "name": "Ring Element Representation", "properties": {"description": "The encoding of elements from a finite ring as binary strings of fixed length l bits, enabling bitwise operations in secure computation protocols.", "keywords": ["ring element", "bit representation", "l-bit", "finite ring", "encoding"], "source_lectures": ["lecture_106108229_w7_l43"]}}
{"id": "concept_cross_term_in_secure_multiplication", "type": "V_concept", "name": "Cross Term in Secure Multiplication", "properties": {"description": "A product term between shares of different parties (e.g., a\u2081\u00d7b\u2082 or a\u2082\u00d7b\u2081) that must be securely computed during multiplication of secret-shared values in multi-party protocols.", "keywords": ["cross term", "a1b2", "a2b1", "secret sharing", "multiplication"], "source_lectures": ["lecture_106108229_w7_l43"]}}
{"id": "concept_gmw_pre_processing_phase", "type": "V_concept", "name": "GMW Pre-processing Phase", "properties": {"description": "The initial stage of the Goldreich-Micali-Wigderson protocol where additive secret shares of multiplication triples are generated to enable secure multiplication in later computation phases.", "keywords": ["gmw", "pre-processing", "multiplication triples", "secure computation", "secret sharing"], "source_lectures": ["lecture_106108229_w7_l43"]}}
{"id": "concept_randomness_extraction_for_secret_sharing", "type": "V_concept", "name": "Randomness Extraction for Secret Sharing", "properties": {"description": "A process to generate uniformly random secret-shared values over a ring, used in the first stage of GMW pre-processing to create random a and b components of multiplication triples.", "keywords": ["randomness extraction", "secret sharing", "random values", "ring", "gmw"], "source_lectures": ["lecture_106108229_w7_l43"]}}
{"id": "concept_secure_multi_party_computation_mpc", "type": "V_concept", "name": "Secure Multi-Party Computation (MPC)", "properties": {"description": "A cryptographic framework allowing multiple parties to jointly compute a function over their private inputs while preserving privacy and correctness.", "keywords": ["secure computation", "mpc", "multi-party", "privacy", "computation"], "source_lectures": ["lecture_106108229_w7_l43"]}}
{"id": "concept_masking_in_secure_protocols", "type": "V_concept", "name": "Masking in Secure Protocols", "properties": {"description": "The technique of adding random values (masks) to intermediate computations to obscure actual values, ensuring privacy in protocols like Gilboa's multiplication protocol.", "keywords": ["masking", "random mask", "privacy", "obfuscation", "secure protocol"], "source_lectures": ["lecture_106108229_w7_l43"]}}
{"id": "concept_ring_arithmetic", "type": "V_concept", "name": "Ring Arithmetic", "properties": {"description": "Mathematical operations (addition, multiplication) performed under the axioms of a general ring, including modular arithmetic over integers modulo 2^l.", "keywords": ["ring arithmetic", "modular arithmetic", "ring operations", "addition", "multiplication"], "source_lectures": ["lecture_106108229_w7_l43"]}}
{"id": "concept_share_reconstruction_in_mpc", "type": "V_concept", "name": "Share Reconstruction in MPC", "properties": {"description": "The process of combining secret shares from multiple parties to recover the result of a computation, such as summing z\u2081 and z\u2082 to obtain x\u00d7y.", "keywords": ["share reconstruction", "secret sharing", "sum", "result recovery", "mpc"], "source_lectures": ["lecture_106108229_w7_l43"]}}
{"id": "concept_privacy_preservation_in_ot", "type": "V_concept", "name": "Privacy Preservation in OT", "properties": {"description": "The guarantee that in an oblivious transfer protocol, the sender does not learn the receiver\u2019s choice bit and the receiver learns only one message, preserving input privacy.", "keywords": ["privacy", "oblivious transfer", "choice bit", "sender privacy", "receiver privacy"], "source_lectures": ["lecture_106108229_w7_l43"]}}
{"id": "concept_two_party_secure_multiplication", "type": "V_concept", "name": "Two-Party Secure Multiplication", "properties": {"description": "A protocol enabling two parties to compute the product of their private ring inputs while revealing only the secret-shared result.", "keywords": ["two-party", "secure multiplication", "ring", "private input", "secret sharing"], "source_lectures": ["lecture_106108229_w7_l43"]}}
{"id": "concept_generalization_to_n_party_gmw", "type": "V_concept", "name": "Generalization to n-Party GMW", "properties": {"description": "The extension of the two-party GMW pre-processing protocol to n parties by computing O(n\u00b2) cross terms using pairwise instances of the multiplication protocol.", "keywords": ["n-party", "generalization", "gmw", "cross terms", "secure computation"], "source_lectures": ["lecture_106108229_w7_l43"]}}
{"id": "concept_bitwise_expansion_of_ring_elements", "type": "V_concept", "name": "Bitwise Expansion of Ring Elements", "properties": {"description": "Representing a ring element as a sum of its bits multiplied by powers of two, enabling decomposition of multiplication into bitwise operations.", "keywords": ["bitwise expansion", "binary representation", "ring element", "power of two", "multiplication"], "source_lectures": ["lecture_106108229_w7_l43"]}}
{"id": "concept_additive_inverse_in_ring_arithmetic", "type": "V_concept", "name": "Additive Inverse in Ring Arithmetic", "properties": {"description": "The element that, when added to a given ring element, yields the additive identity (zero), used to compute the second share in Gilboa's protocol.", "keywords": ["additive inverse", "ring", "zero", "inverse", "arithmetic"], "source_lectures": ["lecture_106108229_w7_l43"]}}
{"id": "concept_secret_shared_output", "type": "V_concept", "name": "Secret-Shared Output", "properties": {"description": "A result of a computation distributed as shares among parties such that the sum of shares equals the true result, without revealing individual shares.", "keywords": ["secret shared", "output", "shares", "sum", "privacy"], "source_lectures": ["lecture_106108229_w7_l43"]}}
{"id": "concept_input_privacy_in_mpc", "type": "V_concept", "name": "Input Privacy in MPC", "properties": {"description": "The security property ensuring that no party learns anything about other parties' private inputs beyond what is revealed by the output of the computation.", "keywords": ["input privacy", "mpc", "secure computation", "privacy", "leakage"], "source_lectures": ["lecture_106108229_w7_l43"]}}
{"id": "concept_local_computation_in_mpc", "type": "V_concept", "name": "Local Computation in MPC", "properties": {"description": "Operations performed by a party using only its own secret shares and publicly known values, without communication, to contribute to the final result.", "keywords": ["local computation", "mpc", "secret share", "local", "computation"], "source_lectures": ["lecture_106108229_w7_l43"]}}
{"id": "concept_pre_processing_of_oblivious_transfer", "type": "V_concept", "name": "Pre-Processing of Oblivious Transfer", "properties": {"description": "A technique to generate multiple oblivious transfer instances using a small number of base OTs combined with symmetric-key operations to reduce computational cost.", "keywords": ["pre-processing", "ot extension", "oblivious transfer", "symmetric key", "computation optimization"], "source_lectures": ["lecture_106108229_w7_l44"]}}
{"id": "concept_random_oblivious_transfer_rot", "type": "V_concept", "name": "Random Oblivious Transfer (ROT)", "properties": {"description": "A variant of oblivious transfer where sender and receiver use random inputs during pre-processing to later enable actual OTs using only symmetric-key operations.", "keywords": ["random ot", "rot", "oblivious transfer", "pre-processing", "one-time pad"], "source_lectures": ["lecture_106108229_w7_l44"]}}
{"id": "concept_domain_extension_for_oblivious_transfer", "type": "V_concept", "name": "Domain Extension for Oblivious Transfer", "properties": {"description": "A method to extend short-input oblivious transfer to handle long-input messages using pseudorandom generators, avoiding costly OTs on large data.", "keywords": ["domain extension", "ot extension", "pseudorandom generator", "seed", "long input"], "source_lectures": ["lecture_106108229_w7_l44"]}}
{"id": "concept_security_parameter_lambda", "type": "V_concept", "name": "Security Parameter (lambda)", "properties": {"description": "A numerical value that determines the security level of a cryptographic primitive, typically measured in bits and tied to the hardness of underlying computational problems.", "keywords": ["security parameter", "lambda", "cryptographic security", "bit length", "hard problem"], "source_lectures": ["lecture_106108229_w7_l44"]}}
{"id": "concept_symmetric_key_cryptographic_primitive", "type": "V_concept", "name": "Symmetric-Key Cryptographic Primitive", "properties": {"description": "A cryptographic function that uses the same key for encryption and decryption, such as pseudorandom functions or hash functions, with typically smaller security parameters (e.g., 128 bits).", "keywords": ["symmetric key", "pseudorandom function", "hash function", "encryption", "security parameter"], "source_lectures": ["lecture_106108229_w7_l44"]}}
{"id": "concept_asymmetric_key_cryptographic_primitive", "type": "V_concept", "name": "Asymmetric-Key Cryptographic Primitive", "properties": {"description": "A cryptographic function that uses a pair of keys (public and private), such as RSA or Diffie-Hellman, requiring large security parameters (e.g., 2048 bits) for security.", "keywords": ["asymmetric key", "public key", "rsa", "diffie-hellman", "modular exponentiation"], "source_lectures": ["lecture_106108229_w7_l44"]}}
{"id": "concept_pseudorandom_generator_prg", "type": "V_concept", "name": "Pseudorandom Generator (PRG)", "properties": {"description": "A deterministic algorithm that expands a short random seed into a longer output that is computationally indistinguishable from a truly random string.", "keywords": ["seed", "expansion", "prg", "pseudorandom", "generator", "indistinguishable", "pseudorandom generator", "indistinguishability"], "source_lectures": ["lecture_106108229_w7_l44", "lecture_106106221_w5_l29"]}}
{"id": "concept_gmw_protocol_pre_processing_phase", "type": "V_concept", "name": "GMW Protocol Pre-Processing Phase", "properties": {"description": "The stage in the Goldreich-Micali-Wigderson MPC protocol where parties generate secret-shared multiplication triples using oblivious transfers and other cryptographic primitives.", "keywords": ["gmw", "pre-processing", "multiplication triples", "mpc", "secret sharing"], "source_lectures": ["lecture_106108229_w7_l44"]}}
{"id": "concept_cross_term_in_mpc", "type": "V_concept", "name": "Cross Term in MPC", "properties": {"description": "A pair of secret shares from two parties that must be securely combined during MPC computation, often requiring an oblivious transfer for secure evaluation.", "keywords": ["cross term", "mpc", "secret sharing", "multiplication gate", "oblivious transfer"], "source_lectures": ["lecture_106108229_w7_l44"]}}
{"id": "concept_one_time_pad_otp_encryption", "type": "V_concept", "name": "One-Time Pad (OTP) Encryption", "properties": {"description": "A symmetric encryption technique where a plaintext is XORed with a random key of the same length, providing perfect secrecy if the key is used only once.", "keywords": ["one-time pad", "otp", "xor", "encryption", "perfect secrecy"], "source_lectures": ["lecture_106108229_w7_l44"]}}
{"id": "concept_computation_complexity_vs_communication_complexity", "type": "V_concept", "name": "Computation Complexity vs Communication Complexity", "properties": {"description": "A trade-off in distributed protocols where computation cost (e.g., modular exponentiation) dominates communication cost due to the overhead of cryptographic operations.", "keywords": ["computation complexity", "communication complexity", "distributed protocol", "cryptographic cost", "overhead"], "source_lectures": ["lecture_106108229_w7_l44"]}}
{"id": "concept_field_size_in_secret_sharing", "type": "V_concept", "name": "Field Size in Secret Sharing", "properties": {"description": "The size of the finite field used in secret-sharing schemes like BGW, which determines the security parameter and must be at least as large as the number of participants.", "keywords": ["field size", "secret sharing", "bgw protocol", "polynomial interpolation", "security parameter"], "source_lectures": ["lecture_106108229_w7_l44"]}}
{"id": "concept_rsa_based_oblivious_transfer", "type": "V_concept", "name": "RSA-Based Oblivious Transfer", "properties": {"description": "An oblivious transfer protocol constructed using the RSA cryptosystem, where security relies on the hardness of factoring large integers.", "keywords": ["rsa", "oblivious transfer", "public key", "factoring", "modular exponentiation"], "source_lectures": ["lecture_106108229_w7_l44"]}}
{"id": "concept_circuit_based_mpc", "type": "V_concept", "name": "Circuit-Based MPC", "properties": {"description": "A model of secure multi-party computation where parties evaluate a Boolean or arithmetic circuit representing the function to be computed securely.", "keywords": ["circuit-based mpc", "boolean circuit", "arithmetic circuit", "mpc", "gmw"], "source_lectures": ["lecture_106108229_w7_l44"]}}
{"id": "concept_polynomial_security_system", "type": "V_concept", "name": "Polynomial Security System", "properties": {"description": "A system that uses polynomial functions to ensure security in computation and data transfer.", "keywords": ["polynomial", "security", "system", "computation", "data"], "source_lectures": ["lecture_106108229_w7_l45"]}}
{"id": "concept_transformation", "type": "V_concept", "name": "Transformation", "properties": {"description": "A process of changing the form or structure of something, often used in computation and data processing.", "keywords": ["transformation", "computation", "data", "processing", "structure"], "source_lectures": ["lecture_106108229_w7_l45"]}}
{"id": "concept_matrix", "type": "V_concept", "name": "Matrix", "properties": {"description": "A mathematical construct used to represent and manipulate data in a structured way.", "keywords": ["matrix", "mathematics", "data", "structure", "manipulation"], "source_lectures": ["lecture_106108229_w7_l45"]}}
{"id": "concept_ot_extension_protocol", "type": "V_concept", "name": "OT Extension Protocol", "properties": {"description": "A cryptographic technique that allows multiple oblivious transfers to be constructed from a small number of base OT instances using symmetric-key operations.", "keywords": ["oblivious", "cryptographic", "efficient", "ot", "oblivious transfer", "protocol", "ot extension", "extension", "transfer", "cryptography"], "source_lectures": ["lecture_106108229_w7_l46", "lecture_106108229_w7_l47", "lecture_106108229_w8_l54"]}}
{"id": "concept_base_ots", "type": "V_concept", "name": "Base OTs", "properties": {"description": "A small number of standard oblivious transfer instances used as primitives to enable the construction of many extended OTs in OT extension protocols.", "keywords": ["base ot", "oblivious transfer", "primitive", "cryptographic primitive", "lambda"], "source_lectures": ["lecture_106108229_w7_l46"]}}
{"id": "concept_iknp_ot_extension", "type": "V_concept", "name": "IKNP OT Extension", "properties": {"description": "An OT extension protocol by Ishai, Kilian, Nissim, and Petrank that uses random matrices, PRGs, and correlation-robust hashing to extend OTs efficiently.", "keywords": ["iknp", "ot extension", "ishai", "kilian", "nissim"], "source_lectures": ["lecture_106108229_w7_l46"]}}
{"id": "concept_random_matrix_t", "type": "V_concept", "name": "Random Matrix T", "properties": {"description": "A k \u00d7 \u03bb random bit matrix generated by the receiver (Bob) to mask his choice bits during OT extension, where rows correspond to message pairs and columns to OT instances.", "keywords": ["random matrix", "t matrix", "ot extension", "bob", "masking"], "source_lectures": ["lecture_106108229_w7_l46"]}}
{"id": "concept_choice_vector_b", "type": "V_concept", "name": "Choice Vector B", "properties": {"description": "A \u03bb-length binary vector held by Bob that determines which message he wishes to receive in each of the k extended OT pairs, masked during base OTs.", "keywords": ["choice vector", "b vector", "bob", "oblivious transfer", "selection"], "source_lectures": ["lecture_106108229_w7_l46"]}}
{"id": "concept_vector_s", "type": "V_concept", "name": "Vector S", "properties": {"description": "A \u03bb-length random binary vector chosen by Alice to XOR with columns of Bob\u2019s matrix T during base OTs, ensuring receiver security in OT extension.", "keywords": ["s vector", "alice", "random vector", "xor", "ot extension"], "source_lectures": ["lecture_106108229_w7_l46"]}}
{"id": "concept_matrix_q", "type": "V_concept", "name": "Matrix Q", "properties": {"description": "The k \u00d7 \u03bb matrix received by Alice after base OTs, where each row is either the corresponding row of T or T XOR S, depending on Bob\u2019s choice bits.", "keywords": ["q matrix", "alice matrix", "ot extension", "oblivious transfer", "received matrix"], "source_lectures": ["lecture_106108229_w7_l46"]}}
{"id": "concept_pseudorandom_generator_prg_seed_pairing", "type": "V_concept", "name": "Pseudorandom Generator (PRG) Seed Pairing", "properties": {"description": "A domain extension technique where Bob uses \u03bb pairs of PRG seeds instead of k-bit messages in base OTs, allowing efficient expansion of OT inputs.", "keywords": ["prg", "seed pairing", "domain extension", "ot extension", "pseudorandom"], "source_lectures": ["lecture_106108229_w7_l46"]}}
{"id": "concept_correlation_robust_hash_function", "type": "V_concept", "name": "Correlation-Robust Hash Function", "properties": {"description": "A cryptographic hash function whose output remains pseudorandom even when inputs are correlated, used to mask messages in OT extension protocols.", "keywords": ["correlation-robust hash", "crh", "hash function", "message masking", "ot extension"], "source_lectures": ["lecture_106108229_w7_l46"]}}
{"id": "concept_sender_security_in_base_ot", "type": "V_concept", "name": "Sender Security in Base OT", "properties": {"description": "The property that a malicious sender in a base OT cannot learn the receiver\u2019s choice bit, which is critical to preserving Bob\u2019s privacy in OT extension.", "keywords": ["sender security", "base ot", "oblivious transfer", "privacy", "choice bit"], "source_lectures": ["lecture_106108229_w7_l46"]}}
{"id": "concept_receiver_security_in_base_ot", "type": "V_concept", "name": "Receiver Security in Base OT", "properties": {"description": "The property that a malicious receiver in a base OT cannot learn more than the one message he is entitled to, which ensures Alice\u2019s message privacy in OT extension.", "keywords": ["receiver security", "base ot", "oblivious transfer", "privacy", "message secrecy"], "source_lectures": ["lecture_106108229_w7_l46"]}}
{"id": "concept_negligible_probability_of_s_0", "type": "V_concept", "name": "Negligible Probability of S = 0", "properties": {"description": "The probability that Alice\u2019s random vector S is all zeros is 1/2^\u03bb, which is negligible in the security parameter \u03bb, ensuring security of message masking.", "keywords": ["negligible probability", "s zero", "security parameter", "lambda", "random vector"], "source_lectures": ["lecture_106108229_w7_l46"]}}
{"id": "concept_domain_extension_in_ot", "type": "V_concept", "name": "Domain Extension in OT", "properties": {"description": "A method to reduce the input size of base OTs by using PRGs to expand short seeds into long messages, improving efficiency in OT extension.", "keywords": ["domain extension", "prg", "ot efficiency", "input size", "seed expansion"], "source_lectures": ["lecture_106108229_w7_l46"]}}
{"id": "concept_yaos_garbled_circuit_protocol", "type": "V_concept", "name": "Yao\u2019s Garbled Circuit Protocol", "properties": {"description": "A secure two-party computation protocol that requires a large number of oblivious transfers, making OT extension essential for practical deployment.", "keywords": ["yao", "garbled circuit", "secure computation", "ot", "two-party"], "source_lectures": ["lecture_106108229_w7_l46"]}}
{"id": "concept_public_key_operation_overhead", "type": "V_concept", "name": "Public Key Operation Overhead", "properties": {"description": "The computational cost of executing individual oblivious transfer instances using public-key cryptography, which OT extension aims to minimize.", "keywords": ["public key", "overhead", "ot cost", "computational cost", "efficiency"], "source_lectures": ["lecture_106108229_w7_l46"]}}
{"id": "concept_symmetric_key_operations_in_ot_extension", "type": "V_concept", "name": "Symmetric-Key Operations in OT Extension", "properties": {"description": "Efficient cryptographic operations (e.g., XOR, PRG, hashing) used to simulate many OTs after a small number of expensive public-key OTs.", "keywords": ["symmetric key", "xor", "prg", "hashing", "ot extension"], "source_lectures": ["lecture_106108229_w7_l46"]}}
{"id": "concept_security_parameter_\u03bb", "type": "V_concept", "name": "Security Parameter \u03bb", "properties": {"description": "A system parameter that determines the security level of a cryptographic protocol; base OTs scale with \u03bb, while extended OTs scale with k \u226b \u03bb.", "keywords": ["security parameter", "lambda", "cryptographic security", "scale", "parameter"], "source_lectures": ["lecture_106108229_w7_l46"]}}
{"id": "concept_message_pairing_in_ot_extension", "type": "V_concept", "name": "Message Pairing in OT Extension", "properties": {"description": "Each of the k extended OTs involves a pair of messages from Alice, one of which Bob receives based on his choice bit, masked using correlation-robust hashing.", "keywords": ["message pair", "ot pair", "alice message", "bob choice", "masking"], "source_lectures": ["lecture_106108229_w7_l46"]}}
{"id": "concept_xor_masking_of_messages", "type": "V_concept", "name": "XOR Masking of Messages", "properties": {"description": "The process of encrypting Alice\u2019s messages using XOR with a pseudorandom pad derived from T and S, ensuring only the correct message is decryptable by Bob.", "keywords": ["xor masking", "message encryption", "pad", "ot extension", "masking"], "source_lectures": ["lecture_106108229_w7_l46"]}}
{"id": "concept_column_wise_ot_input", "type": "V_concept", "name": "Column-wise OT Input", "properties": {"description": "In base OTs, Bob sends columns of matrix T (XORed with B) as messages, enabling oblivious transfer of rows of T to Alice.", "keywords": ["column input", "ot input", "matrix t", "bob sender", "base ot"], "source_lectures": ["lecture_106108229_w7_l46"]}}
{"id": "concept_row_wise_recovery_in_ot_extension", "type": "V_concept", "name": "Row-wise Recovery in OT Extension", "properties": {"description": "Alice recovers the ith row of matrix Q, which corresponds to either T_i or T_i XOR S, enabling her to mask the ith pair of messages.", "keywords": ["row recovery", "q matrix", "alice recovery", "ot extension", "row-wise"], "source_lectures": ["lecture_106108229_w7_l46"]}}
{"id": "concept_receiver_as_sender_in_ot_extension", "type": "V_concept", "name": "Receiver as Sender in OT Extension", "properties": {"description": "In IKNP OT extension, Bob acts as the sender in base OTs to obliviously transfer his matrix T to Alice, despite being the final receiver of messages.", "keywords": ["receiver as sender", "role reversal", "ot extension", "bob", "alice"], "source_lectures": ["lecture_106108229_w7_l46"]}}
{"id": "concept_practical_efficiency_of_ot_extension", "type": "V_concept", "name": "Practical Efficiency of OT Extension", "properties": {"description": "OT extension enables millions of OTs to be simulated with only hundreds or thousands of public-key operations, making secure computation feasible.", "keywords": ["practical efficiency", "ot extension", "scalability", "million ot", "real-world"], "source_lectures": ["lecture_106108229_w7_l46"]}}
{"id": "concept_yaos_protocol", "type": "V_concept", "name": "Yao's Protocol", "properties": {"description": "A secure two-party computation protocol that enables secure computation on private data without revealing the data itself.", "keywords": ["privacy", "protocol", "secure", "boolean", "yao", "two-party", "circuit", "computation"], "source_lectures": ["lecture_106108229_w7_l47", "lecture_106108229_w7_l49", "lecture_106108229_w8_l52"]}}
{"id": "concept_garbled_circuit", "type": "V_concept", "name": "Garbled Circuit", "properties": {"description": "A cryptographic technique that enables secure computation on private data by encrypting the circuit and the input data.", "keywords": ["cryptographic", "evaluation", "encryption", "yao", "garbled", "circuit", "computation", "secure"], "source_lectures": ["lecture_106108229_w7_l47", "lecture_106108229_w7_l49", "lecture_106108229_w8_l50", "lecture_106108229_w8_l51"]}}
{"id": "concept_beavers_triplets", "type": "V_concept", "name": "Beaver's Triplets", "properties": {"description": "A cryptographic technique used in secure multi-party computation to enable secure multiplication of private data.", "keywords": ["beaver", "triplets", "secure", "multiplication", "computation"], "source_lectures": ["lecture_106108229_w7_l47"]}}
{"id": "concept_garbling_scheme", "type": "V_concept", "name": "Garbling Scheme", "properties": {"description": "A cryptographic technique that enables secure computation on private data by encrypting the circuit and the input data.", "keywords": ["garbling", "scheme", "encryption", "secure", "computation"], "source_lectures": ["lecture_106108229_w7_l47"]}}
{"id": "concept_abstract_garbling", "type": "V_concept", "name": "Abstract Garbling", "properties": {"description": "A cryptographic primitive that enables secure computation on private data by abstracting the garbling process.", "keywords": ["abstract", "garbling", "primitive", "secure", "computation"], "source_lectures": ["lecture_106108229_w7_l47"]}}
{"id": "concept_bmr_protocol", "type": "V_concept", "name": "BMR Protocol", "properties": {"description": "A secure multi-party computation protocol that extends Yao's protocol to the multi-party setting.", "keywords": ["bmr", "protocol", "secure", "computation", "multi-party"], "source_lectures": ["lecture_106108229_w7_l47"]}}
{"id": "concept_yaos_garbling_scheme", "type": "V_concept", "name": "Yao's Garbling Scheme", "properties": {"description": "A cryptographic technique used for secure computation.", "keywords": ["garbling", "yao", "computation", "secure", "cryptography"], "source_lectures": ["lecture_106108229_w7_l48", "lecture_106108229_w8_l50"]}}
{"id": "concept_indistinguishability", "type": "V_concept", "name": "Indistinguishability", "properties": {"description": "A concept in cryptography where an attacker cannot distinguish between two or more inputs.", "keywords": ["attack", "distribution", "security", "input", "computational", "distinguish", "ddh", "cryptography", "indistinguishability"], "source_lectures": ["lecture_106108229_w7_l48", "lecture_106106221_w3_l17", "lecture_106106221_w6_l39"]}}
{"id": "concept_lock_box", "type": "V_concept", "name": "Lock Box", "properties": {"description": "A secure container used to store valuable or sensitive items.", "keywords": ["lock", "box", "security", "container", "storage"], "source_lectures": ["lecture_106108229_w7_l48"]}}
{"id": "concept_key_exchange", "type": "V_concept", "name": "Key Exchange", "properties": {"description": "A process where two parties securely exchange cryptographic keys.", "keywords": ["key", "exchange", "cryptography", "security", "communication"], "source_lectures": ["lecture_106108229_w7_l48"]}}
{"id": "concept_secure_two_party_computation", "type": "V_concept", "name": "Secure Two-Party Computation", "properties": {"description": "A cryptographic technique that enables two parties to jointly compute a function without revealing their private inputs.", "keywords": ["cryptographic", "private", "two-party", "computation", "secure", "data"], "source_lectures": ["lecture_106108229_w7_l49", "lecture_106108229_w8_l52"]}}
{"id": "concept_point_and_permute_technique", "type": "V_concept", "name": "Point and Permute Technique", "properties": {"description": "An optimization technique used in Yao's protocol to reduce the number of ciphertexts required for garbled gates.", "keywords": ["technique", "garbling", "yao", "optimization", "permute", "point"], "source_lectures": ["lecture_106108229_w7_l49", "lecture_106108229_w8_l50"]}}
{"id": "concept_garbled_row_reduction", "type": "V_concept", "name": "Garbled Row Reduction", "properties": {"description": "A method used to reduce the size of garbled gates from 4 ciphertexts to 3 ciphertexts.", "keywords": ["garbled", "row", "reduction", "method", "optimization"], "source_lectures": ["lecture_106108229_w7_l49"]}}
{"id": "concept_free_xor_method", "type": "V_concept", "name": "Free XOR Method", "properties": {"description": "A technique used to garble XOR gates without requiring any ciphertext to be computed or communicated.", "keywords": ["free", "xor", "method", "technique", "garbling"], "source_lectures": ["lecture_106108229_w7_l49"]}}
{"id": "concept_free_xor_technique", "type": "V_concept", "name": "Free-XOR Technique", "properties": {"description": "An optimization technique for Yao's garbling scheme that eliminates the need for garbling XOR gates.", "keywords": ["free", "xor", "technique", "garbling", "yao", "garbled", "optimization"], "source_lectures": ["lecture_106108229_w8_l50", "lecture_106108229_w8_l51"]}}
{"id": "concept_cpa_secure_encryption", "type": "V_concept", "name": "CPA Secure Encryption", "properties": {"description": "A type of encryption that is secure against chosen-plaintext attacks.", "keywords": ["cpa", "secure", "encryption", "cryptography"], "source_lectures": ["lecture_106108229_w8_l50"]}}
{"id": "concept_aes_encryption", "type": "V_concept", "name": "AES Encryption", "properties": {"description": "A widely used symmetric key encryption algorithm.", "keywords": ["aes", "encryption", "symmetric", "cryptography"], "source_lectures": ["lecture_106108229_w8_l50"]}}
{"id": "concept_permutation_bit", "type": "V_concept", "name": "Permutation Bit", "properties": {"description": "A bit that is used to determine the position of a ciphertext in a garbled table.", "keywords": ["permutation", "bit", "garbling", "ciphertext"], "source_lectures": ["lecture_106108229_w8_l50"]}}
{"id": "concept_garbled_table", "type": "V_concept", "name": "Garbled Table", "properties": {"description": "A table that contains ciphertexts that have been garbled using a garbling scheme.", "keywords": ["garbled", "table", "ciphertext", "garbling"], "source_lectures": ["lecture_106108229_w8_l50"]}}
{"id": "concept_yaos_2_party_protocol", "type": "V_concept", "name": "Yao's 2 Party Protocol", "properties": {"description": "A secure two-party computation protocol that enables two parties to jointly evaluate a circuit while keeping their inputs private.", "keywords": ["yao", "2party", "secure", "computation", "protocol"], "source_lectures": ["lecture_106108229_w8_l51"]}}
{"id": "concept_yaos_2_party_secret_sharing", "type": "V_concept", "name": "Yao's 2 Party Secret Sharing", "properties": {"description": "A secret sharing scheme based on Yao's 2 party protocol, where two parties jointly evaluate a circuit while keeping their inputs private.", "keywords": ["yao", "2party", "secret", "sharing", "scheme"], "source_lectures": ["lecture_106108229_w8_l51"]}}
{"id": "concept_global_offset", "type": "V_concept", "name": "Global Offset", "properties": {"description": "A random value used in Yao's 2 party secret sharing scheme to ensure the security of the protocol.", "keywords": ["global", "offset", "random", "security", "yao"], "source_lectures": ["lecture_106108229_w8_l51"]}}
{"id": "concept_sharing_semantics", "type": "V_concept", "name": "Sharing Semantics", "properties": {"description": "The rules and definitions that govern how a secret is shared among multiple parties in a secret sharing scheme.", "keywords": ["sharing", "semantics", "secret", "rules", "definitions"], "source_lectures": ["lecture_106108229_w8_l51"]}}
{"id": "concept_oblivious_transfer_protocol", "type": "V_concept", "name": "Oblivious Transfer Protocol", "properties": {"description": "A protocol that enables one party to transfer a message to another party in such a way that the sender does not know which message was transferred.", "keywords": ["oblivious", "transfer", "protocol", "secure", "computation"], "source_lectures": ["lecture_106108229_w8_l51"]}}
{"id": "concept_mixed_protocol_secure_computation", "type": "V_concept", "name": "Mixed Protocol Secure Computation", "properties": {"description": "A method of secure computation that combines different protocols, such as Yao's 2 party protocol and secret sharing, to achieve efficient and secure computation.", "keywords": ["mixed", "protocol", "secure", "computation", "yao"], "source_lectures": ["lecture_106108229_w8_l51"]}}
{"id": "concept_boolean_circuit_abstraction", "type": "V_concept", "name": "Boolean Circuit Abstraction", "properties": {"description": "A model for representing functions as Boolean circuits, where computations are performed using logical operations.", "keywords": ["boolean", "circuit", "abstraction", "logical", "operations"], "source_lectures": ["lecture_106108229_w8_l52"]}}
{"id": "concept_arithmetic_circuit_abstraction", "type": "V_concept", "name": "Arithmetic Circuit Abstraction", "properties": {"description": "A model for representing functions as arithmetic circuits, where computations are performed using addition and multiplication operations over a finite field or ring.", "keywords": ["arithmetic", "circuit", "abstraction", "addition", "multiplication"], "source_lectures": ["lecture_106108229_w8_l52"]}}
{"id": "concept_mixed_protocols", "type": "V_concept", "name": "Mixed Protocols", "properties": {"description": "Protocols that combine different models, such as Boolean and arithmetic circuits, to achieve efficient secure computation.", "keywords": ["mixed", "protocols", "boolean", "arithmetic", "secure"], "source_lectures": ["lecture_106108229_w8_l52"]}}
{"id": "concept_aby_framework", "type": "V_concept", "name": "ABY Framework", "properties": {"description": "A framework for secure two-party computation that allows switching between different secret sharing representations, such as Yao's and GMW protocols.", "keywords": ["aby", "framework", "secure", "two-party", "computation"], "source_lectures": ["lecture_106108229_w8_l52"]}}
{"id": "concept_yaos_secret_sharing", "type": "V_concept", "name": "Yao's Secret Sharing", "properties": {"description": "A method for secret sharing used in Yao's protocol, where the shares are not simply added to reconstruct the original value.", "keywords": ["yao", "secret", "sharing", "protocol", "secure"], "source_lectures": ["lecture_106108229_w8_l52"]}}
{"id": "concept_yao_secret_sharing", "type": "V_concept", "name": "Yao Secret Sharing", "properties": {"description": "A method of secret sharing where a value is split into two keys, one for each party, such that the value can be reconstructed by combining the keys.", "keywords": ["secret", "keys", "sharing", "yao", "cryptography"], "source_lectures": ["lecture_106108229_w8_l53", "lecture_106108229_w8_l54"]}}
{"id": "concept_gmw_boolean_secret_sharing", "type": "V_concept", "name": "Gmw Boolean Secret Sharing", "properties": {"description": "A method of secret sharing where a bit is split into two shares, one for each party, such that the bit can be reconstructed by combining the shares using xor.", "keywords": ["gmw", "boolean", "secret", "sharing", "xor"], "source_lectures": ["lecture_106108229_w8_l53"]}}
{"id": "concept_gmw_arithmetic_secret_sharing", "type": "V_concept", "name": "Gmw Arithmetic Secret Sharing", "properties": {"description": "A method of secret sharing where an l-bit number is split into two shares, one for each party, such that the number can be reconstructed by combining the shares using modular addition.", "keywords": ["gmw", "arithmetic", "secret", "sharing", "modular"], "source_lectures": ["lecture_106108229_w8_l53"]}}
{"id": "concept_beaver_triplet", "type": "V_concept", "name": "Beaver Triplet", "properties": {"description": "A set of three values used to enable secure computation of multiplication gates in secret sharing protocols.", "keywords": ["beaver", "triplet", "multiplication", "gates"], "source_lectures": ["lecture_106108229_w8_l53"]}}
{"id": "concept_aes_key_setup", "type": "V_concept", "name": "Aes Key Setup", "properties": {"description": "A setup where two parties share a common key for use in cryptographic protocols, such as secret sharing.", "keywords": ["aes", "key", "setup", "cryptographic"], "source_lectures": ["lecture_106108229_w8_l53"]}}
{"id": "concept_xor_gate", "type": "V_concept", "name": "Xor Gate", "properties": {"description": "A logical operation that takes two bits as input and produces an output bit that is the result of the exclusive or operation.", "keywords": ["xor", "gate", "logical", "operation"], "source_lectures": ["lecture_106108229_w8_l53"]}}
{"id": "concept_and_gate", "type": "V_concept", "name": "And Gate", "properties": {"description": "A logical operation that takes two bits as input and produces an output bit that is the result of the logical and operation.", "keywords": ["and", "gate", "logical", "operation"], "source_lectures": ["lecture_106108229_w8_l53"]}}
{"id": "concept_yao_to_boolean_conversion", "type": "V_concept", "name": "Yao To Boolean Conversion", "properties": {"description": "A conversion method that transforms a secret shared using Yao's secret sharing scheme to a secret shared using Boolean secret sharing scheme.", "keywords": ["yao", "boolean", "conversion", "cryptography"], "source_lectures": ["lecture_106108229_w8_l54"]}}
{"id": "concept_boolean_to_yao_conversion", "type": "V_concept", "name": "Boolean To Yao Conversion", "properties": {"description": "A conversion method that transforms a secret shared using Boolean secret sharing scheme to a secret shared using Yao's secret sharing scheme.", "keywords": ["boolean", "yao", "conversion", "cryptography"], "source_lectures": ["lecture_106108229_w8_l54"]}}
{"id": "concept_arithmetic_to_yao_conversion", "type": "V_concept", "name": "Arithmetic To Yao Conversion", "properties": {"description": "A conversion method that transforms a secret shared using arithmetic secret sharing scheme to a secret shared using Yao's secret sharing scheme.", "keywords": ["arithmetic", "yao", "conversion", "cryptography"], "source_lectures": ["lecture_106108229_w8_l54"]}}
{"id": "concept_boolean_adder", "type": "V_concept", "name": "Boolean Adder", "properties": {"description": "A digital circuit that performs addition of two binary numbers using Boolean operations.", "keywords": ["boolean", "adder", "circuit", "digital"], "source_lectures": ["lecture_106108229_w8_l54"]}}
{"id": "concept_hard_core_predicate", "type": "V_concept", "name": "Hard-Core Predicate", "properties": {"description": "A Boolean function that is associated with a one way function and is hard to compute from the output of the one way function.", "keywords": ["hard", "core", "predicate", "one", "way", "function"], "source_lectures": ["lecture_106106221_w2_l11"]}}
{"id": "concept_provably_secure_construction", "type": "V_concept", "name": "Provably Secure Construction", "properties": {"description": "A construction that is proven to be secure based on certain assumptions, such as the existence of one way functions.", "keywords": ["provably", "secure", "construction", "cryptography", "one", "way", "function"], "source_lectures": ["lecture_106106221_w2_l11"]}}
{"id": "concept_one_way_permutation", "type": "V_concept", "name": "One Way Permutation", "properties": {"description": "A one way function that is also a permutation, meaning it is a bijection and has a unique inverse.", "keywords": ["one", "way", "permutation", "cryptography", "bijection"], "source_lectures": ["lecture_106106221_w2_l11"]}}
{"id": "concept_pseudo_random_generator_with_minimal_expansion", "type": "V_concept", "name": "Pseudo Random Generator with Minimal Expansion", "properties": {"description": "A pseudo random generator that expands its input by one bit, which is the minimum amount of expansion required for a pseudo random generator.", "keywords": ["pseudo", "random", "generator", "minimal", "expansion", "cryptography"], "source_lectures": ["lecture_106106221_w2_l11"]}}
{"id": "concept_sequential_composition_of_pseudo_random_generators", "type": "V_concept", "name": "Sequential Composition of Pseudo Random Generators", "properties": {"description": "A method of constructing a pseudo random generator by composing multiple instances of a pseudo random generator in sequence.", "keywords": ["sequential", "composition", "pseudo", "random", "generator", "cryptography"], "source_lectures": ["lecture_106106221_w2_l11"]}}
{"id": "concept_linear_feedback_shift_register", "type": "V_concept", "name": "Linear Feedback Shift Register", "properties": {"description": "A type of pseudo random generator that uses a linear feedback function to generate a sequence of bits.", "keywords": ["pseudorandom", "shift", "feedback", "register", "linear", "lfsr"], "source_lectures": ["lecture_106106221_w2_l12", "lecture_108102169_w5_l32"]}}
{"id": "concept_rc4_algorithm", "type": "V_concept", "name": "RC4 Algorithm", "properties": {"description": "A software-based pseudo random generator that uses a key-dependent permutation to generate a sequence of bytes.", "keywords": ["rc4", "algorithm", "software", "permutation", "cryptography"], "source_lectures": ["lecture_106106221_w2_l12"]}}
{"id": "concept_trivium_algorithm", "type": "V_concept", "name": "Trivium Algorithm", "properties": {"description": "A hardware-based pseudo random generator that uses a combination of linear feedback shift registers to generate a sequence of bits.", "keywords": ["trivium", "algorithm", "hardware", "lfsr", "cryptography"], "source_lectures": ["lecture_106106221_w2_l12"]}}
{"id": "concept_non_linearity", "type": "V_concept", "name": "Non-Linearity", "properties": {"description": "A property of a function that makes it difficult to predict the output based on the input.", "keywords": ["non", "linearity", "function", "cryptography", "security"], "source_lectures": ["lecture_106106221_w2_l12"]}}
{"id": "concept_key_dependent_permutation", "type": "V_concept", "name": "Key-Dependent Permutation", "properties": {"description": "A permutation that depends on a secret key and is used to generate a pseudo random sequence.", "keywords": ["key", "dependent", "permutation", "cryptography", "security"], "source_lectures": ["lecture_106106221_w2_l12"]}}
{"id": "concept_state_update_algorithm", "type": "V_concept", "name": "State Update Algorithm", "properties": {"description": "An algorithm that updates the internal state of a pseudo random generator to generate the next output.", "keywords": ["state", "update", "algorithm", "pseudo", "random"], "source_lectures": ["lecture_106106221_w2_l12"]}}
{"id": "concept_initialization_algorithm", "type": "V_concept", "name": "Initialization Algorithm", "properties": {"description": "An algorithm that initializes the internal state of a pseudo random generator.", "keywords": ["initialization", "algorithm", "pseudo", "random", "cryptography"], "source_lectures": ["lecture_106106221_w2_l12"]}}
{"id": "concept_maximum_length_lfsr", "type": "V_concept", "name": "Maximum Length LFSR", "properties": {"description": "A linear feedback shift register that generates a sequence of bits with maximum length before repeating.", "keywords": ["maximum", "length", "lfsr", "cryptography", "security"], "source_lectures": ["lecture_106106221_w2_l12"]}}
{"id": "concept_encryption_oracle", "type": "V_concept", "name": "Encryption Oracle", "properties": {"description": "A system that provides an attacker with access to an encryption algorithm, allowing them to submit plaintexts to be encrypted.", "keywords": ["security", "adversary", "oracle", "encryption", "plaintext", "algorithm", "cryptography"], "source_lectures": ["lecture_106106221_w2_l13", "lecture_106106221_w3_l15", "lecture_106106221_w3_l21"]}}
{"id": "concept_single_message_security", "type": "V_concept", "name": "Single-Message Security", "properties": {"description": "A security notion that ensures an encryption scheme is secure when encrypting a single message with a key.", "keywords": ["single", "message", "security", "encryption", "key"], "source_lectures": ["lecture_106106221_w2_l13"]}}
{"id": "concept_truly_random_function", "type": "V_concept", "name": "Truly Random Function", "properties": {"description": "A function that assigns a random output to each input.", "keywords": ["security", "truly", "function", "random", "cryptography"], "source_lectures": ["lecture_106106221_w3_l15", "lecture_106106221_w3_l17"]}}
{"id": "concept_single_message_cpa_indistinguishability_experiment", "type": "V_concept", "name": "Single Message Cpa Indistinguishability Experiment", "properties": {"description": "An experiment that tests the security of an encryption scheme by trying to distinguish between two ciphertexts.", "keywords": ["single", "message", "cpa", "indistinguishability", "experiment"], "source_lectures": ["lecture_106106221_w3_l15"]}}
{"id": "concept_keyed_pseudo_random_function", "type": "V_concept", "name": "Keyed Pseudo Random Function", "properties": {"description": "A pseudo random function that takes a key as input and produces a random output.", "keywords": ["keyed", "pseudo", "random", "function", "prf"], "source_lectures": ["lecture_106106221_w3_l15"]}}
{"id": "concept_cpa_security_game", "type": "V_concept", "name": "Cpa Security Game", "properties": {"description": "A game played between a challenger and an adversary to test the security of an encryption scheme.", "keywords": ["cpa", "security", "game", "challenger", "adversary"], "source_lectures": ["lecture_106106221_w3_l15"]}}
{"id": "concept_electronic_code_book_ecb_mode", "type": "V_concept", "name": "Electronic Code Book (ECB) Mode", "properties": {"description": "A block cipher mode where each plaintext block is encrypted independently using the same key, producing ciphertext blocks that directly correspond to plaintext blocks.", "keywords": ["ecb", "block cipher", "deterministic", "encryption", "mode"], "source_lectures": ["lecture_106106221_w3_l16"]}}
{"id": "concept_cipher_block_chaining_cbc_mode", "type": "V_concept", "name": "Cipher Block Chaining (CBC) Mode", "properties": {"description": "A block cipher mode where each plaintext block is XORed with the previous ciphertext block before encryption, starting with a random initialization vector (IV).", "keywords": ["cbc", "block cipher", "chaining", "iv", "encryption"], "source_lectures": ["lecture_106106221_w3_l16"]}}
{"id": "concept_initialization_vector_iv", "type": "V_concept", "name": "Initialization Vector (IV)", "properties": {"description": "A random or pseudorandom value used as the first input in CBC mode to ensure that identical plaintexts encrypt to different ciphertexts.", "keywords": ["iv", "merkle-damgard", "cbc", "encryption", "vector", "hash", "initialization vector", "initialization", "randomness"], "source_lectures": ["lecture_106106221_w3_l16", "lecture_106106221_w4_l27"]}}
{"id": "concept_pseudo_random_permutation_prp", "type": "V_concept", "name": "Pseudo-Random Permutation (PRP)", "properties": {"description": "A keyed function that behaves like a random permutation, meaning it is invertible and indistinguishable from a truly random permutation to an efficient adversary.", "keywords": ["prp", "pseudo-random", "permutation", "block cipher", "invertible"], "source_lectures": ["lecture_106106221_w3_l16"]}}
{"id": "concept_pseudo_random_function_prf", "type": "V_concept", "name": "Pseudo-Random Function (PRF)", "properties": {"description": "A keyed function that is computationally indistinguishable from a truly random function to any efficient adversary.", "keywords": ["prf", "pseudo-random", "function", "cryptographic", "indistinguishable"], "source_lectures": ["lecture_106106221_w3_l16"]}}
{"id": "concept_ciphertext_expansion", "type": "V_concept", "name": "Ciphertext Expansion", "properties": {"description": "The increase in size of ciphertext compared to plaintext during encryption, often measured in blocks or bytes.", "keywords": ["ciphertext", "expansion", "size", "plaintext", "overhead"], "source_lectures": ["lecture_106106221_w3_l16"]}}
{"id": "concept_pkcs5_padding", "type": "V_concept", "name": "PKCS#5 Padding", "properties": {"description": "A padding scheme used in block ciphers where the last block is padded with bytes, each containing the value equal to the number of padding bytes added.", "keywords": ["pkcs#5", "padding", "block cipher", "unambiguous", "invertible"], "source_lectures": ["lecture_106106221_w3_l16"]}}
{"id": "concept_stateful_cbc_mode", "type": "V_concept", "name": "Stateful CBC Mode", "properties": {"description": "A variant of CBC mode where the last ciphertext block of a previous message is reused as the IV for the next message, eliminating the need to transmit a new IV.", "keywords": ["stateful", "cbc", "iv reuse", "security", "mode"], "source_lectures": ["lecture_106106221_w3_l16"]}}
{"id": "concept_beast_attack", "type": "V_concept", "name": "BEAST Attack", "properties": {"description": "A chosen plaintext attack exploiting the stateful CBC mode in TLS by predicting and manipulating IVs to decrypt encrypted data.", "keywords": ["beast", "attack", "cbc", "tls", "iv prediction"], "source_lectures": ["lecture_106106221_w3_l16"]}}
{"id": "concept_parallel_encryption", "type": "V_concept", "name": "Parallel Encryption", "properties": {"description": "The ability to encrypt multiple blocks simultaneously using independent processors, enabled when encryption of each block does not depend on prior blocks.", "keywords": ["parallel", "encryption", "block", "performance", "concurrency"], "source_lectures": ["lecture_106106221_w3_l16"]}}
{"id": "concept_deterministic_encryption", "type": "V_concept", "name": "Deterministic Encryption", "properties": {"description": "An encryption scheme that produces the same ciphertext for a given plaintext and key, making it vulnerable to pattern analysis and chosen plaintext attacks.", "keywords": ["vulnerability", "security", "cpa", "encryption", "pattern", "repetition", "deterministic"], "source_lectures": ["lecture_106106221_w3_l16", "lecture_106106221_w7_l46"]}}
{"id": "concept_block_cipher", "type": "V_concept", "name": "Block Cipher", "properties": {"description": "A symmetric key cipher that operates on fixed-size blocks of data, typically using a keyed function to transform plaintext into ciphertext.", "keywords": ["block cipher", "symmetric", "encryption", "block", "keyed function"], "source_lectures": ["lecture_106106221_w3_l16"]}}
{"id": "concept_randomness_in_encryption", "type": "V_concept", "name": "Randomness in Encryption", "properties": {"description": "The use of unpredictable values (e.g., IVs, nonces) to ensure that identical plaintexts produce different ciphertexts, essential for CPA security.", "keywords": ["randomness", "encryption", "iv", "nonce", "cpa security"], "source_lectures": ["lecture_106106221_w3_l16"]}}
{"id": "concept_message_padding", "type": "V_concept", "name": "Message Padding", "properties": {"description": "The process of extending a message to a length that is a multiple of the block size to enable block cipher operations.", "keywords": ["block", "block size", "merkle-damgard", "encryption", "hash", "padding", "message", "alignment"], "source_lectures": ["lecture_106106221_w3_l16", "lecture_106106221_w4_l27"]}}
{"id": "concept_invertible_padding", "type": "V_concept", "name": "Invertible Padding", "properties": {"description": "A padding scheme that can be unambiguously removed during decryption without confusion between actual message data and padding bytes.", "keywords": ["invertible", "padding", "decryption", "unambiguous", "block cipher"], "source_lectures": ["lecture_106106221_w3_l16"]}}
{"id": "concept_ciphertext_integrity", "type": "V_concept", "name": "Ciphertext Integrity", "properties": {"description": "The property that ensures ciphertext has not been altered during transmission, though not inherently provided by modes like ECB or CBC.", "keywords": ["ciphertext", "integrity", "tampering", "authentication", "security"], "source_lectures": ["lecture_106106221_w3_l16"]}}
{"id": "concept_keyed_function", "type": "V_concept", "name": "Keyed Function", "properties": {"description": "A cryptographic function that takes a secret key and an input to produce an output, forming the basis of block ciphers and PRPs/PRFs.", "keywords": ["keyed function", "cryptographic", "prp", "prf", "encryption"], "source_lectures": ["lecture_106106221_w3_l16"]}}
{"id": "concept_chaining_in_cbc", "type": "V_concept", "name": "Chaining in CBC", "properties": {"description": "The process in CBC mode where the output of one block\u2019s encryption is used as input (via XOR) to the next block\u2019s encryption.", "keywords": ["chaining", "cbc", "block", "xor", "encryption"], "source_lectures": ["lecture_106106221_w3_l16"]}}
{"id": "concept_block_size", "type": "V_concept", "name": "Block Size", "properties": {"description": "The fixed number of bits or bytes that a block cipher processes at a time, such as 128 bits in AES.", "keywords": ["block size", "cipher", "encryption", "bits", "bytes"], "source_lectures": ["lecture_106106221_w3_l16"]}}
{"id": "concept_output_feedback_mode", "type": "V_concept", "name": "Output Feedback Mode", "properties": {"description": "A mode of operation for block ciphers where a pseudo-random stream of pad is generated independently of the plaintext.", "keywords": ["ofb", "mode", "operation", "block", "cipher"], "source_lectures": ["lecture_106106221_w3_l17"]}}
{"id": "concept_counter_mode", "type": "V_concept", "name": "Counter Mode", "properties": {"description": "A mode of operation for block ciphers where a pseudo-random stream of pad is generated using a counter.", "keywords": ["block", "pulses", "keystream", "ctr", "operation", "timer", "mode", "events", "cipher", "counter"], "source_lectures": ["lecture_106106221_w3_l17", "lecture_106106221_w3_l21", "lecture_108102169_w5_l34"]}}
{"id": "concept_stateful_variant", "type": "V_concept", "name": "Stateful Variant", "properties": {"description": "A variant of a mode of operation that maintains state between encryptions.", "keywords": ["stateful", "variant", "mode", "operation"], "source_lectures": ["lecture_106106221_w3_l17"]}}
{"id": "concept_parallelization", "type": "V_concept", "name": "Parallelization", "properties": {"description": "The ability to perform multiple computations simultaneously, improving efficiency.", "keywords": ["parallelization", "efficiency", "computation"], "source_lectures": ["lecture_106106221_w3_l17"]}}
{"id": "concept_tree_construction", "type": "V_concept", "name": "Tree Construction", "properties": {"description": "A method of constructing a pseudo random function using a complete binary tree, where each node is assigned a pseudo random string.", "keywords": ["tree", "construction", "pseudo", "random", "function"], "source_lectures": ["lecture_106106221_w3_l18"]}}
{"id": "concept_feistel_network", "type": "V_concept", "name": "Feistel Network", "properties": {"description": "A cryptographic construction that converts a non-invertible function into an invertible one, using a sequence of rounds.", "keywords": ["feistel", "network", "cryptography", "invertible"], "source_lectures": ["lecture_106106221_w3_l18"]}}
{"id": "concept_luby_rackoff_construction", "type": "V_concept", "name": "Luby-Rackoff Construction", "properties": {"description": "A method of constructing a pseudo random permutation from a pseudo random function, using a Feistel network.", "keywords": ["luby", "rackoff", "construction", "pseudo", "random", "permutation"], "source_lectures": ["lecture_106106221_w3_l18"]}}
{"id": "concept_pseudo_random_permutation", "type": "V_concept", "name": "Pseudo Random Permutation", "properties": {"description": "A permutation that is computationally indistinguishable from a truly random permutation.", "keywords": ["security", "pseudo", "permutation", "random", "cryptography"], "source_lectures": ["lecture_106106221_w3_l18", "lecture_106106221_w9_l59"]}}
{"id": "concept_strong_pseudo_random_permutation", "type": "V_concept", "name": "Strong Pseudo Random Permutation", "properties": {"description": "A permutation that is computationally indistinguishable from a truly random permutation, even when the adversary has access to the inverse of the permutation.", "keywords": ["pseudo", "strong", "permutation", "random", "cryptography"], "source_lectures": ["lecture_106106221_w3_l18", "lecture_106106221_w9_l59"]}}
{"id": "concept_active_adversary", "type": "V_concept", "name": "Active Adversary", "properties": {"description": "A malicious entity that can intercept, modify, and inject messages into a communication channel.", "keywords": ["adversary", "active", "malicious", "communication"], "source_lectures": ["lecture_106106221_w3_l21"]}}
{"id": "concept_passive_adversary", "type": "V_concept", "name": "Passive Adversary", "properties": {"description": "An entity that can only intercept messages in a communication channel without modifying or injecting new messages.", "keywords": ["adversary", "passive", "intercept", "communication"], "source_lectures": ["lecture_106106221_w3_l21"]}}
{"id": "concept_decryption_oracle", "type": "V_concept", "name": "Decryption Oracle", "properties": {"description": "A service that provides an adversary with the decryption of a chosen ciphertext.", "keywords": ["security", "adversary", "oracle", "decryption", "plaintext", "ciphertext"], "source_lectures": ["lecture_106106221_w3_l21", "lecture_106106221_w7_l48"]}}
{"id": "concept_malleability", "type": "V_concept", "name": "Malleability", "properties": {"description": "A property of an encryption scheme that allows an adversary to modify a ciphertext to produce a new ciphertext with a related plaintext.", "keywords": ["security", "malleability", "adversary", "public-key", "encryption", "plaintext", "ciphertext", "cryptography"], "source_lectures": ["lecture_106106221_w3_l21", "lecture_106106221_w7_l48", "lecture_106106221_w7_l49", "lecture_106106221_w8_l50"]}}
{"id": "concept_single_message_cca_security", "type": "V_concept", "name": "Single-Message CCA Security", "properties": {"description": "A security notion that protects against chosen-ciphertext attacks on a single message.", "keywords": ["single-message", "cca", "security", "chosen-ciphertext"], "source_lectures": ["lecture_106106221_w3_l21"]}}
{"id": "concept_multi_message_cca_security", "type": "V_concept", "name": "Multi-Message CCA Security", "properties": {"description": "A security notion that protects against chosen-ciphertext attacks on multiple messages.", "keywords": ["multi-message", "cca", "security", "chosen-ciphertext"], "source_lectures": ["lecture_106106221_w3_l21"]}}
{"id": "concept_prefix_free_secure_prf", "type": "V_concept", "name": "Prefix-Free Secure PRF", "properties": {"description": "A PRF that is secure against an adversary who can only make queries from a prefix-free set", "keywords": ["prefix-free", "prf", "security", "cryptography"], "source_lectures": ["lecture_106106221_w4_l23"]}}
{"id": "concept_cbc_mode_of_encryption", "type": "V_concept", "name": "CBC Mode of Encryption", "properties": {"description": "A mode of operation for a block cipher that uses a chaining mechanism to encrypt multiple blocks", "keywords": ["block", "cbc", "encryption", "mode", "cipher"], "source_lectures": ["lecture_106106221_w4_l23", "lecture_106106221_w5_l35"]}}
{"id": "concept_cbc_prefix_free_secure_prf", "type": "V_concept", "name": "CBC Prefix-Free Secure PRF", "properties": {"description": "A PRF that uses the CBC mode of encryption to construct a prefix-free secure PRF", "keywords": ["cbc", "prefix-free", "prf", "security", "cryptography"], "source_lectures": ["lecture_106106221_w4_l23"]}}
{"id": "concept_fully_secure_prf", "type": "V_concept", "name": "Fully Secure PRF", "properties": {"description": "A PRF that is secure against any adversary, without any restrictions on the queries", "keywords": ["prf", "security", "secure", "fully", "cryptography"], "source_lectures": ["lecture_106106221_w4_l23", "lecture_106106221_w4_l24"]}}
{"id": "concept_encrypted_cbc_prf", "type": "V_concept", "name": "Encrypted CBC PRF", "properties": {"description": "A PRF that uses two independent keys to construct a fully secure PRF", "keywords": ["encrypted", "cbc", "prf", "security", "cryptography"], "source_lectures": ["lecture_106106221_w4_l23"]}}
{"id": "concept_streaming_prf", "type": "V_concept", "name": "Streaming PRF", "properties": {"description": "A PRF that can take inputs of arbitrary size, without knowing the length of the input in advance", "keywords": ["streaming", "prf", "arbitrary", "size", "cryptography"], "source_lectures": ["lecture_106106221_w4_l23"]}}
{"id": "concept_streaming_mac", "type": "V_concept", "name": "Streaming MAC", "properties": {"description": "A MAC that can take inputs of arbitrary size, without knowing the length of the input in advance", "keywords": ["streaming", "mac", "arbitrary", "size", "cryptography"], "source_lectures": ["lecture_106106221_w4_l23"]}}
{"id": "concept_prf_indistinguishability_game", "type": "V_concept", "name": "PRF Indistinguishability Game", "properties": {"description": "A game used to define the security of a PRF, where an adversary tries to distinguish between a real PRF and a random function", "keywords": ["prf", "indistinguishability", "game", "security", "cryptography"], "source_lectures": ["lecture_106106221_w4_l23"]}}
{"id": "concept_block_wise_prefix_free_secure_prf", "type": "V_concept", "name": "Block-Wise Prefix-Free Secure PRF", "properties": {"description": "A type of PRF that is secure against prefix-free adversaries, operating on blocks of fixed size", "keywords": ["prf", "prefix-free", "block-wise", "security"], "source_lectures": ["lecture_106106221_w4_l24"]}}
{"id": "concept_deterministic_prefix_free_encoding", "type": "V_concept", "name": "Deterministic Prefix-Free Encoding", "properties": {"description": "A method of encoding input messages to ensure that the encoded messages are prefix-free, using a deterministic algorithm", "keywords": ["encoding", "prefix-free", "deterministic", "security"], "source_lectures": ["lecture_106106221_w4_l24"]}}
{"id": "concept_randomized_prefix_free_encoding", "type": "V_concept", "name": "Randomized Prefix-Free Encoding", "properties": {"description": "A method of encoding input messages to ensure that the encoded messages are prefix-free, using a randomized algorithm", "keywords": ["encoding", "prefix-free", "randomized", "security"], "source_lectures": ["lecture_106106221_w4_l24"]}}
{"id": "concept_cbc_mode", "type": "V_concept", "name": "CBC Mode", "properties": {"description": "A mode of operation for block ciphers, using a cipher block chaining technique", "keywords": ["cbc", "mode", "block", "cipher"], "source_lectures": ["lecture_106106221_w4_l24"]}}
{"id": "concept_unambiguous_padding", "type": "V_concept", "name": "Unambiguous Padding", "properties": {"description": "A method of padding input messages to ensure that the padding can be unambiguously removed by the receiver", "keywords": ["padding", "unambiguous", "security", "cryptography"], "source_lectures": ["lecture_106106221_w4_l24"]}}
{"id": "concept_sub_key_generation_algorithm", "type": "V_concept", "name": "Sub-Key Generation Algorithm", "properties": {"description": "An algorithm used to generate sub-keys from a master key, for use in cryptographic protocols", "keywords": ["sub-key", "generation", "algorithm", "cryptography"], "source_lectures": ["lecture_106106221_w4_l24"]}}
{"id": "concept_epsilon_prefix_free_encoding", "type": "V_concept", "name": "Epsilon-Prefix-Free Encoding", "properties": {"description": "A type of encoding that ensures the encoded messages are prefix-free with a certain probability, epsilon", "keywords": ["encoding", "epsilon", "prefix-free", "security"], "source_lectures": ["lecture_106106221_w4_l24"]}}
{"id": "concept_message_authentication_code_mac", "type": "V_concept", "name": "Message Authentication Code (MAC)", "properties": {"description": "A cryptographic primitive used to authenticate the integrity and authenticity of a message.", "keywords": ["cryptographic", "code", "integrity", "hash", "message", "keyed", "mac", "authentication"], "source_lectures": ["lecture_106106221_w4_l25", "lecture_106106221_w4_l27", "lecture_106106221_w5_l29"]}}
{"id": "concept_one_time_information_theoretic_secure_mac", "type": "V_concept", "name": "One-Time Information-Theoretic Secure MAC", "properties": {"description": "A MAC that provides information-theoretic security for a single message authentication.", "keywords": ["one-time", "information-theoretic", "secure", "mac"], "source_lectures": ["lecture_106106221_w4_l25"]}}
{"id": "concept_strongly_universal_function_suf", "type": "V_concept", "name": "Strongly Universal Function (SUF)", "properties": {"description": "A function that satisfies the property of pairwise independence, used in constructing information-theoretic secure MACs.", "keywords": ["strongly", "universal", "function", "pairwise", "independence"], "source_lectures": ["lecture_106106221_w4_l25"]}}
{"id": "concept_pairwise_independence", "type": "V_concept", "name": "Pairwise Independence", "properties": {"description": "A property of a function where the output values for any two distinct inputs are independent and uniformly distributed.", "keywords": ["variables", "property", "function", "random variables", "random", "pairwise", "pairwise independence", "independence"], "source_lectures": ["lecture_106106221_w4_l25", "lecture_106104233_w3_l15", "lecture_106104233_w5_l32"]}}
{"id": "concept_distributivity_property", "type": "V_concept", "name": "Distributivity Property", "properties": {"description": "A property that states that the result of multiplying a sum of elements is equal to the sum of the products of each element.", "keywords": ["distributivity", "property", "algebra", "mathematics", "field"], "source_lectures": ["lecture_106106221_w4_l26"]}}
{"id": "concept_strongly_universal_function", "type": "V_concept", "name": "Strongly Universal Function", "properties": {"description": "A function that is highly unpredictable and has a low probability of collision, often used in cryptographic applications.", "keywords": ["strongly", "universal", "function", "cryptography", "security"], "source_lectures": ["lecture_106106221_w4_l26"]}}
{"id": "concept_carter_wegman_mac", "type": "V_concept", "name": "Carter-Wegman Mac", "properties": {"description": "A type of message authentication code that uses a polynomial-based construction to provide information-theoretic security.", "keywords": ["carter", "wegman", "mac", "cryptography", "security"], "source_lectures": ["lecture_106106221_w4_l26"]}}
{"id": "concept_finite_field_arithmetic", "type": "V_concept", "name": "Finite Field Arithmetic", "properties": {"description": "A type of arithmetic that is performed in a finite field, often used in cryptographic applications.", "keywords": ["finite", "field", "arithmetic", "cryptography", "mathematics"], "source_lectures": ["lecture_106106221_w4_l26"]}}
{"id": "concept_cryptographic_hash_function", "type": "V_concept", "name": "Cryptographic Hash Function", "properties": {"description": "A deterministic, unkeyed function that maps arbitrary-length bit strings to fixed-length bit strings, primarily used for data compression and security applications.", "keywords": ["cryptographic", "compression", "hash", "collision-resistant", "function", "fixed-length", "digest", "deterministic"], "source_lectures": ["lecture_106106221_w4_l27", "lecture_106106221_w5_l29"]}}
{"id": "concept_collision_resistance", "type": "V_concept", "name": "Collision-Resistance", "properties": {"description": "A property of a cryptographic hash function requiring that it is computationally infeasible to find two distinct inputs that produce the same output hash value.", "keywords": ["cryptographic", "security", "computational", "hash", "collision-resistant", "function", "collision", "resistance", "cryptography"], "source_lectures": ["lecture_106106221_w4_l27", "lecture_106106221_w5_l29", "lecture_106106221_w5_l30", "lecture_106106221_w5_l31", "lecture_106106221_w8_l52", "lecture_106104233_w4_l26"]}}
{"id": "concept_merkle_damg\u00e5rd_paradigm", "type": "V_concept", "name": "Merkle-Damg\u00e5rd Paradigm", "properties": {"description": "A design paradigm for constructing collision-resistant hash functions by iteratively applying a fixed-length compression function to padded message blocks.", "keywords": ["block", "compression", "merkle-damgard", "chaining", "hash", "iterative", "paradigm", "merkle-damg\u00e5rd"], "source_lectures": ["lecture_106106221_w4_l27", "lecture_106106221_w5_l29"]}}
{"id": "concept_fixed_length_compression_function", "type": "V_concept", "name": "Fixed-Length Compression Function", "properties": {"description": "A function that takes a fixed-size input (n + l bits) and produces a shorter fixed-size output (n bits), serving as the building block for Merkle-Damg\u00e5rd hash functions.", "keywords": ["compression", "function", "fixed-length", "merkle-damgard", "hash"], "source_lectures": ["lecture_106106221_w4_l27"]}}
{"id": "concept_pigeonhole_principle", "type": "V_concept", "name": "Pigeonhole Principle", "properties": {"description": "A mathematical principle stating that if more items are placed into fewer containers, at least one container must hold more than one item, explaining why hash collisions must exist.", "keywords": ["principle", "many-to-one", "hash", "function", "collision", "combinatorics", "mathematics", "pigeonhole"], "source_lectures": ["lecture_106106221_w4_l27", "lecture_106106221_w5_l30", "lecture_106104233_w4_l27"]}}
{"id": "concept_chaining_variable", "type": "V_concept", "name": "Chaining Variable", "properties": {"description": "An intermediate output value in the Merkle-Damg\u00e5rd construction that is fed as input to the next iteration of the compression function.", "keywords": ["chaining", "variable", "merkle-damgard", "hash", "intermediate"], "source_lectures": ["lecture_106106221_w4_l27"]}}
{"id": "concept_hash_collision_experiment", "type": "V_concept", "name": "Hash-Collision Experiment", "properties": {"description": "A formal security game where an adversary attempts to find two distinct inputs that hash to the same value, used to define collision-resistance.", "keywords": ["hash", "collision", "experiment", "security", "adversary"], "source_lectures": ["lecture_106106221_w4_l27"]}}
{"id": "concept_reduction_proof_collision_resistance", "type": "V_concept", "name": "Reduction Proof (Collision-Resistance)", "properties": {"description": "A proof technique showing that if a hash function built via Merkle-Damg\u00e5rd is not collision-resistant, then its underlying compression function is also not collision-resistant.", "keywords": ["reduction", "proof", "collision", "resistance", "merkle-damgard"], "source_lectures": ["lecture_106106221_w4_l27"]}}
{"id": "concept_block_size_in_hash_functions", "type": "V_concept", "name": "Block Size in Hash Functions", "properties": {"description": "The fixed number of bits (e.g., 512 in SHA-256) into which the padded message is divided for processing in the Merkle-Damg\u00e5rd construction.", "keywords": ["block", "size", "hash", "merkle-damgard", "sha-256"], "source_lectures": ["lecture_106106221_w4_l27"]}}
{"id": "concept_deterministic_hash_function", "type": "V_concept", "name": "Deterministic Hash Function", "properties": {"description": "A hash function that produces the same output for a given input every time, with no internal randomness or keys.", "keywords": ["deterministic", "hash", "function", "no-key", "reproducible"], "source_lectures": ["lecture_106106221_w4_l27"]}}
{"id": "concept_sha_256", "type": "V_concept", "name": "SHA-256", "properties": {"description": "A widely used cryptographic hash function in the SHA-2 family that uses a 256-bit output and a 512-bit block size within the Merkle-Damg\u00e5rd construction.", "keywords": ["sha-256", "hash", "sha-2", "cryptographic", "nist"], "source_lectures": ["lecture_106106221_w4_l27"]}}
{"id": "concept_input_length_limit_in_merkle_damg\u00e5rd", "type": "V_concept", "name": "Input Length Limit in Merkle-Damg\u00e5rd", "properties": {"description": "The maximum message size that can be hashed, determined by the bit-length allocated for encoding the original message length in the padding scheme.", "keywords": ["input", "length", "limit", "merkle-damgard", "padding"], "source_lectures": ["lecture_106106221_w4_l27"]}}
{"id": "concept_hash_chain", "type": "V_concept", "name": "Hash Chain", "properties": {"description": "The sequence of intermediate hash values produced during the iterative application of the compression function in the Merkle-Damg\u00e5rd construction.", "keywords": ["hash", "chain", "merkle-damgard", "iterative", "intermediate"], "source_lectures": ["lecture_106106221_w4_l27"]}}
{"id": "concept_collision_adversary", "type": "V_concept", "name": "Collision Adversary", "properties": {"description": "A theoretical adversary that has a hardcoded collision pair and can output it in constant time, highlighting a limitation in the formal definition of collision-resistance.", "keywords": ["collision", "adversary", "hardcoded", "constant-time", "definition"], "source_lectures": ["lecture_106106221_w4_l27"]}}
{"id": "concept_unkeyed_cryptographic_primitive", "type": "V_concept", "name": "Unkeyed Cryptographic Primitive", "properties": {"description": "A cryptographic function that operates without a secret key, such as a cryptographic hash function, relying solely on algorithmic design for security.", "keywords": ["unkeyed", "primitive", "hash", "cryptographic", "no-key"], "source_lectures": ["lecture_106106221_w4_l27"]}}
{"id": "concept_data_deduplication", "type": "V_concept", "name": "Data Deduplication", "properties": {"description": "A practical application of cryptographic hash functions where identical data blocks are identified by comparing their hash values to eliminate redundancy.", "keywords": ["deduplication", "data", "hash", "storage", "application"], "source_lectures": ["lecture_106106221_w4_l27"]}}
{"id": "concept_virus_fingerprinting", "type": "V_concept", "name": "Virus Fingerprinting", "properties": {"description": "A security application using cryptographic hash functions to uniquely identify malware by computing and comparing hash values of known malicious code.", "keywords": ["virus", "fingerprinting", "hash", "malware", "security"], "source_lectures": ["lecture_106106221_w4_l27"]}}
{"id": "concept_key_derivation_function", "type": "V_concept", "name": "Key Derivation Function", "properties": {"description": "A cryptographic application where a hash function is used to derive one or more secret keys from a master key or password.", "keywords": ["bit string", "kdf", "symmetric", "secret", "hash", "master", "function", "derivation", "symmetric key", "key derivation function", "key", "password", "hash function"], "source_lectures": ["lecture_106106221_w4_l27", "lecture_106106221_w6_l39", "lecture_106106221_w7_l47", "lecture_106106221_w8_l54"]}}
{"id": "concept_polynomial_time_adversary", "type": "V_concept", "name": "Polynomial-Time Adversary", "properties": {"description": "An adversary in cryptographic security definitions that can perform computations in time bounded by a polynomial function of the security parameter.", "keywords": ["time", "polynomial time", "security", "polynomial", "adversary", "cryptographic security", "computational", "efficient algorithm", "computation", "computational bound"], "source_lectures": ["lecture_106106221_w4_l27", "lecture_106106221_w6_l39", "lecture_106106221_w8_l53"]}}
{"id": "concept_cartesian_product_domain", "type": "V_concept", "name": "Cartesian Product Domain", "properties": {"description": "The mathematical representation of the input domain of a compression function as the product of two sets: chaining variables and message blocks.", "keywords": ["cartesian", "product", "domain", "compression", "function"], "source_lectures": ["lecture_106106221_w4_l27"]}}
{"id": "concept_iterative_hashing", "type": "V_concept", "name": "Iterative Hashing", "properties": {"description": "The process of repeatedly applying a compression function to successive message blocks and previous outputs in the Merkle-Damg\u00e5rd construction.", "keywords": ["iterative", "hashing", "merkle-damgard", "compression", "chain"], "source_lectures": ["lecture_106106221_w4_l27"]}}
{"id": "concept_dummy_block_padding", "type": "V_concept", "name": "Dummy Block Padding", "properties": {"description": "A padding technique in Merkle-Damg\u00e5rd where a full block of padding is added even when the message length is already a multiple of the block size.", "keywords": ["dummy", "block", "padding", "merkle-damgard", "message"], "source_lectures": ["lecture_106106221_w4_l27"]}}
{"id": "concept_second_preimage_resistance", "type": "V_concept", "name": "Second Preimage Resistance", "properties": {"description": "A property of hash functions requiring that, given an input, it is computationally infeasible to find a different input with the same hash value.", "keywords": ["second", "preimage", "resistance", "hash", "collision"], "source_lectures": ["lecture_106106221_w4_l27"]}}
{"id": "concept_preimage_resistance", "type": "V_concept", "name": "Preimage Resistance", "properties": {"description": "A property of hash functions requiring that, given a hash value, it is computationally infeasible to find any input that maps to it.", "keywords": ["preimage", "resistance", "hash", "one-way", "cryptographic"], "source_lectures": ["lecture_106106221_w4_l27"]}}
{"id": "concept_prf_based_mac_fcbc", "type": "V_concept", "name": "PRF-based MAC (F*CBC)", "properties": {"description": "A construction for message authentication of arbitrary-length messages using a pseudorandom function (PRF) in CBC mode with prefix-free encoding and key derivation.", "keywords": ["prf", "cbc", "mac", "prefix-free", "key-derivation"], "source_lectures": ["lecture_106106221_w5_l29"]}}
{"id": "concept_hash_and_mac_paradigm", "type": "V_concept", "name": "Hash-and-MAC Paradigm", "properties": {"description": "A method to construct a MAC for arbitrary-length messages by first hashing the message with a collision-resistant hash function and then applying a fixed-length MAC to the hash output.", "keywords": ["hash-and-mac", "mac", "hash", "fixed-length", "composition"], "source_lectures": ["lecture_106106221_w5_l29"]}}
{"id": "concept_fixed_length_mac", "type": "V_concept", "name": "Fixed-Length MAC", "properties": {"description": "A message authentication code designed to authenticate messages of a specific, fixed bit length using a secret key.", "keywords": ["fixed-length", "mac", "authentication", "keyed", "block"], "source_lectures": ["lecture_106106221_w5_l29"]}}
{"id": "concept_cma_security", "type": "V_concept", "name": "CMA Security", "properties": {"description": "Chosen Message Attack security for a MAC, meaning an adversary cannot forge a valid tag for any message not previously queried, even when allowed to obtain tags for chosen messages.", "keywords": ["cma", "security", "mac", "chosen-message", "forgery"], "source_lectures": ["lecture_106106221_w5_l29"]}}
{"id": "concept_hmac", "type": "V_concept", "name": "HMAC", "properties": {"description": "A widely used message authentication code construction that uses a cryptographic hash function and two nested applications of the hash with XORed key paddings (ipad and opad).", "keywords": ["hmac", "hash", "mac", "ipad", "opad"], "source_lectures": ["lecture_106106221_w5_l29"]}}
{"id": "concept_davies_meyer_compression_function", "type": "V_concept", "name": "Davies-Meyer Compression Function", "properties": {"description": "A method to construct a collision-resistant compression function from a block cipher by XORing the cipher output with the input block.", "keywords": ["davies-meyer", "compression", "block-cipher", "hash", "collision-resistant"], "source_lectures": ["lecture_106106221_w5_l29"]}}
{"id": "concept_inner_pad_ipad_and_outer_pad_opad", "type": "V_concept", "name": "Inner Pad (ipad) and Outer Pad (opad)", "properties": {"description": "Fixed, publicly known bit patterns used in HMAC to derive two distinct keys from the master key via XOR, ensuring separation between inner and outer hash layers.", "keywords": ["ipad", "opad", "hmac", "padding", "key-derivation"], "source_lectures": ["lecture_106106221_w5_l29"]}}
{"id": "concept_keyed_hash_function", "type": "V_concept", "name": "Keyed Hash Function", "properties": {"description": "A hash function that incorporates a secret key into its computation, making its output dependent on the key and suitable for use in message authentication.", "keywords": ["keyed", "hash", "function", "mac", "secret-key"], "source_lectures": ["lecture_106106221_w5_l29"]}}
{"id": "concept_tag_generation_in_hmac", "type": "V_concept", "name": "Tag Generation in HMAC", "properties": {"description": "The process in HMAC of first computing a hash of the message with an inner key (derived from k XOR ipad), then hashing the result with an outer key (derived from k XOR opad).", "keywords": ["hmac", "tag", "generation", "inner-key", "outer-key"], "source_lectures": ["lecture_106106221_w5_l29"]}}
{"id": "concept_tag_verification_in_hmac", "type": "V_concept", "name": "Tag Verification in HMAC", "properties": {"description": "The process of recomputing the HMAC tag using the same key and message and comparing it with the received tag to determine authenticity.", "keywords": ["hmac", "tag", "verification", "comparison", "authentication"], "source_lectures": ["lecture_106106221_w5_l29"]}}
{"id": "concept_subkey_generation", "type": "V_concept", "name": "Subkey Generation", "properties": {"description": "A public algorithm that derives multiple keys from a master key for use in different stages of a cryptographic construction, such as in PRF-based MACs.", "keywords": ["subkey", "generation", "master-key", "key-derivation", "prf"], "source_lectures": ["lecture_106106221_w5_l29"]}}
{"id": "concept_prefix_free_encoding", "type": "V_concept", "name": "Prefix-Free Encoding", "properties": {"description": "A technique to ensure that no message is a prefix of another, used in PRF-based MAC constructions to prevent length-extension attacks.", "keywords": ["prefix-free", "encoding", "prf", "mac", "length-extension"], "source_lectures": ["lecture_106106221_w5_l29"]}}
{"id": "concept_deterministic_mac", "type": "V_concept", "name": "Deterministic MAC", "properties": {"description": "A message authentication code that produces the same tag for a given message and key every time, without randomness.", "keywords": ["deterministic", "mac", "tag", "key", "reproducible"], "source_lectures": ["lecture_106106221_w5_l29"]}}
{"id": "concept_reduction_proof", "type": "V_concept", "name": "Reduction Proof", "properties": {"description": "A cryptographic proof technique that demonstrates the security of a construction by showing that breaking it implies breaking a well-known hard problem.", "keywords": ["cryptographic", "security", "proof", "hard-problem", "reduction", "cryptography"], "source_lectures": ["lecture_106106221_w5_l29", "lecture_106106221_w5_l34", "lecture_106106221_w9_l62"]}}
{"id": "concept_length_extension_attack", "type": "V_concept", "name": "Length Extension Attack", "properties": {"description": "An attack against hash functions where an attacker, given a message and its hash, can compute the hash of an extended message without knowing the original message.", "keywords": ["length-extension", "attack", "hash", "collision", "vulnerability"], "source_lectures": ["lecture_106106221_w5_l29"]}}
{"id": "concept_compression_function", "type": "V_concept", "name": "Compression Function", "properties": {"description": "A function that takes a fixed-size input and produces a fixed-size output, used iteratively in hash functions like Merkle-Damg\u00e5rd to process variable-length inputs.", "keywords": ["compression", "function", "hash", "block", "merkle-damg\u00e5rd"], "source_lectures": ["lecture_106106221_w5_l29"]}}
{"id": "concept_chaining_in_merkle_damg\u00e5rd", "type": "V_concept", "name": "Chaining in Merkle-Damg\u00e5rd", "properties": {"description": "The process of feeding the output of one compression function invocation as input to the next, along with the next message block, to process variable-length inputs.", "keywords": ["chaining", "merkle-damg\u00e5rd", "compression", "hash", "iteration"], "source_lectures": ["lecture_106106221_w5_l29"]}}
{"id": "concept_iv_initialization_vector_in_hash_functions", "type": "V_concept", "name": "IV (Initialization Vector) in Hash Functions", "properties": {"description": "A fixed, publicly known starting value used in iterative hash functions like Merkle-Damg\u00e5rd to begin the chaining process.", "keywords": ["iv", "initialization", "vector", "hash", "merkle-damg\u00e5rd"], "source_lectures": ["lecture_106106221_w5_l29"]}}
{"id": "concept_keyed_davies_meyer_construction", "type": "V_concept", "name": "Keyed Davies-Meyer Construction", "properties": {"description": "A variant of the Davies-Meyer compression function where the block cipher key is derived from a secret MAC key, enabling secure MAC construction.", "keywords": ["davies-meyer", "keyed", "compression", "mac", "block-cipher"], "source_lectures": ["lecture_106106221_w5_l29"]}}
{"id": "concept_security_composition", "type": "V_concept", "name": "Security Composition", "properties": {"description": "The principle that combining two secure cryptographic primitives can yield a secure composite scheme, provided their security properties are preserved under composition.", "keywords": ["composition", "security", "primitive", "combination", "proof"], "source_lectures": ["lecture_106106221_w5_l29"]}}
{"id": "concept_forgery_in_mac_context", "type": "V_concept", "name": "Forgery in MAC Context", "properties": {"description": "The act of producing a valid message-tag pair for a message not previously queried by the adversary in a chosen-message attack.", "keywords": ["forgery", "mac", "attack", "tag", "authenticity"], "source_lectures": ["lecture_106106221_w5_l29"]}}
{"id": "concept_tag_space", "type": "V_concept", "name": "Tag Space", "properties": {"description": "The set of all possible output values (tags) that a message authentication code can produce for a given key.", "keywords": ["tag", "space", "mac", "output", "range"], "source_lectures": ["lecture_106106221_w5_l29"]}}
{"id": "concept_hash_pointer", "type": "V_concept", "name": "Hash Pointer", "properties": {"description": "A pointer that stores not only the address of the data but also the hash value of the data, allowing for efficient verification of data integrity.", "keywords": ["hash", "pointer", "data", "integrity", "cryptography"], "source_lectures": ["lecture_106106221_w5_l30"]}}
{"id": "concept_merkle_tree", "type": "V_concept", "name": "Merkle Tree", "properties": {"description": "A data structure that uses hash pointers to create a tree-like structure, allowing for efficient verification of data integrity and membership proofs.", "keywords": ["merkle", "tree", "hash", "pointer", "cryptography"], "source_lectures": ["lecture_106106221_w5_l30"]}}
{"id": "concept_membership_proof", "type": "V_concept", "name": "Membership Proof", "properties": {"description": "A proof that demonstrates whether a particular data element is a member of a set or not, using a Merkle tree or other data structure.", "keywords": ["membership", "proof", "merkle", "tree", "cryptography"], "source_lectures": ["lecture_106106221_w5_l30"]}}
{"id": "concept_collision_presistant_hash_function", "type": "V_concept", "name": "Collision-Presistant Hash Function", "properties": {"description": "A hash function that is designed to be collision-resistant, meaning that it is computationally infeasible to find two different input values that produce the same output hash value.", "keywords": ["collision", "resistant", "hash", "function", "cryptography"], "source_lectures": ["lecture_106106221_w5_l30"]}}
{"id": "concept_temper_evident_log", "type": "V_concept", "name": "Temper-Evident Log", "properties": {"description": "A log that uses hash pointers or other mechanisms to detect any tampering or modification of the data, ensuring the integrity and authenticity of the log.", "keywords": ["temper", "evident", "log", "hash", "pointer", "cryptography"], "source_lectures": ["lecture_106106221_w5_l30"]}}
{"id": "concept_extractability_property", "type": "V_concept", "name": "Extractability Property", "properties": {"description": "A property of the Random Oracle Model that allows an adversary to extract the input values queried by another adversary.", "keywords": ["extractability", "property", "random", "oracle", "adversary"], "source_lectures": ["lecture_106106221_w5_l31"]}}
{"id": "concept_programmability_property", "type": "V_concept", "name": "Programmability Property", "properties": {"description": "A property of the Random Oracle Model that allows an adversary to program the output of the oracle for a given input.", "keywords": ["programmability", "property", "random", "oracle", "adversary"], "source_lectures": ["lecture_106106221_w5_l31"]}}
{"id": "concept_standard_model", "type": "V_concept", "name": "Standard Model", "properties": {"description": "A model used to analyze the security of cryptographic primitives without making idealized assumptions about the underlying hash functions.", "keywords": ["standard", "model", "cryptography", "hash", "function"], "source_lectures": ["lecture_106106221_w5_l31"]}}
{"id": "concept_cryptographic_primitive", "type": "V_concept", "name": "Cryptographic Primitive", "properties": {"description": "A basic building block of a cryptographic system, such as encryption or digital signatures.", "keywords": ["cryptographic", "primitive", "cryptography", "encryption", "signatures"], "source_lectures": ["lecture_106106221_w5_l31"]}}
{"id": "concept_authenticated_encryption", "type": "V_concept", "name": "Authenticated Encryption", "properties": {"description": "A type of encryption that provides both confidentiality and integrity of the plaintext.", "keywords": ["authenticated", "encryption", "confidentiality", "integrity"], "source_lectures": ["lecture_106106221_w5_l34"]}}
{"id": "concept_encrypt_then_authenticate", "type": "V_concept", "name": "Encrypt Then Authenticate", "properties": {"description": "A method of composing a CPA-secure cipher and a secure MAC to obtain an authenticated encryption scheme.", "keywords": ["encrypt", "authenticate", "composition", "cpa", "mac"], "source_lectures": ["lecture_106106221_w5_l34"]}}
{"id": "concept_mac_security", "type": "V_concept", "name": "Mac Security", "properties": {"description": "A security notion for message authentication codes that ensures the tag cannot be forged.", "keywords": ["mac", "security", "unforgeability", "tag"], "source_lectures": ["lecture_106106221_w5_l34"]}}
{"id": "concept_strong_cma_security", "type": "V_concept", "name": "Strong Cma Security", "properties": {"description": "A security notion for message authentication codes that ensures the tag cannot be forged even when the adversary has access to a tagging oracle.", "keywords": ["strong", "cma", "security", "unforgeability", "tagging"], "source_lectures": ["lecture_106106221_w5_l34"]}}
{"id": "concept_tag_generation_algorithm", "type": "V_concept", "name": "Tag Generation Algorithm", "properties": {"description": "An algorithm used to generate a tag for a message.", "keywords": ["tag", "generation", "algorithm", "message"], "source_lectures": ["lecture_106106221_w5_l34"]}}
{"id": "concept_tag_verification_algorithm", "type": "V_concept", "name": "Tag Verification Algorithm", "properties": {"description": "An algorithm used to verify the authenticity of a tag.", "keywords": ["tag", "verification", "algorithm", "authenticity"], "source_lectures": ["lecture_106106221_w5_l34"]}}
{"id": "concept_mac_scheme", "type": "V_concept", "name": "Mac Scheme", "properties": {"description": "A message authentication code scheme that ensures the authenticity and integrity of a message.", "keywords": ["mac", "message", "authentication", "integrity"], "source_lectures": ["lecture_106106221_w5_l35"]}}
{"id": "concept_encrypt_then_authenticate_approach", "type": "V_concept", "name": "Encrypt Then Authenticate Approach", "properties": {"description": "A method of composing a CPA-secure symmetric encryption scheme and a secure MAC to obtain an authenticated encryption scheme.", "keywords": ["encrypt", "authenticate", "composition", "authenticated", "encryption"], "source_lectures": ["lecture_106106221_w5_l35"]}}
{"id": "concept_authenticate_then_encrypt_approach", "type": "V_concept", "name": "Authenticate Then Encrypt Approach", "properties": {"description": "A method of composing a CPA-secure symmetric encryption scheme and a secure MAC to obtain an authenticated encryption scheme.", "keywords": ["authenticate", "encrypt", "composition", "authenticated", "encryption"], "source_lectures": ["lecture_106106221_w5_l35"]}}
{"id": "concept_encrypt_and_authenticate_approach", "type": "V_concept", "name": "Encrypt And Authenticate Approach", "properties": {"description": "A method of composing a CPA-secure symmetric encryption scheme and a secure MAC to obtain an authenticated encryption scheme.", "keywords": ["encrypt", "authenticate", "composition", "authenticated", "encryption"], "source_lectures": ["lecture_106106221_w5_l35"]}}
{"id": "concept_pkcs_padding", "type": "V_concept", "name": "Pkcs Padding", "properties": {"description": "A method of padding messages to ensure they are a multiple of the block size in block cipher encryption.", "keywords": ["pkcs", "padding", "block", "cipher", "encryption"], "source_lectures": ["lecture_106106221_w5_l35"]}}
{"id": "concept_padding_oracle_attack", "type": "V_concept", "name": "Padding Oracle Attack", "properties": {"description": "A type of attack that exploits information about the padding of encrypted messages to recover the plaintext.", "keywords": ["padding", "oracle", "attack", "encryption", "plaintext"], "source_lectures": ["lecture_106106221_w5_l35"]}}
{"id": "concept_authenticated_encryption_scheme", "type": "V_concept", "name": "Authenticated Encryption Scheme", "properties": {"description": "A type of encryption scheme that provides both confidentiality and authenticity of the encrypted message.", "keywords": ["authenticated", "encryption", "scheme", "confidentiality", "authenticity"], "source_lectures": ["lecture_106106221_w5_l35"]}}
{"id": "concept_key_exchange_protocol", "type": "V_concept", "name": "Key Exchange Protocol", "properties": {"description": "A protocol that enables two parties to establish a shared secret key over an insecure communication channel", "keywords": ["security", "protocol", "exchange", "key", "cryptography"], "source_lectures": ["lecture_106106221_w6_l36", "lecture_106106221_w6_l37"]}}
{"id": "concept_weak_privacy", "type": "V_concept", "name": "Weak Privacy", "properties": {"description": "A security notion that requires an adversary to not learn the entire output key of a key exchange protocol", "keywords": ["privacy", "security", "adversary", "exchange", "probability", "weak", "key"], "source_lectures": ["lecture_106106221_w6_l36", "lecture_106106221_w6_l37"]}}
{"id": "concept_strong_privacy", "type": "V_concept", "name": "Strong Privacy", "properties": {"description": "A security notion that requires an adversary to not distinguish the output key of a key exchange protocol from a uniformly random element", "keywords": ["strong", "privacy", "security", "key", "exchange"], "source_lectures": ["lecture_106106221_w6_l36"]}}
{"id": "concept_indistinguishability_based_security", "type": "V_concept", "name": "Indistinguishability-Based Security", "properties": {"description": "A security notion that requires an adversary to not distinguish between two distributions", "keywords": ["indistinguishability", "security", "cryptography", "adversary"], "source_lectures": ["lecture_106106221_w6_l36"]}}
{"id": "concept_catch_22_situation", "type": "V_concept", "name": "Catch-22 Situation", "properties": {"description": "A situation where a problem cannot be solved because it requires a solution to the same problem", "keywords": ["catch", "22", "situation", "problem", "solution"], "source_lectures": ["lecture_106106221_w6_l36"]}}
{"id": "concept_asymmetric_task", "type": "V_concept", "name": "Asymmetric Task", "properties": {"description": "A task that is easy to perform in one direction but difficult to reverse", "keywords": ["asymmetric", "task", "cryptography", "security"], "source_lectures": ["lecture_106106221_w6_l36"]}}
{"id": "concept_trapdoor_function", "type": "V_concept", "name": "Trapdoor Function", "properties": {"description": "A special type of one-way function that has a secret key, known as the trapdoor, which allows the function to be inverted easily.", "keywords": ["trapdoor", "function", "secret", "key", "invert"], "source_lectures": ["lecture_106106221_w6_l37"]}}
{"id": "concept_inversion_algorithm", "type": "V_concept", "name": "Inversion Algorithm", "properties": {"description": "An algorithm that takes the output of a trapdoor function and the secret key, and produces the original input.", "keywords": ["inversion", "algorithm", "trapdoor", "function", "secret"], "source_lectures": ["lecture_106106221_w6_l37"]}}
{"id": "concept_eavesdropper", "type": "V_concept", "name": "Eavesdropper", "properties": {"description": "An adversary that intercepts and observes the communication between two parties in a key exchange protocol.", "keywords": ["eavesdropper", "adversary", "intercept", "observe", "communication"], "source_lectures": ["lecture_106106221_w6_l37"]}}
{"id": "concept_computational_diffie_hellman_problem", "type": "V_concept", "name": "Computational Diffie-Hellman Problem", "properties": {"description": "The problem of computing g^(alpha*beta) given g^alpha and g^beta in a cyclic group, without knowing alpha or beta.", "keywords": ["cdh", "computational diffie-hellman", "diffie-hellman", "cyclic group", "exponentiation"], "source_lectures": ["lecture_106106221_w6_l39"]}}
{"id": "concept_computational_diffie_hellman_assumption", "type": "V_concept", "name": "Computational Diffie-Hellman Assumption", "properties": {"description": "The assumption that no polynomial-time adversary can compute g^(alpha*beta) from g^alpha and g^beta with non-negligible probability.", "keywords": ["cdh assumption", "computational diffie-hellman assumption", "hardness", "cyclic group", "cryptographic"], "source_lectures": ["lecture_106106221_w6_l39"]}}
{"id": "concept_decisional_diffie_hellman_assumption", "type": "V_concept", "name": "Decisional Diffie-Hellman Assumption", "properties": {"description": "The assumption that no polynomial-time adversary can distinguish a Diffie-Hellman triplet from a random triplet with probability significantly better than 1/2.", "keywords": ["ddh assumption", "decisional diffie-hellman assumption", "indistinguishability", "cyclic group", "cryptographic"], "source_lectures": ["lecture_106106221_w6_l39"]}}
{"id": "concept_diffie_hellman_triple", "type": "V_concept", "name": "Diffie-Hellman Triple", "properties": {"description": "A triplet of group elements (g^alpha, g^beta, g^(alpha*beta)) in a cyclic group where the third element is the product of the discrete logs of the first two.", "keywords": ["diffie-hellman triplet", "ddh triplet", "cyclic group", "exponent", "generator"], "source_lectures": ["lecture_106106221_w6_l39"]}}
{"id": "concept_diffie_hellman_function", "type": "V_concept", "name": "Diffie-Hellman Function", "properties": {"description": "A function that takes two group elements g^alpha and g^beta and outputs g^(alpha*beta) in a multiplicative cyclic group.", "keywords": ["diffie-hellman function", "cdh function", "cyclic group", "exponentiation", "multiplicative"], "source_lectures": ["lecture_106106221_w6_l39"]}}
{"id": "concept_diffie_hellman_key_exchange_protocol", "type": "V_concept", "name": "Diffie-Hellman Key Exchange Protocol", "properties": {"description": "A protocol allowing two parties to establish a shared secret key over an insecure channel using cyclic group exponentiation.", "keywords": ["diffie-hellman", "key exchange", "cyclic group", "shared secret", "public key"], "source_lectures": ["lecture_106106221_w6_l39"]}}
{"id": "concept_weak_privacy_in_diffie_hellman", "type": "V_concept", "name": "Weak Privacy in Diffie-Hellman", "properties": {"description": "A security property ensuring that an eavesdropper cannot compute the shared key g^(alpha*beta) from g^alpha and g^beta, relying on the CDH assumption.", "keywords": ["weak privacy", "diffie-hellman", "cdh assumption", "eavesdropper", "security"], "source_lectures": ["lecture_106106221_w6_l39"]}}
{"id": "concept_strong_privacy_in_diffie_hellman", "type": "V_concept", "name": "Strong Privacy in Diffie-Hellman", "properties": {"description": "A security property ensuring that the shared key g^(alpha*beta) is computationally indistinguishable from a random group element, relying on the DDH assumption.", "keywords": ["strong privacy", "diffie-hellman", "ddh assumption", "indistinguishability", "security"], "source_lectures": ["lecture_106106221_w6_l39"]}}
{"id": "concept_group_exponentiation", "type": "V_concept", "name": "Group Exponentiation", "properties": {"description": "The operation of raising a group element to an integer power, efficiently computable in polynomial time in cyclic groups.", "keywords": ["group exponentiation", "exponentiation", "cyclic group", "efficient computation", "modular arithmetic"], "source_lectures": ["lecture_106106221_w6_l39"]}}
{"id": "concept_man_in_the_middle_attack", "type": "V_concept", "name": "Man-in-the-Middle Attack", "properties": {"description": "An active attack where an adversary intercepts and possibly alters communications between two parties, exploiting the lack of authentication in basic Diffie-Hellman.", "keywords": ["attack", "man in the middle", "security", "impersonation", "diffie-hellman", "man-in-the-middle", "mitm", "active attack", "communication", "cryptography"], "source_lectures": ["lecture_106106221_w6_l39", "lecture_106104233_w4_l26"]}}
{"id": "concept_impersonation_attack", "type": "V_concept", "name": "Impersonation Attack", "properties": {"description": "An attack where an adversary pretends to be one of the legitimate parties in a key exchange protocol to deceive the other party.", "keywords": ["impersonation attack", "man in the middle", "authentication", "diffie-hellman", "active adversary"], "source_lectures": ["lecture_106106221_w6_l39"]}}
{"id": "concept_hybrid_cryptosystem", "type": "V_concept", "name": "Hybrid Cryptosystem", "properties": {"description": "A cryptographic system combining asymmetric key exchange (e.g., Diffie-Hellman) with symmetric encryption for efficiency and security.", "keywords": ["hybrid cryptosystem", "asymmetric", "symmetric", "key exchange", "encryption"], "source_lectures": ["lecture_106106221_w6_l39"]}}
{"id": "concept_multiplicative_cyclic_group", "type": "V_concept", "name": "Multiplicative Cyclic Group", "properties": {"description": "A cyclic group where the group operation is multiplication modulo a prime or in an elliptic curve group.", "keywords": ["multiplicative group", "cyclic group", "modular arithmetic", "elliptic curve", "generator"], "source_lectures": ["lecture_106106221_w6_l39"]}}
{"id": "concept_additive_cyclic_group", "type": "V_concept", "name": "Additive Cyclic Group", "properties": {"description": "A cyclic group where the group operation is addition, such as in elliptic curve cryptography over finite fields.", "keywords": ["additive group", "cyclic group", "elliptic curve", "point addition", "generator"], "source_lectures": ["lecture_106106221_w6_l39"]}}
{"id": "concept_contrapositive_reasoning_in_cryptography", "type": "V_concept", "name": "Contrapositive Reasoning in Cryptography", "properties": {"description": "A logical technique used to prove relationships between cryptographic assumptions by showing that breaking a stronger assumption implies breaking a weaker one.", "keywords": ["contrapositive", "implication", "cryptographic assumption", "dlog", "cdh"], "source_lectures": ["lecture_106106221_w6_l39"]}}
{"id": "concept_hardness_hierarchy_of_cryptographic_assumptions", "type": "V_concept", "name": "Hardness Hierarchy of Cryptographic Assumptions", "properties": {"description": "The relationship where DDH implies CDH, which implies DLog, meaning DDH is the strongest and DLog the weakest assumption.", "keywords": ["hardness hierarchy", "dlog", "cdh", "ddh", "assumption strength"], "source_lectures": ["lecture_106106221_w6_l39"]}}
{"id": "concept_candidate_groups_for_cryptographic_hardness", "type": "V_concept", "name": "Candidate Groups for Cryptographic Hardness", "properties": {"description": "Specific cyclic groups (e.g., prime-order subgroups of Z_p^*, elliptic curves) where discrete log and related problems are believed to be computationally hard.", "keywords": ["candidate group", "cryptographic group", "dlog hard", "elliptic curve", "prime order"], "source_lectures": ["lecture_106106221_w6_l39"]}}
{"id": "concept_group_order", "type": "V_concept", "name": "Group Order", "properties": {"description": "The number of elements in a finite group, denoted q, which determines the size of the exponent space in cryptographic protocols.", "keywords": ["group order", "q", "cyclic group", "size", "finite group"], "source_lectures": ["lecture_106106221_w6_l39"]}}
{"id": "concept_symmetric_cryptographic_primitive", "type": "V_concept", "name": "Symmetric Cryptographic Primitive", "properties": {"description": "A cryptographic algorithm (e.g., AES, ChaCha20) requiring a shared secret key for encryption and decryption.", "keywords": ["symmetric cipher", "aes", "chacha20", "shared key", "encryption"], "source_lectures": ["lecture_106106221_w6_l39"]}}
{"id": "concept_prime_order_cyclic_group", "type": "V_concept", "name": "Prime Order Cyclic Group", "properties": {"description": "A cyclic group with a prime number of elements, used in cryptographic applications.", "keywords": ["prime", "order", "cyclic", "group", "cryptographic"], "source_lectures": ["lecture_106106221_w6_l40"]}}
{"id": "concept_cdh_problem", "type": "V_concept", "name": "CDH Problem", "properties": {"description": "A problem of computing the discrete logarithm of an element in a finite field, given its base and result, with certain constraints.", "keywords": ["diffiehellman", "logarithm", "finite", "computational", "discrete", "problem", "cdh", "cryptography"], "source_lectures": ["lecture_106106221_w6_l40", "lecture_106106221_w7_l47", "lecture_106106221_w7_l49"]}}
{"id": "concept_ddh_problem", "type": "V_concept", "name": "DDH Problem", "properties": {"description": "A problem of distinguishing between two distributions of elements in a finite field, used in cryptographic applications.", "keywords": ["distribution", "diffiehellman", "finite", "computational", "diffie-hellman", "ddh", "problem", "field", "tuple", "cryptography"], "source_lectures": ["lecture_106106221_w6_l40", "lecture_106106221_w7_l47", "lecture_106106221_w7_l49"]}}
{"id": "concept_generator_of_a_group", "type": "V_concept", "name": "Generator of a Group", "properties": {"description": "An element that can generate all other elements of a group, used in cryptographic applications.", "keywords": ["generator", "group", "element", "cryptographic"], "source_lectures": ["lecture_106106221_w6_l40"]}}
{"id": "concept_subgroup", "type": "V_concept", "name": "Subgroup", "properties": {"description": "A subset of a group that is also a group, used in cryptographic applications.", "keywords": ["subgroup", "group", "subset", "cryptographic"], "source_lectures": ["lecture_106106221_w6_l40"]}}
{"id": "concept_elliptic_curve_cryptography", "type": "V_concept", "name": "Elliptic Curve Cryptography", "properties": {"description": "A type of cryptography that uses elliptic curves to provide secure key exchange and encryption.", "keywords": ["public-key", "elliptic", "secure", "key", "cryptography", "curve"], "source_lectures": ["lecture_106106221_w6_l40", "lecture_106106221_w6_l41"]}}
{"id": "concept_elliptic_curve", "type": "V_concept", "name": "Elliptic Curve", "properties": {"description": "A mathematical concept used in number theory and algebraic geometry, defined by a cubic equation in two variables.", "keywords": ["elliptic", "curve", "cryptography", "mathematics"], "source_lectures": ["lecture_106106221_w6_l41"]}}
{"id": "concept_non_singular_elliptic_curve", "type": "V_concept", "name": "Non-Singular Elliptic Curve", "properties": {"description": "An elliptic curve that has no singular points, meaning that it has a unique solution for every point on the curve.", "keywords": ["non-singular", "elliptic", "curve", "mathematics"], "source_lectures": ["lecture_106106221_w6_l41"]}}
{"id": "concept_point_at_infinity", "type": "V_concept", "name": "Point At Infinity", "properties": {"description": "A special point on an elliptic curve that serves as the identity element for the group operation.", "keywords": ["point", "infinity", "elliptic", "curve", "mathematics"], "source_lectures": ["lecture_106106221_w6_l41"]}}
{"id": "concept_addition_operation_on_elliptic_curves", "type": "V_concept", "name": "Addition Operation On Elliptic Curves", "properties": {"description": "A binary operation that combines two points on an elliptic curve to produce a third point, satisfying certain algebraic properties.", "keywords": ["addition", "operation", "elliptic", "curve", "mathematics"], "source_lectures": ["lecture_106106221_w6_l41"]}}
{"id": "concept_hasse_bound", "type": "V_concept", "name": "Hasse Bound", "properties": {"description": "A mathematical bound that provides an estimate for the number of points on an elliptic curve over a finite field.", "keywords": ["hasse", "bound", "elliptic", "curve", "mathematics"], "source_lectures": ["lecture_106106221_w6_l41"]}}
{"id": "concept_anomalous_curve", "type": "V_concept", "name": "Anomalous Curve", "properties": {"description": "An elliptic curve with a specific property that makes it unsuitable for cryptographic applications.", "keywords": ["anomalous", "curve", "elliptic", "cryptography", "weakness"], "source_lectures": ["lecture_106106221_w6_l41"]}}
{"id": "concept_super_singular_curve", "type": "V_concept", "name": "Super Singular Curve", "properties": {"description": "A type of elliptic curve that has a specific property, making it vulnerable to certain attacks in cryptographic applications.", "keywords": ["super", "singular", "curve", "elliptic", "cryptography"], "source_lectures": ["lecture_106106221_w6_l41"]}}
{"id": "concept_discrete_log_assumption", "type": "V_concept", "name": "Discrete Log Assumption", "properties": {"description": "Assumes that it is computationally infeasible to find the discrete logarithm of a given element in a cyclic group.", "keywords": ["assumption", "discrete", "group", "log", "cyclic", "cryptography"], "source_lectures": ["lecture_106106221_w6_l42", "lecture_106106221_w7_l43"]}}
{"id": "concept_collision_resistant_function", "type": "V_concept", "name": "Collision Resistant Function", "properties": {"description": "A function that makes it computationally infeasible to find two distinct inputs with the same output.", "keywords": ["collision", "resistant", "function", "computational", "security"], "source_lectures": ["lecture_106106221_w6_l42"]}}
{"id": "concept_merkle_damgard_transformation", "type": "V_concept", "name": "Merkle-Damgard Transformation", "properties": {"description": "A method for constructing a collision-resistant hash function from a collision-resistant compression function.", "keywords": ["merkle", "damgard", "transformation", "hash", "function"], "source_lectures": ["lecture_106106221_w6_l42"]}}
{"id": "concept_davies_meyer_construction", "type": "V_concept", "name": "Davies-Meyer Construction", "properties": {"description": "A method for constructing a collision-resistant compression function from a block cipher.", "keywords": ["davies", "meyer", "construction", "block", "cipher"], "source_lectures": ["lecture_106106221_w6_l42"]}}
{"id": "concept_hdl_function", "type": "V_concept", "name": "HDL Function", "properties": {"description": "A collision-resistant compression function based on the discrete log assumption.", "keywords": ["hdl", "function", "collision", "resistant", "discrete"], "source_lectures": ["lecture_106106221_w6_l42"]}}
{"id": "concept_pedersen_commitment_scheme", "type": "V_concept", "name": "Pedersen Commitment Scheme", "properties": {"description": "A commitment scheme that provides hiding and binding properties based on the discrete log assumption.", "keywords": ["pedersen", "commitment", "scheme", "hiding", "binding"], "source_lectures": ["lecture_106106221_w6_l42"]}}
{"id": "concept_commitment_scheme", "type": "V_concept", "name": "Commitment Scheme", "properties": {"description": "A cryptographic primitive that allows a sender to commit to a message without revealing it.", "keywords": ["cryptographic", "security", "commitment", "protocol", "scheme", "message", "primitive", "cryptography"], "source_lectures": ["lecture_106106221_w6_l42", "lecture_106106221_w9_l58"]}}
{"id": "concept_hiding_property", "type": "V_concept", "name": "Hiding Property", "properties": {"description": "A security property of a commitment scheme that ensures the committed message remains secret.", "keywords": ["hiding", "property", "security", "commitment", "secret"], "source_lectures": ["lecture_106106221_w6_l42"]}}
{"id": "concept_binding_property", "type": "V_concept", "name": "Binding Property", "properties": {"description": "A security property of a commitment scheme that ensures the sender cannot change the committed message.", "keywords": ["binding", "property", "security", "commitment", "message"], "source_lectures": ["lecture_106106221_w6_l42"]}}
{"id": "concept_homomorphic_property", "type": "V_concept", "name": "Homomorphic Property", "properties": {"description": "A property of a commitment scheme that allows computations to be performed on the committed messages.", "keywords": ["homomorphic", "property", "commitment", "computation", "message"], "source_lectures": ["lecture_106106221_w6_l42"]}}
{"id": "concept_public_key_cryptosystem", "type": "V_concept", "name": "Public Key Cryptosystem", "properties": {"description": "A cryptographic system that uses a pair of keys, one public and one private, for encryption and decryption.", "keywords": ["public", "key", "cryptosystem", "asymmetric", "encryption"], "source_lectures": ["lecture_106106221_w7_l43"]}}
{"id": "concept_asymmetric_key_encryption", "type": "V_concept", "name": "Asymmetric Key Encryption", "properties": {"description": "A type of encryption that uses a pair of keys, one public and one private, for encryption and decryption.", "keywords": ["asymmetric", "key", "encryption", "public", "private"], "source_lectures": ["lecture_106106221_w7_l43"]}}
{"id": "concept_factoring_assumption", "type": "V_concept", "name": "Factoring Assumption", "properties": {"description": "A computational hardness assumption that it is difficult to factor a product of two large prime numbers.", "keywords": ["factoring", "assumption", "hardness", "cryptography"], "source_lectures": ["lecture_106106221_w7_l45"]}}
{"id": "concept_zn_star", "type": "V_concept", "name": "Zn Star", "properties": {"description": "A set of integers modulo N that are coprime to N.", "keywords": ["zn", "star", "coprime", "modulus"], "source_lectures": ["lecture_106106221_w7_l45"]}}
{"id": "concept_extended_euclid_algorithm", "type": "V_concept", "name": "Extended Euclid Algorithm", "properties": {"description": "An algorithm for computing the greatest common divisor of two integers and the coefficients of B\u00e9zout's identity.", "keywords": ["extended", "euclid", "algorithm", "gcd"], "source_lectures": ["lecture_106106221_w7_l45"]}}
{"id": "concept_fermats_little_theorem", "type": "V_concept", "name": "Fermat's Little Theorem", "properties": {"description": "A theorem that states that if p is a prime number, then for any integer a not divisible by p, a^(p-1) is congruent to 1 modulo p.", "keywords": ["fermat", "little", "prime", "modular", "theorem"], "source_lectures": ["lecture_106106221_w7_l45", "lecture_106106221_w7_l46"]}}
{"id": "concept_trapdoor_permutation", "type": "V_concept", "name": "Trapdoor Permutation", "properties": {"description": "A permutation that is easy to compute but hard to invert without a secret trapdoor information.", "keywords": ["trapdoor", "permutation", "cryptography", "security"], "source_lectures": ["lecture_106106221_w7_l45"]}}
{"id": "concept_rsa_trapdoor_permutation", "type": "V_concept", "name": "RSA Trapdoor Permutation", "properties": {"description": "A specific instantiation of a one-way trapdoor permutation based on modular exponentiation with a composite modulus N = p\u00b7q, where encryption is computing m^e mod N and decryption is computing c^d mod N, with ed \u2261 1 mod \u03c6(N).", "keywords": ["rsa", "trapdoor", "exponentiation", "modular", "permutation", "cryptography"], "source_lectures": ["lecture_106106221_w7_l46", "lecture_106106221_w8_l50"]}}
{"id": "concept_plain_rsa_cryptosystem", "type": "V_concept", "name": "Plain RSA Cryptosystem", "properties": {"description": "A deterministic public-key encryption scheme derived directly from the RSA trapdoor permutation, where encryption is c = m^e mod N and decryption is m = c^d mod N without any padding or randomness.", "keywords": ["plain", "rsa", "cryptosystem", "deterministic", "encryption"], "source_lectures": ["lecture_106106221_w7_l46"]}}
{"id": "concept_chosen_plaintext_attack_cpa_security", "type": "V_concept", "name": "Chosen-Plaintext Attack (CPA) Security", "properties": {"description": "A security notion requiring that an adversary cannot distinguish between encryptions of two chosen plaintexts, even when allowed to obtain encryptions of arbitrary plaintexts of its choice.", "keywords": ["cpa", "security", "chosen-plaintext", "indistinguishability", "encryption"], "source_lectures": ["lecture_106106221_w7_l46"]}}
{"id": "concept_small_exponent_attack_on_rsa", "type": "V_concept", "name": "Small Exponent Attack on RSA", "properties": {"description": "An attack on RSA when a small public exponent e (e.g., 3) is used and the plaintext m is small enough that m^e < N, allowing the attacker to recover m by computing the integer e-th root of the ciphertext.", "keywords": ["small", "exponent", "attack", "rsa", "integer-root"], "source_lectures": ["lecture_106106221_w7_l46"]}}
{"id": "concept_h\u00e5stads_broadcast_attack", "type": "V_concept", "name": "H\u00e5stad's Broadcast Attack", "properties": {"description": "An attack on RSA when the same plaintext is encrypted with the same small public exponent e and sent to e or more recipients with different moduli, allowing the attacker to recover the plaintext using the Chinese Remainder Theorem.", "keywords": ["h\u00e5stad", "broadcast", "attack", "rsa", "chinese-remainder"], "source_lectures": ["lecture_106106221_w7_l46"]}}
{"id": "concept_chinese_remainder_theorem_crt", "type": "V_concept", "name": "Chinese Remainder Theorem (CRT)", "properties": {"description": "A number-theoretic result stating that if moduli are pairwise coprime, a system of congruences has a unique solution modulo the product of the moduli.", "keywords": ["chinese", "remainder", "theorem", "crt", "congruence"], "source_lectures": ["lecture_106106221_w7_l46"]}}
{"id": "concept_crt_optimization_for_rsa_decryption", "type": "V_concept", "name": "CRT Optimization for RSA Decryption", "properties": {"description": "A technique to speed up RSA decryption by computing modular exponentiations modulo p and q separately, then combining results via the Chinese Remainder Theorem, reducing computational cost by ~25%.", "keywords": ["crt", "optimization", "rsa", "decryption", "modular"], "source_lectures": ["lecture_106106221_w7_l46"]}}
{"id": "concept_padded_rsa", "type": "V_concept", "name": "Padded RSA", "properties": {"description": "A randomized variant of RSA encryption that appends random padding bits to the plaintext before applying the RSA function to achieve CPA security.", "keywords": ["padded", "rsa", "randomization", "padding", "cpa"], "source_lectures": ["lecture_106106221_w7_l46"]}}
{"id": "concept_rsa_key_generation", "type": "V_concept", "name": "RSA Key Generation", "properties": {"description": "The process of selecting two large primes p and q, computing N = p\u00b7q and \u03c6(N) = (p-1)(q-1), choosing e coprime to \u03c6(N), and computing d as the modular multiplicative inverse of e modulo \u03c6(N).", "keywords": ["rsa", "key", "generation", "primes", "modular-inverse"], "source_lectures": ["lecture_106106221_w7_l46"]}}
{"id": "concept_eulers_totient_function_\u03c6n", "type": "V_concept", "name": "Euler\u2019s Totient Function \u03c6(N)", "properties": {"description": "A function that counts the number of integers less than N that are coprime to N; for N = p\u00b7q (distinct primes), \u03c6(N) = (p-1)(q-1).", "keywords": ["euler", "totient", "phi", "coprime", "modulus"], "source_lectures": ["lecture_106106221_w7_l46"]}}
{"id": "concept_common_modulus_attack", "type": "V_concept", "name": "Common Modulus Attack", "properties": {"description": "An attack where multiple users share the same RSA modulus N; if one user knows their own (e, d), they can compute \u03c6(N) and derive other users\u2019 private keys.", "keywords": ["common", "modulus", "attack", "rsa", "key-recovery"], "source_lectures": ["lecture_106106221_w7_l46"]}}
{"id": "concept_z_n_multiplicative_group_modulo_n", "type": "V_concept", "name": "Z_N* (Multiplicative Group Modulo N)", "properties": {"description": "The set of integers between 1 and N-1 that are coprime to N, forming a group under multiplication modulo N; used as the plaintext space in standard RSA.", "keywords": ["zn-star", "multiplicative", "group", "modular", "coprime"], "source_lectures": ["lecture_106106221_w7_l46"]}}
{"id": "concept_z_n_ring_of_integers_modulo_n", "type": "V_concept", "name": "Z_N (Ring of Integers Modulo N)", "properties": {"description": "The set of integers from 0 to N-1 under addition and multiplication modulo N; RSA encryption and decryption can still work correctly for elements in Z_N, not just Z_N*.", "keywords": ["zn", "ring", "modular", "integers", "rsa"], "source_lectures": ["lecture_106106221_w7_l46"]}}
{"id": "concept_public_key_infrastructure_pki_for_rsa", "type": "V_concept", "name": "Public Key Infrastructure (PKI) for RSA", "properties": {"description": "The framework for distributing and managing RSA public keys (N, e) in a secure and authenticated manner, ensuring that users can verify the authenticity of public keys.", "keywords": ["pki", "rsa", "public-key", "distribution", "authentication"], "source_lectures": ["lecture_106106221_w7_l46"]}}
{"id": "concept_hybrid_rsa_encryption", "type": "V_concept", "name": "Hybrid RSA Encryption", "properties": {"description": "A practical encryption scheme where RSA encrypts a symmetric key, which in turn encrypts the actual message, allowing efficient encryption of large data using RSA's limited plaintext space.", "keywords": ["hybrid", "rsa", "encryption", "symmetric", "key"], "source_lectures": ["lecture_106106221_w7_l46"]}}
{"id": "concept_rsa_decryption_exponent_d", "type": "V_concept", "name": "RSA Decryption Exponent d", "properties": {"description": "The private exponent in RSA, computed as the multiplicative inverse of e modulo \u03c6(N), used to decrypt ciphertexts via c^d mod N.", "keywords": ["rsa", "decryption", "exponent", "d", "private-key"], "source_lectures": ["lecture_106106221_w7_l46"]}}
{"id": "concept_rsa_public_exponent_e", "type": "V_concept", "name": "RSA Public Exponent e", "properties": {"description": "The public exponent in RSA, typically chosen as a small prime (e.g., 3, 17, or 65537) to optimize encryption speed, provided it is coprime to \u03c6(N).", "keywords": ["rsa", "public", "exponent", "e", "encryption"], "source_lectures": ["lecture_106106221_w7_l46"]}}
{"id": "concept_modulus_n_in_rsa", "type": "V_concept", "name": "Modulus N in RSA", "properties": {"description": "The product of two large primes p and q, serving as the modulus for RSA operations; its size determines the security level of the cryptosystem.", "keywords": ["rsa", "modulus", "n", "prime-product", "security"], "source_lectures": ["lecture_106106221_w7_l46"]}}
{"id": "concept_brute_force_attack_on_padded_rsa", "type": "V_concept", "name": "Brute-Force Attack on Padded RSA", "properties": {"description": "An attack on padded RSA where an adversary tries all possible random padding values to recover the plaintext, feasible only if the padding length is too short.", "keywords": ["brute-force", "padded", "rsa", "attack", "padding"], "source_lectures": ["lecture_106106221_w7_l46"]}}
{"id": "concept_correctness_property_in_cryptosystems", "type": "V_concept", "name": "Correctness Property in Cryptosystems", "properties": {"description": "A requirement that decryption of an encryption of a plaintext must always recover the original plaintext, ensuring functional reliability of the cryptosystem.", "keywords": ["correctness", "property", "cryptosystem", "encryption", "decryption"], "source_lectures": ["lecture_106106221_w7_l46"]}}
{"id": "concept_security_reduction_in_cryptography", "type": "V_concept", "name": "Security Reduction in Cryptography", "properties": {"description": "A proof technique that shows breaking a cryptosystem is at least as hard as solving a well-known computational problem, such as the RSA problem.", "keywords": ["security", "reduction", "cryptanalysis", "hardness", "proof"], "source_lectures": ["lecture_106106221_w7_l46"]}}
{"id": "concept_hybrid_public_key_cryptosystem", "type": "V_concept", "name": "Hybrid Public-Key Cryptosystem", "properties": {"description": "A cryptographic system that combines public-key encryption with symmetric-key encryption to achieve efficient and secure data transmission.", "keywords": ["hybrid", "public-key", "cryptosystem", "encryption", "security"], "source_lectures": ["lecture_106106221_w7_l47"]}}
{"id": "concept_key_encapsulation_mechanism_kem", "type": "V_concept", "name": "Key Encapsulation Mechanism (KEM)", "properties": {"description": "A cryptographic primitive that securely encapsulates a symmetric key within a public-key encryption scheme.", "keywords": ["kem", "key", "encapsulation", "mechanism", "public-key"], "source_lectures": ["lecture_106106221_w7_l47"]}}
{"id": "concept_data_encapsulation_mechanism_dem", "type": "V_concept", "name": "Data Encapsulation Mechanism (DEM)", "properties": {"description": "A symmetric-key encryption scheme used in conjunction with a KEM to securely encrypt data.", "keywords": ["dem", "data", "encapsulation", "mechanism", "symmetric-key"], "source_lectures": ["lecture_106106221_w7_l47"]}}
{"id": "concept_key_encapsulation_mechanism", "type": "V_concept", "name": "Key Encapsulation Mechanism", "properties": {"description": "A cryptographic technique used to securely encrypt and decrypt keys.", "keywords": ["mechanism", "encapsulation", "publickey", "symmetric", "security", "keyencapsulation", "kem", "asymmetric", "key", "cryptography"], "source_lectures": ["lecture_106106221_w7_l48", "lecture_106106221_w7_l49", "lecture_106106221_w8_l50", "lecture_106106221_w8_l54"]}}
{"id": "concept_hybrid_encryption", "type": "V_concept", "name": "Hybrid Encryption", "properties": {"description": "A cryptographic technique that combines public-key encryption and symmetric key encryption to achieve efficient and secure encryption.", "keywords": ["hybrid", "encryption", "public-key", "symmetric", "cryptography"], "source_lectures": ["lecture_106106221_w7_l48"]}}
{"id": "concept_cca_secure_public_key_cipher", "type": "V_concept", "name": "Cca Secure Public-Key Cipher", "properties": {"description": "A public-key encryption scheme that is secure against chosen ciphertext attacks.", "keywords": ["cca", "secure", "public-key", "cipher", "encryption"], "source_lectures": ["lecture_106106221_w7_l48"]}}
{"id": "concept_passive_adversary_model", "type": "V_concept", "name": "Passive Adversary Model", "properties": {"description": "A model of an adversary that can only eavesdrop on communications and cannot modify or inject messages.", "keywords": ["passive", "adversary", "model", "security", "cryptography"], "source_lectures": ["lecture_106106221_w7_l48"]}}
{"id": "concept_active_adversary_model", "type": "V_concept", "name": "Active Adversary Model", "properties": {"description": "A model of an adversary that can modify or inject messages in addition to eavesdropping on communications.", "keywords": ["active", "adversary", "model", "security", "cryptography"], "source_lectures": ["lecture_106106221_w7_l48"]}}
{"id": "concept_el_gamal_cipher", "type": "V_concept", "name": "El Gamal Cipher", "properties": {"description": "A public-key cryptosystem based on the difficulty of the discrete logarithm problem.", "keywords": ["elgamal", "cipher", "publickey", "cryptography"], "source_lectures": ["lecture_106106221_w7_l49"]}}
{"id": "concept_gap_computational_diffie_hellman_assumption", "type": "V_concept", "name": "Gap Computational Diffie-Hellman Assumption", "properties": {"description": "A computational assumption that states the difficulty of computing the Diffie-Hellman function even with access to a DDH oracle.", "keywords": ["gapcdh", "assumption", "diffiehellman", "cryptography"], "source_lectures": ["lecture_106106221_w7_l49"]}}
{"id": "concept_hybrid_public_key_encryption", "type": "V_concept", "name": "Hybrid Public-Key Encryption", "properties": {"description": "A public-key encryption scheme that combines a key encapsulation mechanism with a symmetric-key encryption scheme.", "keywords": ["hybrid", "publickey", "encryption", "cryptography"], "source_lectures": ["lecture_106106221_w7_l49"]}}
{"id": "concept_dhies", "type": "V_concept", "name": "DHIES", "properties": {"description": "A hybrid public-key encryption scheme based on the Diffie-Hellman key exchange and a symmetric-key encryption scheme.", "keywords": ["dhies", "hybrid", "publickey", "encryption", "cryptography"], "source_lectures": ["lecture_106106221_w7_l49"]}}
{"id": "concept_ecies", "type": "V_concept", "name": "ECIES", "properties": {"description": "A hybrid public-key encryption scheme based on the elliptic curve Diffie-Hellman key exchange and a symmetric-key encryption scheme.", "keywords": ["ecies", "hybrid", "publickey", "encryption", "cryptography"], "source_lectures": ["lecture_106106221_w7_l49"]}}
{"id": "concept_bleichenbachers_attack", "type": "V_concept", "name": "Bleichenbacher's Attack", "properties": {"description": "A side-channel attack on the RSA encryption scheme with PKCS#1 v1.5 padding, which exploits the malleability of the scheme to recover the plaintext.", "keywords": ["bleichenbacher", "attack", "rsa", "pkcs"], "source_lectures": ["lecture_106106221_w8_l50"]}}
{"id": "concept_oaep_padding", "type": "V_concept", "name": "Oaep Padding", "properties": {"description": "A padding scheme used in public-key encryption schemes, such as RSA-OAEP, to ensure the security of the scheme against chosen-ciphertext attacks.", "keywords": ["oaep", "padding", "cryptography", "security"], "source_lectures": ["lecture_106106221_w8_l50"]}}
{"id": "concept_rsa_oaep", "type": "V_concept", "name": "Rsa-Oaep", "properties": {"description": "A public-key encryption scheme based on the RSA algorithm and OAEP padding, which provides security against chosen-ciphertext attacks.", "keywords": ["rsa-oaep", "cryptography", "public-key", "security"], "source_lectures": ["lecture_106106221_w8_l50"]}}
{"id": "concept_digital_signatures", "type": "V_concept", "name": "Digital Signatures", "properties": {"description": "A cryptographic primitive that verifies the authenticity of a digital document or message.", "keywords": ["digital", "cryptography", "signatures", "authentication"], "source_lectures": ["lecture_106106221_w8_l51", "lecture_106106221_w8_l52"]}}
{"id": "concept_hash_and_sign_paradigm", "type": "V_concept", "name": "Hash And Sign Paradigm", "properties": {"description": "A method that combines a collision-resistant hash function with a digital signature scheme to sign arbitrary-length messages.", "keywords": ["sign", "paradigm", "hash", "cryptography", "and"], "source_lectures": ["lecture_106106221_w8_l51", "lecture_106106221_w8_l52"]}}
{"id": "concept_digital_certificates", "type": "V_concept", "name": "Digital Certificates", "properties": {"description": "A digitally signed document that verifies the identity of an entity and its public key.", "keywords": ["digital", "certificates", "public", "key"], "source_lectures": ["lecture_106106221_w8_l51"]}}
{"id": "concept_signcryption", "type": "V_concept", "name": "Signcryption", "properties": {"description": "A cryptographic primitive that combines digital signatures and public-key encryption to achieve authenticated encryption.", "keywords": ["signcryption", "cryptography", "encryption", "signatures"], "source_lectures": ["lecture_106106221_w8_l51"]}}
{"id": "concept_certificate_authority", "type": "V_concept", "name": "Certificate Authority", "properties": {"description": "A trusted entity that issues digital certificates and verifies the identity of entities.", "keywords": ["certificate", "authority", "trusted", "entity", "identity", "verification", "digital"], "source_lectures": ["lecture_106106221_w8_l51", "lecture_106106221_w8_l54"]}}
{"id": "concept_collision_resistant_hash_function", "type": "V_concept", "name": "Collision-Resistant Hash Function", "properties": {"description": "A hash function that makes it computationally infeasible to find two different inputs with the same output hash value.", "keywords": ["collision", "resistant", "hash", "function"], "source_lectures": ["lecture_106106221_w8_l51"]}}
{"id": "concept_unforgeability", "type": "V_concept", "name": "Unforgeability", "properties": {"description": "A security property that ensures it is computationally infeasible for an adversary to create a valid digital signature without knowing the signing key.", "keywords": ["unforgeability", "security", "digital", "signatures"], "source_lectures": ["lecture_106106221_w8_l51"]}}
{"id": "concept_signature_scheme", "type": "V_concept", "name": "Signature Scheme", "properties": {"description": "A cryptographic system that consists of a key generation algorithm, a signing algorithm, and a verification algorithm.", "keywords": ["signature", "scheme", "cryptography", "digital", "signatures"], "source_lectures": ["lecture_106106221_w8_l51"]}}
{"id": "concept_rsa_function", "type": "V_concept", "name": "RSA Function", "properties": {"description": "A one-way trapdoor permutation used for encryption and digital signatures.", "keywords": ["rsa", "function", "trapdoor", "permutation"], "source_lectures": ["lecture_106106221_w8_l52"]}}
{"id": "concept_plain_rsa_signatures", "type": "V_concept", "name": "Plain RSA Signatures", "properties": {"description": "A digital signature scheme based on the RSA function, where the signing key is used to compute the signature.", "keywords": ["plain", "rsa", "signatures", "insecure"], "source_lectures": ["lecture_106106221_w8_l52"]}}
{"id": "concept_no_message_attack", "type": "V_concept", "name": "No Message Attack", "properties": {"description": "A type of attack on a digital signature scheme where the adversary forges a signature without knowing the corresponding message.", "keywords": ["no", "message", "attack", "forgery"], "source_lectures": ["lecture_106106221_w8_l52"]}}
{"id": "concept_signature_forgery_experiment", "type": "V_concept", "name": "Signature Forgery Experiment", "properties": {"description": "A security experiment that tests the ability of an adversary to forge a valid signature.", "keywords": ["signature", "forgery", "experiment", "security"], "source_lectures": ["lecture_106106221_w8_l52"]}}
{"id": "concept_rsa_full_domain_hash", "type": "V_concept", "name": "RSA Full Domain Hash", "properties": {"description": "A secure digital signature scheme based on the RSA function, which uses a hash function to transform the message before signing.", "keywords": ["rsa", "full", "domain", "hash", "secure"], "source_lectures": ["lecture_106106221_w8_l52"]}}
{"id": "concept_one_wayness_property", "type": "V_concept", "name": "One-Wayness Property", "properties": {"description": "A security property of a function that makes it computationally difficult to find an input that produces a given output.", "keywords": ["one-wayness", "property", "function", "security"], "source_lectures": ["lecture_106106221_w8_l52"]}}
{"id": "concept_identification_scheme", "type": "V_concept", "name": "Identification Scheme", "properties": {"description": "A cryptographic protocol allowing a prover to convince a verifier of its identity without revealing secret credentials.", "keywords": ["identification", "scheme", "cryptographic", "prover", "verifier"], "source_lectures": ["lecture_106106221_w8_l53"]}}
{"id": "concept_schnorr_identification_scheme", "type": "V_concept", "name": "Schnorr Identification Scheme", "properties": {"description": "A three-round identification scheme based on the discrete logarithm problem, where the prover proves knowledge of a discrete log without revealing it.", "keywords": ["schnorr", "identification", "discrete", "logarithm", "three-round"], "source_lectures": ["lecture_106106221_w8_l53"]}}
{"id": "concept_commit_challenge_response_protocol", "type": "V_concept", "name": "Commit-Challenge-Response Protocol", "properties": {"description": "A three-round interactive protocol where the prover commits to a value, the verifier sends a random challenge, and the prover responds with a computed value.", "keywords": ["commit", "challenge", "response", "protocol", "interactive"], "source_lectures": ["lecture_106106221_w8_l53"]}}
{"id": "concept_verification_key", "type": "V_concept", "name": "Verification Key", "properties": {"description": "A public key component in a cryptographic scheme that allows a verifier to check the validity of a prover's identity claim.", "keywords": ["verification", "key", "public", "cryptographic", "verifier"], "source_lectures": ["lecture_106106221_w8_l53"]}}
{"id": "concept_secret_key", "type": "V_concept", "name": "Secret Key", "properties": {"description": "A private key component known only to the prover, used to generate valid responses in an identification scheme.", "keywords": ["secret", "key", "private", "prover", "cryptographic"], "source_lectures": ["lecture_106106221_w8_l53"]}}
{"id": "concept_commitment_in_identification_scheme", "type": "V_concept", "name": "Commitment in Identification Scheme", "properties": {"description": "The first message sent by the prover in a three-round identification protocol, typically a group element derived from a random value and the group generator.", "keywords": ["commitment", "identification", "prover", "group", "element"], "source_lectures": ["lecture_106106221_w8_l53"]}}
{"id": "concept_challenge_in_identification_scheme", "type": "V_concept", "name": "Challenge in Identification Scheme", "properties": {"description": "A randomly selected value sent by the verifier to the prover in the second round of a three-round identification protocol to test knowledge of the secret.", "keywords": ["challenge", "identification", "verifier", "random", "proof"], "source_lectures": ["lecture_106106221_w8_l53"]}}
{"id": "concept_response_in_identification_scheme", "type": "V_concept", "name": "Response in Identification Scheme", "properties": {"description": "The value computed by the prover in the third round using the secret key, challenge, and commitment, to prove knowledge of the secret without revealing it.", "keywords": ["response", "identification", "prover", "secret", "challenge"], "source_lectures": ["lecture_106106221_w8_l53"]}}
{"id": "concept_security_property", "type": "V_concept", "name": "Security Property", "properties": {"description": "A requirement that no polynomial-time adversary, even after observing multiple transcripts, can forge a valid accepting transcript without the secret key.", "keywords": ["security", "property", "identification", "adversary", "forge"], "source_lectures": ["lecture_106106221_w8_l53"]}}
{"id": "concept_identification_experiment", "type": "V_concept", "name": "Identification Experiment", "properties": {"description": "A formal security game where an adversary tries to forge a valid transcript against a challenger that simulates honest prover-verifier interactions.", "keywords": ["identification", "experiment", "security", "game", "adversary"], "source_lectures": ["lecture_106106221_w8_l53"]}}
{"id": "concept_transcript_oracle", "type": "V_concept", "name": "Transcript Oracle", "properties": {"description": "An oracle provided to an adversary in the identification experiment that returns random, valid transcripts generated by an honest prover-verifier pair.", "keywords": ["transcript", "oracle", "identification", "experiment", "adversary"], "source_lectures": ["lecture_106106221_w8_l53"]}}
{"id": "concept_accepting_transcript", "type": "V_concept", "name": "Accepting Transcript", "properties": {"description": "A triple (I, r, s) that satisfies the verification equation gs * y^(-r) = I in the Schnorr identification scheme, indicating a successful proof.", "keywords": ["accepting", "transcript", "schnorr", "verification", "equation"], "source_lectures": ["lecture_106106221_w8_l53"]}}
{"id": "concept_zero_knowledge_property", "type": "V_concept", "name": "Zero-Knowledge Property", "properties": {"description": "A property ensuring that an eavesdropper learns nothing about the secret key from observing valid transcripts in an identification scheme.", "keywords": ["eavesdropper", "security", "identification", "secret", "property", "zero-knowledge", "proof", "verifier"], "source_lectures": ["lecture_106106221_w8_l53", "lecture_106106221_w9_l57"]}}
{"id": "concept_simulated_transcript", "type": "V_concept", "name": "Simulated Transcript", "properties": {"description": "A forged transcript generated by an adversary without observing any real interaction, using only the public verification key and random values.", "keywords": ["simulated", "transcript", "adversary", "identification", "forge"], "source_lectures": ["lecture_106106221_w8_l53"]}}
{"id": "concept_rewinding_technique", "type": "V_concept", "name": "Rewinding Technique", "properties": {"description": "A method in cryptographic proofs where an adversary is forced to replay its commitment and respond to a different challenge to extract secret information.", "keywords": ["rewinding", "technique", "proof", "adversary", "challenge"], "source_lectures": ["lecture_106106221_w8_l53"]}}
{"id": "concept_security_reduction", "type": "V_concept", "name": "Security Reduction", "properties": {"description": "A proof technique showing that breaking a cryptographic scheme implies solving a known hard problem, such as the discrete logarithm problem.", "keywords": ["security", "reduction", "proof", "cryptographic", "hardness"], "source_lectures": ["lecture_106106221_w8_l53"]}}
{"id": "concept_group_generator", "type": "V_concept", "name": "Group Generator", "properties": {"description": "An element of a cyclic group such that every group element can be expressed as a power of this element under the group operation.", "keywords": ["generator", "group", "cyclic", "element", "operation"], "source_lectures": ["lecture_106106221_w8_l53"]}}
{"id": "concept_challenge_space", "type": "V_concept", "name": "Challenge Space", "properties": {"description": "The finite set from which the verifier randomly selects the challenge in an identification scheme, typically Zq for a prime q.", "keywords": ["challenge", "space", "identification", "random", "zq"], "source_lectures": ["lecture_106106221_w8_l53"]}}
{"id": "concept_fiat_shamir_heuristic", "type": "V_concept", "name": "Fiat-Shamir Heuristic", "properties": {"description": "A technique to convert an interactive identification scheme into a non-interactive digital signature scheme by replacing the verifier's challenge with a hash of the commitment.", "keywords": ["signature", "heuristic", "identification", "non-interactive", "fiat-shamir", "hash"], "source_lectures": ["lecture_106106221_w8_l53", "lecture_106106221_w8_l54"]}}
{"id": "concept_verification_algorithm", "type": "V_concept", "name": "Verification Algorithm", "properties": {"description": "The deterministic algorithm run by the verifier to check whether a response s and challenge r correspond correctly to a commitment I under the verification key.", "keywords": ["verification", "algorithm", "verifier", "identification", "check"], "source_lectures": ["lecture_106106221_w8_l53"]}}
{"id": "concept_prover_algorithm_p1", "type": "V_concept", "name": "Prover Algorithm P1", "properties": {"description": "The first algorithm used by the prover in an identification scheme to generate a commitment and internal state from the secret key.", "keywords": ["prover", "p1", "commitment", "algorithm", "secret"], "source_lectures": ["lecture_106106221_w8_l53"]}}
{"id": "concept_prover_algorithm_p2", "type": "V_concept", "name": "Prover Algorithm P2", "properties": {"description": "The second algorithm used by the prover in an identification scheme to compute a response using the secret key, state, and challenge.", "keywords": ["prover", "p2", "response", "algorithm", "secret"], "source_lectures": ["lecture_106106221_w8_l53"]}}
{"id": "concept_public_key_setting", "type": "V_concept", "name": "Public Key Setting", "properties": {"description": "A cryptographic model where the verifier holds a public verification key and the prover holds a corresponding private secret key.", "keywords": ["public", "key", "setting", "cryptographic", "prover"], "source_lectures": ["lecture_106106221_w8_l53"]}}
{"id": "concept_schnorr_signature_scheme", "type": "V_concept", "name": "Schnorr Signature Scheme", "properties": {"description": "A digital signature scheme based on the discrete logarithm problem, using the Fiat-Shamir heuristic.", "keywords": ["schnorr", "signature", "discrete", "logarithm", "fiat-shamir"], "source_lectures": ["lecture_106106221_w8_l54"]}}
{"id": "concept_digital_signature_algorithm_dsa", "type": "V_concept", "name": "Digital Signature Algorithm (DSA)", "properties": {"description": "A digital signature scheme based on the discrete logarithm problem, developed by NIST.", "keywords": ["dsa", "digital", "signature", "discrete", "logarithm"], "source_lectures": ["lecture_106106221_w8_l54"]}}
{"id": "concept_elliptic_curve_digital_signature_algorithm_ecdsa", "type": "V_concept", "name": "Elliptic Curve Digital Signature Algorithm (ECDSA)", "properties": {"description": "A variant of the DSA digital signature scheme that uses elliptic curve cryptography.", "keywords": ["ecdsa", "elliptic", "curve", "digital", "signature"], "source_lectures": ["lecture_106106221_w8_l54"]}}
{"id": "concept_ssltls_protocol", "type": "V_concept", "name": "SSL/TLS Protocol", "properties": {"description": "A cryptographic protocol that provides secure communication over the internet, using public-key cryptography and symmetric encryption.", "keywords": ["ssl", "tls", "protocol", "secure", "communication"], "source_lectures": ["lecture_106106221_w8_l54"]}}
{"id": "concept_congruence_modulo_n", "type": "V_concept", "name": "Congruence Modulo N", "properties": {"description": "A relation between two integers that have the same remainder when divided by a modulus N.", "keywords": ["congruence", "modulus", "remainder", "equivalence"], "source_lectures": ["lecture_106106221_w8_l55"]}}
{"id": "concept_square_and_multiply_method", "type": "V_concept", "name": "Square And Multiply Method", "properties": {"description": "An efficient algorithm for computing modular exponentiation.", "keywords": ["square", "multiply", "modular", "exponentiation", "algorithm"], "source_lectures": ["lecture_106106221_w8_l55"]}}
{"id": "concept_prime_number", "type": "V_concept", "name": "Prime Number", "properties": {"description": "A positive integer greater than 1 that has no positive divisors other than 1 and itself.", "keywords": ["integer", "prime", "divisor", "number", "divisibility", "number theory"], "source_lectures": ["lecture_106106221_w8_l55", "lecture_106104233_w4_l28"]}}
{"id": "concept_fundamental_theorem_of_arithmetic", "type": "V_concept", "name": "Fundamental Theorem Of Arithmetic", "properties": {"description": "A theorem stating that every positive integer can be expressed as a product of prime numbers in a unique way.", "keywords": ["fundamental", "theorem", "arithmetic", "prime", "factorization"], "source_lectures": ["lecture_106106221_w8_l55"]}}
{"id": "concept_primality_testing", "type": "V_concept", "name": "Primality Testing", "properties": {"description": "The process of determining whether a given number is prime or composite.", "keywords": ["prime", "number", "testing", "problem", "algorithm", "primality", "composite"], "source_lectures": ["lecture_106106221_w8_l55", "lecture_106104357_w6_l37"]}}
{"id": "concept_miller_rabin_primality_test", "type": "V_concept", "name": "Miller-Rabin Primality Test", "properties": {"description": "A probabilistic algorithm for testing whether a given number is prime or composite.", "keywords": ["miller-rabin", "primality", "test", "probabilistic", "algorithm"], "source_lectures": ["lecture_106106221_w8_l55"]}}
{"id": "concept_euclids_gcd_algorithm", "type": "V_concept", "name": "Euclid's GCD Algorithm", "properties": {"description": "An efficient algorithm for computing the greatest common divisor of two integers.", "keywords": ["euclid", "gcd", "algorithm", "integer", "division"], "source_lectures": ["lecture_106106221_w8_l55"]}}
{"id": "concept_extended_euclids_algorithm", "type": "V_concept", "name": "Extended Euclid's Algorithm", "properties": {"description": "An extension of Euclid's algorithm that also computes the coefficients of B\u00e9zout's identity.", "keywords": ["extended", "euclid", "algorithm", "bezout", "identity"], "source_lectures": ["lecture_106106221_w8_l55"]}}
{"id": "concept_b\u00e9zouts_identity", "type": "V_concept", "name": "B\u00e9zout's Identity", "properties": {"description": "A mathematical statement that expresses the greatest common divisor of two integers as a linear combination of the two integers.", "keywords": ["bezout", "identity", "gcd", "linear", "combination"], "source_lectures": ["lecture_106106221_w8_l55"]}}
{"id": "concept_shamirs_secret_sharing", "type": "V_concept", "name": "Shamir's Secret Sharing", "properties": {"description": "A type of secret sharing scheme that uses polynomial equations to distribute the secret among parties.", "keywords": ["shamir", "secret", "sharing", "cryptography", "polynomial"], "source_lectures": ["lecture_106106221_w8_l56"]}}
{"id": "concept_cryptographic_protocol", "type": "V_concept", "name": "Cryptographic Protocol", "properties": {"description": "A set of rules and procedures for secure communication, often using cryptography and secret sharing.", "keywords": ["cryptographic", "protocol", "cryptography", "security"], "source_lectures": ["lecture_106106221_w8_l56"]}}
{"id": "concept_graph_isomorphism_problem", "type": "V_concept", "name": "Graph Isomorphism Problem", "properties": {"description": "A computational problem that involves determining whether two given graphs are isomorphic, meaning they have the same structure.", "keywords": ["graph", "theory", "computational", "complexity", "problem", "isomorphism"], "source_lectures": ["lecture_106106221_w9_l57", "lecture_106106221_w9_l58"]}}
{"id": "concept_completeness_property", "type": "V_concept", "name": "Completeness Property", "properties": {"description": "A property of a zero-knowledge proof system that ensures the verifier will accept the proof if the prover is honest and the statement is true.", "keywords": ["completeness", "property", "zero-knowledge", "proof", "verifier"], "source_lectures": ["lecture_106106221_w9_l57"]}}
{"id": "concept_soundness_property", "type": "V_concept", "name": "Soundness Property", "properties": {"description": "A property of a zero-knowledge proof system that ensures the verifier will reject the proof if the prover is dishonest or the statement is false.", "keywords": ["soundness", "property", "zero-knowledge", "proof", "verifier"], "source_lectures": ["lecture_106106221_w9_l57"]}}
{"id": "concept_rsa_public_key_cryptosystem", "type": "V_concept", "name": "RSA Public-Key Cryptosystem", "properties": {"description": "A cryptographic system that uses a pair of keys, one public and one private, to encrypt and decrypt messages.", "keywords": ["rsa", "public-key", "cryptosystem", "encryption", "decryption"], "source_lectures": ["lecture_106106221_w9_l57"]}}
{"id": "concept_witness", "type": "V_concept", "name": "Witness", "properties": {"description": "A piece of information that proves the validity of a statement in a zero-knowledge proof system.", "keywords": ["witness", "proof", "statement", "validity", "information"], "source_lectures": ["lecture_106106221_w9_l57"]}}
{"id": "concept_bijection", "type": "V_concept", "name": "Bijection", "properties": {"description": "A mathematical function that maps one set to another in a one-to-one correspondence.", "keywords": ["bijection", "function", "set", "one-to-one", "correspondence"], "source_lectures": ["lecture_106106221_w9_l57"]}}
{"id": "concept_interactive_protocol", "type": "V_concept", "name": "Interactive Protocol", "properties": {"description": "A communication protocol that involves multiple rounds of interaction between two or more parties.", "keywords": ["interactive", "protocol", "communication", "rounds", "parties"], "source_lectures": ["lecture_106106221_w9_l57"]}}
{"id": "concept_poly_time_algorithm", "type": "V_concept", "name": "Poly-Time Algorithm", "properties": {"description": "An algorithm that runs in polynomial time, meaning its running time grows at most polynomially with the size of the input.", "keywords": ["poly-time", "algorithm", "polynomial", "time", "complexity"], "source_lectures": ["lecture_106106221_w9_l57"]}}
{"id": "concept_zero_knowledge_protocol", "type": "V_concept", "name": "Zero-Knowledge Protocol", "properties": {"description": "A cryptographic protocol that enables one party to prove the truth of a statement to another party without revealing any information beyond the validity of the statement.", "keywords": ["zero", "knowledge", "protocol", "cryptography", "proof"], "source_lectures": ["lecture_106106221_w9_l58"]}}
{"id": "concept_np_complete_problem", "type": "V_concept", "name": "NP-Complete Problem", "properties": {"description": "A problem that is at least as hard as the hardest problems in the class NP, where NP is the set of decision problems that can be solved in polynomial time by a non-deterministic Turing machine.", "keywords": ["np", "complete", "problem", "complexity", "theory"], "source_lectures": ["lecture_106106221_w9_l58"]}}
{"id": "concept_3_coloring_problem", "type": "V_concept", "name": "3-Coloring Problem", "properties": {"description": "A problem of determining whether a given graph can be colored with three colors such that no two adjacent vertices have the same color.", "keywords": ["3", "coloring", "problem", "graph", "theory"], "source_lectures": ["lecture_106106221_w9_l58"]}}
{"id": "concept_zero_knowledge_proof_system", "type": "V_concept", "name": "Zero-Knowledge Proof System", "properties": {"description": "A system that enables a prover to convince a verifier of the truth of a statement without revealing any underlying information.", "keywords": ["zero", "knowledge", "proof", "system", "cryptography"], "source_lectures": ["lecture_106106221_w9_l58"]}}
{"id": "concept_passively_secure_protocol", "type": "V_concept", "name": "Passively Secure Protocol", "properties": {"description": "A protocol that is secure against a passive adversary, who can only observe the communication between parties but not modify it.", "keywords": ["passively", "secure", "protocol", "cryptography", "security"], "source_lectures": ["lecture_106106221_w9_l58"]}}
{"id": "concept_maliciously_secure_protocol", "type": "V_concept", "name": "Maliciously Secure Protocol", "properties": {"description": "A protocol that is secure against a malicious adversary, who can modify the communication between parties and try to cheat.", "keywords": ["maliciously", "secure", "protocol", "cryptography", "security"], "source_lectures": ["lecture_106106221_w9_l58"]}}
{"id": "concept_compiler_for_secure_protocols", "type": "V_concept", "name": "Compiler for Secure Protocols", "properties": {"description": "A method for transforming a passively secure protocol into a maliciously secure protocol using zero-knowledge proof systems.", "keywords": ["compiler", "secure", "protocols", "cryptography", "security"], "source_lectures": ["lecture_106106221_w9_l58"]}}
{"id": "concept_number_theoretic_hard_problems", "type": "V_concept", "name": "Number Theoretic Hard Problems", "properties": {"description": "Mathematical problems that are difficult to solve, often used as the basis for cryptographic algorithms.", "keywords": ["number", "theoretic", "hard", "problems", "cryptography"], "source_lectures": ["lecture_106106221_w9_l59"]}}
{"id": "concept_private_key_cryptography", "type": "V_concept", "name": "Private Key Cryptography", "properties": {"description": "A method of encrypting data using a single secret key, shared between the sender and receiver.", "keywords": ["private", "key", "cryptography", "encryption", "security"], "source_lectures": ["lecture_106106221_w9_l59"]}}
{"id": "concept_passive_adversarial_model", "type": "V_concept", "name": "Passive Adversarial Model", "properties": {"description": "A model of an attacker who only observes the communication between two parties, without modifying or injecting data.", "keywords": ["passive", "adversarial", "model", "cryptography", "security"], "source_lectures": ["lecture_106106221_w9_l59"]}}
{"id": "concept_leakage_resilient_cryptography", "type": "V_concept", "name": "Leakage Resilient Cryptography", "properties": {"description": "A branch of cryptography that deals with the design of cryptographic primitives that are resistant to side-channel attacks.", "keywords": ["leakage", "resilient", "cryptography", "security", "side-channel"], "source_lectures": ["lecture_106106221_w9_l59"]}}
{"id": "concept_lightweight_cryptography", "type": "V_concept", "name": "Lightweight Cryptography", "properties": {"description": "A branch of cryptography that deals with the design of cryptographic primitives for resource-constrained environments.", "keywords": ["lightweight", "cryptography", "security", "resource-constrained", "iot"], "source_lectures": ["lecture_106106221_w9_l59"]}}
{"id": "concept_computer_security", "type": "V_concept", "name": "Computer Security", "properties": {"description": "The practice of protecting computer systems and networks from unauthorized access, use, disclosure, disruption, modification, or destruction.", "keywords": ["security", "computer", "network", "protection"], "source_lectures": ["lecture_106106221_w9_l60"]}}
{"id": "concept_random_number_generator", "type": "V_concept", "name": "Random Number Generator", "properties": {"description": "A device or algorithm that generates a sequence of numbers that lack any pattern or predictability.", "keywords": ["generator", "number", "sequence", "random", "algorithm", "pattern"], "source_lectures": ["lecture_106106221_w9_l60", "lecture_108102169_w5_l32"]}}
{"id": "concept_secure_construction", "type": "V_concept", "name": "Secure Construction", "properties": {"description": "The process of designing and building secure systems, including computer systems and networks.", "keywords": ["secure", "construction", "system", "network"], "source_lectures": ["lecture_106106221_w9_l60"]}}
{"id": "concept_verification", "type": "V_concept", "name": "Verification", "properties": {"description": "The process of checking or proving the correctness of a system, algorithm, or data.", "keywords": ["verification", "correctness", "system", "algorithm"], "source_lectures": ["lecture_106106221_w9_l60"]}}
{"id": "concept_security_scheme", "type": "V_concept", "name": "Security Scheme", "properties": {"description": "A plan or system for protecting computer systems and networks from unauthorized access or malicious activity.", "keywords": ["security", "scheme", "plan", "protection"], "source_lectures": ["lecture_106106221_w9_l60"]}}
{"id": "concept_third_party_verification", "type": "V_concept", "name": "Third-Party Verification", "properties": {"description": "The process of verifying the identity or authenticity of a system, algorithm, or data by a third-party entity.", "keywords": ["third-party", "verification", "identity", "authenticity"], "source_lectures": ["lecture_106106221_w9_l60"]}}
{"id": "concept_secure_protocol", "type": "V_concept", "name": "Secure Protocol", "properties": {"description": "A set of rules and procedures for secure communication between computer systems and networks.", "keywords": ["secure", "protocol", "communication", "network"], "source_lectures": ["lecture_106106221_w9_l60"]}}
{"id": "concept_polynomial_running_time", "type": "V_concept", "name": "Polynomial Running Time", "properties": {"description": "An algorithm's running time that grows polynomially with the size of the input.", "keywords": ["polynomial", "running", "time", "algorithm"], "source_lectures": ["lecture_106106221_w9_l62"]}}
{"id": "concept_indistinguishability_notion", "type": "V_concept", "name": "Indistinguishability Notion", "properties": {"description": "A concept in cryptography that refers to the inability of an adversary to distinguish between two distributions or sequences.", "keywords": ["indistinguishability", "notion", "cryptography", "security"], "source_lectures": ["lecture_106106221_w9_l62"]}}
{"id": "concept_cryptographic_engineering", "type": "V_concept", "name": "Cryptographic Engineering", "properties": {"description": "The practice of designing and implementing secure cryptographic systems and protocols.", "keywords": ["cryptographic", "engineering", "security", "cryptography"], "source_lectures": ["lecture_106106221_w9_l62"]}}
{"id": "concept_induction_proof", "type": "V_concept", "name": "Induction Proof", "properties": {"description": "A method of proof that involves showing a statement is true for a base case and then showing it is true for all subsequent cases.", "keywords": ["induction", "proof", "base", "case"], "source_lectures": ["lecture_106101360_w2_l10"]}}
{"id": "concept_ki_operator", "type": "V_concept", "name": "Ki Operator", "properties": {"description": "A mathematical operator that represents the knowledge of a player about an event.", "keywords": ["ki", "operator", "knowledge", "event"], "source_lectures": ["lecture_106101360_w2_l10"]}}
{"id": "concept_fi_partition", "type": "V_concept", "name": "Fi Partition", "properties": {"description": "A partition of a set of states, used to represent a player's knowledge in a game.", "keywords": ["fi", "partition", "set", "state"], "source_lectures": ["lecture_106101360_w2_l10"]}}
{"id": "concept_mixed_strategy_saddle_point", "type": "V_concept", "name": "Mixed Strategy Saddle Point", "properties": {"description": "A pair of mixed strategies for two players in a zero-sum game where neither player can improve their expected payoff by unilaterally changing their strategy.", "keywords": ["mixed strategy", "saddle point", "zero-sum game", "nash equilibrium", "minimax"], "source_lectures": ["lecture_106101360_w4_l21"]}}
{"id": "concept_row_players_security_strategy", "type": "V_concept", "name": "Row Player's Security Strategy", "properties": {"description": "The mixed strategy for the row player that minimizes the maximum expected loss, ensuring the best guaranteed outcome against any column player strategy.", "keywords": ["security strategy", "row player", "minimax", "zero-sum game", "mixed strategy"], "source_lectures": ["lecture_106101360_w4_l21"]}}
{"id": "concept_column_players_security_strategy", "type": "V_concept", "name": "Column Player's Security Strategy", "properties": {"description": "The mixed strategy for the column player that maximizes the minimum expected gain, ensuring the best guaranteed outcome against any row player strategy.", "keywords": ["security strategy", "column player", "maximin", "zero-sum game", "mixed strategy"], "source_lectures": ["lecture_106101360_w4_l21"]}}
{"id": "concept_expected_payoff_in_mixed_strategies", "type": "V_concept", "name": "Expected Payoff in Mixed Strategies", "properties": {"description": "The weighted average payoff for a player when both players use mixed strategies, calculated as the dot product of strategy vectors and the payoff matrix.", "keywords": ["expected payoff", "mixed strategy", "dot product", "payoff matrix", "zero-sum"], "source_lectures": ["lecture_106101360_w4_l21"]}}
{"id": "concept_upper_envelope_max_over_strategies", "type": "V_concept", "name": "Upper Envelope (Max over Strategies)", "properties": {"description": "The piecewise linear function formed by taking the maximum expected payoff across all pure strategies of the opponent, used to find the minimax strategy.", "keywords": ["upper envelope", "max over strategies", "minimax", "mixed strategy", "graphical method"], "source_lectures": ["lecture_106101360_w4_l21"]}}
{"id": "concept_lower_envelope_min_over_strategies", "type": "V_concept", "name": "Lower Envelope (Min over Strategies)", "properties": {"description": "The piecewise linear function formed by taking the minimum expected payoff across all pure strategies of the player, used to find the maximin strategy.", "keywords": ["lower envelope", "min over strategies", "maximin", "mixed strategy", "graphical method"], "source_lectures": ["lecture_106101360_w4_l21"]}}
{"id": "concept_2x2_zero_sum_game", "type": "V_concept", "name": "2x2 Zero-Sum Game", "properties": {"description": "A zero-sum game where each player has exactly two pure strategies, allowing graphical or algebraic solution for mixed strategy equilibria.", "keywords": ["2x2 game", "zero-sum", "mixed strategy", "payoff matrix", "two-player"], "source_lectures": ["lecture_106101360_w4_l21"]}}
{"id": "concept_strategy_probability_constraint", "type": "V_concept", "name": "Strategy Probability Constraint", "properties": {"description": "The requirement that the probabilities of all pure strategies for a player sum to one, ensuring a valid mixed strategy.", "keywords": ["probability constraint", "mixed strategy", "sum to one", "probability distribution", "strategy weights"], "source_lectures": ["lecture_106101360_w4_l21"]}}
{"id": "concept_value_of_the_game", "type": "V_concept", "name": "Value of the Game", "properties": {"description": "The expected payoff when both players use their optimal mixed strategies in a zero-sum game, equal to both the minimax and maximin values.", "keywords": ["value of game", "minimax value", "maximin value", "zero-sum game", "saddle point value"], "source_lectures": ["lecture_106101360_w4_l21"]}}
{"id": "concept_graphical_method_for_mixed_strategies", "type": "V_concept", "name": "Graphical Method for Mixed Strategies", "properties": {"description": "A visual technique to solve 2x2 zero-sum games by plotting expected payoffs as functions of one player\u2019s strategy probability and identifying the minimax/maximin intersection.", "keywords": ["graphical method", "mixed strategy", "2x2 game", "minimax", "payoff plot"], "source_lectures": ["lecture_106101360_w4_l21"]}}
{"id": "concept_non_zero_sum_game", "type": "V_concept", "name": "Non-Zero Sum Game", "properties": {"description": "A game where the total payoff to all players is not constant, and players can cooperate or compete to achieve their goals.", "keywords": ["theory", "negative-sum", "sum", "non-zero-sum", "game theory", "non-zero", "game", "positive-sum", "cooperative potential", "cooperation"], "source_lectures": ["lecture_106101360_w5_l23", "lecture_106101360_w6_l32"]}}
{"id": "concept_set_valued_map", "type": "V_concept", "name": "Set-Valued Map", "properties": {"description": "A function that maps each point in a set to a subset of that set, used to model the best response correspondence in game theory.", "keywords": ["set-valued", "map", "function", "game", "theory"], "source_lectures": ["lecture_106101360_w5_l23"]}}
{"id": "concept_convex_valued", "type": "V_concept", "name": "Convex Valued", "properties": {"description": "A property of a set-valued map where the image of each point is a convex set, used in the Kakutani Fixed Point Theorem.", "keywords": ["convex", "valued", "set-valued", "map", "mathematics"], "source_lectures": ["lecture_106101360_w5_l23"]}}
{"id": "concept_closed_graph", "type": "V_concept", "name": "Closed Graph", "properties": {"description": "A property of a set-valued map where the graph of the map is a closed set, used in the Kakutani Fixed Point Theorem.", "keywords": ["closed", "graph", "set-valued", "map", "mathematics"], "source_lectures": ["lecture_106101360_w5_l23"]}}
{"id": "concept_brouwers_fix_point_theorem", "type": "V_concept", "name": "Brouwer's Fix Point Theorem", "properties": {"description": "A mathematical theorem that states that every continuous function from a closed, convex, and bounded set to itself has a fixed point.", "keywords": ["fix", "continuous", "brouwer", "theorem", "point"], "source_lectures": ["lecture_106101360_w5_l26", "lecture_106101360_w5_l28"]}}
{"id": "concept_convex_optimization", "type": "V_concept", "name": "Convex Optimization", "properties": {"description": "A type of mathematical optimization problem where the objective function is convex and the constraint set is convex.", "keywords": ["convex", "optimization", "mathematical", "problem", "function"], "source_lectures": ["lecture_106101360_w5_l26"]}}
{"id": "concept_strictly_convex_function", "type": "V_concept", "name": "Strictly Convex Function", "properties": {"description": "A function that is convex and has no flat regions, meaning that the line segment connecting any two points on the graph of the function lies above the graph.", "keywords": ["strictly", "convex", "function", "mathematical", "optimization"], "source_lectures": ["lecture_106101360_w5_l26"]}}
{"id": "concept_kakutanis_fix_point_theorem", "type": "V_concept", "name": "Kakutani's Fix Point Theorem", "properties": {"description": "A mathematical theorem that states that every upper semi-continuous correspondence from a compact, convex set to itself has a fixed point.", "keywords": ["kakutani", "fix", "point", "theorem", "upper"], "source_lectures": ["lecture_106101360_w5_l26"]}}
{"id": "concept_pure_strategies", "type": "V_concept", "name": "Pure Strategies", "properties": {"description": "A specific action or decision made by a player in a game, as opposed to a mixed strategy which involves randomization.", "keywords": ["pure", "strategies", "game", "theory", "action"], "source_lectures": ["lecture_106101360_w5_l26"]}}
{"id": "concept_quantal_response_function", "type": "V_concept", "name": "Quantal Response Function", "properties": {"description": "A function that maps a vector of payoffs to a mixed strategy, satisfying certain properties such as continuous differentiability and responsiveness to utility changes.", "keywords": ["quantal", "response", "function", "mixed", "strategy"], "source_lectures": ["lecture_106101360_w5_l28"]}}
{"id": "concept_quantal_response_equilibrium", "type": "V_concept", "name": "Quantal Response Equilibrium", "properties": {"description": "A mixed strategy profile that is preserved under a quantal response operation, meaning that the response to the strategy is the strategy itself.", "keywords": ["quantal", "response", "equilibrium", "mixed", "strategy"], "source_lectures": ["lecture_106101360_w5_l28"]}}
{"id": "concept_exploration_exploitation_tradeoff", "type": "V_concept", "name": "Exploration-Exploitation Tradeoff", "properties": {"description": "A fundamental problem in decision-making and game theory, where players must balance exploring new strategies with exploiting known ones, relevant to quantal response modeling.", "keywords": ["exploration", "exploitation", "tradeoff", "decision", "game"], "source_lectures": ["lecture_106101360_w5_l28"]}}
{"id": "concept_strategic_intent", "type": "V_concept", "name": "Strategic Intent", "properties": {"description": "The idea that players in a game have a deliberate plan or goal, rather than just acting randomly or exploratorily, important for interpreting quantal response models.", "keywords": ["strategic", "intent", "plan", "goal", "game"], "source_lectures": ["lecture_106101360_w5_l28"]}}
{"id": "concept_simultaneous_move_game", "type": "V_concept", "name": "Simultaneous Move Game", "properties": {"description": "A type of game where all players make their moves at the same time, without knowing the actions of the other players.", "keywords": ["simultaneous", "theory", "no observation", "simultaneous move", "action", "player", "normal form", "decisions", "strategy", "strategic interaction", "game", "static game", "actions", "move", "decision"], "source_lectures": ["lecture_106101360_w6_l30", "lecture_106101360_w6_l31", "lecture_106101360_w6_l32", "lecture_106101360_w7_l36", "lecture_106101360_w8_l38", "lecture_106101360_w10_l50", "lecture_106101360_w9_l62"]}}
{"id": "concept_strategy_space", "type": "V_concept", "name": "Strategy Space", "properties": {"description": "The set of all possible strategies that a player can choose from in a game.", "keywords": ["strategy", "space", "game", "theory", "choice"], "source_lectures": ["lecture_106101360_w6_l30"]}}
{"id": "concept_action_space", "type": "V_concept", "name": "Action Space", "properties": {"description": "The set of all possible actions that a player can take in a game.", "keywords": ["action", "space", "game", "theory", "choice"], "source_lectures": ["lecture_106101360_w6_l30"]}}
{"id": "concept_unilateral_deviation", "type": "V_concept", "name": "Unilateral Deviation", "properties": {"description": "A situation where a player changes their strategy or action, while all other players keep their strategies or actions unchanged.", "keywords": ["theory", "deviation", "equilibrium", "strategy", "game", "unilateral"], "source_lectures": ["lecture_106101360_w6_l30", "lecture_106101360_w10_l51"]}}
{"id": "concept_subgame_perfection", "type": "V_concept", "name": "Subgame Perfection", "properties": {"description": "A refinement of the Nash equilibrium concept that requires the equilibrium to be robust to changes in the game's structure or parameters.", "keywords": ["subgame", "perfection", "nash", "equilibrium", "game"], "source_lectures": ["lecture_106101360_w6_l30"]}}
{"id": "concept_sequential_rationality", "type": "V_concept", "name": "Sequential Rationality", "properties": {"description": "The concept that players in a dynamic game make rational decisions at each stage of the game, taking into account the actions and strategies of other players.", "keywords": ["sequential", "rationality", "game", "theory", "decision"], "source_lectures": ["lecture_106101360_w6_l30"]}}
{"id": "concept_solution_concept", "type": "V_concept", "name": "Solution Concept", "properties": {"description": "A concept or criterion used to predict the outcome of a game, such as the Nash equilibrium or subgame perfection.", "keywords": ["theory", "prediction", "equilibrium", "solution", "concept", "game"], "source_lectures": ["lecture_106101360_w6_l30", "lecture_106101360_w11_l56"]}}
{"id": "concept_strategic_decision", "type": "V_concept", "name": "Strategic Decision", "properties": {"description": "A decision that takes into account the potential actions and reactions of other players or parties.", "keywords": ["strategic", "decision", "game", "theory", "action"], "source_lectures": ["lecture_106101360_w6_l31"]}}
{"id": "concept_information_flow", "type": "V_concept", "name": "Information Flow", "properties": {"description": "The transfer of information from one player to another, which can affect the decisions made by each player.", "keywords": ["information", "flow", "game", "theory", "decision"], "source_lectures": ["lecture_106101360_w6_l31"]}}
{"id": "concept_irrational_play", "type": "V_concept", "name": "Irrational Play", "properties": {"description": "A strategy that involves making decisions that are not based on rational considerations, such as ignoring available information.", "keywords": ["irrational", "play", "game", "theory", "strategy"], "source_lectures": ["lecture_106101360_w6_l31"]}}
{"id": "concept_backward_induction", "type": "V_concept", "name": "Backward Induction", "properties": {"description": "A method for solving dynamic games by reasoning backward from the end of the game to determine optimal actions at each node.", "keywords": ["backward", "theory", "solution concept", "induction", "backward induction", "dynamic programming", "strategy", "recursive reasoning", "information", "game", "subgame perfect"], "source_lectures": ["lecture_106101360_w6_l32", "lecture_106101360_w8_l38", "lecture_106101360_w8_l40"]}}
{"id": "concept_threat_equilibrium", "type": "V_concept", "name": "Threat Equilibrium", "properties": {"description": "A Nash equilibrium sustained by a player's non-credible threat to take an irrational action in a future node to influence prior decisions.", "keywords": ["threat equilibrium", "non-credible threat", "bluff", "commitment", "irrational threat"], "source_lectures": ["lecture_106101360_w6_l32"]}}
{"id": "concept_non_credible_threat", "type": "V_concept", "name": "Non-Credible Threat", "properties": {"description": "A promise to take an action that is not in the player\u2019s best interest when the time comes to execute it, making the threat implausible.", "keywords": ["non-credible threat", "bluff", "irrational action", "dynamic game", "commitment"], "source_lectures": ["lecture_106101360_w6_l32"]}}
{"id": "concept_common_knowledge_in_games", "type": "V_concept", "name": "Common Knowledge in Games", "properties": {"description": "A situation where all players know the game structure, payoffs, and rules, and know that all others know this as well, recursively.", "keywords": ["common knowledge", "game structure", "information", "rationality", "complete information"], "source_lectures": ["lecture_106101360_w6_l32"]}}
{"id": "concept_subgame_perfect_equilibrium", "type": "V_concept", "name": "Subgame Perfect Equilibrium", "properties": {"description": "A refinement of Nash equilibrium requiring that players' strategies constitute a Nash equilibrium in every subgame of the original game.", "keywords": ["subgame perfect equilibrium", "recursive rationality", "credible threat", "dynamic consistency", "backward induction"], "source_lectures": ["lecture_106101360_w6_l32"]}}
{"id": "concept_mutually_assured_destruction", "type": "V_concept", "name": "Mutually Assured Destruction", "properties": {"description": "A strategic doctrine where each side threatens catastrophic retaliation, deterring aggression through the promise of mutual ruin.", "keywords": ["mutually assured destruction", "nuclear deterrence", "credible threat", "game theory", "geopolitics"], "source_lectures": ["lecture_106101360_w6_l32"]}}
{"id": "concept_strategy_in_extensive_form_games", "type": "V_concept", "name": "Strategy in Extensive Form Games", "properties": {"description": "A complete plan of action specifying what a player will do at every information set they might encounter during the game.", "keywords": ["strategy", "extensive form", "complete plan", "decision rule", "game tree"], "source_lectures": ["lecture_106101360_w6_l32"]}}
{"id": "concept_information_set", "type": "V_concept", "name": "Information Set", "properties": {"description": "A set of decision nodes in an extensive-form game that a player cannot distinguish between when making a decision.", "keywords": ["theory", "tree", "imperfect information", "observation", "game tree", "nodes", "information set", "player", "node", "perfect information", "information", "game", "decision", "set"], "source_lectures": ["lecture_106101360_w6_l32", "lecture_106101360_w7_l36", "lecture_106101360_w8_l39", "lecture_106101360_w8_l42", "lecture_106101360_w9_l43", "lecture_106101360_w9_l44", "lecture_106101360_w9_l45", "lecture_106101360_w9_l46", "lecture_106101360_w10_l50", "lecture_106101360_w9_l62"]}}
{"id": "concept_payoff_structure", "type": "V_concept", "name": "Payoff Structure", "properties": {"description": "The mapping of strategy profiles to outcomes, specifying the utility or reward each player receives for every possible combination of actions.", "keywords": ["payoff", "utility", "outcome", "reward", "game matrix"], "source_lectures": ["lecture_106101360_w6_l32"]}}
{"id": "concept_commitment_in_game_theory", "type": "V_concept", "name": "Commitment in Game Theory", "properties": {"description": "A player\u2019s ability to bind themselves to a future action, even if it is not optimal at the time, to influence opponents\u2019 behavior.", "keywords": ["commitment", "binding promise", "credible threat", "strategic behavior", "pre-commitment"], "source_lectures": ["lecture_106101360_w6_l32"]}}
{"id": "concept_rationality_in_dynamic_games", "type": "V_concept", "name": "Rationality in Dynamic Games", "properties": {"description": "The assumption that players choose actions to maximize their expected payoffs, with rationality applied consistently across all decision points.", "keywords": ["rationality", "utility maximization", "decision-making", "game theory", "optimization"], "source_lectures": ["lecture_106101360_w6_l32"]}}
{"id": "concept_extensive_form_representation", "type": "V_concept", "name": "Extensive Form Representation", "properties": {"description": "A tree-based representation of a game showing the sequence of moves, information available at each node, and payoffs at terminal nodes.", "keywords": ["extensive form", "game tree", "decision tree", "sequential game", "nodes"], "source_lectures": ["lecture_106101360_w6_l32"]}}
{"id": "concept_credibility_of_threats", "type": "V_concept", "name": "Credibility of Threats", "properties": {"description": "The extent to which a player\u2019s threat to take a harmful action is believable based on their incentives at the time of execution.", "keywords": ["credibility", "threat", "credible threat", "non-credible threat", "incentive compatibility"], "source_lectures": ["lecture_106101360_w6_l32"]}}
{"id": "concept_fictitious_action", "type": "V_concept", "name": "Fictitious Action", "properties": {"description": "An artificial move added to a game tree to maintain consistency in strategy representation, with no real strategic consequence.", "keywords": ["fictitious action", "dummy move", "null action", "game tree", "strategy representation"], "source_lectures": ["lecture_106101360_w6_l32"]}}
{"id": "concept_bluff_in_game_theory", "type": "V_concept", "name": "Bluff in Game Theory", "properties": {"description": "A deceptive strategy where a player pretends to be willing to take an irrational action to influence an opponent\u2019s decision.", "keywords": ["bluff", "deception", "non-credible threat", "strategic signaling", "game theory"], "source_lectures": ["lecture_106101360_w6_l32"]}}
{"id": "concept_recursive_rationality", "type": "V_concept", "name": "Recursive Rationality", "properties": {"description": "The property of a strategy profile where each player\u2019s action is optimal at every decision node, given future rational play.", "keywords": ["dynamic consistency", "theory", "rational play", "rationality", "subgame perfection", "recursive rationality", "backward induction", "recursive", "game"], "source_lectures": ["lecture_106101360_w6_l32", "lecture_106101360_w8_l41"]}}
{"id": "concept_player_information_in_extensive_games", "type": "V_concept", "name": "Player Information in Extensive Games", "properties": {"description": "The knowledge a player has about the history of play and the current state of the game when making a decision.", "keywords": ["player information", "perfect information", "imperfect information", "information state", "game history"], "source_lectures": ["lecture_106101360_w6_l32"]}}
{"id": "concept_threat_as_strategic_tool", "type": "V_concept", "name": "Threat as Strategic Tool", "properties": {"description": "A player\u2019s declaration of intent to inflict harm on others to induce favorable behavior, even if the threat is not executed.", "keywords": ["threat", "strategic tool", "deterrence", "influence", "game theory"], "source_lectures": ["lecture_106101360_w6_l32"]}}
{"id": "concept_game_tree", "type": "V_concept", "name": "Game Tree", "properties": {"description": "A graphical representation of a dynamic game showing all possible sequences of moves, decision nodes, and payoffs.", "keywords": ["tree", "representation", "game tree", "nodes", "decision tree", "action", "graphical", "node", "extensive form", "sequence", "game", "branches"], "source_lectures": ["lecture_106101360_w6_l32", "lecture_106101360_w8_l39", "lecture_106101360_w9_l46", "lecture_106101360_w9_l62"]}}
{"id": "concept_optimal_response", "type": "V_concept", "name": "Optimal Response", "properties": {"description": "The action that maximizes a player\u2019s payoff given the strategies of other players.", "keywords": ["optimal response", "best response", "utility maximization", "strategy", "payoff"], "source_lectures": ["lecture_106101360_w6_l32"]}}
{"id": "concept_credible_commitment", "type": "V_concept", "name": "Credible Commitment", "properties": {"description": "A binding promise that a player makes to follow a certain strategy, making their threats or offers believable to others.", "keywords": ["credible commitment", "binding promise", "strategic commitment", "trust", "game theory"], "source_lectures": ["lecture_106101360_w6_l32"]}}
{"id": "concept_strategic_interaction", "type": "V_concept", "name": "Strategic Interaction", "properties": {"description": "The process by which players\u2019 decisions affect each other\u2019s outcomes, requiring anticipation of others\u2019 actions.", "keywords": ["strategic interaction", "game theory", "decision interdependence", "rational choice", "mutual influence"], "source_lectures": ["lecture_106101360_w6_l32"]}}
{"id": "concept_node_in_game_tree", "type": "V_concept", "name": "Node in Game Tree", "properties": {"description": "A point in the extensive form of a game where a player makes a decision or the game ends with a payoff.", "keywords": ["node", "decision point", "game tree", "terminal node", "information node"], "source_lectures": ["lecture_106101360_w6_l32"]}}
{"id": "concept_terminal_node", "type": "V_concept", "name": "Terminal Node", "properties": {"description": "A node in a game tree with no further moves, where payoffs are assigned to all players.", "keywords": ["terminal node", "end node", "payoff node", "game end", "leaf node"], "source_lectures": ["lecture_106101360_w6_l32"]}}
{"id": "concept_player_turn", "type": "V_concept", "name": "Player Turn", "properties": {"description": "The point in a dynamic game when a specific player is authorized to make a move.", "keywords": ["player turn", "move order", "turn-based", "sequential play", "decision timing"], "source_lectures": ["lecture_106101360_w6_l32"]}}
{"id": "concept_single_act_game", "type": "V_concept", "name": "Single Act Game", "properties": {"description": "A game where each player gets to act at most once.", "keywords": ["static", "single", "action", "player", "single-act", "one", "game", "act", "decision"], "source_lectures": ["lecture_106101360_w7_l36", "lecture_106101360_w8_l39", "lecture_106101360_w9_l43"]}}
{"id": "concept_extensive_form_game", "type": "V_concept", "name": "Extensive Form Game", "properties": {"description": "A game represented as a tree, where nodes are divided into player sets and information sets.", "keywords": ["extensive", "tree", "node", "sequential", "form", "information", "game", "actions", "decision"], "source_lectures": ["lecture_106101360_w7_l36", "lecture_106101360_w8_l38", "lecture_106101360_w8_l39", "lecture_106101360_w10_l50"]}}
{"id": "concept_player_set", "type": "V_concept", "name": "Player Set", "properties": {"description": "A set of nodes in a game tree that belong to a particular player.", "keywords": ["player", "set", "node", "game", "tree"], "source_lectures": ["lecture_106101360_w7_l36"]}}
{"id": "concept_normal_form_game", "type": "V_concept", "name": "Normal Form Game", "properties": {"description": "A game represented as a matrix, where each cell contains the payoffs for a particular strategy combination.", "keywords": ["matrix", "normal", "form", "game", "payoff"], "source_lectures": ["lecture_106101360_w7_l36", "lecture_106101360_w8_l38"]}}
{"id": "concept_informationally_inferior_game", "type": "V_concept", "name": "Informationally Inferior Game", "properties": {"description": "A game where a player has less information than in the original game.", "keywords": ["informationally", "inferior", "game", "player", "information"], "source_lectures": ["lecture_106101360_w7_l36"]}}
{"id": "concept_perfect_information_game", "type": "V_concept", "name": "Perfect Information Game", "properties": {"description": "A game where every information set is a single node, and players have complete knowledge of the game state.", "keywords": ["knowledge", "state", "node", "perfect", "game", "information"], "source_lectures": ["lecture_106101360_w7_l36", "lecture_106101360_w8_l38", "lecture_106101360_w8_l39"]}}
{"id": "concept_imperfect_information_game", "type": "V_concept", "name": "Imperfect Information Game", "properties": {"description": "A game where players do not have complete knowledge of the game's history or current state.", "keywords": ["imperfect", "information", "game", "uncertainty"], "source_lectures": ["lecture_106101360_w8_l38"]}}
{"id": "concept_information_structure", "type": "V_concept", "name": "Information Structure", "properties": {"description": "A description of what each player knows at each point in the game.", "keywords": ["information", "structure", "game", "knowledge"], "source_lectures": ["lecture_106101360_w8_l38"]}}
{"id": "concept_single_turn_information_set", "type": "V_concept", "name": "Single Turn Information Set", "properties": {"description": "A set of nodes in a game tree where a player's decision is made, and the player has complete knowledge of the game's history up to that point.", "keywords": ["single", "information", "game", "turn", "set"], "source_lectures": ["lecture_106101360_w8_l38", "lecture_106101360_w8_l41"]}}
{"id": "concept_nested_extensive_form", "type": "V_concept", "name": "Nested Extensive Form", "properties": {"description": "An extensive form game where each player has access to the information acquired by all its predecessors.", "keywords": ["nested", "extensive", "form", "game", "information"], "source_lectures": ["lecture_106101360_w8_l39"]}}
{"id": "concept_ladder_nested_extensive_form", "type": "V_concept", "name": "Ladder Nested Extensive Form", "properties": {"description": "A nested extensive form game where the only difference in information between a player and its immediate predecessor is about the actions of the predecessor, taken at a single turn information set.", "keywords": ["ladder", "nested", "extensive", "form", "game"], "source_lectures": ["lecture_106101360_w8_l39"]}}
{"id": "concept_strategic_equivalence", "type": "V_concept", "name": "Strategic Equivalence", "properties": {"description": "The property of two games being equivalent in terms of their strategic implications, despite differences in their extensive form representations.", "keywords": ["strategic", "equivalence", "game", "extensive", "form"], "source_lectures": ["lecture_106101360_w8_l39"]}}
{"id": "concept_payoff_relevance", "type": "V_concept", "name": "Payoff Relevance", "properties": {"description": "The property of information being relevant to a player's payoff in a game.", "keywords": ["payoff", "relevance", "information", "game"], "source_lectures": ["lecture_106101360_w8_l39"]}}
{"id": "concept_node", "type": "V_concept", "name": "Node", "properties": {"description": "A point in a game tree representing a game state or a decision point.", "keywords": ["tree", "state", "node", "game", "point", "decision"], "source_lectures": ["lecture_106101360_w8_l39", "lecture_106101360_w9_l62"]}}
{"id": "concept_equilibrium_algorithm", "type": "V_concept", "name": "Equilibrium Algorithm", "properties": {"description": "A method for finding equilibria in dynamic games by recursively solving static sub-games.", "keywords": ["equilibrium", "algorithm", "dynamic", "game", "theory"], "source_lectures": ["lecture_106101360_w8_l40"]}}
{"id": "concept_subextensive_form", "type": "V_concept", "name": "Subextensive Form", "properties": {"description": "A sub-game that includes all players with the same information as a given information set.", "keywords": ["subextensive", "form", "game", "theory", "information"], "source_lectures": ["lecture_106101360_w8_l40"]}}
{"id": "concept_delayed_commitment", "type": "V_concept", "name": "Delayed Commitment", "properties": {"description": "A type of equilibrium where players commit to actions only when they have the necessary information.", "keywords": ["theory", "commitment", "equilibrium", "delayed", "information", "game"], "source_lectures": ["lecture_106101360_w8_l40", "lecture_106101360_w10_l48"]}}
{"id": "concept_precommitment", "type": "V_concept", "name": "Precommitment", "properties": {"description": "A strategy where a player commits to an action before having all the necessary information.", "keywords": ["precommitment", "strategy", "game", "theory", "information"], "source_lectures": ["lecture_106101360_w8_l40"]}}
{"id": "concept_refinement", "type": "V_concept", "name": "Refinement", "properties": {"description": "The process of narrowing down the set of possible equilibria in a game by imposing additional criteria.", "keywords": ["refinement", "equilibrium", "game", "theory", "criteria"], "source_lectures": ["lecture_106101360_w8_l40"]}}
{"id": "concept_perfect_information", "type": "V_concept", "name": "Perfect Information", "properties": {"description": "A game where all players have complete knowledge of the game state at all times.", "keywords": ["theory", "knowledge", "sequence", "perfect", "game", "information"], "source_lectures": ["lecture_106101360_w8_l40", "lecture_106101360_w9_l62"]}}
{"id": "concept_multi_act_game", "type": "V_concept", "name": "Multi-Act Game", "properties": {"description": "A game where at least one player acts more than once along some path of the game tree.", "keywords": ["action", "player", "multiple", "single-act", "decisions", "game", "multi-act"], "source_lectures": ["lecture_106101360_w8_l41", "lecture_106101360_w9_l43"]}}
{"id": "concept_stage_wise_game", "type": "V_concept", "name": "Stage-Wise Game", "properties": {"description": "A game divided into stages, where each stage is a single-act game and players are aware of the current stage.", "keywords": ["stage-wise", "game", "stage", "single-act"], "source_lectures": ["lecture_106101360_w8_l41"]}}
{"id": "concept_feedback_form", "type": "V_concept", "name": "Feedback Form", "properties": {"description": "A game structure where players' information sets do not span across multiple stages, allowing for systematic analysis.", "keywords": ["theory", "players", "structure", "form", "game", "feedback"], "source_lectures": ["lecture_106101360_w8_l41", "lecture_106101360_w8_l42"]}}
{"id": "concept_feedback_nash_equilibrium", "type": "V_concept", "name": "Feedback Nash Equilibrium", "properties": {"description": "A refinement of Nash equilibrium that applies to multi-act games, ensuring players are rational at every stage and taking into account the history of the game.", "keywords": ["theory", "feedback", "equilibrium", "nash", "game", "multi-act"], "source_lectures": ["lecture_106101360_w8_l41", "lecture_106101360_w8_l42"]}}
{"id": "concept_dynamic_programming", "type": "V_concept", "name": "Dynamic Programming", "properties": {"description": "A method for solving complex problems by breaking them down into smaller sub-problems and solving each sub-problem only once.", "keywords": ["dynamic", "programming", "problem", "solving"], "source_lectures": ["lecture_106101360_w8_l41"]}}
{"id": "concept_ladder_nested_feedback_form", "type": "V_concept", "name": "Ladder Nested Feedback Form", "properties": {"description": "A game structure that combines ladder nested and feedback form properties, allowing for a more systematic analysis of multi-act games.", "keywords": ["ladder", "nested", "feedback", "form"], "source_lectures": ["lecture_106101360_w8_l41"]}}
{"id": "concept_delayed_commitment_type_equilibrium", "type": "V_concept", "name": "Delayed Commitment Type Equilibrium", "properties": {"description": "A type of equilibrium where players are not allowed to make threats or commitments that are not credible, ensuring a more stable and realistic outcome.", "keywords": ["delayed", "commitment", "type", "equilibrium"], "source_lectures": ["lecture_106101360_w8_l41"]}}
{"id": "concept_delayed_commitment_type", "type": "V_concept", "name": "Delayed Commitment Type", "properties": {"description": "A type of commitment in game theory where players make decisions at a specific stage, without knowing the actions of other players.", "keywords": ["delayed", "commitment", "type", "game", "theory"], "source_lectures": ["lecture_106101360_w8_l42"]}}
{"id": "concept_multistage_game", "type": "V_concept", "name": "Multistage Game", "properties": {"description": "A game that consists of multiple stages, where players make decisions at each stage, taking into account the actions of other players.", "keywords": ["multistage", "game", "theory", "stages", "players"], "source_lectures": ["lecture_106101360_w8_l42"]}}
{"id": "concept_stage_wise_form", "type": "V_concept", "name": "Stage Wise Form", "properties": {"description": "A way of representing a game, where each stage is represented separately, and players make decisions at each stage.", "keywords": ["stage", "wise", "form", "game", "theory"], "source_lectures": ["lecture_106101360_w8_l42"]}}
{"id": "concept_informational_inferiority", "type": "V_concept", "name": "Informational Inferiority", "properties": {"description": "A concept in game theory where a player has less information than other players, making it difficult to make decisions.", "keywords": ["informational", "inferiority", "game", "theory", "players"], "source_lectures": ["lecture_106101360_w8_l42"]}}
{"id": "concept_normal_form", "type": "V_concept", "name": "Normal Form", "properties": {"description": "A way of representing a game, where all possible strategies and payoffs are listed, and players make decisions based on this information.", "keywords": ["theory", "representation", "normal", "strategies", "form", "game"], "source_lectures": ["lecture_106101360_w8_l42", "lecture_106101360_w9_l43"]}}
{"id": "concept_randomization_in_dynamic_games", "type": "V_concept", "name": "Randomization In Dynamic Games", "properties": {"description": "A technique used in game theory, where players use randomization to make decisions in dynamic games.", "keywords": ["randomization", "dynamic", "games", "game", "theory"], "source_lectures": ["lecture_106101360_w8_l42"]}}
{"id": "concept_strategic_analysis", "type": "V_concept", "name": "Strategic Analysis", "properties": {"description": "The process of analyzing a game to determine the best strategy for a player, taking into account the actions of other players.", "keywords": ["strategic", "analysis", "game", "theory", "players"], "source_lectures": ["lecture_106101360_w8_l42"]}}
{"id": "concept_behavioral_strategy", "type": "V_concept", "name": "Behavioral Strategy", "properties": {"description": "A strategy where a player chooses an action at random at each information set, based on a probability distribution over available actions.", "keywords": ["distribution", "information set", "action", "behavioral", "strategy", "random", "game theory", "probability", "information", "game", "randomization", "set"], "source_lectures": ["lecture_106101360_w9_l43", "lecture_106101360_w9_l44", "lecture_106101360_w9_l45", "lecture_106101360_w9_l46", "lecture_106101360_w10_l48", "lecture_106101360_w10_l49", "lecture_106101360_w10_l50"]}}
{"id": "concept_extensive_form", "type": "V_concept", "name": "Extensive Form", "properties": {"description": "A representation of a game that shows the sequence of actions and information sets, illustrating the flow of the game.", "keywords": ["extensive", "form", "game", "sequence", "information"], "source_lectures": ["lecture_106101360_w9_l43"]}}
{"id": "concept_equivalence_of_strategies", "type": "V_concept", "name": "Equivalence of Strategies", "properties": {"description": "The concept that two strategies, such as mixed and behavioral, can be considered equivalent if they produce the same probability distribution over the game tree.", "keywords": ["distribution", "outcomes", "equivalence", "expected", "behavioral", "strategy", "mixed", "probability", "strategies", "outcome"], "source_lectures": ["lecture_106101360_w9_l43", "lecture_106101360_w9_l44", "lecture_106101360_w9_l45", "lecture_106101360_w9_l46"]}}
{"id": "concept_perfect_recall", "type": "V_concept", "name": "Perfect Recall", "properties": {"description": "A property where players remember all past actions and information, ensuring each information set intersects every path at most once.", "keywords": ["perfect", "recall", "memory", "actions"], "source_lectures": ["lecture_106101360_w9_l44"]}}
{"id": "concept_absentmindedness", "type": "V_concept", "name": "Absentmindedness", "properties": {"description": "A game situation where players forget previous actions, potentially revisiting the same information set multiple times.", "keywords": ["absentmindedness", "forgetting", "memory", "information set"], "source_lectures": ["lecture_106101360_w9_l44"]}}
{"id": "concept_counterexample_mixed_without_behavioral", "type": "V_concept", "name": "Counterexample Mixed Without Behavioral", "properties": {"description": "An example demonstrating a mixed strategy that has no equivalent behavioral strategy due to memory constraints.", "keywords": ["counterexample", "mixed", "behavioral", "equivalence"], "source_lectures": ["lecture_106101360_w9_l44"]}}
{"id": "concept_counterexample_behavioral_without_mixed", "type": "V_concept", "name": "Counterexample Behavioral Without Mixed", "properties": {"description": "An example showing a behavioral strategy that cannot be replicated by any mixed strategy, enabling unreachable outcomes.", "keywords": ["counterexample", "behavioral", "mixed", "equivalence"], "source_lectures": ["lecture_106101360_w9_l44"]}}
{"id": "concept_strategy_equivalence_theorem", "type": "V_concept", "name": "Strategy Equivalence Theorem", "properties": {"description": "The result stating that equivalence between mixed and behavioral strategies holds if all players have perfect recall.", "keywords": ["theorem", "equivalence", "mixed", "behavioral", "perfect recall"], "source_lectures": ["lecture_106101360_w9_l44"]}}
{"id": "concept_kuhns_theorem", "type": "V_concept", "name": "Kuhn's Theorem", "properties": {"description": "A theorem that provides conditions under which behavioral strategies and mixed strategies are equivalent.", "keywords": ["kuhn", "behavioral", "strategy", "mixed", "theorem"], "source_lectures": ["lecture_106101360_w9_l45", "lecture_106101360_w9_l46"]}}
{"id": "concept_game_of_perfect_recall", "type": "V_concept", "name": "Game of Perfect Recall", "properties": {"description": "A game where a player has perfect recall, meaning they remember all previous actions and information sets.", "keywords": ["game", "perfect", "recall", "memory", "information"], "source_lectures": ["lecture_106101360_w9_l45"]}}
{"id": "concept_probability_of_reaching_a_node", "type": "V_concept", "name": "Probability of Reaching a Node", "properties": {"description": "The probability of reaching a specific node in a game tree, given a strategy or set of strategies.", "keywords": ["probability", "node", "game", "tree", "strategy"], "source_lectures": ["lecture_106101360_w9_l45"]}}
{"id": "concept_decomposition_of_probability", "type": "V_concept", "name": "Decomposition of Probability", "properties": {"description": "The process of breaking down a probability into smaller components, such as the probability of individual actions or players.", "keywords": ["decomposition", "probability", "action", "player", "game"], "source_lectures": ["lecture_106101360_w9_l45"]}}
{"id": "concept_independence_of_actions", "type": "V_concept", "name": "Independence of Actions", "properties": {"description": "The concept that actions taken by different players are independent of each other.", "keywords": ["independence", "actions", "player", "game", "probability"], "source_lectures": ["lecture_106101360_w9_l45"]}}
{"id": "concept_expected_outcome", "type": "V_concept", "name": "Expected Outcome", "properties": {"description": "The average outcome of a strategy, weighted by the probability of each outcome.", "keywords": ["expected", "outcome", "average", "probability"], "source_lectures": ["lecture_106101360_w9_l46"]}}
{"id": "concept_imperfect_information", "type": "V_concept", "name": "Imperfect Information", "properties": {"description": "A situation in a game where a player does not know the actions or events that have occurred during the game.", "keywords": ["incomplete", "uncertainty", "knowledge", "imperfect", "information", "game", "actions"], "source_lectures": ["lecture_106101360_w10_l48", "lecture_106101360_w9_l62"]}}
{"id": "concept_bayesian_games", "type": "V_concept", "name": "Bayesian Games", "properties": {"description": "Games of incomplete information where players have probabilistic beliefs about the types of other players.", "keywords": ["bayesian", "game", "incomplete", "information"], "source_lectures": ["lecture_106101360_w10_l48"]}}
{"id": "concept_type_space", "type": "V_concept", "name": "Type Space", "properties": {"description": "The set of all possible types or characteristics of a player in a game.", "keywords": ["characteristics", "private", "space", "preferences", "information", "game", "type"], "source_lectures": ["lecture_106101360_w10_l48", "lecture_106101360_w10_l49", "lecture_106101360_w10_l50"]}}
{"id": "concept_ex_ante_belief", "type": "V_concept", "name": "Ex Ante Belief", "properties": {"description": "A player's belief about the types of other players before the game starts.", "keywords": ["ex ante", "belief", "game", "type"], "source_lectures": ["lecture_106101360_w10_l48"]}}
{"id": "concept_interim_payoff", "type": "V_concept", "name": "Interim Payoff", "properties": {"description": "The expected payoff of a player after they have learned their own type but before they have learned the types of other players.", "keywords": ["interim", "payoff", "game", "type"], "source_lectures": ["lecture_106101360_w10_l48"]}}
{"id": "concept_ex_post_belief", "type": "V_concept", "name": "Ex Post Belief", "properties": {"description": "A player's belief about the types of other players after they have learned their own type.", "keywords": ["ex post", "belief", "game", "type"], "source_lectures": ["lecture_106101360_w10_l48"]}}
{"id": "concept_bayes_nash_equilibrium", "type": "V_concept", "name": "Bayes-Nash Equilibrium", "properties": {"description": "A concept in game theory that describes a situation where no player can improve their payoff by unilaterally changing their strategy, given their beliefs about the types of other players.", "keywords": ["bayes-nash", "equilibrium", "game", "theory"], "source_lectures": ["lecture_106101360_w10_l48"]}}
{"id": "concept_bayesian_nash_equilibrium", "type": "V_concept", "name": "Bayesian Nash Equilibrium", "properties": {"description": "A refinement of the Nash equilibrium concept that takes into account the uncertainty of players about the types of their opponents.", "keywords": ["bayesian", "uncertainty", "incomplete information", "equilibrium", "game theory", "nash", "game"], "source_lectures": ["lecture_106101360_w10_l49", "lecture_106101360_w10_l50"]}}
{"id": "concept_agent_form", "type": "V_concept", "name": "Agent Form", "properties": {"description": "A representation of a game where each type of each player is treated as a separate player, allowing for the analysis of games with incomplete information.", "keywords": ["agent", "form", "game", "incomplete", "information"], "source_lectures": ["lecture_106101360_w10_l49"]}}
{"id": "concept_harsanyis_theorem", "type": "V_concept", "name": "Harsanyi's Theorem", "properties": {"description": "A theorem that states that any Bayesian Nash equilibrium can be represented as a Nash equilibrium in an auxiliary game, known as the agent form.", "keywords": ["harsanyi", "theorem", "bayesian", "nash", "equilibrium"], "source_lectures": ["lecture_106101360_w10_l49"]}}
{"id": "concept_incomplete_information_game", "type": "V_concept", "name": "Incomplete Information Game", "properties": {"description": "A game where players have incomplete knowledge about the game, such as the types of other players or the payoff structure.", "keywords": ["incomplete", "information", "game", "knowledge", "types"], "source_lectures": ["lecture_106101360_w10_l50"]}}
{"id": "concept_self_enforcing_agreement", "type": "V_concept", "name": "Self-enforcing Agreement", "properties": {"description": "An agreement where players adhere to a strategy without external enforcement due to mutual incentives.", "keywords": ["self-enforcing", "agreement", "incentives", "commitment"], "source_lectures": ["lecture_106101360_w10_l51"]}}
{"id": "concept_pareto_dominant_equilibrium", "type": "V_concept", "name": "Pareto Dominant Equilibrium", "properties": {"description": "A Nash equilibrium that yields higher payoffs for all players compared to other equilibria.", "keywords": ["pareto", "dominant", "equilibrium", "payoffs"], "source_lectures": ["lecture_106101360_w10_l51"]}}
{"id": "concept_risk_dominant_equilibrium", "type": "V_concept", "name": "Risk Dominant Equilibrium", "properties": {"description": "A Nash equilibrium that minimizes potential losses if other players deviate from their strategies.", "keywords": ["risk", "dominant", "equilibrium", "safety"], "source_lectures": ["lecture_106101360_w10_l51"]}}
{"id": "concept_stag_hunt_game", "type": "V_concept", "name": "Stag Hunt Game", "properties": {"description": "A coordination game with two Nash equilibria where players choose between high-reward cooperation or safer individual action.", "keywords": ["stag hunt", "coordination", "equilibrium", "risk"], "source_lectures": ["lecture_106101360_w10_l51"]}}
{"id": "concept_battle_of_the_sexes", "type": "V_concept", "name": "Battle of the Sexes", "properties": {"description": "A coordination game where players prefer different outcomes but must align actions to avoid zero payoffs.", "keywords": ["battle", "sexes", "coordination", "equilibrium"], "source_lectures": ["lecture_106101360_w10_l51"]}}
{"id": "concept_non_binding_agreement", "type": "V_concept", "name": "Non-binding Agreement", "properties": {"description": "An agreement without external enforcement mechanisms, relying solely on players' incentives.", "keywords": ["non-binding", "agreement", "enforcement", "incentives"], "source_lectures": ["lecture_106101360_w10_l51"]}}
{"id": "concept_information_conveyance", "type": "V_concept", "name": "Information Conveyance", "properties": {"description": "The process by which pre-play communication reveals players' intentions or preferences.", "keywords": ["information", "conveyance", "signaling", "intent"], "source_lectures": ["lecture_106101360_w10_l51"]}}
{"id": "concept_security_dilemma", "type": "V_concept", "name": "Security Dilemma", "properties": {"description": "A strategic scenario where mutual mistrust leads players to choose risk-dominant equilibria despite Pareto-superior options.", "keywords": ["security", "dilemma", "mistrust", "risk"], "source_lectures": ["lecture_106101360_w10_l51"]}}
{"id": "concept_coordination_game", "type": "V_concept", "name": "Coordination Game", "properties": {"description": "A game where players benefit from aligning actions but may have conflicting preferences over outcomes.", "keywords": ["coordination", "game", "alignment", "preferences"], "source_lectures": ["lecture_106101360_w10_l51"]}}
{"id": "concept_incentive_structure", "type": "V_concept", "name": "Incentive Structure", "properties": {"description": "The arrangement of payoffs that influences players' strategic decisions in a game.", "keywords": ["incentive", "structure", "payoffs", "strategies"], "source_lectures": ["lecture_106101360_w10_l51"]}}
{"id": "concept_stackelberg_equilibrium", "type": "V_concept", "name": "Stackelberg Equilibrium", "properties": {"description": "A concept in game theory where one player, the leader, commits to a strategy first and the other player, the follower, responds to that strategy.", "keywords": ["stackelberg", "equilibrium", "game theory", "leader", "follower"], "source_lectures": ["lecture_106101360_w10_l52"]}}
{"id": "concept_leader_follower_game", "type": "V_concept", "name": "Leader-Follower Game", "properties": {"description": "A type of game where one player, the leader, makes a decision first and the other player, the follower, responds to that decision.", "keywords": ["leader", "follower", "game", "decision", "response"], "source_lectures": ["lecture_106101360_w10_l52"]}}
{"id": "concept_commitment_strategy", "type": "V_concept", "name": "Commitment Strategy", "properties": {"description": "A strategy where a player commits to a particular action or decision, which can influence the behavior of other players.", "keywords": ["commitment", "strategy", "game theory", "influence", "behavior"], "source_lectures": ["lecture_106101360_w10_l52"]}}
{"id": "concept_optimistic_leader", "type": "V_concept", "name": "Optimistic Leader", "properties": {"description": "A type of leader who chooses a strategy that minimizes the best-case outcome for the follower.", "keywords": ["optimistic", "leader", "strategy", "best-case", "outcome"], "source_lectures": ["lecture_106101360_w10_l52"]}}
{"id": "concept_pessimistic_leader", "type": "V_concept", "name": "Pessimistic Leader", "properties": {"description": "A type of leader who chooses a strategy that minimizes the worst-case outcome for the follower.", "keywords": ["pessimistic", "leader", "strategy", "worst-case", "outcome"], "source_lectures": ["lecture_106101360_w10_l52"]}}
{"id": "concept_multiple_followers", "type": "V_concept", "name": "Multiple Followers", "properties": {"description": "A situation where a leader faces multiple followers, each with their own strategy and payoff.", "keywords": ["multiple followers", "leader", "game theory", "strategy", "payoff"], "source_lectures": ["lecture_106101360_w10_l52"]}}
{"id": "concept_nash_equilibrium_with_multiple_leaders", "type": "V_concept", "name": "Nash Equilibrium with Multiple Leaders", "properties": {"description": "A concept in game theory where multiple leaders interact with multiple followers, leading to multiple possible Nash equilibria.", "keywords": ["nash equilibrium", "multiple leaders", "game theory", "followers", "equilibria"], "source_lectures": ["lecture_106101360_w10_l52"]}}
{"id": "concept_stackelberg_game_with_multiple_leaders", "type": "V_concept", "name": "Stackelberg Game with Multiple Leaders", "properties": {"description": "A type of game where multiple leaders commit to strategies first, and multiple followers respond to those strategies.", "keywords": ["stackelberg game", "multiple leaders", "game theory", "followers", "strategies"], "source_lectures": ["lecture_106101360_w10_l52"]}}
{"id": "concept_principal_agent_model", "type": "V_concept", "name": "Principal Agent Model", "properties": {"description": "A model that studies the relationship between a principal and an agent, where the principal delegates a task to the agent and the agent makes decisions based on the information received from the principal.", "keywords": ["principal", "agent", "model", "contract", "theory"], "source_lectures": ["lecture_106101360_w11_l53"]}}
{"id": "concept_sender_receiver_game", "type": "V_concept", "name": "Sender Receiver Game", "properties": {"description": "A game where one player, the sender, sends information to another player, the receiver, who then takes an action based on the received information.", "keywords": ["sender", "receiver", "game", "information", "communication"], "source_lectures": ["lecture_106101360_w11_l53"]}}
{"id": "concept_contract_theory", "type": "V_concept", "name": "Contract Theory", "properties": {"description": "A branch of economics that studies the design of contracts between two or more parties, taking into account the information asymmetry and incentives of the parties involved.", "keywords": ["theory", "asymmetry", "economics", "contract", "design", "optimize", "information"], "source_lectures": ["lecture_106101360_w11_l53", "lecture_106101360_w11_l55"]}}
{"id": "concept_participation_constraint", "type": "V_concept", "name": "Participation Constraint", "properties": {"description": "A condition in contract theory that ensures the agent's participation in the contract by guaranteeing a minimum level of utility or payoff.", "keywords": ["theory", "constraint", "utility", "reservation", "reserve", "contract", "participation", "payoff"], "source_lectures": ["lecture_106101360_w11_l53", "lecture_106101360_w11_l55", "lecture_106101360_w11_l56"]}}
{"id": "concept_reservation_utility", "type": "V_concept", "name": "Reservation Utility", "properties": {"description": "The minimum level of utility or payoff that an agent requires to participate in a contract or take an action.", "keywords": ["reservation", "utility", "contract", "theory", "payoff"], "source_lectures": ["lecture_106101360_w11_l53"]}}
{"id": "concept_action", "type": "V_concept", "name": "Action", "properties": {"description": "A decision made by a player in a game that directly affects the payoff or cost.", "keywords": ["action", "decision", "game", "payoff", "cost"], "source_lectures": ["lecture_106101360_w11_l53"]}}
{"id": "concept_signal", "type": "V_concept", "name": "Signal", "properties": {"description": "A decision made by a player in a game that affects the information of another player, but does not directly affect the payoff or cost.", "keywords": ["signal", "decision", "game", "information", "communication"], "source_lectures": ["lecture_106101360_w11_l53"]}}
{"id": "concept_information_asymmetry", "type": "V_concept", "name": "Information Asymmetry", "properties": {"description": "A situation where one party in a contract or game has more or better information than the other party.", "keywords": ["theory", "knowledge", "state", "asymmetry", "contract", "information", "game"], "source_lectures": ["lecture_106101360_w11_l53", "lecture_106101360_w9_l62"]}}
{"id": "concept_principals_problem", "type": "V_concept", "name": "Principal's Problem", "properties": {"description": "The problem faced by the principal in a principal-agent model, where the principal needs to design a contract that incentivizes the agent to take the desired action.", "keywords": ["principal", "problem", "contract", "theory", "incentive"], "source_lectures": ["lecture_106101360_w11_l53"]}}
{"id": "concept_agents_problem", "type": "V_concept", "name": "Agent's Problem", "properties": {"description": "The problem faced by the agent in a principal-agent model, where the agent needs to decide whether to accept or reject the contract and how much effort to exert.", "keywords": ["agent", "problem", "contract", "theory", "effort"], "source_lectures": ["lecture_106101360_w11_l53"]}}
{"id": "concept_moral_hazard", "type": "V_concept", "name": "Moral Hazard", "properties": {"description": "A situation where one party takes on more risk because they are protected from its consequences, often due to information asymmetry.", "keywords": ["moral", "hazard", "risk", "information", "asymmetry"], "source_lectures": ["lecture_106101360_w11_l55"]}}
{"id": "concept_adverse_selection", "type": "V_concept", "name": "Adverse Selection", "properties": {"description": "A phenomenon where one party in a transaction has more information than the other, leading to an unequal distribution of risk.", "keywords": ["adverse", "selection", "information", "asymmetry", "risk"], "source_lectures": ["lecture_106101360_w11_l55"]}}
{"id": "concept_principal_agent_problem", "type": "V_concept", "name": "Principal-Agent Problem", "properties": {"description": "A situation where one party (the agent) makes decisions on behalf of another party (the principal), often with conflicting interests.", "keywords": ["theory", "moral hazard", "interests", "problem", "principal", "game", "agent", "conflict"], "source_lectures": ["lecture_106101360_w11_l55", "lecture_106101360_w12_l58"]}}
{"id": "concept_vickrey_auction", "type": "V_concept", "name": "Vickrey Auction", "properties": {"description": "A type of auction where the winner pays the second-highest bid, incentivizing bidders to reveal their true valuations.", "keywords": ["vickrey", "auction", "second", "highest", "bid"], "source_lectures": ["lecture_106101360_w11_l55"]}}
{"id": "concept_first_best", "type": "V_concept", "name": "First Best", "properties": {"description": "The optimal outcome for a principal when they have complete control over an agent's actions.", "keywords": ["first", "best", "optimal", "outcome", "control"], "source_lectures": ["lecture_106101360_w11_l55"]}}
{"id": "concept_second_best", "type": "V_concept", "name": "Second Best", "properties": {"description": "The optimal outcome for a principal when they have incomplete control over an agent's actions, often due to information asymmetry.", "keywords": ["second", "best", "optimal", "outcome", "incomplete"], "source_lectures": ["lecture_106101360_w11_l55"]}}
{"id": "concept_information_rent", "type": "V_concept", "name": "Information Rent", "properties": {"description": "The difference between the first best and second best outcomes, often resulting from information asymmetry.", "keywords": ["information", "rent", "difference", "first", "second"], "source_lectures": ["lecture_106101360_w11_l55"]}}
{"id": "concept_bargaining_theory", "type": "V_concept", "name": "Bargaining Theory", "properties": {"description": "The study of how players negotiate and reach agreements considering their utilities.", "keywords": ["bargaining", "agreement", "negotiation", "utilities"], "source_lectures": ["lecture_106101360_w11_l56"]}}
{"id": "concept_contract_signing_game", "type": "V_concept", "name": "Contract Signing Game", "properties": {"description": "An extended game where players choose whether to sign binding contracts that alter their action sets.", "keywords": ["contract", "signing", "game", "actions"], "source_lectures": ["lecture_106101360_w11_l56"]}}
{"id": "concept_correlated_strategy", "type": "V_concept", "name": "Correlated Strategy", "properties": {"description": "A probability distribution over joint actions enforced by a contract for signing players.", "keywords": ["correlated", "strategy", "probability", "actions"], "source_lectures": ["lecture_106101360_w11_l56"]}}
{"id": "concept_minmax_value", "type": "V_concept", "name": "Minmax Value", "properties": {"description": "The security level payoff a player can guarantee by optimizing against adversarial contracts signed by others.", "keywords": ["minmax", "value", "security", "payoff"], "source_lectures": ["lecture_106101360_w11_l56"]}}
{"id": "concept_achievable_payoff_set", "type": "V_concept", "name": "Achievable Payoff Set", "properties": {"description": "The set of all payoff vectors attainable through enforceable contracts satisfying participation constraints.", "keywords": ["achievable", "payoff", "set", "contracts"], "source_lectures": ["lecture_106101360_w11_l56"]}}
{"id": "concept_myersons_framework", "type": "V_concept", "name": "Myerson's Framework", "properties": {"description": "An approach modeling communication outcomes via contracts without detailing the communication process.", "keywords": ["myerson", "framework", "communication", "contracts"], "source_lectures": ["lecture_106101360_w11_l56"]}}
{"id": "concept_enforcement_mechanism", "type": "V_concept", "name": "Enforcement Mechanism", "properties": {"description": "An external system ensuring compliance with binding agreements signed by players.", "keywords": ["enforcement", "mechanism", "compliance", "binding"], "source_lectures": ["lecture_106101360_w11_l56"]}}
{"id": "concept_mixed_strategy_equilibrium", "type": "V_concept", "name": "Mixed Strategy Equilibrium", "properties": {"description": "An equilibrium where players randomize actions independently, often arising in contract signing games.", "keywords": ["mixed", "strategy", "equilibrium", "randomization"], "source_lectures": ["lecture_106101360_w11_l56"]}}
{"id": "concept_mediated_communication", "type": "V_concept", "name": "Mediated Communication", "properties": {"description": "A form of communication where players communicate separately and confidentially with a mediator.", "keywords": ["theory", "communication", "incomplete", "mediator", "strategic", "game", "information", "mediated"], "source_lectures": ["lecture_106101360_w12_l58", "lecture_106101360_w12_l60"]}}
{"id": "concept_obedience_constraint", "type": "V_concept", "name": "Obedience Constraint", "properties": {"description": "A constraint that ensures a player's payoff from following a recommended strategy is better than deviating from it.", "keywords": ["obedience", "constraint", "game", "theory", "payoff"], "source_lectures": ["lecture_106101360_w12_l58"]}}
{"id": "concept_indirect_communication", "type": "V_concept", "name": "Indirect Communication", "properties": {"description": "A form of communication where players communicate through a noisy or imperfect channel.", "keywords": ["indirect", "communication", "game", "theory", "noisy"], "source_lectures": ["lecture_106101360_w12_l58"]}}
{"id": "concept_polytope", "type": "V_concept", "name": "Polytope", "properties": {"description": "A geometric shape defined by a set of linear inequalities.", "keywords": ["polytope", "geometry", "linear", "inequalities"], "source_lectures": ["lecture_106101360_w12_l58"]}}
{"id": "concept_private_information", "type": "V_concept", "name": "Private Information", "properties": {"description": "Information that is known only to a specific player or group of players, and not to others, in a game or strategic situation.", "keywords": ["private", "information", "game", "theory", "asymmetry"], "source_lectures": ["lecture_106101360_w12_l60"]}}
{"id": "concept_strategic_decision_making", "type": "V_concept", "name": "Strategic Decision Making", "properties": {"description": "The process of making decisions in a situation where the outcome depends on the actions of multiple players or agents, and each player's goal is to maximize their payoff.", "keywords": ["strategic", "decision", "making", "game", "theory"], "source_lectures": ["lecture_106101360_w12_l60"]}}
{"id": "concept_sequential_move_game", "type": "V_concept", "name": "Sequential Move Game", "properties": {"description": "A game where players make decisions in a sequence, with each player knowing the actions of previous players.", "keywords": ["sequential", "move", "game", "decision", "sequence"], "source_lectures": ["lecture_106101360_w9_l62"]}}
{"id": "concept_player_ignorance", "type": "V_concept", "name": "Player Ignorance", "properties": {"description": "A player's lack of knowledge about the game state or the actions of other players.", "keywords": ["player", "ignorance", "game", "knowledge", "action"], "source_lectures": ["lecture_106101360_w9_l62"]}}
{"id": "concept_game_state", "type": "V_concept", "name": "Game State", "properties": {"description": "The current situation in a game, including the actions taken by all players.", "keywords": ["game", "state", "situation", "action", "player"], "source_lectures": ["lecture_106101360_w9_l62"]}}
{"id": "concept_embedded_system", "type": "V_concept", "name": "Embedded System", "properties": {"description": "A computer system that is designed to perform a specific task and is embedded in a larger device or system.", "keywords": ["electronics", "specific", "device", "embedded", "system", "real-time", "function", "hardware", "task", "software", "computer"], "source_lectures": ["lecture_108102169_w1_l2", "lecture_108102169_w1_l6", "lecture_108102169_w2_l10", "lecture_108102169_w3_l16", "lecture_108102169_w6_l39"]}}
{"id": "concept_microprocessor", "type": "V_concept", "name": "Microprocessor", "properties": {"description": "A central processing unit (CPU) that contains the entire processing system of a computer on a single chip of silicon.", "keywords": ["microprocessor", "cpu", "central", "processing", "unit"], "source_lectures": ["lecture_108102169_w1_l2"]}}
{"id": "concept_microcontroller", "type": "V_concept", "name": "Microcontroller", "properties": {"description": "A small computer on a single integrated circuit (IC) that contains a processor, memory, and input/output peripherals.", "keywords": ["electronics", "memory", "io", "integrated", "processor", "peripherals", "control", "cpu", "circuit", "computer", "small", "microcontroller"], "source_lectures": ["lecture_108102169_w1_l2", "lecture_108102169_w1_l3", "lecture_108102169_w1_l6", "lecture_108102169_w2_l10", "lecture_108102169_w3_l16", "lecture_108102169_w5_l32", "lecture_108102169_w5_l35", "lecture_108102169_w6_l39"]}}
{"id": "concept_system_on_chip_soc", "type": "V_concept", "name": "System on Chip (SoC)", "properties": {"description": "An integrated circuit (IC) that contains all the components of a computer system, including the processor, memory, and input/output peripherals.", "keywords": ["system", "chip", "integrated", "circuit", "computer"], "source_lectures": ["lecture_108102169_w1_l2"]}}
{"id": "concept_field_programmable_gate_array_fpga", "type": "V_concept", "name": "Field-Programmable Gate Array (FPGA)", "properties": {"description": "An integrated circuit (IC) that can be programmed and reprogrammed to perform specific tasks.", "keywords": ["field", "programmable", "gate", "array", "integrated"], "source_lectures": ["lecture_108102169_w1_l2"]}}
{"id": "concept_application_specific_integrated_circuit_asic", "type": "V_concept", "name": "Application-Specific Integrated Circuit (ASIC)", "properties": {"description": "An integrated circuit (IC) that is designed to perform a specific task and is not programmable.", "keywords": ["application", "specific", "integrated", "circuit", "non-programmable"], "source_lectures": ["lecture_108102169_w1_l2"]}}
{"id": "concept_real_time_system", "type": "V_concept", "name": "Real-Time System", "properties": {"description": "A computer system that is designed to respond to inputs and events in real-time, with a guaranteed response time.", "keywords": ["real", "time", "system", "responsive", "guaranteed"], "source_lectures": ["lecture_108102169_w1_l2"]}}
{"id": "concept_embedded_operating_system", "type": "V_concept", "name": "Embedded Operating System", "properties": {"description": "An operating system that is designed to run on embedded systems, with a focus on efficiency, reliability, and real-time performance.", "keywords": ["embedded", "operating", "system", "efficient", "reliable"], "source_lectures": ["lecture_108102169_w1_l2"]}}
{"id": "concept_device_driver", "type": "V_concept", "name": "Device Driver", "properties": {"description": "A software component that allows a computer to interact with a hardware device, such as a sensor or actuator.", "keywords": ["device", "driver", "software", "hardware", "interaction"], "source_lectures": ["lecture_108102169_w1_l2"]}}
{"id": "concept_sensor", "type": "V_concept", "name": "Sensor", "properties": {"description": "A device that detects and measures physical parameters, such as temperature, pressure, or light.", "keywords": ["sensor", "device", "detect", "measure", "physical"], "source_lectures": ["lecture_108102169_w1_l2"]}}
{"id": "concept_modular_approach", "type": "V_concept", "name": "Modular Approach", "properties": {"description": "A design approach that involves dividing a system into smaller, independent modules that can be easily integrated and modified.", "keywords": ["modular", "design", "approach", "system", "integration"], "source_lectures": ["lecture_108102169_w1_l3"]}}
{"id": "concept_embedded_system_design", "type": "V_concept", "name": "Embedded System Design", "properties": {"description": "The process of designing and developing computer systems that are embedded in other devices or systems, such as consumer electronics, medical devices, or industrial control systems.", "keywords": ["devices", "electronics", "computing", "embedded", "system", "design", "computer"], "source_lectures": ["lecture_108102169_w1_l3", "lecture_108102169_w4_l23", "lecture_108102169_w5_l35"]}}
{"id": "concept_general_purpose_processor", "type": "V_concept", "name": "General Purpose Processor", "properties": {"description": "A type of processor that can be used for a wide range of applications, such as personal computers, servers, and mobile devices.", "keywords": ["general", "purpose", "processor", "application", "computer"], "source_lectures": ["lecture_108102169_w1_l3"]}}
{"id": "concept_application_specific_processor", "type": "V_concept", "name": "Application Specific Processor", "properties": {"description": "A type of processor that is designed for a specific application or task, such as a digital signal processor or a graphics processing unit.", "keywords": ["application", "specific", "processor", "design", "task"], "source_lectures": ["lecture_108102169_w1_l3"]}}
{"id": "concept_single_purpose_computer", "type": "V_concept", "name": "Single Purpose Computer", "properties": {"description": "A computer that is designed to perform a single specific task, such as a traffic light controller or a microwave oven controller.", "keywords": ["purpose", "specific", "single", "embedded", "system", "controller", "task", "computer"], "source_lectures": ["lecture_108102169_w1_l3", "lecture_108102169_w6_l38", "lecture_108102169_w6_l39"]}}
{"id": "concept_time_to_market", "type": "V_concept", "name": "Time to Market", "properties": {"description": "The time it takes for a product to be developed and released to the market, from the initial concept to the final product launch.", "keywords": ["time", "market", "product", "development", "launch"], "source_lectures": ["lecture_108102169_w1_l3"]}}
{"id": "concept_system_cost", "type": "V_concept", "name": "System Cost", "properties": {"description": "The total cost of a system, including the cost of hardware, software, and maintenance, over its entire lifecycle.", "keywords": ["system", "cost", "hardware", "software", "maintenance"], "source_lectures": ["lecture_108102169_w1_l3"]}}
{"id": "concept_microcontroller_selection", "type": "V_concept", "name": "Microcontroller Selection", "properties": {"description": "The process of choosing a microcontroller that meets the requirements of a specific application or project, based on factors such as performance, power consumption, and cost.", "keywords": ["microcontroller", "selection", "application", "project", "performance"], "source_lectures": ["lecture_108102169_w1_l3"]}}
{"id": "concept_development_tools", "type": "V_concept", "name": "Development Tools", "properties": {"description": "Software and hardware tools used to design, develop, and test embedded systems, such as compilers, debuggers, and emulators.", "keywords": ["development", "tools", "software", "hardware", "compiler"], "source_lectures": ["lecture_108102169_w1_l3"]}}
{"id": "concept_memory_architecture", "type": "V_concept", "name": "Memory Architecture", "properties": {"description": "The organization and structure of a computer's memory system, including the types of memory, memory hierarchy, and memory management.", "keywords": ["memory", "architecture", "organization", "structure", "hierarchy"], "source_lectures": ["lecture_108102169_w1_l3"]}}
{"id": "concept_harvard_architecture", "type": "V_concept", "name": "Harvard Architecture", "properties": {"description": "A computer architecture that uses separate buses for data and instructions, with separate memory spaces for program and data, allowing for faster execution and improved performance.", "keywords": ["harvard", "architecture", "bus", "data", "instruction"], "source_lectures": ["lecture_108102169_w1_l3"]}}
{"id": "concept_digital_input", "type": "V_concept", "name": "Digital Input", "properties": {"description": "A pin or interface on a microcontroller that reads discrete logic levels (0 or 1) from external devices like switches or sensors.", "keywords": ["digital", "input", "microcontroller", "logic", "signal"], "source_lectures": ["lecture_108102169_w1_l5"]}}
{"id": "concept_digital_output", "type": "V_concept", "name": "Digital Output", "properties": {"description": "A pin or interface on a microcontroller that produces discrete logic levels (0 or 1) to control external devices like LEDs or relays.", "keywords": ["digital", "output", "microcontroller", "logic", "signal"], "source_lectures": ["lecture_108102169_w1_l5"]}}
{"id": "concept_digital_to_analog_converter_dac", "type": "V_concept", "name": "Digital-to-Analog Converter (DAC)", "properties": {"description": "A hardware component that converts digital values from a microcontroller into continuous analog voltage signals.", "keywords": ["dac", "digital", "analog", "converter", "voltage"], "source_lectures": ["lecture_108102169_w1_l5"]}}
{"id": "concept_pwm_pulse_width_modulation", "type": "V_concept", "name": "PWM (Pulse Width Modulation)", "properties": {"description": "A technique used to encode analog signal levels using digital pulses by varying the width of the pulse while keeping the frequency constant.", "keywords": ["duty cycle", "analog", "pulse", "modulation", "width", "pwm"], "source_lectures": ["lecture_108102169_w1_l5", "lecture_108102169_w5_l31"]}}
{"id": "concept_interrupt", "type": "V_concept", "name": "Interrupt", "properties": {"description": "A hardware or software mechanism that allows a microcontroller to respond asynchronously to external events without continuous polling.", "keywords": ["event", "signal", "processor", "asynchronous", "cpu", "interrupt", "microcontroller"], "source_lectures": ["lecture_108102169_w1_l5", "lecture_108102169_w1_l6", "lecture_108102169_w4_l26", "lecture_108102169_w5_l29"]}}
{"id": "concept_general_purpose_inputoutput_gpio", "type": "V_concept", "name": "General-Purpose Input/Output (GPIO)", "properties": {"description": "Programmable pins on a microcontroller that can be configured as either digital input or output based on software requirements.", "keywords": ["gpio", "general-purpose", "input", "output", "programmable"], "source_lectures": ["lecture_108102169_w1_l5"]}}
{"id": "concept_source_current", "type": "V_concept", "name": "Source Current", "properties": {"description": "The maximum current a microcontroller pin can supply to an external load when configured as a digital output in the high state.", "keywords": ["source", "current", "output", "microcontroller", "drive"], "source_lectures": ["lecture_108102169_w1_l5"]}}
{"id": "concept_sink_current", "type": "V_concept", "name": "Sink Current", "properties": {"description": "The maximum current a microcontroller pin can absorb from an external load when configured as a digital output in the low state.", "keywords": ["sink", "current", "output", "microcontroller", "drive"], "source_lectures": ["lecture_108102169_w1_l5"]}}
{"id": "concept_timercounter", "type": "V_concept", "name": "Timer/Counter", "properties": {"description": "A hardware module in a microcontroller that measures time intervals or counts external events for timing and synchronization tasks.", "keywords": ["timer", "counter", "time", "event", "microcontroller"], "source_lectures": ["lecture_108102169_w1_l5"]}}
{"id": "concept_serial_communication_interface", "type": "V_concept", "name": "Serial Communication Interface", "properties": {"description": "A hardware peripheral that enables a microcontroller to exchange data serially with other devices using protocols like UART, SPI, or I2C.", "keywords": ["serial", "communication", "uart", "spi", "i2c"], "source_lectures": ["lecture_108102169_w1_l5"]}}
{"id": "concept_internal_memory", "type": "V_concept", "name": "Internal Memory", "properties": {"description": "On-chip memory in a microcontroller used for storing program code (Flash/EEPROM) and runtime data (RAM).", "keywords": ["memory", "internal", "flash", "ram", "eeprom"], "source_lectures": ["lecture_108102169_w1_l5"]}}
{"id": "concept_external_memory_interface", "type": "V_concept", "name": "External Memory Interface", "properties": {"description": "A set of pins and control logic that allows a microcontroller to connect to and access external memory devices like SRAM or Flash.", "keywords": ["external", "memory", "interface", "sram", "flash"], "source_lectures": ["lecture_108102169_w1_l5"]}}
{"id": "concept_multi_plexed_pin", "type": "V_concept", "name": "Multi-Plexed Pin", "properties": {"description": "A microcontroller pin that can perform multiple functions (e.g., GPIO, ADC, UART) depending on software configuration.", "keywords": ["multiplexed", "pin", "function", "microcontroller", "configurable"], "source_lectures": ["lecture_108102169_w1_l5"]}}
{"id": "concept_voltage_reference", "type": "V_concept", "name": "Voltage Reference", "properties": {"description": "A stable voltage source used by an ADC or DAC to define the full-scale range of analog measurements or outputs.", "keywords": ["voltage", "reference", "adc", "dac", "stable"], "source_lectures": ["lecture_108102169_w1_l5"]}}
{"id": "concept_differential_amplifier", "type": "V_concept", "name": "Differential Amplifier", "properties": {"description": "An electronic circuit that amplifies the difference between two input voltages while rejecting common-mode signals.", "keywords": ["signal", "amplifier", "voltage", "op-amp", "differential", "difference"], "source_lectures": ["lecture_108102169_w1_l5", "lecture_106102229_w3_l21"]}}
{"id": "concept_current_sensing_resistor", "type": "V_concept", "name": "Current Sensing Resistor", "properties": {"description": "A low-value resistor placed in series with a current path to convert current into a measurable voltage drop for monitoring.", "keywords": ["current", "sensing", "resistor", "shunt", "voltage"], "source_lectures": ["lecture_108102169_w1_l5"]}}
{"id": "concept_resistor_divider", "type": "V_concept", "name": "Resistor Divider", "properties": {"description": "A circuit using two resistors in series to scale down a voltage to a level suitable for a microcontroller's ADC input.", "keywords": ["resistor", "divider", "voltage", "scale", "adc"], "source_lectures": ["lecture_108102169_w1_l5"]}}
{"id": "concept_microcontroller_architecture", "type": "V_concept", "name": "Microcontroller Architecture", "properties": {"description": "The structural design of a microcontroller, including CPU, memory, and bus systems, categorized as Harvard or Von Neumann.", "keywords": ["architecture", "microcontroller", "harvard", "von neumann", "cpu"], "source_lectures": ["lecture_108102169_w1_l5"]}}
{"id": "concept_cisc_architecture", "type": "V_concept", "name": "CISC Architecture", "properties": {"description": "A microprocessor design philosophy featuring a large, complex set of instructions to perform multi-step operations in a single command.", "keywords": ["cisc", "architecture", "instruction", "microcontroller", "processor"], "source_lectures": ["lecture_108102169_w1_l5"]}}
{"id": "concept_in_system_programming_isp", "type": "V_concept", "name": "In-System Programming (ISP)", "properties": {"description": "The ability to program or reprogram a microcontroller's memory while it is soldered onto the target circuit board.", "keywords": ["programming", "isp", "in-system", "system", "target", "microcontroller", "flash"], "source_lectures": ["lecture_108102169_w1_l5", "lecture_108102169_w2_l8"]}}
{"id": "concept_jtag_debug_interface", "type": "V_concept", "name": "JTAG Debug Interface", "properties": {"description": "A standardized hardware interface used for testing, debugging, and programming embedded microcontrollers via boundary scan.", "keywords": ["jtag", "debug", "interface", "programming", "microcontroller"], "source_lectures": ["lecture_108102169_w1_l5"]}}
{"id": "concept_serial_wire_debug_swd", "type": "V_concept", "name": "Serial Wire Debug (SWD)", "properties": {"description": "A two-pin debug interface used by ARM-based microcontrollers for programming and debugging, offering a simpler alternative to JTAG.", "keywords": ["swd", "debug", "serial", "wire", "arm"], "source_lectures": ["lecture_108102169_w1_l5"]}}
{"id": "concept_pin_multiplexing", "type": "V_concept", "name": "Pin Multiplexing", "properties": {"description": "The technique of assigning multiple functions to a single physical pin on a microcontroller to conserve pin count.", "keywords": ["pin", "multiplexing", "function", "microcontroller", "gpio"], "source_lectures": ["lecture_108102169_w1_l5"]}}
{"id": "concept_active_low_signal", "type": "V_concept", "name": "Active Low Signal", "properties": {"description": "A logic signal where the active or asserted state corresponds to a low voltage level (0), commonly used in reset or enable lines.", "keywords": ["active", "low", "signal", "logic", "microcontroller"], "source_lectures": ["lecture_108102169_w1_l5"]}}
{"id": "concept_active_high_signal", "type": "V_concept", "name": "Active High Signal", "properties": {"description": "A logic signal where the active or asserted state corresponds to a high voltage level (1), commonly used in control lines.", "keywords": ["active", "high", "signal", "logic", "microcontroller"], "source_lectures": ["lecture_108102169_w1_l5"]}}
{"id": "concept_tristate_pin", "type": "V_concept", "name": "Tristate Pin", "properties": {"description": "A digital pin that can be set to high, low, or high-impedance (disconnected) states to avoid bus conflicts.", "keywords": ["tristate", "pin", "high-impedance", "microcontroller", "bus"], "source_lectures": ["lecture_108102169_w1_l5"]}}
{"id": "concept_sram_static_random_access_memory", "type": "V_concept", "name": "SRAM (Static Random Access Memory)", "properties": {"description": "A type of volatile memory that retains its data as long as power is supplied, used for temporary storage of data in microcontrollers.", "keywords": ["sram", "volatile", "memory", "temporary"], "source_lectures": ["lecture_108102169_w1_l6"]}}
{"id": "concept_eeprom_electrically_erasable_programmable_read_only_memory", "type": "V_concept", "name": "EEPROM (Electrically Erasable Programmable Read-Only Memory)", "properties": {"description": "A type of non-volatile memory that can be erased and reprogrammed electrically, used to store configuration data and programs in microcontrollers.", "keywords": ["eeprom", "non-volatile", "reprogrammable"], "source_lectures": ["lecture_108102169_w1_l6"]}}
{"id": "concept_clock_signal", "type": "V_concept", "name": "Clock Signal", "properties": {"description": "A periodic signal used to synchronize the operation of a microcontroller, generated by an internal or external clock source.", "keywords": ["synchronize", "signal", "periodic", "synchronization", "clock", "microcontroller"], "source_lectures": ["lecture_108102169_w1_l6", "lecture_108102169_w1_l7", "lecture_108102169_w5_l29"]}}
{"id": "concept_power_management", "type": "V_concept", "name": "Power Management", "properties": {"description": "The process of controlling and managing the power consumption of a microcontroller, used to minimize power usage and prolong battery life.", "keywords": ["power", "management", "consumption", "microcontroller"], "source_lectures": ["lecture_108102169_w1_l6"]}}
{"id": "concept_adc_analog_to_digital_converter", "type": "V_concept", "name": "ADC (Analog-to-Digital Converter)", "properties": {"description": "A peripheral that converts analog signals to digital signals, used to interface with analog sensors and devices in microcontrollers.", "keywords": ["adc", "analog", "digital", "converter"], "source_lectures": ["lecture_108102169_w1_l6"]}}
{"id": "concept_dac_digital_to_analog_converter", "type": "V_concept", "name": "DAC (Digital-to-Analog Converter)", "properties": {"description": "A peripheral that converts digital signals to analog signals, used to interface with analog devices and actuators in microcontrollers.", "keywords": ["dac", "digital", "analog", "converter"], "source_lectures": ["lecture_108102169_w1_l6"]}}
{"id": "concept_uart_universal_asynchronous_receiver_transmitter", "type": "V_concept", "name": "UART (Universal Asynchronous Receiver-Transmitter)", "properties": {"description": "A peripheral that provides asynchronous serial communication, used for communication between microcontrollers and other devices.", "keywords": ["uart", "asynchronous", "serial", "communication"], "source_lectures": ["lecture_108102169_w1_l6"]}}
{"id": "concept_spi_serial_peripheral_interface", "type": "V_concept", "name": "SPI (Serial Peripheral Interface)", "properties": {"description": "A peripheral that provides synchronous serial communication, used for communication between microcontrollers and other devices.", "keywords": ["spi", "synchronous", "serial", "communication"], "source_lectures": ["lecture_108102169_w1_l6"]}}
{"id": "concept_i2c_inter_integrated_circuit", "type": "V_concept", "name": "I2C (Inter-Integrated Circuit)", "properties": {"description": "A peripheral that provides synchronous serial communication, used for communication between microcontrollers and other devices.", "keywords": ["i2c", "synchronous", "serial", "communication"], "source_lectures": ["lecture_108102169_w1_l6"]}}
{"id": "concept_jtag_joint_test_action_group", "type": "V_concept", "name": "JTAG (Joint Test Action Group)", "properties": {"description": "A standard for testing and debugging microcontrollers, used for boundary scan testing and debugging.", "keywords": ["jtag", "testing", "debugging", "boundary", "scan"], "source_lectures": ["lecture_108102169_w1_l6"]}}
{"id": "concept_on_chip_debugging", "type": "V_concept", "name": "On-Chip Debugging", "properties": {"description": "The process of debugging a microcontroller using on-chip debugging tools and techniques, used to identify and fix errors in the code.", "keywords": ["on-chip", "debugging", "microcontroller", "code"], "source_lectures": ["lecture_108102169_w1_l6"]}}
{"id": "concept_microcontroller_ecosystem", "type": "V_concept", "name": "Microcontroller Ecosystem", "properties": {"description": "The environment and components required for a microcontroller to operate effectively.", "keywords": ["microcontroller", "ecosystem", "embedded", "system"], "source_lectures": ["lecture_108102169_w1_l7"]}}
{"id": "concept_synchronous_sequential_circuits", "type": "V_concept", "name": "Synchronous Sequential Circuits", "properties": {"description": "Digital circuits that use a clock signal to synchronize their operations and are commonly used in microcontrollers.", "keywords": ["synchronous", "sequential", "circuits", "digital", "microcontroller"], "source_lectures": ["lecture_108102169_w1_l7"]}}
{"id": "concept_asynchronous_sequential_circuits", "type": "V_concept", "name": "Asynchronous Sequential Circuits", "properties": {"description": "Digital circuits that do not use a clock signal to synchronize their operations and are less common in microcontrollers due to their complexity.", "keywords": ["asynchronous", "sequential", "circuits", "digital", "complexity"], "source_lectures": ["lecture_108102169_w1_l7"]}}
{"id": "concept_clock_frequency", "type": "V_concept", "name": "Clock Frequency", "properties": {"description": "The rate at which a clock signal oscillates, measured in Hertz (Hz).", "keywords": ["signal", "oscillation", "hertz", "clock", "speed", "rate", "microcontroller", "execution", "frequency"], "source_lectures": ["lecture_108102169_w1_l7", "lecture_108102169_w2_l8", "lecture_106103359_w1_l7"]}}
{"id": "concept_power_consumption", "type": "V_concept", "name": "Power Consumption", "properties": {"description": "The amount of power used by a microcontroller or other electronic device, often affected by clock frequency.", "keywords": ["power", "device", "system", "consumption", "clock", "energy", "microcontroller", "frequency"], "source_lectures": ["lecture_108102169_w1_l7", "lecture_108102169_w2_l10"]}}
{"id": "concept_555_timer_ic", "type": "V_concept", "name": "555 Timer IC", "properties": {"description": "A popular integrated circuit used to generate clock signals and other timing functions in electronic circuits.", "keywords": ["555", "timer", "ic", "clock", "signal"], "source_lectures": ["lecture_108102169_w1_l7"]}}
{"id": "concept_rc_oscillator", "type": "V_concept", "name": "RC Oscillator", "properties": {"description": "A type of oscillator that uses a resistor and capacitor to generate a clock signal.", "keywords": ["rc", "oscillator", "resistor", "capacitor", "clock"], "source_lectures": ["lecture_108102169_w1_l7"]}}
{"id": "concept_crystal_oscillator", "type": "V_concept", "name": "Crystal Oscillator", "properties": {"description": "A type of oscillator that uses a crystal to generate a highly stable and accurate clock signal.", "keywords": ["oscillator", "crystal", "signal", "stable", "accurate", "clock", "frequency"], "source_lectures": ["lecture_108102169_w1_l7", "lecture_108102169_w5_l32"]}}
{"id": "concept_real_time_clock_rtc", "type": "V_concept", "name": "Real-Time Clock (RTC)", "properties": {"description": "A clock that keeps track of the current time and is often used in microcontrollers and other electronic devices.", "keywords": ["real-time", "clock", "rtc", "time", "microcontroller"], "source_lectures": ["lecture_108102169_w1_l7"]}}
{"id": "concept_temperature_compensation", "type": "V_concept", "name": "Temperature Compensation", "properties": {"description": "A technique used to minimize the effects of temperature on the accuracy of a clock signal or other electronic circuit.", "keywords": ["temperature", "compensation", "clock", "accuracy", "circuit"], "source_lectures": ["lecture_108102169_w1_l7"]}}
{"id": "concept_sampling_theorem", "type": "V_concept", "name": "Sampling Theorem", "properties": {"description": "A fundamental concept in signal processing that describes the conditions under which a continuous-time signal can be reconstructed from its samples.", "keywords": ["sampling", "theorem", "signal", "processing", "reconstruction"], "source_lectures": ["lecture_108102169_w2_l8"]}}
{"id": "concept_nyquist_rate", "type": "V_concept", "name": "Nyquist Rate", "properties": {"description": "The minimum sampling rate required to accurately reconstruct a continuous-time signal, equal to twice the highest frequency component of the signal.", "keywords": ["aliasing", "nyquist", "reconstruction", "rate", "sampling", "frequency"], "source_lectures": ["lecture_108102169_w2_l8", "lecture_108102169_w5_l31"]}}
{"id": "concept_instruction_cycle", "type": "V_concept", "name": "Instruction Cycle", "properties": {"description": "The time it takes for a microcontroller to fetch, decode, and execute a single instruction.", "keywords": ["instruction", "cycle", "microcontroller", "fetch", "decode", "execute"], "source_lectures": ["lecture_108102169_w2_l8"]}}
{"id": "concept_reset_signal", "type": "V_concept", "name": "Reset Signal", "properties": {"description": "A signal that resets a microcontroller's internal state, often used to initialize or recover from errors.", "keywords": ["reset", "signal", "microcontroller", "internal", "state", "initialize", "error"], "source_lectures": ["lecture_108102169_w2_l8"]}}
{"id": "concept_brownout_detector", "type": "V_concept", "name": "Brownout Detector", "properties": {"description": "A circuit that detects when the supply voltage drops below a certain threshold, often used to prevent data corruption or system malfunction.", "keywords": ["brownout", "detector", "voltage", "threshold", "data", "corruption", "malfunction"], "source_lectures": ["lecture_108102169_w2_l8"]}}
{"id": "concept_power_supply_design", "type": "V_concept", "name": "Power Supply Design", "properties": {"description": "The process of designing a power supply system that meets the voltage and current requirements of a microcontroller and its peripherals.", "keywords": ["power", "requirements", "peripherals", "voltage", "supply", "design", "current", "microcontroller"], "source_lectures": ["lecture_108102169_w2_l8", "lecture_108102169_w2_l9"]}}
{"id": "concept_power_supply", "type": "V_concept", "name": "Power Supply", "properties": {"description": "A component that supplies power to a circuit or device.", "keywords": ["power", "device", "supply", "circuit", "electrical"], "source_lectures": ["lecture_108102169_w2_l9", "lecture_108102169_w2_l10"]}}
{"id": "concept_voltage_regulation", "type": "V_concept", "name": "Voltage Regulation", "properties": {"description": "The process of maintaining a constant voltage level in a power supply despite changes in load current or input voltage.", "keywords": ["voltage", "regulation", "power", "supply"], "source_lectures": ["lecture_108102169_w2_l9"]}}
{"id": "concept_linear_voltage_regulator", "type": "V_concept", "name": "Linear Voltage Regulator", "properties": {"description": "A type of voltage regulator that uses a linear circuit to regulate the output voltage.", "keywords": ["linear", "voltage", "regulator", "circuit"], "source_lectures": ["lecture_108102169_w2_l9"]}}
{"id": "concept_switch_mode_power_supply", "type": "V_concept", "name": "Switch-Mode Power Supply", "properties": {"description": "A type of power supply that uses a switching circuit to regulate the output voltage.", "keywords": ["power", "electronics", "switch-mode", "supply", "circuit"], "source_lectures": ["lecture_108102169_w2_l9", "lecture_108102169_w2_l10"]}}
{"id": "concept_transformer", "type": "V_concept", "name": "Transformer", "properties": {"description": "A component that transfers electrical energy from one circuit to another through electromagnetic induction.", "keywords": ["transformer", "electromagnetic", "induction", "circuit"], "source_lectures": ["lecture_108102169_w2_l9"]}}
{"id": "concept_zener_diode", "type": "V_concept", "name": "Zener Diode", "properties": {"description": "A type of diode that regulates voltage by breaking down at a specific voltage level.", "keywords": ["zener", "diode", "voltage", "regulation"], "source_lectures": ["lecture_108102169_w2_l9"]}}
{"id": "concept_voltage_drop", "type": "V_concept", "name": "Voltage Drop", "properties": {"description": "The decrease in voltage that occurs when current flows through a resistor or other component.", "keywords": ["resistor", "drop", "component", "voltage", "circuit", "decrease", "current"], "source_lectures": ["lecture_108102169_w2_l9", "lecture_108102169_w3_l17"]}}
{"id": "concept_quiescent_current", "type": "V_concept", "name": "Quiescent Current", "properties": {"description": "The current that flows through a circuit when it is in a steady-state condition.", "keywords": ["quiescent", "current", "circuit", "steady-state"], "source_lectures": ["lecture_108102169_w2_l9"]}}
{"id": "concept_op_amp", "type": "V_concept", "name": "Op-Amp", "properties": {"description": "A type of amplifier that uses operational amplifiers to regulate voltage.", "keywords": ["op-amp", "amplifier", "voltage", "regulation"], "source_lectures": ["lecture_108102169_w2_l9"]}}
{"id": "concept_voltage_regulator", "type": "V_concept", "name": "Voltage Regulator", "properties": {"description": "A device that regulates the voltage of an electrical power supply.", "keywords": ["voltage", "regulator", "power", "supply", "electrical"], "source_lectures": ["lecture_108102169_w2_l10"]}}
{"id": "concept_battery_management", "type": "V_concept", "name": "Battery Management", "properties": {"description": "The process of controlling and maintaining the state of a battery.", "keywords": ["battery", "management", "control", "maintenance", "power"], "source_lectures": ["lecture_108102169_w2_l10"]}}
{"id": "concept_linear_regulator", "type": "V_concept", "name": "Linear Regulator", "properties": {"description": "A type of voltage regulator that uses a linear circuit to regulate the output voltage.", "keywords": ["linear", "regulator", "voltage", "circuit", "electronics"], "source_lectures": ["lecture_108102169_w2_l10"]}}
{"id": "concept_low_power_mode", "type": "V_concept", "name": "Low Power Mode", "properties": {"description": "A mode of operation that reduces the power consumption of a device or system.", "keywords": ["power", "operation", "low", "mode", "consumption", "energy"], "source_lectures": ["lecture_108102169_w2_l10", "lecture_108102169_w5_l32"]}}
{"id": "concept_sleep_mode", "type": "V_concept", "name": "Sleep Mode", "properties": {"description": "A mode of operation that reduces the power consumption of a device or system by putting it into a low-power state.", "keywords": ["sleep", "mode", "operation", "power", "energy"], "source_lectures": ["lecture_108102169_w2_l10"]}}
{"id": "concept_inputoutput_devices", "type": "V_concept", "name": "Input/Output Devices", "properties": {"description": "Hardware components that allow a computer to interact with the outside world, such as keyboards, displays, and sensors.", "keywords": ["input", "output", "devices", "hardware", "computer"], "source_lectures": ["lecture_108102169_w3_l16"]}}
{"id": "concept_dc_voltage", "type": "V_concept", "name": "DC Voltage", "properties": {"description": "A type of electric potential difference that remains constant over time.", "keywords": ["dc", "voltage", "electric", "potential", "difference"], "source_lectures": ["lecture_108102169_w3_l16"]}}
{"id": "concept_led_control", "type": "V_concept", "name": "LED Control", "properties": {"description": "The process of regulating the operation of light-emitting diodes using electronic circuits or microcontrollers.", "keywords": ["led", "control", "electronic", "circuits", "microcontrollers"], "source_lectures": ["lecture_108102169_w3_l16"]}}
{"id": "concept_dc_motor_control", "type": "V_concept", "name": "DC Motor Control", "properties": {"description": "The process of regulating the speed and direction of a direct current motor using electronic circuits or microcontrollers.", "keywords": ["dc", "motor", "control", "electronic", "circuits"], "source_lectures": ["lecture_108102169_w3_l16"]}}
{"id": "concept_bluetooth_technology", "type": "V_concept", "name": "Bluetooth Technology", "properties": {"description": "A wireless personal area network technology that allows devices to communicate with each other over short distances.", "keywords": ["bluetooth", "wireless", "personal", "area", "network"], "source_lectures": ["lecture_108102169_w3_l16"]}}
{"id": "concept_rotary_encoder", "type": "V_concept", "name": "Rotary Encoder", "properties": {"description": "A type of sensor that converts the rotation of a shaft into a digital signal.", "keywords": ["rotary", "encoder", "sensor", "rotation", "digital"], "source_lectures": ["lecture_108102169_w3_l16"]}}
{"id": "concept_atm_machine", "type": "V_concept", "name": "ATM Machine", "properties": {"description": "An automated teller machine that allows users to perform financial transactions using a card and PIN.", "keywords": ["atm", "machine", "automated", "teller", "financial"], "source_lectures": ["lecture_108102169_w3_l16"]}}
{"id": "concept_programming_language", "type": "V_concept", "name": "Programming Language", "properties": {"description": "A formal language that allows users to write instructions that a computer can execute.", "keywords": ["programming", "language", "formal", "instructions", "computer"], "source_lectures": ["lecture_108102169_w3_l16"]}}
{"id": "concept_led_driver_circuit", "type": "V_concept", "name": "Led Driver Circuit", "properties": {"description": "A circuit that controls the current flowing through an LED to prevent damage and ensure efficient operation.", "keywords": ["led", "driver", "circuit", "current", "control"], "source_lectures": ["lecture_108102169_w3_l17"]}}
{"id": "concept_high_side_control", "type": "V_concept", "name": "High Side Control", "properties": {"description": "A method of controlling an LED by connecting the resistor to the positive side of the power supply.", "keywords": ["high", "side", "control", "led", "resistor"], "source_lectures": ["lecture_108102169_w3_l17"]}}
{"id": "concept_low_side_control", "type": "V_concept", "name": "Low Side Control", "properties": {"description": "A method of controlling an LED by connecting the resistor to the negative side of the power supply.", "keywords": ["low", "side", "control", "led", "resistor"], "source_lectures": ["lecture_108102169_w3_l17"]}}
{"id": "concept_seven_segment_display", "type": "V_concept", "name": "Seven Segment Display", "properties": {"description": "A display device that shows numerical digits using seven LED segments.", "keywords": ["crystal", "digits", "display", "seven", "segment", "led", "liquid"], "source_lectures": ["lecture_108102169_w3_l17", "lecture_108102169_w4_l27"]}}
{"id": "concept_common_anode", "type": "V_concept", "name": "Common Anode", "properties": {"description": "A type of seven segment display where all the anodes of the LEDs are connected together.", "keywords": ["anode", "common", "display", "seven", "segment", "led"], "source_lectures": ["lecture_108102169_w3_l17", "lecture_108102169_w4_l27"]}}
{"id": "concept_common_cathode", "type": "V_concept", "name": "Common Cathode", "properties": {"description": "A type of seven segment display where all the cathodes of the LEDs are connected together.", "keywords": ["cathode", "common", "display", "seven", "segment", "led"], "source_lectures": ["lecture_108102169_w3_l17", "lecture_108102169_w4_l27"]}}
{"id": "concept_transistor", "type": "V_concept", "name": "Transistor", "properties": {"description": "A semiconductor device used to amplify or switch electronic signals.", "keywords": ["transistor", "semiconductor", "amplify", "switch", "electronic"], "source_lectures": ["lecture_108102169_w3_l17"]}}
{"id": "concept_npn_transistor", "type": "V_concept", "name": "NPN Transistor", "properties": {"description": "A type of transistor where the base is made of a p-type material and the collector and emitter are made of n-type material.", "keywords": ["p-type", "negative", "npn", "transistor", "n-type", "base", "positive"], "source_lectures": ["lecture_108102169_w3_l17", "lecture_108102169_w3_l18"]}}
{"id": "concept_saturation_region", "type": "V_concept", "name": "Saturation Region", "properties": {"description": "The region of operation where the transistor is fully turned on and the collector current is maximum.", "keywords": ["saturation", "region", "transistor", "fully", "turned"], "source_lectures": ["lecture_108102169_w3_l17"]}}
{"id": "concept_base_emitter_voltage", "type": "V_concept", "name": "Base Emitter Voltage", "properties": {"description": "The voltage between the base and emitter of a transistor.", "keywords": ["base", "emitter", "voltage", "transistor"], "source_lectures": ["lecture_108102169_w3_l17"]}}
{"id": "concept_collector_emitter_voltage", "type": "V_concept", "name": "Collector Emitter Voltage", "properties": {"description": "The voltage between the collector and emitter of a transistor.", "keywords": ["collector", "emitter", "voltage", "transistor"], "source_lectures": ["lecture_108102169_w3_l17"]}}
{"id": "concept_resistor_value_calculation", "type": "V_concept", "name": "Resistor Value Calculation", "properties": {"description": "The process of calculating the value of a resistor needed for a particular circuit.", "keywords": ["resistor", "value", "calculation", "circuit"], "source_lectures": ["lecture_108102169_w3_l17"]}}
{"id": "concept_current_limiting_resistor", "type": "V_concept", "name": "Current Limiting Resistor", "properties": {"description": "A resistor used to limit the current flowing through a circuit or component.", "keywords": ["resistor", "component", "limiting", "circuit", "current", "led"], "source_lectures": ["lecture_108102169_w3_l17", "lecture_108102169_w3_l18"]}}
{"id": "concept_power_dissipation", "type": "V_concept", "name": "Power Dissipation", "properties": {"description": "The amount of power dissipated by a component or circuit.", "keywords": ["power", "dissipation", "component", "circuit"], "source_lectures": ["lecture_108102169_w3_l17"]}}
{"id": "concept_low_side_switching", "type": "V_concept", "name": "Low Side Switching", "properties": {"description": "A method of controlling an LED by switching the low side of the circuit.", "keywords": ["low", "side", "switching", "led", "control"], "source_lectures": ["lecture_108102169_w3_l18"]}}
{"id": "concept_transistor_saturation", "type": "V_concept", "name": "Transistor Saturation", "properties": {"description": "A state in which a transistor is fully turned on, allowing maximum current to flow.", "keywords": ["collector-emitter voltage", "saturation", "transistor", "fully on", "switch mode", "transistor on", "current", "flow"], "source_lectures": ["lecture_108102169_w3_l18", "lecture_108102169_w3_l19"]}}
{"id": "concept_base_current", "type": "V_concept", "name": "Base Current", "properties": {"description": "The current that flows into the base of a transistor.", "keywords": ["base", "current", "transistor"], "source_lectures": ["lecture_108102169_w3_l18"]}}
{"id": "concept_emitter_follower", "type": "V_concept", "name": "Emitter Follower", "properties": {"description": "A circuit configuration in which the emitter of a transistor is connected to the output.", "keywords": ["emitter", "follower", "transistor", "circuit"], "source_lectures": ["lecture_108102169_w3_l18"]}}
{"id": "concept_high_side_switching", "type": "V_concept", "name": "High Side Switching", "properties": {"description": "A method of controlling an LED by switching the high side of the circuit.", "keywords": ["high", "side", "switching", "led", "control"], "source_lectures": ["lecture_108102169_w3_l18"]}}
{"id": "concept_pnp_transistor", "type": "V_concept", "name": "PNP Transistor", "properties": {"description": "A type of transistor with a positive-negative-positive structure.", "keywords": ["switching", "negative", "negative logic", "transistor", "bipolar transistor", "pnp", "pnp transistor", "current flow", "positive"], "source_lectures": ["lecture_108102169_w3_l18", "lecture_108102169_w3_l19"]}}
{"id": "concept_stable_current_source", "type": "V_concept", "name": "Stable Current Source", "properties": {"description": "A circuit that provides a stable current to a load, regardless of changes in supply voltage.", "keywords": ["stable", "current", "source", "load", "voltage"], "source_lectures": ["lecture_108102169_w3_l18"]}}
{"id": "concept_multiplexing", "type": "V_concept", "name": "Multiplexing", "properties": {"description": "A technique used to control multiple devices using a limited number of pins.", "keywords": ["devices", "control", "display", "seven", "pins", "multiplexing", "segment"], "source_lectures": ["lecture_108102169_w3_l18", "lecture_108102169_w4_l27"]}}
{"id": "concept_persistence_of_vision", "type": "V_concept", "name": "Persistence of Vision", "properties": {"description": "The phenomenon by which the human eye retains an image for a short period of time after it has disappeared.", "keywords": ["persistence", "vision", "human", "eye", "image"], "source_lectures": ["lecture_108102169_w3_l18"]}}
{"id": "concept_anode_driver_circuit", "type": "V_concept", "name": "Anode Driver Circuit", "properties": {"description": "A circuit used to drive the anode of an LED or other device.", "keywords": ["anode", "driver", "circuit", "led"], "source_lectures": ["lecture_108102169_w3_l18"]}}
{"id": "concept_cathode_driver_circuit", "type": "V_concept", "name": "Cathode Driver Circuit", "properties": {"description": "A circuit used to drive the cathode of an LED or other device.", "keywords": ["cathode", "driver", "circuit", "led"], "source_lectures": ["lecture_108102169_w3_l18"]}}
{"id": "concept_uln2003", "type": "V_concept", "name": "ULN2003", "properties": {"description": "A type of integrated circuit used as a low-side driver.", "keywords": ["uln2003", "integrated", "circuit", "low-side", "driver"], "source_lectures": ["lecture_108102169_w3_l18"]}}
{"id": "concept_udn2981", "type": "V_concept", "name": "UDN2981", "properties": {"description": "A type of integrated circuit used as a high-side driver.", "keywords": ["udn2981", "integrated", "circuit", "high-side", "driver"], "source_lectures": ["lecture_108102169_w3_l18"]}}
{"id": "concept_bc547_transistor", "type": "V_concept", "name": "BC547 Transistor", "properties": {"description": "An NPN bipolar junction transistor commonly used for switching and amplification in electronic circuits.", "keywords": ["bc547", "npn transistor", "bipolar junction transistor", "switching", "amplification"], "source_lectures": ["lecture_108102169_w3_l19"]}}
{"id": "concept_led_current_limiting_resistor", "type": "V_concept", "name": "LED Current Limiting Resistor", "properties": {"description": "A resistor placed in series with an LED to limit the current flowing through it and prevent damage.", "keywords": ["led", "current limiting", "resistor", "series resistor", "led protection"], "source_lectures": ["lecture_108102169_w3_l19"]}}
{"id": "concept_transistor_base_current", "type": "V_concept", "name": "Transistor Base Current", "properties": {"description": "The small current flowing into the base terminal of a transistor that controls the larger collector current.", "keywords": ["base current", "transistor", "ib", "current control", "bipolar transistor"], "source_lectures": ["lecture_108102169_w3_l19"]}}
{"id": "concept_transistor_collector_current", "type": "V_concept", "name": "Transistor Collector Current", "properties": {"description": "The larger current flowing from the collector to the emitter terminal of a transistor, controlled by the base current.", "keywords": ["collector current", "ic", "transistor", "current gain", "bipolar transistor"], "source_lectures": ["lecture_108102169_w3_l19"]}}
{"id": "concept_current_gain_beta_of_transistor", "type": "V_concept", "name": "Current Gain (Beta) of Transistor", "properties": {"description": "The ratio of collector current to base current in a bipolar transistor, indicating its current amplification capability.", "keywords": ["beta", "current gain", "hfe", "transistor gain", "ic/ib"], "source_lectures": ["lecture_108102169_w3_l19"]}}
{"id": "concept_microcontroller_output_voltage", "type": "V_concept", "name": "Microcontroller Output Voltage", "properties": {"description": "The voltage level produced by a microcontroller's digital output pin, typically 3.3V or 5V in embedded systems.", "keywords": ["microcontroller", "output voltage", "gpio", "digital output", "3.3v"], "source_lectures": ["lecture_108102169_w3_l19"]}}
{"id": "concept_led_forward_voltage", "type": "V_concept", "name": "LED Forward Voltage", "properties": {"description": "The voltage drop across an LED when it is conducting current in the forward direction, typically 1.6V to 3.3V depending on color.", "keywords": ["led", "forward voltage", "vfd", "voltage drop", "led specification"], "source_lectures": ["lecture_108102169_w3_l19"]}}
{"id": "concept_voltage_divider_circuit", "type": "V_concept", "name": "Voltage Divider Circuit", "properties": {"description": "A passive linear circuit that produces an output voltage that is a fraction of its input voltage using two resistors in series.", "keywords": ["voltage divider", "resistor divider", "voltage reduction", "r1 r2", "biasing"], "source_lectures": ["lecture_108102169_w3_l19"]}}
{"id": "concept_microcontroller_driving_external_load", "type": "V_concept", "name": "Microcontroller Driving External Load", "properties": {"description": "The practice of using a microcontroller to control higher-power devices (like LEDs or motors) through transistors or drivers due to limited I/O current.", "keywords": ["microcontroller", "external load", "driver circuit", "current limitation", "gpio driver"], "source_lectures": ["lecture_108102169_w3_l19"]}}
{"id": "concept_transistor_switching_mode", "type": "V_concept", "name": "Transistor Switching Mode", "properties": {"description": "The operation of a transistor as a switch, biased either in cutoff (off) or saturation (on) to control power to a load.", "keywords": ["transistor switch", "switching mode", "saturation", "cutoff", "digital control"], "source_lectures": ["lecture_108102169_w3_l19"]}}
{"id": "concept_dc_motor_speed_control", "type": "V_concept", "name": "DC Motor Speed Control", "properties": {"description": "The method of regulating the rotational speed of a DC motor by varying the voltage applied across its terminals.", "keywords": ["dc motor", "speed control", "voltage control", "motor driver", "pwm"], "source_lectures": ["lecture_108102169_w3_l19"]}}
{"id": "concept_microcontroller_power_supply_voltage", "type": "V_concept", "name": "Microcontroller Power Supply Voltage", "properties": {"description": "The operating voltage required by a microcontroller to function correctly, commonly 3.3V or 5V in embedded systems.", "keywords": ["microcontroller supply", "vcc", "power voltage", "3.3v", "5v"], "source_lectures": ["lecture_108102169_w3_l19"]}}
{"id": "concept_base_emitter_voltage_drop", "type": "V_concept", "name": "Base-Emitter Voltage Drop", "properties": {"description": "The voltage difference between the base and emitter terminals of a bipolar transistor when forward-biased, typically around 0.7V.", "keywords": ["vbe", "base emitter voltage", "voltage drop", "transistor bias", "0.7v"], "source_lectures": ["lecture_108102169_w3_l19"]}}
{"id": "concept_resistor_value_calculation_for_led_circuit", "type": "V_concept", "name": "Resistor Value Calculation for LED Circuit", "properties": {"description": "The process of determining the appropriate resistor value to limit current through an LED using Ohm\u2019s Law and LED specifications.", "keywords": ["led resistor", "ohm's law", "current calculation", "resistor value", "led circuit design"], "source_lectures": ["lecture_108102169_w3_l19"]}}
{"id": "concept_logic_level_translation", "type": "V_concept", "name": "Logic Level Translation", "properties": {"description": "The process of converting signal voltage levels between different logic families or components, such as microcontroller outputs to transistor inputs.", "keywords": ["logic level", "voltage translation", "level shifter", "microcontroller interface", "ttl"], "source_lectures": ["lecture_108102169_w3_l19"]}}
{"id": "concept_collector_resistor", "type": "V_concept", "name": "Collector Resistor", "properties": {"description": "A resistor connected between the collector of a transistor and the power supply to limit current and set operating point.", "keywords": ["collector resistor", "rc", "current limiting", "transistor bias", "load resistor"], "source_lectures": ["lecture_108102169_w3_l19"]}}
{"id": "concept_ground_reference_in_circuit_design", "type": "V_concept", "name": "Ground Reference in Circuit Design", "properties": {"description": "The common reference point in a circuit to which all voltages are measured, essential for proper transistor and component operation.", "keywords": ["ground", "reference point", "circuit ground", "common return", "voltage reference"], "source_lectures": ["lecture_108102169_w3_l19"]}}
{"id": "concept_transistor_as_current_amplifier", "type": "V_concept", "name": "Transistor as Current Amplifier", "properties": {"description": "The use of a transistor to amplify a small input current at the base into a larger output current at the collector.", "keywords": ["current amplifier", "transistor amplification", "beta gain", "ib to ic", "signal amplification"], "source_lectures": ["lecture_108102169_w3_l19"]}}
{"id": "concept_switch_interfacing", "type": "V_concept", "name": "Switch Interfacing", "properties": {"description": "The process of connecting and controlling switches with a microcontroller.", "keywords": ["switch", "interfacing", "microcontroller", "control"], "source_lectures": ["lecture_108102169_w4_l23"]}}
{"id": "concept_digital_io", "type": "V_concept", "name": "Digital I/O", "properties": {"description": "A type of input/output operation where digital signals are used to interact with external devices.", "keywords": ["digital", "i/o", "input/output", "signals"], "source_lectures": ["lecture_108102169_w4_l23"]}}
{"id": "concept_internal_pull_up_register", "type": "V_concept", "name": "Internal Pull-up Register", "properties": {"description": "A register that controls the internal pull-up resistors of a microcontroller's input/output pins.", "keywords": ["internal", "pull-up", "register", "microcontroller", "resistors"], "source_lectures": ["lecture_108102169_w4_l23"]}}
{"id": "concept_led_toggle", "type": "V_concept", "name": "LED Toggle", "properties": {"description": "A technique used to switch an LED on and off using a microcontroller.", "keywords": ["led", "toggle", "microcontroller", "switch"], "source_lectures": ["lecture_108102169_w4_l23"]}}
{"id": "concept_register_configuration", "type": "V_concept", "name": "Register Configuration", "properties": {"description": "The process of setting up and configuring registers in a microcontroller to achieve a specific functionality.", "keywords": ["register", "configuration", "microcontroller", "functionality"], "source_lectures": ["lecture_108102169_w4_l23"]}}
{"id": "concept_inputoutput_ports", "type": "V_concept", "name": "Input/Output Ports", "properties": {"description": "Ports on a microcontroller that are used for input/output operations.", "keywords": ["input/output", "ports", "microcontroller"], "source_lectures": ["lecture_108102169_w4_l23"]}}
{"id": "concept_switch_debouncing", "type": "V_concept", "name": "Switch Debouncing", "properties": {"description": "A technique used to eliminate noise and false triggers in switch inputs.", "keywords": ["switch", "debouncing", "noise", "false triggers"], "source_lectures": ["lecture_108102169_w4_l23"]}}
{"id": "concept_microcontroller_programming", "type": "V_concept", "name": "Microcontroller Programming", "properties": {"description": "The process of writing and loading software into a microcontroller to control its behavior.", "keywords": ["microcontroller", "programming", "software", "control"], "source_lectures": ["lecture_108102169_w4_l23"]}}
{"id": "concept_interrupt_priority", "type": "V_concept", "name": "Interrupt Priority", "properties": {"description": "A mechanism to determine which interrupt should be handled first when multiple interrupts occur simultaneously.", "keywords": ["interrupt", "priority", "mechanism", "handling"], "source_lectures": ["lecture_108102169_w4_l26"]}}
{"id": "concept_vector_table", "type": "V_concept", "name": "Vector Table", "properties": {"description": "A table that maps interrupt numbers to their corresponding interrupt service routines.", "keywords": ["vector", "table", "interrupt", "routine"], "source_lectures": ["lecture_108102169_w4_l26"]}}
{"id": "concept_interrupt_service_routine_isr", "type": "V_concept", "name": "Interrupt Service Routine (ISR)", "properties": {"description": "A routine that handles a specific interrupt and performs the necessary actions.", "keywords": ["interrupt", "service", "routine", "handling"], "source_lectures": ["lecture_108102169_w4_l26"]}}
{"id": "concept_context_switching", "type": "V_concept", "name": "Context Switching", "properties": {"description": "The process of switching between different tasks or processes, saving and restoring the context of each task.", "keywords": ["context", "switching", "task", "process"], "source_lectures": ["lecture_108102169_w4_l26"]}}
{"id": "concept_interrupt_flag", "type": "V_concept", "name": "Interrupt Flag", "properties": {"description": "A flag that indicates whether interrupts are enabled or disabled.", "keywords": ["interrupt", "flag", "enabled", "disabled"], "source_lectures": ["lecture_108102169_w4_l26"]}}
{"id": "concept_interfacing", "type": "V_concept", "name": "Interfacing", "properties": {"description": "The process of connecting and communicating between different devices, such as microcontrollers and displays.", "keywords": ["interfacing", "microcontroller", "display", "communication"], "source_lectures": ["lecture_108102169_w4_l27"]}}
{"id": "concept_interrupts", "type": "V_concept", "name": "Interrupts", "properties": {"description": "A signal to the microcontroller that an event has occurred and requires immediate attention.", "keywords": ["event", "signal", "interrupts", "attention", "microcontroller"], "source_lectures": ["lecture_108102169_w4_l27", "lecture_108102169_w5_l35"]}}
{"id": "concept_low_power_mode_0_lpm0", "type": "V_concept", "name": "Low Power Mode 0 (LPM0)", "properties": {"description": "A low power mode of the MSP430 microcontroller where the CPU is disabled, but some peripherals remain active.", "keywords": ["low", "power", "mode", "msp430", "cpu", "peripherals"], "source_lectures": ["lecture_108102169_w4_l27"]}}
{"id": "concept_low_power_mode_1_lpm1", "type": "V_concept", "name": "Low Power Mode 1 (LPM1)", "properties": {"description": "A low power mode of the MSP430 microcontroller where the CPU and some peripherals are disabled.", "keywords": ["low", "power", "mode", "msp430", "cpu", "peripherals"], "source_lectures": ["lecture_108102169_w4_l27"]}}
{"id": "concept_low_power_mode_2_lpm2", "type": "V_concept", "name": "Low Power Mode 2 (LPM2)", "properties": {"description": "A low power mode of the MSP430 microcontroller where the CPU, peripherals, and clocks are disabled.", "keywords": ["low", "power", "mode", "msp430", "cpu", "peripherals", "clocks"], "source_lectures": ["lecture_108102169_w4_l27"]}}
{"id": "concept_low_power_mode_3_lpm3", "type": "V_concept", "name": "Low Power Mode 3 (LPM3)", "properties": {"description": "A low power mode of the MSP430 microcontroller where the CPU, peripherals, clocks, and voltage regulator are disabled.", "keywords": ["low", "power", "mode", "msp430", "cpu", "peripherals", "clocks", "voltage", "regulator"], "source_lectures": ["lecture_108102169_w4_l27"]}}
{"id": "concept_low_power_mode_4_lpm4", "type": "V_concept", "name": "Low Power Mode 4 (LPM4)", "properties": {"description": "A low power mode of the MSP430 microcontroller where the CPU, peripherals, clocks, voltage regulator, and crystal oscillator are disabled.", "keywords": ["low", "power", "mode", "msp430", "cpu", "peripherals", "clocks", "voltage", "regulator", "crystal", "oscillator"], "source_lectures": ["lecture_108102169_w4_l27"]}}
{"id": "concept_liquid_crystal_display", "type": "V_concept", "name": "Liquid Crystal Display", "properties": {"description": "A type of display technology used in electronic devices to show images and text.", "keywords": ["lcd", "display", "technology", "electronic"], "source_lectures": ["lecture_108102169_w4_l28"]}}
{"id": "concept_character_lcd", "type": "V_concept", "name": "Character LCD", "properties": {"description": "A type of LCD display that can show alphanumeric characters and symbols.", "keywords": ["character", "lcd", "display", "alphanumeric"], "source_lectures": ["lecture_108102169_w4_l28"]}}
{"id": "concept_hitachi_hd44780_lcd_controller", "type": "V_concept", "name": "Hitachi HD44780 LCD Controller", "properties": {"description": "A widely used LCD controller chip that provides a standard interface for controlling LCD displays.", "keywords": ["hitachi", "hd44780", "lcd", "controller", "chip"], "source_lectures": ["lecture_108102169_w4_l28"]}}
{"id": "concept_4_bit_mode", "type": "V_concept", "name": "4-Bit Mode", "properties": {"description": "A mode of operation for LCD displays where 4 bits of data are sent at a time.", "keywords": ["4-bit", "mode", "lcd", "display", "data"], "source_lectures": ["lecture_108102169_w4_l28"]}}
{"id": "concept_rs_pin", "type": "V_concept", "name": "RS Pin", "properties": {"description": "A pin on the LCD controller that selects whether the data being sent is a command or data.", "keywords": ["rs", "pin", "lcd", "controller", "command"], "source_lectures": ["lecture_108102169_w4_l28"]}}
{"id": "concept_en_pin", "type": "V_concept", "name": "EN Pin", "properties": {"description": "A pin on the LCD controller that enables the display to receive data.", "keywords": ["en", "pin", "lcd", "controller", "enable"], "source_lectures": ["lecture_108102169_w4_l28"]}}
{"id": "concept_rw_pin", "type": "V_concept", "name": "RW Pin", "properties": {"description": "A pin on the LCD controller that selects whether the display is in read or write mode.", "keywords": ["rw", "pin", "lcd", "controller", "read", "write"], "source_lectures": ["lecture_108102169_w4_l28"]}}
{"id": "concept_lcd_initialization", "type": "V_concept", "name": "LCD Initialization", "properties": {"description": "The process of setting up the LCD display to receive data and display characters.", "keywords": ["lcd", "initialization", "setup", "display"], "source_lectures": ["lecture_108102169_w4_l28"]}}
{"id": "concept_custom_character_generation", "type": "V_concept", "name": "Custom Character Generation", "properties": {"description": "The process of creating custom characters for an LCD display using a character generator.", "keywords": ["custom", "character", "generation", "lcd", "display"], "source_lectures": ["lecture_108102169_w4_l28"]}}
{"id": "concept_cg_ram", "type": "V_concept", "name": "CG RAM", "properties": {"description": "A type of memory in an LCD display that stores custom character data.", "keywords": ["cg", "ram", "lcd", "display", "memory"], "source_lectures": ["lecture_108102169_w4_l28"]}}
{"id": "concept_counter", "type": "V_concept", "name": "Counter", "properties": {"description": "A device that stores a count of events, used to measure time or count occurrences.", "keywords": ["time", "pulses", "measure", "events", "circuit", "digital", "counter"], "source_lectures": ["lecture_108102169_w5_l29", "lecture_108102169_w6_l38", "lecture_108102169_w6_l39"]}}
{"id": "concept_timer", "type": "V_concept", "name": "Timer", "properties": {"description": "A device that measures time intervals, used to generate events or interrupts at specific times.", "keywords": ["timer", "time", "intervals", "events"], "source_lectures": ["lecture_108102169_w5_l29"]}}
{"id": "concept_capture_mode", "type": "V_concept", "name": "Capture Mode", "properties": {"description": "A mode of operation where a timer captures the value of a counter when a specific event occurs.", "keywords": ["capture", "mode", "timer", "counter", "event"], "source_lectures": ["lecture_108102169_w5_l29"]}}
{"id": "concept_compare_mode", "type": "V_concept", "name": "Compare Mode", "properties": {"description": "A mode of operation where a timer compares the value of a counter to a reference value and generates an interrupt when they match.", "keywords": ["compare", "mode", "timer", "counter", "interrupt"], "source_lectures": ["lecture_108102169_w5_l29"]}}
{"id": "concept_timer_register", "type": "V_concept", "name": "Timer Register", "properties": {"description": "A register that stores the value of a timer, used to keep track of time or count events.", "keywords": ["timer", "register", "value", "time", "events"], "source_lectures": ["lecture_108102169_w5_l29"]}}
{"id": "concept_counter_register", "type": "V_concept", "name": "Counter Register", "properties": {"description": "A register that stores the value of a counter, used to keep track of events or measure time.", "keywords": ["counter", "register", "value", "events", "time"], "source_lectures": ["lecture_108102169_w5_l29"]}}
{"id": "concept_msp430_timer_module", "type": "V_concept", "name": "MSP430 Timer Module", "properties": {"description": "A hardware module in the MSP430 microcontroller that provides timer and counter functionality.", "keywords": ["msp430", "timer", "module", "microcontroller"], "source_lectures": ["lecture_108102169_w5_l29"]}}
{"id": "concept_ta0ccr0_register", "type": "V_concept", "name": "TA0CCR0 Register", "properties": {"description": "A register in the MSP430 Timer Module that stores the capture/compare value for Timer0.", "keywords": ["ta0ccr0", "register", "msp430", "timer", "capture"], "source_lectures": ["lecture_108102169_w5_l29"]}}
{"id": "concept_ta0cctl0_register", "type": "V_concept", "name": "TA0CCTL0 Register", "properties": {"description": "A register in the MSP430 Timer Module that controls the mode of operation for Timer0.", "keywords": ["ta0cctl0", "register", "msp430", "timer", "mode"], "source_lectures": ["lecture_108102169_w5_l29"]}}
{"id": "concept_pulse_width_modulation_pwm", "type": "V_concept", "name": "Pulse Width Modulation (PWM)", "properties": {"description": "A technique that modulates the width of digital pulses to control the average power or voltage delivered to a load while keeping the frequency constant.", "keywords": ["pwm", "pulse width modulation", "duty cycle", "digital control", "analog simulation"], "source_lectures": ["lecture_108102169_w5_l30"]}}
{"id": "concept_duty_cycle", "type": "V_concept", "name": "Duty Cycle", "properties": {"description": "The ratio of the time a signal is active (high) to the total period of the signal, expressed as a percentage.", "keywords": ["duty cycle", "pulse ratio", "on-time", "off-time", "average voltage"], "source_lectures": ["lecture_108102169_w5_l30"]}}
{"id": "concept_average_voltage_in_pwm", "type": "V_concept", "name": "Average Voltage in PWM", "properties": {"description": "The mean voltage level of a PWM signal, calculated as the product of the peak voltage and the duty cycle.", "keywords": ["average voltage", "pwm voltage", "duty cycle", "voltage scaling", "dc level"], "source_lectures": ["lecture_108102169_w5_l30"]}}
{"id": "concept_low_pass_filter_rc_filter", "type": "V_concept", "name": "Low-Pass Filter (RC Filter)", "properties": {"description": "An electronic filter that passes signals with a frequency lower than a selected cutoff frequency and attenuates higher frequencies, used to smooth PWM signals into analog voltages.", "keywords": ["low-pass filter", "rc filter", "pwm smoothing", "analog conversion", "cutoff frequency"], "source_lectures": ["lecture_108102169_w5_l30"]}}
{"id": "concept_carrier_frequency_in_pwm", "type": "V_concept", "name": "Carrier Frequency in PWM", "properties": {"description": "The frequency of the PWM signal itself, which must be significantly higher than the frequency of the desired analog signal to enable effective filtering.", "keywords": ["carrier frequency", "pwm frequency", "switching frequency", "filtering", "sampling rate"], "source_lectures": ["lecture_108102169_w5_l30"]}}
{"id": "concept_timer_based_pwm_generation", "type": "V_concept", "name": "Timer-Based PWM Generation", "properties": {"description": "A hardware method of generating PWM signals using a microcontroller's timer peripheral to precisely control pulse width and period without CPU intervention.", "keywords": ["timer pwm", "hardware pwm", "microcontroller timer", "pwm generation", "peripheral"], "source_lectures": ["lecture_108102169_w5_l30"]}}
{"id": "concept_compare_mode_in_timer", "type": "V_concept", "name": "Compare Mode in Timer", "properties": {"description": "A timer operating mode where the timer value is compared against a preset register value to trigger an output change, used to generate PWM waveforms.", "keywords": ["compare mode", "timer compare", "pwm compare", "timer register", "output control"], "source_lectures": ["lecture_108102169_w5_l30"]}}
{"id": "concept_timer_capturecompare_register", "type": "V_concept", "name": "Timer Capture/Compare Register", "properties": {"description": "A register in a microcontroller timer that stores a target value for comparison with the timer counter to generate precise output events such as PWM transitions.", "keywords": ["capture compare register", "ccr", "timer register", "pwm register", "compare value"], "source_lectures": ["lecture_108102169_w5_l30"]}}
{"id": "concept_resolution_in_pwm", "type": "V_concept", "name": "Resolution in PWM", "properties": {"description": "The number of distinct duty cycle levels a PWM system can produce, determined by the bit width of the timer counter (e.g., 8-bit = 256 levels).", "keywords": ["pwm resolution", "bit resolution", "duty cycle steps", "timer bits", "precision"], "source_lectures": ["lecture_108102169_w5_l30"]}}
{"id": "concept_up_mode_timer_operation", "type": "V_concept", "name": "Up Mode Timer Operation", "properties": {"description": "A timer mode where the counter increments from 0 to a specified top value and then resets, commonly used to generate standard PWM waveforms.", "keywords": ["up mode", "timer up mode", "pwm up mode", "timer counting", "incremental timer"], "source_lectures": ["lecture_108102169_w5_l30"]}}
{"id": "concept_reset_set_pwm_mode", "type": "V_concept", "name": "Reset-Set PWM Mode", "properties": {"description": "An output mode where the PWM signal is set high when the timer reaches zero and reset low when it matches the compare register value, producing a standard PWM waveform.", "keywords": ["reset-set mode", "pwm reset set", "timer output mode", "pwm waveform", "compare trigger"], "source_lectures": ["lecture_108102169_w5_l30"]}}
{"id": "concept_timer_clock_source", "type": "V_concept", "name": "Timer Clock Source", "properties": {"description": "The clock signal that drives the timer counter, which can be derived from the system clock, an internal oscillator, or an external source.", "keywords": ["timer clock", "clock source", "system clock", "timer frequency", "clock divider"], "source_lectures": ["lecture_108102169_w5_l30"]}}
{"id": "concept_dc_motor_speed_control_via_pwm", "type": "V_concept", "name": "DC Motor Speed Control via PWM", "properties": {"description": "A method of controlling the speed of a DC motor by varying the average voltage applied to it using a PWM signal, where speed is proportional to duty cycle.", "keywords": ["dc motor pwm", "motor speed control", "pwm motor", "average voltage", "torque control"], "source_lectures": ["lecture_108102169_w5_l30"]}}
{"id": "concept_led_brightness_control_via_pwm", "type": "V_concept", "name": "LED Brightness Control via PWM", "properties": {"description": "A technique to adjust the perceived brightness of an LED by varying the duty cycle of a PWM signal, exploiting human persistence of vision.", "keywords": ["led pwm", "led brightness", "pwm led", "human vision", "perceived intensity"], "source_lectures": ["lecture_108102169_w5_l30"]}}
{"id": "concept_timer_overflow_interrupt", "type": "V_concept", "name": "Timer Overflow Interrupt", "properties": {"description": "An interrupt generated when a timer counter reaches its maximum value and rolls over to zero, often used to update PWM parameters in software-controlled PWM.", "keywords": ["timer overflow", "interrupt", "pwm update", "timer interrupt", "software pwm"], "source_lectures": ["lecture_108102169_w5_l30"]}}
{"id": "concept_port_configuration_for_pwm_output", "type": "V_concept", "name": "Port Configuration for PWM Output", "properties": {"description": "The process of configuring a microcontroller's GPIO port pin to function as a timer-controlled PWM output instead of a general-purpose digital I/O.", "keywords": ["port configuration", "pwm pin", "gpio pwm", "timer output pin", "mux selection"], "source_lectures": ["lecture_108102169_w5_l30"]}}
{"id": "concept_dco_digitally_controlled_oscillator", "type": "V_concept", "name": "DCO (Digitally Controlled Oscillator)", "properties": {"description": "An internal oscillator in microcontrollers that generates a programmable clock frequency, used to set the base frequency for timer-based PWM generation.", "keywords": ["dco", "digitally controlled oscillator", "clock source", "microcontroller clock", "frequency tuning"], "source_lectures": ["lecture_108102169_w5_l30"]}}
{"id": "concept_timer_resolution_trade_off", "type": "V_concept", "name": "Timer Resolution Trade-off", "properties": {"description": "The inverse relationship between PWM resolution and maximum achievable frequency: higher resolution reduces maximum frequency for a given clock source.", "keywords": ["resolution trade-off", "pwm resolution vs frequency", "timer bits", "frequency vs precision", "clock divider"], "source_lectures": ["lecture_108102169_w5_l30"]}}
{"id": "concept_pwm_frequency_calculation", "type": "V_concept", "name": "PWM Frequency Calculation", "properties": {"description": "The formula for calculating PWM frequency as the timer clock frequency divided by the timer period (top value), determining the switching rate of the signal.", "keywords": ["pwm frequency", "frequency calculation", "timer frequency", "clock divide", "period calculation"], "source_lectures": ["lecture_108102169_w5_l30"]}}
{"id": "concept_hardware_vs_software_pwm", "type": "V_concept", "name": "Hardware vs Software PWM", "properties": {"description": "Hardware PWM uses dedicated timer peripherals to generate signals autonomously, while software PWM relies on CPU loops, consuming processing resources.", "keywords": ["hardware pwm", "software pwm", "cpu usage", "timer peripheral", "real-time control"], "source_lectures": ["lecture_108102169_w5_l30"]}}
{"id": "concept_triangular_waveform_in_pwm", "type": "V_concept", "name": "Triangular Waveform in PWM", "properties": {"description": "A waveform generated when a timer operates in up-down mode, where the counter increments to a peak and then decrements back to zero, producing a symmetric PWM-like signal.", "keywords": ["triangular waveform", "up-down mode", "pwm triangular", "timer up-down", "symmetric pwm"], "source_lectures": ["lecture_108102169_w5_l30"]}}
{"id": "concept_pwm_signal_filtering", "type": "V_concept", "name": "PWM Signal Filtering", "properties": {"description": "The process of using a low-pass filter to remove high-frequency switching components from a PWM signal, leaving only the average DC voltage component.", "keywords": ["pwm filtering", "signal smoothing", "analog output", "low-pass filter", "rc network"], "source_lectures": ["lecture_108102169_w5_l30"]}}
{"id": "concept_timer_mode_selection", "type": "V_concept", "name": "Timer Mode Selection", "properties": {"description": "The configuration of a microcontroller timer to operate in specific modes such as up, up-down, or continuous to suit PWM or other timing applications.", "keywords": ["timer mode", "timer configuration", "pwm mode", "timer control register", "operating mode"], "source_lectures": ["lecture_108102169_w5_l30"]}}
{"id": "concept_pwm_output_pin_routing", "type": "V_concept", "name": "PWM Output Pin Routing", "properties": {"description": "The process of mapping a timer's PWM output signal to a specific physical pin on the microcontroller via peripheral function selection registers.", "keywords": ["pwm pin routing", "timer output pin", "peripheral mux", "pin assignment", "gpio mux"], "source_lectures": ["lecture_108102169_w5_l30"]}}
{"id": "concept_cutoff_frequency_of_low_pass_filter", "type": "V_concept", "name": "Cutoff Frequency of Low-Pass Filter", "properties": {"description": "The frequency at which a low-pass filter begins to significantly attenuate the input signal, typically defined as the -3 dB point.", "keywords": ["cutoff frequency", "low-pass filter", "filter bandwidth", "-3db point", "rc filter"], "source_lectures": ["lecture_108102169_w5_l30"]}}
{"id": "concept_timer_period", "type": "V_concept", "name": "Timer Period", "properties": {"description": "The total time duration of one complete cycle of the timer counter, from reset to overflow or compare match, determining the PWM signal's fundamental frequency.", "keywords": ["timer period", "pwm period", "cycle time", "timer duration", "fundamental frequency"], "source_lectures": ["lecture_108102169_w5_l30"]}}
{"id": "concept_microcontroller_peripheral", "type": "V_concept", "name": "Microcontroller Peripheral", "properties": {"description": "A hardware module integrated into a microcontroller that provides specialized functions such as timers, ADCs, UARTs, and PWM generators to offload the CPU.", "keywords": ["microcontroller peripheral", "timer peripheral", "hardware module", "embedded peripheral", "offload cpu"], "source_lectures": ["lecture_108102169_w5_l30"]}}
{"id": "concept_resolution_in_digital_control", "type": "V_concept", "name": "Resolution in Digital Control", "properties": {"description": "The smallest incremental change in a digital control parameter, such as duty cycle, that can be achieved based on the bit depth of the controlling register.", "keywords": ["digital resolution", "step size", "bit depth", "control precision", "quantization"], "source_lectures": ["lecture_108102169_w5_l30"]}}
{"id": "concept_pwm_for_analog_signal_synthesis", "type": "V_concept", "name": "PWM for Analog Signal Synthesis", "properties": {"description": "The use of PWM to synthesize arbitrary analog waveforms by modulating the duty cycle over time and filtering the result with a low-pass filter.", "keywords": ["analog synthesis", "pwm waveform", "signal generation", "arbitrary waveform", "dac alternative"], "source_lectures": ["lecture_108102169_w5_l30"]}}
{"id": "concept_sampling_and_hold_circuit", "type": "V_concept", "name": "Sampling and Hold Circuit", "properties": {"description": "A circuit that captures and holds an analog voltage at a specific point in time to ensure stability during analog-to-digital conversion.", "keywords": ["sampling", "hold", "circuit", "analog", "stabilize"], "source_lectures": ["lecture_108102169_w5_l31"]}}
{"id": "concept_quantization", "type": "V_concept", "name": "Quantization", "properties": {"description": "The process of mapping a continuous range of analog voltage values to a finite set of discrete digital levels.", "keywords": ["quantization", "discrete", "levels", "analog", "digital"], "source_lectures": ["lecture_108102169_w5_l31"]}}
{"id": "concept_encoding_digital_coding", "type": "V_concept", "name": "Encoding (Digital Coding)", "properties": {"description": "The process of assigning a binary code to each quantized voltage level to represent the analog signal in digital form.", "keywords": ["encoding", "binary", "code", "digital", "representation"], "source_lectures": ["lecture_108102169_w5_l31"]}}
{"id": "concept_successive_approximation_register_sar_adc", "type": "V_concept", "name": "Successive Approximation Register (SAR) ADC", "properties": {"description": "A type of analog-to-digital converter that uses a binary search algorithm to approximate the input voltage with a reference voltage.", "keywords": ["sar", "adc", "successive", "approximation", "binary"], "source_lectures": ["lecture_108102169_w5_l31"]}}
{"id": "concept_reference_voltage", "type": "V_concept", "name": "Reference Voltage", "properties": {"description": "A stable voltage used as a benchmark against which the input analog signal is compared during analog-to-digital conversion.", "keywords": ["reference", "voltage", "adc", "benchmark", "comparison"], "source_lectures": ["lecture_108102169_w5_l31"]}}
{"id": "concept_resolution_adc", "type": "V_concept", "name": "Resolution (ADC)", "properties": {"description": "The number of distinct digital values an ADC can produce, determined by the number of bits in its output (e.g., 10-bit = 1024 levels).", "keywords": ["resolution", "bit", "adc", "digital", "levels"], "source_lectures": ["lecture_108102169_w5_l31"]}}
{"id": "concept_anti_aliasing_filter", "type": "V_concept", "name": "Anti-Aliasing Filter", "properties": {"description": "A low-pass filter applied before analog-to-digital conversion to remove frequency components above half the sampling rate and prevent aliasing.", "keywords": ["anti-aliasing", "filter", "low-pass", "aliasing", "sampling"], "source_lectures": ["lecture_108102169_w5_l31"]}}
{"id": "concept_multiplexer_analog_mux", "type": "V_concept", "name": "Multiplexer (Analog MUX)", "properties": {"description": "A circuit that selects one of multiple analog input signals and routes it to a single ADC for conversion.", "keywords": ["multiplexer", "mux", "analog", "input", "channel"], "source_lectures": ["lecture_108102169_w5_l31"]}}
{"id": "concept_direct_memory_access_dma_controller", "type": "V_concept", "name": "Direct Memory Access (DMA) Controller", "properties": {"description": "A hardware component that transfers data between memory and peripherals (like ADC) without CPU intervention.", "keywords": ["dma", "memory", "transfer", "controller", "adc"], "source_lectures": ["lecture_108102169_w5_l31"]}}
{"id": "concept_msp430_adc10", "type": "V_concept", "name": "MSP430 ADC10", "properties": {"description": "A 10-bit successive approximation ADC module integrated into the MSP430 microcontroller family for analog signal acquisition.", "keywords": ["msp430", "adc10", "10-bit", "microcontroller", "adc"], "source_lectures": ["lecture_108102169_w5_l31"]}}
{"id": "concept_internal_temperature_sensor_msp430", "type": "V_concept", "name": "Internal Temperature Sensor (MSP430)", "properties": {"description": "A built-in sensor in the MSP430 microcontroller that outputs a voltage proportional to the chip's temperature for ADC measurement.", "keywords": ["temperature", "sensor", "internal", "msp430", "adc"], "source_lectures": ["lecture_108102169_w5_l31"]}}
{"id": "concept_voltage_divider_internal", "type": "V_concept", "name": "Voltage Divider (Internal)", "properties": {"description": "A resistive network within the MSP430 that scales the supply voltage for measurement by the ADC.", "keywords": ["voltage", "divider", "supply", "internal", "adc"], "source_lectures": ["lecture_108102169_w5_l31"]}}
{"id": "concept_potentiometer", "type": "V_concept", "name": "Potentiometer", "properties": {"description": "A variable resistor used to produce a variable analog voltage, commonly used as an input to ADCs for user input or sensing.", "keywords": ["potentiometer", "variable", "resistor", "analog", "input"], "source_lectures": ["lecture_108102169_w5_l31"]}}
{"id": "concept_light_dependent_resistor_ldr", "type": "V_concept", "name": "Light-Dependent Resistor (LDR)", "properties": {"description": "A passive component whose resistance changes with light intensity, used to generate analog voltage signals for ADC input.", "keywords": ["ldr", "light", "resistor", "sensor", "analog"], "source_lectures": ["lecture_108102169_w5_l31"]}}
{"id": "concept_negative_temperature_coefficient_ntc_thermistor", "type": "V_concept", "name": "Negative Temperature Coefficient (NTC) Thermistor", "properties": {"description": "A temperature-sensitive resistor whose resistance decreases as temperature increases, used for analog temperature sensing.", "keywords": ["ntc", "thermistor", "temperature", "sensor", "resistance"], "source_lectures": ["lecture_108102169_w5_l31"]}}
{"id": "concept_load_cell", "type": "V_concept", "name": "Load Cell", "properties": {"description": "A transducer that converts mechanical force into an analog voltage signal, often used with ADCs in weighing systems.", "keywords": ["load", "cell", "force", "sensor", "analog"], "source_lectures": ["lecture_108102169_w5_l31"]}}
{"id": "concept_clock_source_adc", "type": "V_concept", "name": "Clock Source (ADC)", "properties": {"description": "The timing signal that drives the conversion steps in an ADC, selectable from internal or external oscillators.", "keywords": ["clock", "source", "adc", "timing", "oscillator"], "source_lectures": ["lecture_108102169_w5_l31"]}}
{"id": "concept_adc_register_set_msp430", "type": "V_concept", "name": "ADC Register Set (MSP430)", "properties": {"description": "A group of memory-mapped registers used to configure, control, and read results from the MSP430 ADC10 module.", "keywords": ["adc", "register", "msp430", "configuration", "control"], "source_lectures": ["lecture_108102169_w5_l31"]}}
{"id": "concept_conversion_trigger", "type": "V_concept", "name": "Conversion Trigger", "properties": {"description": "A signal or software command that initiates a single or sequence of analog-to-digital conversions in an ADC.", "keywords": ["trigger", "conversion", "start", "adc", "software"], "source_lectures": ["lecture_108102169_w5_l31"]}}
{"id": "concept_interrupt_adc_completion", "type": "V_concept", "name": "Interrupt (ADC Completion)", "properties": {"description": "A hardware signal generated by the ADC upon completion of a conversion to notify the processor without polling.", "keywords": ["interrupt", "adc", "completion", "notification", "polling"], "source_lectures": ["lecture_108102169_w5_l31"]}}
{"id": "concept_twos_complement_encoding", "type": "V_concept", "name": "Two's Complement Encoding", "properties": {"description": "A binary representation method used by ADCs to encode negative voltage ranges symmetrically around zero.", "keywords": ["two's complement", "encoding", "binary", "negative", "adc"], "source_lectures": ["lecture_108102169_w5_l31"]}}
{"id": "concept_mapping_adc_output_scaling", "type": "V_concept", "name": "Mapping (ADC Output Scaling)", "properties": {"description": "The process of converting an ADC's output value (e.g., 10-bit) to a different scale (e.g., 8-bit) for compatibility with other systems.", "keywords": ["mapping", "scaling", "adc", "bit", "conversion"], "source_lectures": ["lecture_108102169_w5_l31"]}}
{"id": "concept_flash_adc", "type": "V_concept", "name": "Flash ADC", "properties": {"description": "A high-speed analog-to-digital converter that uses a bank of comparators to convert the input voltage in a single step.", "keywords": ["flash", "adc", "high-speed", "comparator", "parallel"], "source_lectures": ["lecture_108102169_w5_l31"]}}
{"id": "concept_sigma_delta_adc", "type": "V_concept", "name": "Sigma-Delta ADC", "properties": {"description": "A type of ADC that uses oversampling and noise shaping to achieve high resolution at lower speeds, commonly used in audio applications.", "keywords": ["sigma", "delta", "adc", "oversampling", "audio"], "source_lectures": ["lecture_108102169_w5_l31"]}}
{"id": "concept_counter_based_adc", "type": "V_concept", "name": "Counter-Based ADC", "properties": {"description": "A simple ADC that uses a counter and DAC to incrementally approximate the input voltage until it matches.", "keywords": ["counter", "adc", "dac", "approximation", "simple"], "source_lectures": ["lecture_108102169_w5_l31"]}}
{"id": "concept_digital_storage_oscilloscope_dso", "type": "V_concept", "name": "Digital Storage Oscilloscope (DSO)", "properties": {"description": "An instrument that digitizes analog waveforms using a high-speed ADC for display, storage, and analysis.", "keywords": ["dso", "oscilloscope", "adc", "digital", "storage"], "source_lectures": ["lecture_108102169_w5_l31"]}}
{"id": "concept_input_impedance", "type": "V_concept", "name": "Input Impedance", "properties": {"description": "The resistance and reactance presented by a circuit to an incoming analog signal, affecting signal integrity and loading.", "keywords": ["impedance", "input", "analog", "loading", "signal"], "source_lectures": ["lecture_108102169_w5_l31"]}}
{"id": "concept_pseudorandom_number_generation", "type": "V_concept", "name": "Pseudorandom Number Generation", "properties": {"description": "A method of generating a sequence of numbers that appear to be random but are actually determined by a algorithm or formula.", "keywords": ["pseudorandom", "number", "generation", "algorithm", "formula"], "source_lectures": ["lecture_108102169_w5_l32"]}}
{"id": "concept_digital_to_analog_conversion", "type": "V_concept", "name": "Digital To Analog Conversion", "properties": {"description": "The process of converting a digital signal into an analog signal.", "keywords": ["digital", "analog", "conversion", "signal", "process"], "source_lectures": ["lecture_108102169_w5_l32"]}}
{"id": "concept_r2r_ladder_network", "type": "V_concept", "name": "R2R Ladder Network", "properties": {"description": "A type of digital-to-analog converter that uses a network of resistors to generate an analog output voltage.", "keywords": ["r2r", "ladder", "network", "digital", "analog"], "source_lectures": ["lecture_108102169_w5_l32"]}}
{"id": "concept_pulse_width_modulation", "type": "V_concept", "name": "Pulse Width Modulation", "properties": {"description": "A technique for generating an analog signal by modulating the width of a digital pulse.", "keywords": ["pulse", "width", "modulation", "analog", "signal"], "source_lectures": ["lecture_108102169_w5_l32"]}}
{"id": "concept_timer_capture_mode", "type": "V_concept", "name": "Timer Capture Mode", "properties": {"description": "A mode of operation for timers where the timer value is captured in response to an external event or internal event.", "keywords": ["timer", "capture", "mode", "event", "external"], "source_lectures": ["lecture_108102169_w5_l34"]}}
{"id": "concept_msp430_timer", "type": "V_concept", "name": "MSP430 Timer", "properties": {"description": "A timer module in the MSP430 microcontroller that can be used in various modes, including capture mode.", "keywords": ["msp430", "timer", "microcontroller", "capture"], "source_lectures": ["lecture_108102169_w5_l34"]}}
{"id": "concept_capture_register", "type": "V_concept", "name": "Capture Register", "properties": {"description": "A register that stores the captured timer value in response to an external event or internal event.", "keywords": ["capture", "register", "timer", "event", "external"], "source_lectures": ["lecture_108102169_w5_l34"]}}
{"id": "concept_timer_control_register", "type": "V_concept", "name": "Timer Control Register", "properties": {"description": "A register that controls the operation of the timer, including the capture mode.", "keywords": ["timer", "control", "register", "capture", "mode"], "source_lectures": ["lecture_108102169_w5_l34"]}}
{"id": "concept_interrupt_vector_register", "type": "V_concept", "name": "Interrupt Vector Register", "properties": {"description": "A register that stores the address of the interrupt service routine.", "keywords": ["interrupt", "vector", "register", "address", "isr"], "source_lectures": ["lecture_108102169_w5_l34"]}}
{"id": "concept_frequency_measurement", "type": "V_concept", "name": "Frequency Measurement", "properties": {"description": "The process of measuring the frequency of an unknown signal.", "keywords": ["frequency", "measurement", "signal", "unknown"], "source_lectures": ["lecture_108102169_w5_l34"]}}
{"id": "concept_period_measurement", "type": "V_concept", "name": "Period Measurement", "properties": {"description": "The process of measuring the period of an unknown signal.", "keywords": ["period", "measurement", "signal", "unknown"], "source_lectures": ["lecture_108102169_w5_l34"]}}
{"id": "concept_time_interval_measurement", "type": "V_concept", "name": "Time Interval Measurement", "properties": {"description": "The process of measuring the time interval between two events.", "keywords": ["time", "interval", "measurement", "events"], "source_lectures": ["lecture_108102169_w5_l34"]}}
{"id": "concept_capture_mode_selection", "type": "V_concept", "name": "Capture Mode Selection", "properties": {"description": "The process of selecting the capture mode for a timer.", "keywords": ["capture", "mode", "selection", "timer"], "source_lectures": ["lecture_108102169_w5_l34"]}}
{"id": "concept_analog_to_digital_conversion_adc", "type": "V_concept", "name": "Analog-to-Digital Conversion (ADC)", "properties": {"description": "The process of converting an analog signal into a digital signal, which can be processed by a microcontroller or computer.", "keywords": ["analog", "digital", "conversion", "signal", "processing"], "source_lectures": ["lecture_108102169_w5_l35"]}}
{"id": "concept_digital_inputoutput_io", "type": "V_concept", "name": "Digital Input/Output (I/O)", "properties": {"description": "The process of sending or receiving digital signals to or from external devices, such as sensors, actuators, or other microcontrollers.", "keywords": ["digital", "input", "output", "signals", "devices"], "source_lectures": ["lecture_108102169_w5_l35"]}}
{"id": "concept_charliplexing", "type": "V_concept", "name": "Charliplexing", "properties": {"description": "A technique used to drive multiple LEDs using a limited number of pins, by rapidly switching between them.", "keywords": ["charliplexing", "leds", "pins", "switching", "technique"], "source_lectures": ["lecture_108102169_w5_l35"]}}
{"id": "concept_non_blocking_subroutines", "type": "V_concept", "name": "Non-Blocking Subroutines", "properties": {"description": "A type of subroutine that does not block the main program from executing, allowing for concurrent execution of multiple tasks.", "keywords": ["non-blocking", "subroutines", "concurrent", "execution", "tasks"], "source_lectures": ["lecture_108102169_w5_l35"]}}
{"id": "concept_blocking_subroutines", "type": "V_concept", "name": "Blocking Subroutines", "properties": {"description": "A type of subroutine that blocks the main program from executing until it completes, allowing for sequential execution of tasks.", "keywords": ["blocking", "subroutines", "sequential", "execution", "tasks"], "source_lectures": ["lecture_108102169_w5_l35"]}}
{"id": "concept_printed_circuit_board", "type": "V_concept", "name": "Printed Circuit Board", "properties": {"description": "A board used to connect and support electronic components using conductive pathways.", "keywords": ["pcb", "circuit", "board", "electronic", "components"], "source_lectures": ["lecture_108102169_w6_l37"]}}
{"id": "concept_circuit_prototyping", "type": "V_concept", "name": "Circuit Prototyping", "properties": {"description": "The process of creating a preliminary model of a circuit to test and refine its design.", "keywords": ["prototyping", "circuit", "design", "testing", "refining"], "source_lectures": ["lecture_108102169_w6_l37"]}}
{"id": "concept_soldering", "type": "V_concept", "name": "Soldering", "properties": {"description": "A process of joining two metal pieces together using a filler metal with a low melting point.", "keywords": ["soldering", "metal", "joining", "filler", "melting"], "source_lectures": ["lecture_108102169_w6_l37"]}}
{"id": "concept_copper_wire", "type": "V_concept", "name": "Copper Wire", "properties": {"description": "A type of wire made from copper, often used in electrical applications due to its high conductivity.", "keywords": ["copper", "wire", "electrical", "conductivity", "applications"], "source_lectures": ["lecture_108102169_w6_l37"]}}
{"id": "concept_electronic_components", "type": "V_concept", "name": "Electronic Components", "properties": {"description": "Devices used to control the flow of electrical current in a circuit, such as resistors, capacitors, and transistors.", "keywords": ["components", "electronic", "circuit", "resistors", "capacitors", "transistors"], "source_lectures": ["lecture_108102169_w6_l37"]}}
{"id": "concept_pcb_fabrication", "type": "V_concept", "name": "PCB Fabrication", "properties": {"description": "The process of manufacturing a printed circuit board, involving various steps such as design, printing, and assembly.", "keywords": ["pcb", "fabrication", "manufacturing", "design", "printing", "assembly"], "source_lectures": ["lecture_108102169_w6_l37"]}}
{"id": "concept_double_sided_pcb", "type": "V_concept", "name": "Double-Sided PCB", "properties": {"description": "A type of printed circuit board with conductive pathways on both sides, allowing for more complex circuit designs.", "keywords": ["double-sided", "pcb", "conductive", "pathways", "circuit", "design"], "source_lectures": ["lecture_108102169_w6_l37"]}}
{"id": "concept_single_sided_pcb", "type": "V_concept", "name": "Single-Sided PCB", "properties": {"description": "A type of printed circuit board with conductive pathways on only one side, often used for simpler circuit designs.", "keywords": ["single-sided", "pcb", "conductive", "pathways", "circuit", "design"], "source_lectures": ["lecture_108102169_w6_l37"]}}
{"id": "concept_circuit_design", "type": "V_concept", "name": "Circuit Design", "properties": {"description": "The process of creating a detailed plan for a circuit, including the selection and arrangement of components.", "keywords": ["circuit", "design", "plan", "components", "selection", "arrangement"], "source_lectures": ["lecture_108102169_w6_l37"]}}
{"id": "concept_electrolytic_capacitor", "type": "V_concept", "name": "Electrolytic Capacitor", "properties": {"description": "A type of capacitor that uses an electrolyte to store electrical energy, often used in power supply applications.", "keywords": ["electrolytic", "capacitor", "electrolyte", "energy", "power", "supply"], "source_lectures": ["lecture_108102169_w6_l37"]}}
{"id": "concept_state_machine", "type": "V_concept", "name": "State Machine", "properties": {"description": "A mathematical model that can be in one of a finite number of states and can change state based on certain rules", "keywords": ["model", "finite", "state", "automaton", "mathematical", "machine"], "source_lectures": ["lecture_108102169_w6_l38", "lecture_108102169_w6_l39"]}}
{"id": "concept_digital_logic", "type": "V_concept", "name": "Digital Logic", "properties": {"description": "A branch of electronics that deals with the design and construction of digital circuits", "keywords": ["digital", "logic", "electronics", "circuits", "design"], "source_lectures": ["lecture_108102169_w6_l38"]}}
{"id": "concept_combination_logic", "type": "V_concept", "name": "Combination Logic", "properties": {"description": "A type of digital logic that combines multiple inputs to produce a single output", "keywords": ["combination", "logic", "digital", "inputs", "output"], "source_lectures": ["lecture_108102169_w6_l38"]}}
{"id": "concept_sequential_logic", "type": "V_concept", "name": "Sequential Logic", "properties": {"description": "A type of digital logic that uses feedback to store information and change state over time", "keywords": ["state", "sequential", "logic", "information", "digital", "feedback"], "source_lectures": ["lecture_108102169_w6_l38", "lecture_108102169_w6_l39"]}}
{"id": "concept_moore_machine", "type": "V_concept", "name": "Moore Machine", "properties": {"description": "A type of state machine where the output depends only on the current state", "keywords": ["moore", "machine", "state", "output", "current"], "source_lectures": ["lecture_108102169_w6_l38"]}}
{"id": "concept_mealy_machine", "type": "V_concept", "name": "Mealy Machine", "properties": {"description": "A type of state machine where the output depends on both the current state and input", "keywords": ["mealy", "machine", "state", "output", "input"], "source_lectures": ["lecture_108102169_w6_l38"]}}
{"id": "concept_finite_state_automaton", "type": "V_concept", "name": "Finite State Automaton", "properties": {"description": "A mathematical model that can be in one of a finite number of states and can change state based on certain rules", "keywords": ["finite", "state", "automaton", "model", "rules"], "source_lectures": ["lecture_108102169_w6_l38"]}}
{"id": "concept_flip_flop", "type": "V_concept", "name": "Flip Flop", "properties": {"description": "A digital circuit that can store a single bit of information", "keywords": ["flip", "flop", "digital", "circuit", "bit"], "source_lectures": ["lecture_108102169_w6_l38"]}}
{"id": "concept_programmable_logic_device", "type": "V_concept", "name": "Programmable Logic Device", "properties": {"description": "An electronic component that can be programmed to perform a variety of logical operations", "keywords": ["programmable", "logic", "device", "electronic", "component"], "source_lectures": ["lecture_108102169_w6_l39"]}}
{"id": "concept_field_programmable_gate_array", "type": "V_concept", "name": "Field Programmable Gate Array", "properties": {"description": "An integrated circuit that can be programmed to perform a variety of logical operations", "keywords": ["gate", "programmable", "integrated", "field", "fpga", "array"], "source_lectures": ["lecture_108102169_w6_l39", "lecture_106102229_w3_l16"]}}
{"id": "concept_digital_circuit", "type": "V_concept", "name": "Digital Circuit", "properties": {"description": "An electronic circuit that operates on digital signals", "keywords": ["digital", "circuit", "electronic", "signals"], "source_lectures": ["lecture_108102169_w6_l39"]}}
{"id": "concept_logic_gate", "type": "V_concept", "name": "Logic Gate", "properties": {"description": "A digital circuit that performs a basic logical operation", "keywords": ["logic", "gate", "digital", "circuit", "operation"], "source_lectures": ["lecture_108102169_w6_l39"]}}
{"id": "concept_assembly_language", "type": "V_concept", "name": "Assembly Language", "properties": {"description": "A low-level programming language that uses symbolic codes to represent machine-specific instructions.", "keywords": ["assembly", "language", "programming", "low-level"], "source_lectures": ["lecture_106102229_w1_l1"]}}
{"id": "concept_moores_law", "type": "V_concept", "name": "Moore's Law", "properties": {"description": "A prediction that the number of transistors on a microchip will double approximately every two years, leading to exponential improvements in computing power and reductions in cost.", "keywords": ["law", "transistors", "moore", "power", "density", "moore's law", "exponential", "computing power", "transistor", "microchip", "processing", "semiconductor"], "source_lectures": ["lecture_106102229_w1_l1", "lecture_106103359_w1_l1", "lecture_106103359_w1_l2", "lecture_106104182_w1_l1"]}}
{"id": "concept_dennard_scaling", "type": "V_concept", "name": "Dennard Scaling", "properties": {"description": "A principle that states that as transistors get smaller, their power density remains constant, leading to increased performance and reduced power consumption.", "keywords": ["transistors", "power", "density", "scaling", "transistor", "dennard", "voltage", "current"], "source_lectures": ["lecture_106102229_w1_l1", "lecture_106103359_w1_l2"]}}
{"id": "concept_out_of_order_execution", "type": "V_concept", "name": "Out-of-Order Execution", "properties": {"description": "A technique used in computer processors to improve performance by executing instructions in a non-sequential order, while maintaining the correct order of dependencies.", "keywords": ["dependencies", "instruction scheduling", "out", "instructions", "processor", "of", "instruction reordering", "data dependency", "order", "processor architecture", "out-of-order execution", "pipeline", "out-of-order", "execution", "performance"], "source_lectures": ["lecture_106102229_w1_l1", "lecture_106102229_w1_l3", "lecture_106102229_w2_l11", "lecture_106102229_w4_l26", "lecture_106103359_w9_l58", "lecture_106103359_w10_l69"]}}
{"id": "concept_spec_benchmark", "type": "V_concept", "name": "SPEC Benchmark", "properties": {"description": "A standardized benchmarking suite used to measure the performance of computer systems, particularly in the areas of integer and floating-point processing.", "keywords": ["spec", "benchmark", "performance", "integer", "floating-point"], "source_lectures": ["lecture_106102229_w1_l1"]}}
{"id": "concept_multicore_processor", "type": "V_concept", "name": "Multicore Processor", "properties": {"description": "A type of processor that contains multiple processing cores on a single chip, allowing for increased parallelism and improved performance.", "keywords": ["processor", "parallel", "multicore", "cores", "parallelism", "processing", "performance"], "source_lectures": ["lecture_106102229_w1_l1", "lecture_106103359_w1_l1"]}}
{"id": "concept_gpu_architecture", "type": "V_concept", "name": "GPU Architecture", "properties": {"description": "A type of processor architecture designed specifically for graphics processing, but also used for general-purpose computing and other tasks.", "keywords": ["architecture", "gpu", "units", "graphics", "parallelism", "processing"], "source_lectures": ["lecture_106102229_w1_l1", "lecture_106103359_w1_l3"]}}
{"id": "concept_cache_design", "type": "V_concept", "name": "Cache Design", "properties": {"description": "The process of designing and optimizing cache memory systems to improve performance and reduce latency in computer systems.", "keywords": ["power", "memory", "latency", "design", "optimization", "computer", "performance", "cache"], "source_lectures": ["lecture_106102229_w1_l1", "lecture_106102229_w3_l21", "lecture_106102229_w4_l23"]}}
{"id": "concept_on_chip_network", "type": "V_concept", "name": "On-Chip Network", "properties": {"description": "A communication network integrated into a single chip, used to connect multiple cores, caches, and other components.", "keywords": ["on-chip", "network", "communication", "cores", "caches"], "source_lectures": ["lecture_106102229_w1_l1"]}}
{"id": "concept_non_volatile_memory", "type": "V_concept", "name": "Non-Volatile Memory", "properties": {"description": "A type of memory that retains its data even when power is turned off, used in devices such as flash drives and solid-state drives.", "keywords": ["non-volatile", "memory", "data", "retention", "power"], "source_lectures": ["lecture_106102229_w1_l1"]}}
{"id": "concept_parameter_variation", "type": "V_concept", "name": "Parameter Variation", "properties": {"description": "The phenomenon of variations in transistor parameters, such as size and operating conditions, that can affect the performance and reliability of integrated circuits.", "keywords": ["parameter", "variation", "transistors", "performance", "reliability"], "source_lectures": ["lecture_106102229_w1_l1"]}}
{"id": "concept_cosmic_ray_faults", "type": "V_concept", "name": "Cosmic Ray Faults", "properties": {"description": "A type of fault that occurs when high-energy particles from space interact with electronic devices, causing errors or damage.", "keywords": ["cosmic", "ray", "faults", "particles", "errors"], "source_lectures": ["lecture_106102229_w1_l1"]}}
{"id": "concept_machine_learning_accelerator", "type": "V_concept", "name": "Machine Learning Accelerator", "properties": {"description": "A specialized processor or hardware component designed to accelerate machine learning workloads, such as neural networks and deep learning.", "keywords": ["machine", "learning", "accelerator", "neural", "networks"], "source_lectures": ["lecture_106102229_w1_l1"]}}
{"id": "concept_performance_equation", "type": "V_concept", "name": "Performance Equation", "properties": {"description": "A formula that relates performance to instructions per cycle, frequency, and number of instructions", "keywords": ["performance", "equation", "instructions", "frequency", "ipc"], "source_lectures": ["lecture_106102229_w1_l3"]}}
{"id": "concept_instructions_per_cycle", "type": "V_concept", "name": "Instructions Per Cycle", "properties": {"description": "The average number of instructions that a processor can execute per clock cycle", "keywords": ["instructions", "cycle", "ipc", "performance", "processor"], "source_lectures": ["lecture_106102229_w1_l3"]}}
{"id": "concept_clock_period", "type": "V_concept", "name": "Clock Period", "properties": {"description": "The time it takes for a clock signal to complete one cycle", "keywords": ["clock", "period", "time", "cycle", "frequency"], "source_lectures": ["lecture_106102229_w1_l3"]}}
{"id": "concept_pipelining", "type": "V_concept", "name": "Pipelining", "properties": {"description": "A technique used in processors to increase throughput by breaking down instructions into stages", "keywords": ["architecture", "latency", "instructions", "pipelining", "processor", "technique", "throughput", "computer", "stages", "instruction pipeline", "performance"], "source_lectures": ["lecture_106102229_w1_l3", "lecture_106102229_w4_l23", "lecture_106102229_w5_l31", "lecture_106103359_w1_l3", "lecture_106103359_w10_l69"]}}
{"id": "concept_superscalar_processor", "type": "V_concept", "name": "Superscalar Processor", "properties": {"description": "A type of processor that can execute multiple instructions per clock cycle", "keywords": ["superscalar", "processor", "instructions", "cycle", "performance"], "source_lectures": ["lecture_106102229_w1_l3"]}}
{"id": "concept_cycles_per_instruction", "type": "V_concept", "name": "Cycles Per Instruction", "properties": {"description": "The average number of clock cycles it takes to execute an instruction", "keywords": ["cpi", "instruction", "processor", "cycles", "performance"], "source_lectures": ["lecture_106102229_w1_l3", "lecture_106102229_w3_l20"]}}
{"id": "concept_frequency_limitations", "type": "V_concept", "name": "Frequency Limitations", "properties": {"description": "The limitations on increasing the frequency of a processor due to power and temperature constraints", "keywords": ["frequency", "limitations", "power", "temperature", "processor"], "source_lectures": ["lecture_106102229_w1_l3"]}}
{"id": "concept_program_order_dependence", "type": "V_concept", "name": "Program Order Dependence", "properties": {"description": "The order of instructions that appear in the original program.", "keywords": ["program", "order", "dependence", "instruction"], "source_lectures": ["lecture_106102229_w1_l4"]}}
{"id": "concept_static_instruction", "type": "V_concept", "name": "Static Instruction", "properties": {"description": "A classic example of an instruction that can be represented in assembly code.", "keywords": ["static", "instruction", "assembly", "code"], "source_lectures": ["lecture_106102229_w1_l4"]}}
{"id": "concept_dynamic_instruction", "type": "V_concept", "name": "Dynamic Instruction", "properties": {"description": "An instruction that is executed at runtime, taking into account the program's dynamic behavior.", "keywords": ["dynamic", "instruction", "runtime", "behavior"], "source_lectures": ["lecture_106102229_w1_l4"]}}
{"id": "concept_read_after_write_dependency", "type": "V_concept", "name": "Read After Write Dependency", "properties": {"description": "A dependency that occurs when an instruction reads a value written by a previous instruction.", "keywords": ["read", "write", "dependency", "instruction"], "source_lectures": ["lecture_106102229_w1_l4"]}}
{"id": "concept_write_after_write_dependency", "type": "V_concept", "name": "Write After Write Dependency", "properties": {"description": "A dependency that occurs when an instruction writes a value to a location that has already been written to by a previous instruction.", "keywords": ["write", "write", "dependency", "location"], "source_lectures": ["lecture_106102229_w1_l4"]}}
{"id": "concept_output_dependence", "type": "V_concept", "name": "Output Dependence", "properties": {"description": "A dependency that occurs when an instruction writes to a location that is also written to by another instruction.", "keywords": ["output", "dependence", "write", "location"], "source_lectures": ["lecture_106102229_w1_l4"]}}
{"id": "concept_anti_dependence", "type": "V_concept", "name": "Anti Dependence", "properties": {"description": "A dependency that occurs when an instruction reads a value that is later written to by another instruction.", "keywords": ["anti", "dependence", "read", "write"], "source_lectures": ["lecture_106102229_w1_l4"]}}
{"id": "concept_control_dependence", "type": "V_concept", "name": "Control Dependence", "properties": {"description": "A dependency that occurs when an instruction's execution depends on the outcome of a previous instruction.", "keywords": ["relationship", "operation", "control", "execution", "dependence", "outcome"], "source_lectures": ["lecture_106102229_w1_l4", "lecture_106103359_w9_l58"]}}
{"id": "concept_renaming", "type": "V_concept", "name": "Renaming", "properties": {"description": "A technique used to remove false dependencies by assigning a separate physical register to each avatar of a register.", "keywords": ["renaming", "false", "dependencies", "register"], "source_lectures": ["lecture_106102229_w1_l4"]}}
{"id": "concept_precise_exception", "type": "V_concept", "name": "Precise Exception", "properties": {"description": "A mechanism that allows an out-of-order processor to stop and resume execution at an arbitrary point, ensuring that all instructions before the exception have completed and none after have started.", "keywords": ["precise", "exception", "out-of-order", "execution"], "source_lectures": ["lecture_106102229_w1_l4"]}}
{"id": "concept_out_of_order_processor", "type": "V_concept", "name": "Out-of-Order Processor", "properties": {"description": "A type of processor that executes instructions in a non-sequential manner to improve performance.", "keywords": ["out-of-order", "processor", "performance", "execution"], "source_lectures": ["lecture_106102229_w1_l4"]}}
{"id": "concept_branch_predictor", "type": "V_concept", "name": "Branch Predictor", "properties": {"description": "A component that predicts the outcome of a branch instruction to improve instruction-level parallelism.", "keywords": ["branch", "predictor", "instruction-level", "parallelism"], "source_lectures": ["lecture_106102229_w1_l4"]}}
{"id": "concept_bimodal_predictor", "type": "V_concept", "name": "Bimodal Predictor", "properties": {"description": "A type of branch predictor that uses a single bit to predict the outcome of a branch", "keywords": ["bimodal", "predictor", "branch", "prediction"], "source_lectures": ["lecture_106102229_w1_l6"]}}
{"id": "concept_saturating_counter", "type": "V_concept", "name": "Saturating Counter", "properties": {"description": "A counter that increments or decrements based on the outcome of a branch, but saturates at a maximum or minimum value", "keywords": ["saturating", "counter", "branch", "prediction"], "source_lectures": ["lecture_106102229_w1_l6"]}}
{"id": "concept_global_history_register", "type": "V_concept", "name": "Global History Register", "properties": {"description": "A register that stores the history of recent branch outcomes", "keywords": ["global", "history", "register", "branch"], "source_lectures": ["lecture_106102229_w1_l6"]}}
{"id": "concept_gap_predictor", "type": "V_concept", "name": "GAp Predictor", "properties": {"description": "A type of branch predictor that combines global history and program counter information", "keywords": ["gap", "predictor", "branch", "prediction"], "source_lectures": ["lecture_106102229_w1_l6"]}}
{"id": "concept_pap_predictor", "type": "V_concept", "name": "PAp Predictor", "properties": {"description": "A type of branch predictor that uses multiple global history registers and program counter information", "keywords": ["pap", "predictor", "branch", "prediction"], "source_lectures": ["lecture_106102229_w1_l6"]}}
{"id": "concept_tournament_predictor", "type": "V_concept", "name": "Tournament Predictor", "properties": {"description": "A type of branch predictor that chooses between multiple predictors based on their performance", "keywords": ["tournament", "predictor", "branch", "prediction"], "source_lectures": ["lecture_106102229_w1_l6"]}}
{"id": "concept_fanos_inequality", "type": "V_concept", "name": "Fano's Inequality", "properties": {"description": "A mathematical inequality that relates the compressibility of a sequence to its predictability", "keywords": ["fano", "inequality", "compressibility", "predictability"], "source_lectures": ["lecture_106102229_w1_l6"]}}
{"id": "concept_return_address_stack", "type": "V_concept", "name": "Return Address Stack", "properties": {"description": "A stack that stores the return addresses of recently called functions", "keywords": ["return", "address", "stack", "function"], "source_lectures": ["lecture_106102229_w1_l6"]}}
{"id": "concept_fetch_unit", "type": "V_concept", "name": "Fetch Unit", "properties": {"description": "A component responsible for retrieving instructions from memory", "keywords": ["fetch", "unit", "instruction", "memory"], "source_lectures": ["lecture_106102229_w1_l7"]}}
{"id": "concept_decode_stage", "type": "V_concept", "name": "Decode Stage", "properties": {"description": "A stage in the pipeline where instructions are decoded and prepared for execution", "keywords": ["decode", "stage", "instruction", "pipeline"], "source_lectures": ["lecture_106102229_w1_l7"]}}
{"id": "concept_risc_instruction_set", "type": "V_concept", "name": "RISC Instruction Set", "properties": {"description": "A type of instruction set architecture that uses simple, fixed-length instructions", "keywords": ["risc", "instruction", "set", "architecture"], "source_lectures": ["lecture_106102229_w1_l7"]}}
{"id": "concept_cisc_instruction_set", "type": "V_concept", "name": "CISC Instruction Set", "properties": {"description": "A type of instruction set architecture that uses complex, variable-length instructions", "keywords": ["cisc", "instruction", "set", "architecture"], "source_lectures": ["lecture_106102229_w1_l7"]}}
{"id": "concept_microcode_cache", "type": "V_concept", "name": "Microcode Cache", "properties": {"description": "A cache that stores micro-operations for complex instructions", "keywords": ["microcode", "cache", "instruction", "microoperation"], "source_lectures": ["lecture_106102229_w1_l7"]}}
{"id": "concept_pre_decoding", "type": "V_concept", "name": "Pre-Decoding", "properties": {"description": "A technique used to identify instruction boundaries in the instruction cache", "keywords": ["pre-decoding", "instruction", "boundary", "cache"], "source_lectures": ["lecture_106102229_w1_l7"]}}
{"id": "concept_instruction_compression", "type": "V_concept", "name": "Instruction Compression", "properties": {"description": "A technique used to reduce the size of instructions in the instruction cache", "keywords": ["instruction", "compression", "cache", "size"], "source_lectures": ["lecture_106102229_w1_l7"]}}
{"id": "concept_code_word", "type": "V_concept", "name": "Code Word", "properties": {"description": "A short mnemonic that represents a sequence of instructions", "keywords": ["code", "word", "instruction", "sequence"], "source_lectures": ["lecture_106102229_w1_l7"]}}
{"id": "concept_micro_operation", "type": "V_concept", "name": "Micro-Operation", "properties": {"description": "A small, basic operation that is part of a larger instruction", "keywords": ["micro-operation", "instruction", "operation", "basic"], "source_lectures": ["lecture_106102229_w1_l7"]}}
{"id": "concept_load_store_queue", "type": "V_concept", "name": "Load Store Queue", "properties": {"description": "A data structure that manages the ordering of load and store instructions in a processor", "keywords": ["dependencies", "ordering", "processor", "load", "queue", "store"], "source_lectures": ["lecture_106102229_w2_l10", "lecture_106102229_w2_l11"]}}
{"id": "concept_bypass_paths", "type": "V_concept", "name": "Bypass Paths", "properties": {"description": "Paths that allow data to be forwarded from one instruction to another without going through the register file", "keywords": ["bypass", "paths", "data", "forwarding", "register"], "source_lectures": ["lecture_106102229_w2_l10"]}}
{"id": "concept_rename_table", "type": "V_concept", "name": "Rename Table", "properties": {"description": "A data structure that maps architectural registers to physical registers", "keywords": ["rename", "table", "registers", "mapping"], "source_lectures": ["lecture_106102229_w2_l10"]}}
{"id": "concept_double_broadcast", "type": "V_concept", "name": "Double Broadcast", "properties": {"description": "A technique used to handle corner cases in out-of-order pipelines", "keywords": ["double", "broadcast", "corner", "cases", "pipelines"], "source_lectures": ["lecture_106102229_w2_l10"]}}
{"id": "concept_store_queue", "type": "V_concept", "name": "Store Queue", "properties": {"description": "A buffer that holds store instructions that are waiting to be committed", "keywords": ["store", "queue", "buffer", "instructions", "commit"], "source_lectures": ["lecture_106102229_w2_l10"]}}
{"id": "concept_load_queue", "type": "V_concept", "name": "Load Queue", "properties": {"description": "A buffer that holds load instructions that are waiting to be executed", "keywords": ["load", "queue", "buffer", "instructions", "execution"], "source_lectures": ["lecture_106102229_w2_l10"]}}
{"id": "concept_content_addressable_array", "type": "V_concept", "name": "Content Addressable Array", "properties": {"description": "A type of memory that allows data to be accessed by its content rather than its address", "keywords": ["content", "addressable", "array", "memory", "access"], "source_lectures": ["lecture_106102229_w2_l10"]}}
{"id": "concept_tree_shaped_select_unit", "type": "V_concept", "name": "Tree-Shaped Select Unit", "properties": {"description": "A type of select unit that uses a tree-shaped structure to quickly find the position of a bit in a bit vector", "keywords": ["tree", "shaped", "select", "unit", "bit", "vector"], "source_lectures": ["lecture_106102229_w2_l10"]}}
{"id": "concept_instruction_commit", "type": "V_concept", "name": "Instruction Commit", "properties": {"description": "The process of removing instructions from the pipeline after they have been executed", "keywords": ["instruction", "state", "architectural", "commit", "execution", "pipeline"], "source_lectures": ["lecture_106102229_w2_l10", "lecture_106102229_w2_l11"]}}
{"id": "concept_instruction_retirement", "type": "V_concept", "name": "Instruction Retirement", "properties": {"description": "The process of removing instructions from the pipeline after they have been executed and their results have been committed", "keywords": ["instruction", "retirement", "pipeline", "execution", "commit"], "source_lectures": ["lecture_106102229_w2_l10"]}}
{"id": "concept_commit_width", "type": "V_concept", "name": "Commit Width", "properties": {"description": "The maximum number of instructions that can be committed per cycle.", "keywords": ["commit", "width", "instructions", "cycle"], "source_lectures": ["lecture_106102229_w2_l11"]}}
{"id": "concept_retirement_register_file", "type": "V_concept", "name": "Retirement Register File", "properties": {"description": "A file that stores the architectural register state of all committed instructions.", "keywords": ["retirement", "register", "file", "architectural", "state"], "source_lectures": ["lecture_106102229_w2_l11"]}}
{"id": "concept_register_alias_table", "type": "V_concept", "name": "Register Alias Table", "properties": {"description": "A table that maps architectural registers to physical registers.", "keywords": ["register", "alias", "table", "architectural", "physical"], "source_lectures": ["lecture_106102229_w2_l11"]}}
{"id": "concept_state_recovery", "type": "V_concept", "name": "State Recovery", "properties": {"description": "The process of restoring the architectural state to a previous point in time.", "keywords": ["state", "recovery", "architectural", "restore"], "source_lectures": ["lecture_106102229_w2_l11"]}}
{"id": "concept_branch_misprediction", "type": "V_concept", "name": "Branch Misprediction", "properties": {"description": "An incorrect prediction of the outcome of a branch instruction.", "keywords": ["branch", "misprediction", "prediction", "outcome"], "source_lectures": ["lecture_106102229_w2_l11"]}}
{"id": "concept_content_addressable_memory", "type": "V_concept", "name": "Content Addressable Memory", "properties": {"description": "A type of memory that allows searching by content rather than address.", "keywords": ["content", "addressable", "memory", "search"], "source_lectures": ["lecture_106102229_w2_l11"]}}
{"id": "concept_replay_mechanism", "type": "V_concept", "name": "Replay Mechanism", "properties": {"description": "A technique used in out-of-order pipelines to recover from mis-speculation by re-executing instructions that were dependent on incorrect speculative values.", "keywords": ["replay", "mechanism", "out-of-order", "pipeline", "speculation"], "source_lectures": ["lecture_106102229_w2_l13"]}}
{"id": "concept_forward_slice", "type": "V_concept", "name": "Forward Slice", "properties": {"description": "The set of instructions that are dependent on the value produced by a particular instruction, including the instruction itself and all its consumers.", "keywords": ["forward", "slice", "instruction", "dependency", "consumer"], "source_lectures": ["lecture_106102229_w2_l13"]}}
{"id": "concept_window_of_vulnerability", "type": "V_concept", "name": "Window of Vulnerability", "properties": {"description": "The period of time during which an instruction's operands may be affected by a mis-speculation, typically defined as the time between the instruction's selection and the completion of its execution.", "keywords": ["window", "vulnerability", "instruction", "operand", "mis-speculation"], "source_lectures": ["lecture_106102229_w2_l13"]}}
{"id": "concept_non_selective_replay", "type": "V_concept", "name": "Non-Selective Replay", "properties": {"description": "A replay scheme that squashes all instructions in the window of vulnerability, regardless of whether they are actually dependent on the mis-speculated value.", "keywords": ["non-selective", "replay", "scheme", "window", "vulnerability"], "source_lectures": ["lecture_106102229_w2_l13"]}}
{"id": "concept_delayed_selective_replay", "type": "V_concept", "name": "Delayed Selective Replay", "properties": {"description": "A replay scheme that uses a poison bit to identify instructions that are dependent on a mis-speculated value and only replays those instructions.", "keywords": ["delayed", "selective", "replay", "scheme", "poison", "bit"], "source_lectures": ["lecture_106102229_w2_l13"]}}
{"id": "concept_poison_bit", "type": "V_concept", "name": "Poison Bit", "properties": {"description": "A bit that is set to indicate that an instruction's value is potentially incorrect due to a mis-speculation.", "keywords": ["poison", "bit", "instruction", "value", "mis-speculation"], "source_lectures": ["lecture_106102229_w2_l13"]}}
{"id": "concept_token_based_replay", "type": "V_concept", "name": "Token-Based Replay", "properties": {"description": "A replay scheme that uses tokens to identify instructions that are dependent on a mis-speculated value and only replays those instructions.", "keywords": ["token-based", "replay", "scheme", "token", "instruction"], "source_lectures": ["lecture_106102229_w2_l13"]}}
{"id": "concept_orphan_instruction", "type": "V_concept", "name": "Orphan Instruction", "properties": {"description": "An instruction that is no longer dependent on any other instruction, but its operands are still invalid due to a mis-speculation.", "keywords": ["orphan", "instruction", "operand", "mis-speculation"], "source_lectures": ["lecture_106102229_w2_l13"]}}
{"id": "concept_replay_queue", "type": "V_concept", "name": "Replay Queue", "properties": {"description": "A buffer that stores instructions that have been issued but not yet verified to be correct, used to implement replay schemes.", "keywords": ["replay", "queue", "instruction", "buffer", "verification"], "source_lectures": ["lecture_106102229_w2_l13"]}}
{"id": "concept_hit_miss_predictor", "type": "V_concept", "name": "Hit-Miss Predictor", "properties": {"description": "A predictor that predicts whether a load instruction will hit or miss in the cache, used to guide replay schemes.", "keywords": ["hit-miss", "predictor", "load", "instruction", "cache"], "source_lectures": ["lecture_106102229_w2_l13"]}}
{"id": "concept_graphics_processor_unit", "type": "V_concept", "name": "Graphics Processor Unit", "properties": {"description": "A specialized electronic circuit designed to quickly manipulate and alter memory to accelerate the creation of images on a display device.", "keywords": ["gpu", "graphics", "processor", "unit"], "source_lectures": ["lecture_106102229_w3_l16"]}}
{"id": "concept_application_specific_integrated_circuit", "type": "V_concept", "name": "Application Specific Integrated Circuit", "properties": {"description": "An integrated circuit designed for a specific application, such as image processing or networking.", "keywords": ["asic", "integrated", "circuit", "application"], "source_lectures": ["lecture_106102229_w3_l16"]}}
{"id": "concept_general_purpose_graphics_processing_unit", "type": "V_concept", "name": "General Purpose Graphics Processing Unit", "properties": {"description": "A graphics processing unit designed to perform general-purpose computing tasks, in addition to graphics processing.", "keywords": ["gpgpu", "general", "purpose", "graphics", "processing"], "source_lectures": ["lecture_106102229_w3_l16"]}}
{"id": "concept_shader_program", "type": "V_concept", "name": "Shader Program", "properties": {"description": "A program that runs on a graphics processing unit, used to calculate and define the visual appearance of 3D objects.", "keywords": ["shader", "program", "graphics", "processing"], "source_lectures": ["lecture_106102229_w3_l16"]}}
{"id": "concept_vertex_processor", "type": "V_concept", "name": "Vertex Processor", "properties": {"description": "A component of a graphics processing unit that performs geometric transformations on 3D vertices.", "keywords": ["vertex", "processor", "graphics", "processing"], "source_lectures": ["lecture_106102229_w3_l16"]}}
{"id": "concept_rasterization", "type": "V_concept", "name": "Rasterization", "properties": {"description": "The process of converting 3D graphics into 2D pixels that can be displayed on a screen.", "keywords": ["rasterization", "graphics", "pixels", "screen"], "source_lectures": ["lecture_106102229_w3_l16"]}}
{"id": "concept_fragment_processor", "type": "V_concept", "name": "Fragment Processor", "properties": {"description": "A component of a graphics processing unit that performs calculations on fragments, such as pixels or texels.", "keywords": ["fragment", "processor", "graphics", "processing"], "source_lectures": ["lecture_106102229_w3_l16"]}}
{"id": "concept_pixel_engine", "type": "V_concept", "name": "Pixel Engine", "properties": {"description": "A component of a graphics processing unit that performs final rendering and display of pixels on a screen.", "keywords": ["pixel", "engine", "graphics", "processing"], "source_lectures": ["lecture_106102229_w3_l16"]}}
{"id": "concept_goraud_shading", "type": "V_concept", "name": "Goraud Shading", "properties": {"description": "A technique used to calculate the color of pixels in a 3D graphics scene, based on the colors of nearby vertices.", "keywords": ["goraud", "shading", "graphics", "pixels"], "source_lectures": ["lecture_106102229_w3_l16"]}}
{"id": "concept_phong_shading", "type": "V_concept", "name": "Phong Shading", "properties": {"description": "A technique used to calculate the color of pixels in a 3D graphics scene, based on the reflection and refraction of light.", "keywords": ["phong", "shading", "graphics", "light"], "source_lectures": ["lecture_106102229_w3_l16"]}}
{"id": "concept_linear_algebra", "type": "V_concept", "name": "Linear Algebra", "properties": {"description": "A branch of mathematics that deals with the study of linear equations, vector spaces, and linear transformations.", "keywords": ["linear", "algebra", "mathematics", "vectors"], "source_lectures": ["lecture_106102229_w3_l16"]}}
{"id": "concept_cuda", "type": "V_concept", "name": "CUDA", "properties": {"description": "A parallel computing platform and programming model developed by NVIDIA, used for general-purpose computing on graphics processing units.", "keywords": ["cuda", "parallel", "computing", "nvidia"], "source_lectures": ["lecture_106102229_w3_l16"]}}
{"id": "concept_ptx", "type": "V_concept", "name": "PTX", "properties": {"description": "A virtual instruction set architecture used by NVIDIA graphics processing units, designed to be compiled to native machine code at runtime.", "keywords": ["ptx", "virtual", "instruction", "nvidia"], "source_lectures": ["lecture_106102229_w3_l16"]}}
{"id": "concept_sass", "type": "V_concept", "name": "SASS", "properties": {"description": "A shader assembly language used by NVIDIA graphics processing units, designed to be compiled from high-level programming languages.", "keywords": ["sass", "shader", "assembly", "nvidia"], "source_lectures": ["lecture_106102229_w3_l16"]}}
{"id": "concept_cache_line", "type": "V_concept", "name": "Cache Line", "properties": {"description": "A block of memory that is transferred between the cache and main memory.", "keywords": ["cache unit", "block", "line", "memory", "cache", "cache line", "line size", "alignment", "cache block", "memory block", "data transfer"], "source_lectures": ["lecture_106102229_w3_l19", "lecture_106102229_w4_l28", "lecture_106103359_w3_l15", "lecture_106103359_w10_l69"]}}
{"id": "concept_direct_mapped_cache", "type": "V_concept", "name": "Direct Mapped Cache", "properties": {"description": "A cache organization where each memory block is mapped to a specific cache line.", "keywords": ["location", "conflict miss", "mapped", "one-to-one mapping", "cache organization", "organization", "direct mapped", "cache mapping", "direct", "cache"], "source_lectures": ["lecture_106102229_w3_l19", "lecture_106102229_w4_l24", "lecture_106103359_w3_l15"]}}
{"id": "concept_fully_associative_cache", "type": "V_concept", "name": "Fully Associative Cache", "properties": {"description": "A cache organization where a memory block can be stored in any cache line.", "keywords": ["no conflict miss", "anywhere", "cam", "mapping", "associative", "organization", "cache organization", "tag search", "array", "fully", "replacement policy", "fully associative", "cache"], "source_lectures": ["lecture_106102229_w3_l19", "lecture_106102229_w3_l21", "lecture_106102229_w4_l24", "lecture_106103359_w2_l13", "lecture_106103359_w3_l15"]}}
{"id": "concept_cache_tag", "type": "V_concept", "name": "Cache Tag", "properties": {"description": "A unique identifier stored with each cache line to identify the memory block it contains.", "keywords": ["memory", "identification", "identifier", "address", "tag", "cache"], "source_lectures": ["lecture_106102229_w3_l19", "lecture_106103359_w2_l13"]}}
{"id": "concept_write_through_cache", "type": "V_concept", "name": "Write-Through Cache", "properties": {"description": "A cache organization where every write operation is propagated to the lower-level memory.", "keywords": ["through", "main", "memory", "write-through", "write", "organization", "cache"], "source_lectures": ["lecture_106102229_w3_l19", "lecture_106103359_w4_l24", "lecture_106103359_w4_l25", "lecture_106103359_w5_l34"]}}
{"id": "concept_write_back_cache", "type": "V_concept", "name": "Write-Back Cache", "properties": {"description": "A cache organization where write operations are stored in the cache and only written to the lower-level memory when the cache line is replaced.", "keywords": ["main", "memory", "back", "write", "organization", "write-back", "cache"], "source_lectures": ["lecture_106102229_w3_l19", "lecture_106103359_w4_l25", "lecture_106103359_w4_l26", "lecture_106103359_w5_l34"]}}
{"id": "concept_least_recently_used_lru_replacement_policy", "type": "V_concept", "name": "Least Recently Used (LRU) Replacement Policy", "properties": {"description": "A cache replacement policy where the least recently used cache line is replaced first.", "keywords": ["lru", "replacement", "policy", "cache"], "source_lectures": ["lecture_106102229_w3_l19"]}}
{"id": "concept_pseudo_lru_replacement_policy", "type": "V_concept", "name": "Pseudo LRU Replacement Policy", "properties": {"description": "A cache replacement policy that approximates the LRU policy by using a saturating counter to track the recency of cache line access.", "keywords": ["pseudo", "lru", "replacement", "policy", "cache"], "source_lectures": ["lecture_106102229_w3_l19"]}}
{"id": "concept_average_memory_access_time", "type": "V_concept", "name": "Average Memory Access Time", "properties": {"description": "The average time it takes for a processor to access memory, including both hits and misses.", "keywords": ["amat", "memory", "access", "time", "average"], "source_lectures": ["lecture_106102229_w3_l20"]}}
{"id": "concept_cache_hit_time", "type": "V_concept", "name": "Cache Hit Time", "properties": {"description": "The time it takes for a processor to access data that is already in the cache.", "keywords": ["cache", "hit", "time", "access", "memory"], "source_lectures": ["lecture_106102229_w3_l20"]}}
{"id": "concept_cache_miss_penalty", "type": "V_concept", "name": "Cache Miss Penalty", "properties": {"description": "The additional time it takes for a processor to access data that is not in the cache.", "keywords": ["cache", "miss", "penalty", "time", "access"], "source_lectures": ["lecture_106102229_w3_l20"]}}
{"id": "concept_cache_miss_rate", "type": "V_concept", "name": "Cache Miss Rate", "properties": {"description": "The percentage of times that a processor accesses data that is not in the cache.", "keywords": ["cache", "miss", "rate", "percentage", "access"], "source_lectures": ["lecture_106102229_w3_l20"]}}
{"id": "concept_critical_word_first", "type": "V_concept", "name": "Critical Word First", "properties": {"description": "A technique that prioritizes the transfer of critical words in a cache block to reduce access time.", "keywords": ["critical", "word", "first", "cache", "access"], "source_lectures": ["lecture_106102229_w3_l20"]}}
{"id": "concept_virtual_memory", "type": "V_concept", "name": "Virtual Memory", "properties": {"description": "A memory management technique that uses a combination of physical memory and secondary storage to provide a large address space.", "keywords": ["physical", "memory", "process", "virtual", "space", "management", "address", "storage"], "source_lectures": ["lecture_106102229_w3_l20", "lecture_106103359_w3_l18"]}}
{"id": "concept_page_table", "type": "V_concept", "name": "Page Table", "properties": {"description": "A data structure that maps virtual pages to physical frames in virtual memory.", "keywords": ["physical", "mapping", "virtual", "table", "frames", "page"], "source_lectures": ["lecture_106102229_w3_l20", "lecture_106103359_w3_l18"]}}
{"id": "concept_translation_lookaside_buffer", "type": "V_concept", "name": "Translation Lookaside Buffer", "properties": {"description": "A cache that stores recently used page table entries to speed up virtual-to-physical address translation.", "keywords": ["memory virtualization", "physical", "virtual", "translation", "tlb", "translation lookaside buffer", "table", "cache", "page"], "source_lectures": ["lecture_106102229_w3_l20", "lecture_106103359_w3_l18", "lecture_106104182_w1_l2"]}}
{"id": "concept_page_replacement_policy", "type": "V_concept", "name": "Page Replacement Policy", "properties": {"description": "A policy that determines which page to replace when a new page needs to be allocated in virtual memory.", "keywords": ["page", "replacement", "policy", "virtual", "memory"], "source_lectures": ["lecture_106102229_w3_l20"]}}
{"id": "concept_sram_cell", "type": "V_concept", "name": "Sram Cell", "properties": {"description": "A type of memory cell used in static random-access memory (SRAM) that stores a bit of information", "keywords": ["sram", "memory", "cell", "static"], "source_lectures": ["lecture_106102229_w3_l21"]}}
{"id": "concept_cam_array", "type": "V_concept", "name": "Cam Array", "properties": {"description": "A type of memory array that uses content-addressable memory (CAM) cells to store and compare data", "keywords": ["cam", "array", "memory", "content-addressable"], "source_lectures": ["lecture_106102229_w3_l21"]}}
{"id": "concept_sense_amplifier", "type": "V_concept", "name": "Sense Amplifier", "properties": {"description": "A circuit used in SRAM and CAM arrays to amplify the difference in voltage between two bit lines", "keywords": ["sense", "amplifier", "voltage", "bit", "lines"], "source_lectures": ["lecture_106102229_w3_l21"]}}
{"id": "concept_precharging", "type": "V_concept", "name": "Precharging", "properties": {"description": "A technique used in SRAM and CAM arrays to quickly charge the bit lines to a pre-determined voltage", "keywords": ["precharging", "voltage", "bit", "lines", "speed"], "source_lectures": ["lecture_106102229_w3_l21"]}}
{"id": "concept_current_mirror", "type": "V_concept", "name": "Current Mirror", "properties": {"description": "A circuit used in sense amplifiers to mirror the current flowing through one branch to another branch", "keywords": ["current", "mirror", "circuit", "sense", "amplifier"], "source_lectures": ["lecture_106102229_w3_l21"]}}
{"id": "concept_priority_encoder", "type": "V_concept", "name": "Priority Encoder", "properties": {"description": "A circuit used in CAM arrays to encode the index of the match line with the highest priority", "keywords": ["priority", "encoder", "cam", "array", "index"], "source_lectures": ["lecture_106102229_w3_l21"]}}
{"id": "concept_tag_array", "type": "V_concept", "name": "Tag Array", "properties": {"description": "A type of memory array that stores tags or identifiers for data stored in a cache", "keywords": ["memory", "lookup", "identifier", "array", "tag", "cache"], "source_lectures": ["lecture_106102229_w3_l21", "lecture_106103359_w4_l23"]}}
{"id": "concept_data_array", "type": "V_concept", "name": "Data Array", "properties": {"description": "A type of memory array that stores the actual data in a cache", "keywords": ["data", "array", "cache", "memory", "storage"], "source_lectures": ["lecture_106102229_w3_l21"]}}
{"id": "concept_cacti_tool", "type": "V_concept", "name": "Cacti Tool", "properties": {"description": "An automatic cache design space exploration tool used to design and optimize caches", "keywords": ["cacti", "tool", "cache", "design", "optimization"], "source_lectures": ["lecture_106102229_w3_l21"]}}
{"id": "concept_word_line", "type": "V_concept", "name": "Word Line", "properties": {"description": "A signal used in caches to select the correct row of memory cells", "keywords": ["word", "line", "cache", "memory", "row"], "source_lectures": ["lecture_106102229_w3_l21"]}}
{"id": "concept_bit_line", "type": "V_concept", "name": "Bit Line", "properties": {"description": "A signal used in caches to read or write data from a memory cell", "keywords": ["bit", "line", "cache", "memory", "cell"], "source_lectures": ["lecture_106102229_w3_l21"]}}
{"id": "concept_data_access", "type": "V_concept", "name": "Data Access", "properties": {"description": "The process of retrieving or modifying data stored in a computer system.", "keywords": ["data", "access", "computer", "storage", "retrieval"], "source_lectures": ["lecture_106102229_w4_l23"]}}
{"id": "concept_cache_memory", "type": "V_concept", "name": "Cache Memory", "properties": {"description": "A small, fast memory that stores frequently-used data or instructions.", "keywords": ["memory", "instructions", "storage", "fast", "computer", "small", "data", "performance", "cache"], "source_lectures": ["lecture_106102229_w4_l23", "lecture_106102229_w5_l31", "lecture_106103359_w2_l13"]}}
{"id": "concept_computer_architecture", "type": "V_concept", "name": "Computer Architecture", "properties": {"description": "The design and organization of a computer's internal components, including the CPU, memory, and input/output devices.", "keywords": ["architecture", "engineering", "organization", "design", "computer", "components"], "source_lectures": ["lecture_106102229_w4_l23", "lecture_106102229_w5_l31", "lecture_106102229_w5_l32", "lecture_106103359_w1_l1"]}}
{"id": "concept_optimization_techniques", "type": "V_concept", "name": "Optimization Techniques", "properties": {"description": "Methods used to improve the performance, efficiency, or effectiveness of a computer system or algorithm.", "keywords": ["optimization", "techniques", "computer", "performance", "efficiency"], "source_lectures": ["lecture_106102229_w4_l23"]}}
{"id": "concept_computer_labs", "type": "V_concept", "name": "Computer Labs", "properties": {"description": "A facility or environment where computers and other technology are used for educational or research purposes.", "keywords": ["computer", "labs", "education", "research", "technology"], "source_lectures": ["lecture_106102229_w4_l23"]}}
{"id": "concept_programming_languages", "type": "V_concept", "name": "Programming Languages", "properties": {"description": "A set of rules and syntax used to write software programs.", "keywords": ["programming", "languages", "software", "development", "coding"], "source_lectures": ["lecture_106102229_w4_l23"]}}
{"id": "concept_virtual_address", "type": "V_concept", "name": "Virtual Address", "properties": {"description": "An address used by a computer to access memory or other resources, which is translated into a physical address.", "keywords": ["virtual", "address", "computer", "memory", "translation"], "source_lectures": ["lecture_106102229_w4_l23"]}}
{"id": "concept_trace_cache", "type": "V_concept", "name": "Trace Cache", "properties": {"description": "A type of cache that stores an entire sequence of decoded instructions to bypass predictors and decoders.", "keywords": ["cache", "trace", "instructions", "decoders", "predictors"], "source_lectures": ["lecture_106102229_w4_l24"]}}
{"id": "concept_markov_prefetching", "type": "V_concept", "name": "Markov Prefetching", "properties": {"description": "A prefetching technique that uses a Markov chain to predict the next cache line to be accessed based on the current access sequence.", "keywords": ["markov", "prefetching", "chain", "sequence"], "source_lectures": ["lecture_106102229_w4_l24"]}}
{"id": "concept_call_graph_prefetching", "type": "V_concept", "name": "Call Graph Prefetching", "properties": {"description": "A prefetching technique that predicts and fetches instructions based on the call graph of a program.", "keywords": ["call", "graph", "prefetching", "instructions"], "source_lectures": ["lecture_106102229_w4_l24"]}}
{"id": "concept_stride_based_prefetching", "type": "V_concept", "name": "Stride-Based Prefetching", "properties": {"description": "A prefetching technique that predicts and fetches data based on the stride of a memory access pattern.", "keywords": ["stride", "prefetching", "data", "access"], "source_lectures": ["lecture_106102229_w4_l24"]}}
{"id": "concept_run_ahead_mode", "type": "V_concept", "name": "Run-Ahead Mode", "properties": {"description": "A mode of execution where the processor executes instructions speculatively, without updating the architectural state, to prefetch data and train predictors.", "keywords": ["run", "ahead", "mode", "execution", "speculative"], "source_lectures": ["lecture_106102229_w4_l24"]}}
{"id": "concept_helper_threads", "type": "V_concept", "name": "Helper Threads", "properties": {"description": "A technique where a separate thread is executed on a separate core to prefetch data and compute addresses for a load instruction.", "keywords": ["helper", "threads", "prefetching", "data", "addresses"], "source_lectures": ["lecture_106102229_w4_l24"]}}
{"id": "concept_parallel_programming", "type": "V_concept", "name": "Parallel Programming", "properties": {"description": "A technique to achieve faster execution of a program by dividing it into smaller sub-problems that can be executed simultaneously by multiple processing units.", "keywords": ["parallel", "programming", "multicore", "concurrency"], "source_lectures": ["lecture_106102229_w4_l25"]}}
{"id": "concept_amdahls_law", "type": "V_concept", "name": "Amdahl's Law", "properties": {"description": "A theoretical bound on the maximum speedup that can be achieved by parallel processing, based on the fraction of the program that can be parallelized.", "keywords": ["law", "speedup", "amdahl's law", "performance limit", "parallel fraction", "sequential fraction", "parallel", "amdahl", "sequential", "parallelization", "processing"], "source_lectures": ["lecture_106102229_w4_l25", "lecture_106102229_w4_l28", "lecture_106103359_w1_l6", "lecture_106103359_w1_l7", "lecture_106103359_w10_l69"]}}
{"id": "concept_gustafsons_law", "type": "V_concept", "name": "Gustafson's Law", "properties": {"description": "A modification of Amdahl's Law that takes into account the scaling of the problem size with the number of processors, leading to a more optimistic prediction of parallel speedup.", "keywords": ["law", "speedup", "scalability", "scaling", "gustafson", "parallel", "parallelism", "processing"], "source_lectures": ["lecture_106102229_w4_l25", "lecture_106102229_w4_l28", "lecture_106103359_w1_l6", "lecture_106103359_w1_l7"]}}
{"id": "concept_flynns_classification", "type": "V_concept", "name": "Flynn's Classification", "properties": {"description": "A taxonomy of parallel computer architectures, including SISD, SIMD, MISD, and MIMD, based on the number of instruction streams and data streams.", "keywords": ["flynn", "classification", "parallel", "architecture"], "source_lectures": ["lecture_106102229_w4_l25"]}}
{"id": "concept_sisd_architecture", "type": "V_concept", "name": "SISD Architecture", "properties": {"description": "A single-instruction, single-data architecture, where one instruction is executed on a single data stream, typical of sequential computers.", "keywords": ["sisd", "architecture", "sequential", "single-instruction"], "source_lectures": ["lecture_106102229_w4_l25"]}}
{"id": "concept_simd_architecture", "type": "V_concept", "name": "SIMD Architecture", "properties": {"description": "A single-instruction, multiple-data architecture, where one instruction is executed on multiple data streams, typical of vector processors and GPUs.", "keywords": ["architecture", "processors", "gpu", "parallel", "vector", "simd", "data"], "source_lectures": ["lecture_106102229_w4_l25", "lecture_106103359_w1_l3", "lecture_106103359_w2_l8"]}}
{"id": "concept_misd_architecture", "type": "V_concept", "name": "MISD Architecture", "properties": {"description": "A multiple-instruction, single-data architecture, where multiple instructions are executed on a single data stream, typical of some specialized processors.", "keywords": ["misd", "architecture", "specialized", "multiple-instruction"], "source_lectures": ["lecture_106102229_w4_l25"]}}
{"id": "concept_mimd_architecture", "type": "V_concept", "name": "MIMD Architecture", "properties": {"description": "A multiple-instruction, multiple-data architecture, where multiple instructions are executed on multiple data streams, typical of modern parallel computers.", "keywords": ["architecture", "parallel", "mimd", "data", "multiple-instruction"], "source_lectures": ["lecture_106102229_w4_l25", "lecture_106103359_w1_l3"]}}
{"id": "concept_hardware_thread", "type": "V_concept", "name": "Hardware Thread", "properties": {"description": "A separate flow of execution that can run concurrently with other threads on the same core, utilizing the core's resources.", "keywords": ["concurrency", "thread", "hardware", "core", "hyper-threading"], "source_lectures": ["lecture_106102229_w4_l25", "lecture_106102229_w4_l28"]}}
{"id": "concept_simultaneous_multithreading_smt", "type": "V_concept", "name": "Simultaneous Multithreading (SMT)", "properties": {"description": "A technique that allows multiple hardware threads to run concurrently on the same core, improving resource utilization and throughput.", "keywords": ["smt", "multithreading", "concurrency", "core"], "source_lectures": ["lecture_106102229_w4_l25"]}}
{"id": "concept_hyperthreading", "type": "V_concept", "name": "Hyperthreading", "properties": {"description": "A specific implementation of SMT, where the core's resources are divided between two threads, improving throughput for certain workloads.", "keywords": ["hyperthreading", "smt", "concurrency", "core"], "source_lectures": ["lecture_106102229_w4_l25"]}}
{"id": "concept_openmp", "type": "V_concept", "name": "OpenMP", "properties": {"description": "A programming model and API for parallel programming on shared-memory architectures, providing a simple and efficient way to parallelize loops and tasks.", "keywords": ["openmp", "parallel", "programming", "shared-memory"], "source_lectures": ["lecture_106102229_w4_l25"]}}
{"id": "concept_message_passing_interface_mpi", "type": "V_concept", "name": "Message Passing Interface (MPI)", "properties": {"description": "A standardized API for message passing between processes in a parallel program, allowing for communication and coordination between processes.", "keywords": ["mpi", "message", "passing", "parallel"], "source_lectures": ["lecture_106102229_w4_l25"]}}
{"id": "concept_distributed_cache", "type": "V_concept", "name": "Distributed Cache", "properties": {"description": "A cache architecture where multiple small, private caches (one per core) collectively appear as a single large shared cache to software.", "keywords": ["distributed cache", "private cache", "sister cache", "multi-core", "cache coherence"], "source_lectures": ["lecture_106102229_w4_l26"]}}
{"id": "concept_memory_consistency_model", "type": "V_concept", "name": "Memory Consistency Model", "properties": {"description": "A specification that defines the allowed orderings of memory operations across multiple threads in a parallel system.", "keywords": ["memory consistency", "memory model", "parallel execution", "ordering", "specification"], "source_lectures": ["lecture_106102229_w4_l26"]}}
{"id": "concept_sequential_execution", "type": "V_concept", "name": "Sequential Execution", "properties": {"description": "An execution where all memory operations are ordered linearly, and each read returns the value of the most recent write to the same address.", "keywords": ["sequential execution", "linear order", "read-write order", "legal execution", "single-threaded"], "source_lectures": ["lecture_106102229_w4_l26"]}}
{"id": "concept_parallel_execution", "type": "V_concept", "name": "Parallel Execution", "properties": {"description": "An execution involving multiple threads running concurrently on different cores, with memory operations potentially interleaved in any order.", "keywords": ["parallel execution", "concurrent threads", "multi-core", "interleaving", "memory operations"], "source_lectures": ["lecture_106102229_w4_l26"]}}
{"id": "concept_execution_equivalence", "type": "V_concept", "name": "Execution Equivalence", "properties": {"description": "A relationship between a parallel execution and a sequential execution where operations from each thread appear in the same relative order in both.", "keywords": ["execution equivalence", "sequential equivalence", "thread order", "bijection", "parallel to sequential"], "source_lectures": ["lecture_106102229_w4_l26"]}}
{"id": "concept_atomicity_memory_operation", "type": "V_concept", "name": "Atomicity (Memory Operation)", "properties": {"description": "The property that a memory operation appears to take effect instantaneously at a single point in time, with no observable intermediate state.", "keywords": ["atomicity", "memory operation", "instantaneous", "visibility", "consistency"], "source_lectures": ["lecture_106102229_w4_l26"]}}
{"id": "concept_load_store_queue_lsq", "type": "V_concept", "name": "Load-Store Queue (LSQ)", "properties": {"description": "A hardware structure in out-of-order processors that tracks pending load and store operations and enforces memory ordering constraints.", "keywords": ["load-store queue", "lsq", "memory ordering", "out-of-order", "memory dependency"], "source_lectures": ["lecture_106102229_w4_l26"]}}
{"id": "concept_network_on_chip_noc", "type": "V_concept", "name": "Network-on-Chip (NoC)", "properties": {"description": "A communication subsystem on a chip that connects multiple cores, caches, and memory controllers in a multicore system.", "keywords": ["network on chip", "noc", "on-chip network", "interconnect", "multicore communication"], "source_lectures": ["lecture_106102229_w4_l26"]}}
{"id": "concept_memory_address_visibility", "type": "V_concept", "name": "Memory Address Visibility", "properties": {"description": "The property that a write to a memory address becomes observable by other cores after it has been propagated through the memory hierarchy.", "keywords": ["memory visibility", "write visibility", "cache coherence", "memory update", "core visibility"], "source_lectures": ["lecture_106102229_w4_l26"]}}
{"id": "concept_non_intuitive_outcome_memory", "type": "V_concept", "name": "Non-Intuitive Outcome (Memory)", "properties": {"description": "A program outcome that violates expected sequential behavior due to reordering by hardware or memory system optimizations.", "keywords": ["non-intuitive outcome", "memory anomaly", "unexpected result", "parallel bug", "memory reordering"], "source_lectures": ["lecture_106102229_w4_l26"]}}
{"id": "concept_shared_memory_model", "type": "V_concept", "name": "Shared Memory Model", "properties": {"description": "A programming model where multiple threads access a common memory space, requiring synchronization for correctness.", "keywords": ["shared memory", "memory model", "thread synchronization", "multi-threading", "concurrent access"], "source_lectures": ["lecture_106102229_w4_l26"]}}
{"id": "concept_global_variable", "type": "V_concept", "name": "Global Variable", "properties": {"description": "A variable accessible and modifiable by multiple threads or cores, requiring coherence mechanisms for correct access.", "keywords": ["global variable", "shared variable", "multi-core", "thread access", "memory location"], "source_lectures": ["lecture_106102229_w4_l26"]}}
{"id": "concept_local_variable", "type": "V_concept", "name": "Local Variable", "properties": {"description": "A variable private to a single thread or core, typically stored in registers and not visible to other threads.", "keywords": ["local variable", "private variable", "register", "thread-local", "non-shared"], "source_lectures": ["lecture_106102229_w4_l26"]}}
{"id": "concept_completion_time_memory_operation", "type": "V_concept", "name": "Completion Time (Memory Operation)", "properties": {"description": "The point in time when a memory operation (read or write) becomes globally visible and its effect is finalized.", "keywords": ["completion time", "memory completion", "visibility time", "operation finalization", "global effect"], "source_lectures": ["lecture_106102229_w4_l26"]}}
{"id": "concept_start_time_memory_operation", "type": "V_concept", "name": "Start Time (Memory Operation)", "properties": {"description": "The time when a memory operation is initiated by a core, such as when a load or store instruction is issued.", "keywords": ["start time", "memory start", "operation initiation", "instruction issue", "pipeline entry"], "source_lectures": ["lecture_106102229_w4_l26"]}}
{"id": "concept_end_time_memory_operation", "type": "V_concept", "name": "End Time (Memory Operation)", "properties": {"description": "The time when a memory operation completes locally within the issuing core\u2019s pipeline, regardless of global visibility.", "keywords": ["end time", "local completion", "pipeline exit", "operation end", "core-bound"], "source_lectures": ["lecture_106102229_w4_l26"]}}
{"id": "concept_memory_ordering", "type": "V_concept", "name": "Memory Ordering", "properties": {"description": "The constraints on the relative order in which memory operations from different threads become visible to each other.", "keywords": ["ordering", "memory", "relaxed", "visibility order", "operation ordering", "sequential", "reordering", "memory ordering", "consistency"], "source_lectures": ["lecture_106102229_w4_l26", "lecture_106102229_w4_l28"]}}
{"id": "concept_write_to_read_ordering_violation", "type": "V_concept", "name": "Write-to-Read Ordering Violation", "properties": {"description": "A scenario where a read operation observes an older value than a preceding write to the same or different address due to reordering.", "keywords": ["write-read ordering", "reordering violation", "memory anomaly", "out-of-order", "load-store"], "source_lectures": ["lecture_106102229_w4_l26"]}}
{"id": "concept_multi_ported_cache", "type": "V_concept", "name": "Multi-Ported Cache", "properties": {"description": "A cache designed to handle multiple concurrent access requests from different cores, often at the cost of increased complexity and latency.", "keywords": ["multi-ported cache", "concurrent access", "cache port", "shared cache", "multi-core"], "source_lectures": ["lecture_106102229_w4_l26"]}}
{"id": "concept_bank_conflict_cache", "type": "V_concept", "name": "Bank Conflict (Cache)", "properties": {"description": "A performance degradation in multi-bank caches when multiple requests target the same memory bank simultaneously.", "keywords": ["bank conflict", "cache bank", "memory bank", "concurrency", "latency"], "source_lectures": ["lecture_106102229_w4_l26"]}}
{"id": "concept_message_congestion_noc", "type": "V_concept", "name": "Message Congestion (NoC)", "properties": {"description": "A condition in a Network-on-Chip where high traffic volume causes delays in message delivery between cores or caches.", "keywords": ["message congestion", "noc congestion", "network delay", "on-chip network", "traffic jam"], "source_lectures": ["lecture_106102229_w4_l26"]}}
{"id": "concept_deadlock_noc", "type": "V_concept", "name": "Deadlock (NoC)", "properties": {"description": "A situation in a Network-on-Chip where two or more messages are blocked indefinitely, each waiting for the other to release resources.", "keywords": ["deadlock", "noc deadlock", "network deadlock", "resource wait", "communication deadlock"], "source_lectures": ["lecture_106102229_w4_l26"]}}
{"id": "concept_starvation_noc", "type": "V_concept", "name": "Starvation (NoC)", "properties": {"description": "A condition in a Network-on-Chip where a message is perpetually denied service due to prioritization of other messages.", "keywords": ["starvation", "noc starvation", "message starvation", "resource starvation", "priority"], "source_lectures": ["lecture_106102229_w4_l26"]}}
{"id": "concept_live_lock_noc", "type": "V_concept", "name": "Live Lock (NoC)", "properties": {"description": "A situation in a Network-on-Chip where messages continuously change state without making progress toward completion.", "keywords": ["live lock", "noc live lock", "progress starvation", "state cycling", "no forward progress"], "source_lectures": ["lecture_106102229_w4_l26"]}}
{"id": "concept_memory_hierarchy", "type": "V_concept", "name": "Memory Hierarchy", "properties": {"description": "The layered structure of storage in a computer system, including registers, L1, L2, L3 caches, and main memory.", "keywords": ["cache", "memory", "latency", "memory hierarchy", "l3 cache", "main memory", "l1 cache", "locality", "ram", "storage layers", "hierarchy", "cache levels", "l2 cache"], "source_lectures": ["lecture_106102229_w4_l26", "lecture_106102229_w4_l28", "lecture_106103359_w2_l9", "lecture_106103359_w2_l13"]}}
{"id": "concept_multicore_systems", "type": "V_concept", "name": "Multicore Systems", "properties": {"description": "A type of computer processor that contains multiple processing cores on a single chip.", "keywords": ["systems", "architecture", "processor", "chip", "multicore", "computer"], "source_lectures": ["lecture_106102229_w4_l27", "lecture_106102229_w5_l31", "lecture_106102229_w5_l32"]}}
{"id": "concept_distributed_systems", "type": "V_concept", "name": "Distributed Systems", "properties": {"description": "A collection of independent computers that appear to be a single, cohesive system to the user.", "keywords": ["distributed", "systems", "computer", "network", "cohesive"], "source_lectures": ["lecture_106102229_w4_l27"]}}
{"id": "concept_cache_consistency", "type": "V_concept", "name": "Cache Consistency", "properties": {"description": "A mechanism to ensure that changes made to data in one cache are reflected in all other caches.", "keywords": ["reflection", "mechanism", "coherence", "cache consistency", "memory consistency", "protocol", "multicore", "system", "shared memory", "write ordering", "data", "consistency", "cache"], "source_lectures": ["lecture_106102229_w4_l27", "lecture_106102229_w5_l32", "lecture_106103359_w2_l9"]}}
{"id": "concept_atomicity", "type": "V_concept", "name": "Atomicity", "properties": {"description": "A property of an operation that ensures it is executed as a single, indivisible unit.", "keywords": ["instruction", "property", "operation", "atomicity", "indivisible", "transaction", "uninterruptible", "unit", "consistency"], "source_lectures": ["lecture_106102229_w4_l27", "lecture_106102229_w5_l33", "lecture_106103359_w9_l60"]}}
{"id": "concept_memory_allocation", "type": "V_concept", "name": "Memory Allocation", "properties": {"description": "The process of assigning memory to a program or variable.", "keywords": ["memory", "allocation", "process", "program", "variable"], "source_lectures": ["lecture_106102229_w4_l27"]}}
{"id": "concept_synchronization", "type": "V_concept", "name": "Synchronization", "properties": {"description": "The process of coordinating the actions of multiple processes or threads.", "keywords": ["concurrency", "thread", "coordination", "processes", "process", "technique", "action", "resources", "synchronization", "access", "shared", "parallelism", "multithreading", "execution", "threads"], "source_lectures": ["lecture_106102229_w4_l27", "lecture_106102229_w5_l32", "lecture_106103359_w2_l8", "lecture_106103359_w2_l10", "lecture_106103359_w9_l59"]}}
{"id": "concept_parallel_processing", "type": "V_concept", "name": "Parallel Processing", "properties": {"description": "A technique where multiple processors or cores execute multiple tasks simultaneously.", "keywords": ["tasks", "instructions", "computing power", "processor", "technique", "units", "parallel", "performance", "processing", "core", "concurrent", "simultaneous"], "source_lectures": ["lecture_106102229_w4_l27", "lecture_106102229_w5_l31", "lecture_106102229_w5_l32", "lecture_106103359_w1_l1"]}}
{"id": "concept_multicore_system", "type": "V_concept", "name": "Multicore System", "properties": {"description": "A computer processor that contains two or more independent processing units (cores) on a single chip to improve performance and parallelism.", "keywords": ["multicore", "processor", "core", "parallel processing", "computer architecture"], "source_lectures": ["lecture_106102229_w4_l28"]}}
{"id": "concept_memory_model", "type": "V_concept", "name": "Memory Model", "properties": {"description": "A specification that defines how memory is organized, accessed, and managed in a computer system, especially in the context of concurrent or parallel execution.", "keywords": ["model", "memory", "memory hierarchy", "organization", "access", "computer"], "source_lectures": ["lecture_106102229_w4_l28", "lecture_106102229_w5_l31"]}}
{"id": "concept_data_dependency", "type": "V_concept", "name": "Data Dependency", "properties": {"description": "A condition in which an instruction depends on the result of a previous instruction, potentially limiting parallel execution in multicore systems.", "keywords": ["data", "dependency", "parallelism", "instruction", "pipeline"], "source_lectures": ["lecture_106102229_w4_l28"]}}
{"id": "concept_control_dependency", "type": "V_concept", "name": "Control Dependency", "properties": {"description": "A condition where the execution of an instruction depends on the outcome of a branch or conditional statement, affecting instruction scheduling in multicore processors.", "keywords": ["control", "dependency", "branch", "execution", "pipeline"], "source_lectures": ["lecture_106102229_w4_l28"]}}
{"id": "concept_shared_memory_architecture", "type": "V_concept", "name": "Shared Memory Architecture", "properties": {"description": "A system design where multiple processors access a common physical memory space, requiring coordination to avoid conflicts.", "keywords": ["architecture", "multiprocessor", "memory", "memory architecture", "synchronization", "smp", "multicore", "shared", "shared memory", "uniform memory"], "source_lectures": ["lecture_106102229_w4_l28", "lecture_106103359_w2_l10", "lecture_106103359_w10_l69"]}}
{"id": "concept_thread_synchronization", "type": "V_concept", "name": "Thread Synchronization", "properties": {"description": "The coordination of multiple threads to ensure correct access to shared resources and prevent race conditions in multicore environments.", "keywords": ["thread", "synchronization", "mutex", "lock", "race condition"], "source_lectures": ["lecture_106102229_w4_l28"]}}
{"id": "concept_memory_bandwidth", "type": "V_concept", "name": "Memory Bandwidth", "properties": {"description": "The rate at which data can be read from or written to memory, often a bottleneck in multicore systems due to concurrent access demands.", "keywords": ["bottleneck", "data transfer rate", "memory", "bandwidth", "latency", "memory bandwidth", "throughput", "memory throughput"], "source_lectures": ["lecture_106102229_w4_l28", "lecture_106103359_w2_l9"]}}
{"id": "concept_false_sharing", "type": "V_concept", "name": "False Sharing", "properties": {"description": "A performance issue in multicore systems where multiple cores modify variables residing on the same cache line, causing unnecessary cache invalidations.", "keywords": ["false", "coherence", "sharing", "performance", "cache"], "source_lectures": ["lecture_106102229_w4_l28", "lecture_106103359_w10_l67"]}}
{"id": "concept_lock_free_data_structure", "type": "V_concept", "name": "Lock-Free Data Structure", "properties": {"description": "A concurrent data structure that allows multiple threads to access and modify it without using traditional locks, relying on atomic operations instead.", "keywords": ["lock-free", "concurrent", "data structure", "atomic", "thread-safe"], "source_lectures": ["lecture_106102229_w4_l28"]}}
{"id": "concept_atomic_operation", "type": "V_concept", "name": "Atomic Operation", "properties": {"description": "An operation that completes in a single step without interruption, ensuring thread safety in shared memory environments.", "keywords": ["atomic", "operation", "thread", "synchronization", "indivisible"], "source_lectures": ["lecture_106102229_w4_l28"]}}
{"id": "concept_software_thread", "type": "V_concept", "name": "Software Thread", "properties": {"description": "A logical unit of execution managed by the operating system or runtime environment, which may be scheduled across multiple hardware threads.", "keywords": ["software", "thread", "scheduler", "os", "concurrency"], "source_lectures": ["lecture_106102229_w4_l28"]}}
{"id": "concept_task_parallelism", "type": "V_concept", "name": "Task Parallelism", "properties": {"description": "A form of parallel computing where different tasks or functions are executed simultaneously across multiple cores.", "keywords": ["concurrency", "units", "multicore", "function", "division", "parallelism", "task", "processing"], "source_lectures": ["lecture_106102229_w4_l28", "lecture_106103359_w1_l7"]}}
{"id": "concept_data_parallelism", "type": "V_concept", "name": "Data Parallelism", "properties": {"description": "A form of parallel computing where the same operation is applied simultaneously to multiple data elements across different cores.", "keywords": ["programming", "processors", "units", "vector", "multicore", "division", "parallelism", "simd", "data", "processing"], "source_lectures": ["lecture_106102229_w4_l28", "lecture_106103359_w1_l7", "lecture_106103359_w2_l8"]}}
{"id": "concept_numa_architecture", "type": "V_concept", "name": "NUMA Architecture", "properties": {"description": "Non-Uniform Memory Access architecture where memory access time depends on the memory location relative to the processor.", "keywords": ["architecture", "memory", "numa", "non-uniform", "multicore"], "source_lectures": ["lecture_106102229_w4_l28", "lecture_106103359_w2_l10"]}}
{"id": "concept_synchronization_primitive", "type": "V_concept", "name": "Synchronization Primitive", "properties": {"description": "A low-level construct used to control access to shared resources in concurrent programming, such as mutexes, semaphores, or barriers.", "keywords": ["synchronization", "primitive", "mutex", "semaphore", "barrier"], "source_lectures": ["lecture_106102229_w4_l28"]}}
{"id": "concept_pipeline_stalling", "type": "V_concept", "name": "Pipeline Stalling", "properties": {"description": "A delay in the instruction pipeline caused by dependencies or resource conflicts, reducing throughput in multicore processors.", "keywords": ["pipeline", "stalling", "dependency", "throughput", "latency"], "source_lectures": ["lecture_106102229_w4_l28"]}}
{"id": "concept_core_affinity", "type": "V_concept", "name": "Core Affinity", "properties": {"description": "The binding of a thread or process to a specific CPU core to improve cache locality and reduce context-switching overhead.", "keywords": ["core", "affinity", "thread", "cpu", "locality"], "source_lectures": ["lecture_106102229_w4_l28"]}}
{"id": "concept_parallel_programming_model", "type": "V_concept", "name": "Parallel Programming Model", "properties": {"description": "A framework or methodology for writing programs that execute multiple threads or processes concurrently, such as OpenMP or MPI.", "keywords": ["parallel", "programming", "model", "openmp", "mpi"], "source_lectures": ["lecture_106102229_w4_l28"]}}
{"id": "concept_race_condition", "type": "V_concept", "name": "Race Condition", "properties": {"description": "An undesirable situation that occurs when multiple threads access shared data concurrently and the outcome depends on the timing of their execution.", "keywords": ["concurrency", "thread", "non-deterministic", "race", "timing", "system", "inconsistent state", "condition", "shared resource", "shared", "distributed", "race condition"], "source_lectures": ["lecture_106102229_w4_l28", "lecture_106103359_w8_l52", "lecture_106104182_w2_l12"]}}
{"id": "concept_memory_fence", "type": "V_concept", "name": "Memory Fence", "properties": {"description": "A hardware or software instruction that enforces ordering of memory operations to prevent reordering by the compiler or processor.", "keywords": ["memory", "fence", "barrier", "ordering", "atomic"], "source_lectures": ["lecture_106102229_w4_l28"]}}
{"id": "concept_load_store_unit", "type": "V_concept", "name": "Load-Store Unit", "properties": {"description": "A component within a processor core responsible for executing memory read (load) and write (store) operations.", "keywords": ["load", "store", "unit", "processor", "memory"], "source_lectures": ["lecture_106102229_w4_l28"]}}
{"id": "concept_cache_coherence_protocols", "type": "V_concept", "name": "Cache Coherence Protocols", "properties": {"description": "Protocols used to maintain consistency among multiple caches in a multicore system", "keywords": ["cache", "coherence", "protocols", "multicore"], "source_lectures": ["lecture_106102229_w5_l29"]}}
{"id": "concept_write_update_protocol", "type": "V_concept", "name": "Write Update Protocol", "properties": {"description": "A cache coherence protocol where a write is broadcasted to all caches", "keywords": ["multiprocessor", "update", "cache update", "coherence", "write", "protocol", "shared data", "write update", "cache", "coherence protocol"], "source_lectures": ["lecture_106102229_w5_l29", "lecture_106103359_w4_l23", "lecture_106103359_w10_l69"]}}
{"id": "concept_snoopy_bus", "type": "V_concept", "name": "Snoopy Bus", "properties": {"description": "A type of bus used in cache coherence protocols where all caches can read and write to the bus", "keywords": ["snoopy", "bus", "cache", "coherence"], "source_lectures": ["lecture_106102229_w5_l29"]}}
{"id": "concept_msi_protocol", "type": "V_concept", "name": "MSI Protocol", "properties": {"description": "A cache coherence protocol with three states: Modified, Shared, and Invalid", "keywords": ["coherence", "msi", "protocol", "cache"], "source_lectures": ["lecture_106102229_w5_l29", "lecture_106103359_w4_l25"]}}
{"id": "concept_cache_state_transitions", "type": "V_concept", "name": "Cache State Transitions", "properties": {"description": "The process of changing the state of a cache line in response to read and write requests", "keywords": ["cache", "state", "transitions", "read", "write"], "source_lectures": ["lecture_106102229_w5_l29"]}}
{"id": "concept_read_miss_message", "type": "V_concept", "name": "Read Miss Message", "properties": {"description": "A message sent by a cache when it misses a read request", "keywords": ["read", "miss", "message", "cache"], "source_lectures": ["lecture_106102229_w5_l29"]}}
{"id": "concept_write_miss_message", "type": "V_concept", "name": "Write Miss Message", "properties": {"description": "A message sent by a cache when it misses a write request", "keywords": ["write", "miss", "message", "cache"], "source_lectures": ["lecture_106102229_w5_l29"]}}
{"id": "concept_upgrade_message", "type": "V_concept", "name": "Upgrade Message", "properties": {"description": "A message sent by a cache to upgrade its state from Shared to Modified", "keywords": ["upgrade", "message", "cache", "state"], "source_lectures": ["lecture_106102229_w5_l29"]}}
{"id": "concept_evict_message", "type": "V_concept", "name": "Evict Message", "properties": {"description": "A message sent by a cache when it evicts a cache line", "keywords": ["evict", "message", "cache", "line"], "source_lectures": ["lecture_106102229_w5_l29"]}}
{"id": "concept_seamless_eviction", "type": "V_concept", "name": "Seamless Eviction", "properties": {"description": "The process of evicting a cache line without writing it back to main memory", "keywords": ["seamless", "eviction", "cache", "line"], "source_lectures": ["lecture_106102229_w5_l29"]}}
{"id": "concept_cache_coherence_axioms", "type": "V_concept", "name": "Cache Coherence Axioms", "properties": {"description": "The fundamental principles that govern cache coherence protocols", "keywords": ["cache", "coherence", "axioms", "principles"], "source_lectures": ["lecture_106102229_w5_l29"]}}
{"id": "concept_processor_consistency", "type": "V_concept", "name": "Processor Consistency", "properties": {"description": "A model that describes how multiple processors in a shared-memory system access and update shared variables.", "keywords": ["processor", "consistency", "model", "shared-memory", "variables"], "source_lectures": ["lecture_106102229_w5_l31"]}}
{"id": "concept_advanced_computer_architecture", "type": "V_concept", "name": "Advanced Computer Architecture", "properties": {"description": "A field of study that focuses on the design and development of high-performance computer systems.", "keywords": ["advanced", "computer", "architecture", "high-performance", "systems"], "source_lectures": ["lecture_106102229_w5_l32"]}}
{"id": "concept_transactional_memory", "type": "V_concept", "name": "Transactional Memory", "properties": {"description": "A parallel programming paradigm that manages concurrent access to shared memory by grouping related memory accesses into transactions.", "keywords": ["transactional", "memory", "concurrency", "parallelism"], "source_lectures": ["lecture_106102229_w5_l33"]}}
{"id": "concept_lock_and_unlock_functions", "type": "V_concept", "name": "Lock And Unlock Functions", "properties": {"description": "Mechanisms used to synchronize access to shared resources in a multithreaded environment.", "keywords": ["lock", "unlock", "synchronization", "multithreading"], "source_lectures": ["lecture_106102229_w5_l33"]}}
{"id": "concept_disjoint_access_parallelism", "type": "V_concept", "name": "Disjoint Access Parallelism", "properties": {"description": "A technique that allows multiple threads to access different parts of a shared resource in parallel without conflicts.", "keywords": ["disjoint", "access", "parallelism", "concurrency"], "source_lectures": ["lecture_106102229_w5_l33"]}}
{"id": "concept_two_phase_locking", "type": "V_concept", "name": "Two Phase Locking", "properties": {"description": "A protocol that ensures deadlock-free execution by acquiring locks in a specific order.", "keywords": ["two", "phase", "locking", "deadlock"], "source_lectures": ["lecture_106102229_w5_l33"]}}
{"id": "concept_serializability", "type": "V_concept", "name": "Serializability", "properties": {"description": "A consistency model that ensures the execution of transactions is equivalent to a serial execution.", "keywords": ["serializability", "consistency", "transaction"], "source_lectures": ["lecture_106102229_w5_l33"]}}
{"id": "concept_strict_serializability", "type": "V_concept", "name": "Strict Serializability", "properties": {"description": "A consistency model that ensures the execution of transactions is equivalent to a serial execution, with the additional constraint of real-time ordering.", "keywords": ["strict", "serializability", "consistency", "transaction"], "source_lectures": ["lecture_106102229_w5_l33"]}}
{"id": "concept_opacity", "type": "V_concept", "name": "Opacity", "properties": {"description": "A property of transactions that ensures even aborted transactions see a consistent state.", "keywords": ["opacity", "transaction", "consistency"], "source_lectures": ["lecture_106102229_w5_l33"]}}
{"id": "concept_software_transactional_memory", "type": "V_concept", "name": "Software Transactional Memory", "properties": {"description": "A programming paradigm that implements transactional memory using software-only techniques.", "keywords": ["software", "transactional", "memory", "concurrency"], "source_lectures": ["lecture_106102229_w5_l33"]}}
{"id": "concept_hardware_transactional_memory", "type": "V_concept", "name": "Hardware Transactional Memory", "properties": {"description": "A programming paradigm that implements transactional memory using hardware-only techniques.", "keywords": ["hardware", "transactional", "memory", "concurrency"], "source_lectures": ["lecture_106102229_w5_l33"]}}
{"id": "concept_undo_log", "type": "V_concept", "name": "Undo Log", "properties": {"description": "A data structure used to store the original values of variables before they are modified by a transaction.", "keywords": ["undo", "log", "transaction", "recovery"], "source_lectures": ["lecture_106102229_w5_l33"]}}
{"id": "concept_redo_log", "type": "V_concept", "name": "Redo Log", "properties": {"description": "A data structure used to store the new values of variables modified by a transaction.", "keywords": ["redo", "log", "transaction", "recovery"], "source_lectures": ["lecture_106102229_w5_l33"]}}
{"id": "concept_conflict_detection", "type": "V_concept", "name": "Conflict Detection", "properties": {"description": "A mechanism used to detect conflicts between transactions.", "keywords": ["conflict", "detection", "transaction", "concurrency"], "source_lectures": ["lecture_106102229_w5_l33"]}}
{"id": "concept_pessimistic_concurrency_control", "type": "V_concept", "name": "Pessimistic Concurrency Control", "properties": {"description": "A technique that detects and resolves conflicts as soon as they occur.", "keywords": ["pessimistic", "concurrency", "control", "conflict"], "source_lectures": ["lecture_106102229_w5_l33"]}}
{"id": "concept_optimistic_concurrency_control", "type": "V_concept", "name": "Optimistic Concurrency Control", "properties": {"description": "A technique that detects and resolves conflicts at the end of a transaction.", "keywords": ["optimistic", "concurrency", "control", "conflict"], "source_lectures": ["lecture_106102229_w5_l33"]}}
{"id": "concept_instruction_set_architecture", "type": "V_concept", "name": "Instruction Set Architecture", "properties": {"description": "A set of instructions that a computer's processor can execute, defining the interface between software and hardware.", "keywords": ["instruction", "set", "architecture", "isa"], "source_lectures": ["lecture_106103359_w1_l1"]}}
{"id": "concept_software_layer", "type": "V_concept", "name": "Software Layer", "properties": {"description": "The layer of a computer system that consists of applications, programs, compilers, libraries, and operating systems.", "keywords": ["software", "layer", "applications", "operating system"], "source_lectures": ["lecture_106103359_w1_l1"]}}
{"id": "concept_computer_system_organization", "type": "V_concept", "name": "Computer System Organization", "properties": {"description": "The way in which the various modules of a computer system are organized and interact with each other.", "keywords": ["computer", "system", "organization", "modules"], "source_lectures": ["lecture_106103359_w1_l1"]}}
{"id": "concept_parallel_architecture", "type": "V_concept", "name": "Parallel Architecture", "properties": {"description": "A type of computer architecture that uses multiple processing units to perform tasks concurrently.", "keywords": ["architecture", "units", "processing", "parallel"], "source_lectures": ["lecture_106103359_w1_l1", "lecture_106103359_w1_l3"]}}
{"id": "concept_throughput_parallelism", "type": "V_concept", "name": "Throughput Parallelism", "properties": {"description": "A type of parallelism that focuses on increasing the rate at which tasks are completed, rather than the speed at which individual tasks are performed.", "keywords": ["throughput", "parallelism", "tasks", "rate"], "source_lectures": ["lecture_106103359_w1_l1"]}}
{"id": "concept_number_crunching", "type": "V_concept", "name": "Number Crunching", "properties": {"description": "A type of computation that involves performing large numbers of mathematical calculations, often in parallel.", "keywords": ["number", "crunching", "computation", "parallel"], "source_lectures": ["lecture_106103359_w1_l1"]}}
{"id": "concept_data_movement", "type": "V_concept", "name": "Data Movement", "properties": {"description": "The transfer of data between different parts of a computer system, such as between memory and processing units.", "keywords": ["data", "movement", "transfer", "computer system"], "source_lectures": ["lecture_106103359_w1_l1"]}}
{"id": "concept_power_wall", "type": "V_concept", "name": "Power Wall", "properties": {"description": "A limitation on the growth of computing systems due to increasing power consumption and heat density.", "keywords": ["power", "wall", "heat", "density", "limitation"], "source_lectures": ["lecture_106103359_w1_l2"]}}
{"id": "concept_inter_chip_parallelism", "type": "V_concept", "name": "Inter-Chip Parallelism", "properties": {"description": "A technique used to improve the performance of a system by executing multiple tasks in parallel across multiple chips.", "keywords": ["inter", "chip", "parallelism", "performance", "system"], "source_lectures": ["lecture_106103359_w1_l2"]}}
{"id": "concept_intra_chip_parallelism", "type": "V_concept", "name": "Intra-Chip Parallelism", "properties": {"description": "A technique used to improve the performance of a system by executing multiple tasks in parallel within a single chip.", "keywords": ["intra", "chip", "parallelism", "performance", "system"], "source_lectures": ["lecture_106103359_w1_l2"]}}
{"id": "concept_3d_integration", "type": "V_concept", "name": "3D Integration", "properties": {"description": "A technique used to stack multiple layers of silicon ICs on top of each other to improve performance and reduce power consumption.", "keywords": ["3d", "integration", "silicon", "ic", "stacking"], "source_lectures": ["lecture_106103359_w1_l2"]}}
{"id": "concept_through_silicon_via", "type": "V_concept", "name": "Through-Silicon Via", "properties": {"description": "A type of interconnect used to connect multiple layers of silicon ICs in a 3D integrated system.", "keywords": ["through", "silicon", "via", "interconnect", "3d"], "source_lectures": ["lecture_106103359_w1_l2"]}}
{"id": "concept_heterogeneous_system", "type": "V_concept", "name": "Heterogeneous System", "properties": {"description": "A type of system that combines different types of processing cores or components to improve performance and efficiency.", "keywords": ["heterogeneous", "system", "processing", "core", "component"], "source_lectures": ["lecture_106103359_w1_l2"]}}
{"id": "concept_thread_level_parallelism", "type": "V_concept", "name": "Thread Level Parallelism", "properties": {"description": "A technique used to improve the performance of a processor by executing multiple threads in parallel", "keywords": ["thread", "level", "parallelism", "processor"], "source_lectures": ["lecture_106103359_w1_l3"]}}
{"id": "concept_vector_processor", "type": "V_concept", "name": "Vector Processor", "properties": {"description": "A type of processor that uses pipelining to perform operations on vectors of data", "keywords": ["pipelining", "processor", "vector", "vector instruction", "lane", "data parallelism", "simd", "data", "vector processor"], "source_lectures": ["lecture_106103359_w1_l3", "lecture_106103359_w10_l69"]}}
{"id": "concept_array_processor", "type": "V_concept", "name": "Array Processor", "properties": {"description": "A type of processor that uses multiple processing elements to perform operations on arrays of data", "keywords": ["array", "processor", "processing", "elements"], "source_lectures": ["lecture_106103359_w1_l3"]}}
{"id": "concept_flynns_taxonomy", "type": "V_concept", "name": "Flynn's Taxonomy", "properties": {"description": "A classification system for parallel architectures based on the number of instructions and data elements", "keywords": ["flynn", "taxonomy", "parallel", "architectures"], "source_lectures": ["lecture_106103359_w1_l3"]}}
{"id": "concept_speedup", "type": "V_concept", "name": "Speedup", "properties": {"description": "A measure of the improvement in performance of a parallel system compared to a sequential system", "keywords": ["parallel speedup", "time", "speedup", "efficiency", "performance", "parallel", "ratio", "performance gain", "sequential", "processing", "execution time"], "source_lectures": ["lecture_106103359_w1_l6", "lecture_106103359_w1_l7", "lecture_106103359_w10_l69"]}}
{"id": "concept_parallel_fraction", "type": "V_concept", "name": "Parallel Fraction", "properties": {"description": "The portion of a program that can be executed in parallel", "keywords": ["parallel", "fraction", "program", "execution"], "source_lectures": ["lecture_106103359_w1_l6"]}}
{"id": "concept_sequential_fraction", "type": "V_concept", "name": "Sequential Fraction", "properties": {"description": "The portion of a program that cannot be executed in parallel", "keywords": ["sequential", "fraction", "program", "execution"], "source_lectures": ["lecture_106103359_w1_l6"]}}
{"id": "concept_multi_core_system", "type": "V_concept", "name": "Multi-Core System", "properties": {"description": "A computer system that uses multiple processing cores to improve performance", "keywords": ["multi-core", "system", "processing", "performance"], "source_lectures": ["lecture_106103359_w1_l6"]}}
{"id": "concept_diminishing_returns", "type": "V_concept", "name": "Diminishing Returns", "properties": {"description": "A phenomenon where the benefit of adding more resources to a system decreases as the number of resources increases", "keywords": ["diminishing", "returns", "resources", "benefit"], "source_lectures": ["lecture_106103359_w1_l6"]}}
{"id": "concept_scalable_design", "type": "V_concept", "name": "Scalable Design", "properties": {"description": "A design that can be easily adapted to larger or smaller systems without significant changes", "keywords": ["scalable", "design", "adaptation", "systems"], "source_lectures": ["lecture_106103359_w1_l6"]}}
{"id": "concept_parallelizable_workload", "type": "V_concept", "name": "Parallelizable Workload", "properties": {"description": "A workload that can be divided into smaller tasks that can be executed in parallel", "keywords": ["parallelizable", "workload", "tasks", "execution"], "source_lectures": ["lecture_106103359_w1_l6"]}}
{"id": "concept_multi_core_architecture", "type": "V_concept", "name": "Multi-Core Architecture", "properties": {"description": "A type of computer architecture that uses multiple processing cores on a single chip", "keywords": ["multi-core", "architecture", "parallel", "processing", "chip"], "source_lectures": ["lecture_106103359_w1_l7"]}}
{"id": "concept_parallel_computing", "type": "V_concept", "name": "Parallel Computing", "properties": {"description": "A type of computing that uses multiple processing units to perform tasks simultaneously", "keywords": ["parallel", "computing", "processing", "units", "simultaneous"], "source_lectures": ["lecture_106103359_w1_l7"]}}
{"id": "concept_transistor_density", "type": "V_concept", "name": "Transistor Density", "properties": {"description": "A measure of the number of transistors that can be packed into a given area of a chip", "keywords": ["transistor", "density", "chip", "area", "packing"], "source_lectures": ["lecture_106103359_w1_l7"]}}
{"id": "concept_heat_dissipation", "type": "V_concept", "name": "Heat Dissipation", "properties": {"description": "The process of removing heat from a system", "keywords": ["heat", "dissipation", "removal", "system", "cooling"], "source_lectures": ["lecture_106103359_w1_l7"]}}
{"id": "concept_parallel_computer", "type": "V_concept", "name": "Parallel Computer", "properties": {"description": "A collection of processing elements that communicate and cooperate to solve large problems fast.", "keywords": ["parallel", "computer", "processing", "elements"], "source_lectures": ["lecture_106103359_w2_l8"]}}
{"id": "concept_conventional_computer_architecture", "type": "V_concept", "name": "Conventional Computer Architecture", "properties": {"description": "A basic computer architecture that provides a set of operations, data types, and an organization structure.", "keywords": ["conventional", "computer", "architecture", "operations"], "source_lectures": ["lecture_106103359_w2_l8"]}}
{"id": "concept_communication_architecture", "type": "V_concept", "name": "Communication Architecture", "properties": {"description": "An architecture that provides communication and synchronization operations, and an organizational structure to realize these operations.", "keywords": ["communication", "architecture", "synchronization", "operations"], "source_lectures": ["lecture_106103359_w2_l8"]}}
{"id": "concept_programming_model", "type": "V_concept", "name": "Programming Model", "properties": {"description": "A conceptualization of a machine that defines how a programmer understands the communication mediums and facilities available in the machine.", "keywords": ["programming", "model", "communication", "machine"], "source_lectures": ["lecture_106103359_w2_l8"]}}
{"id": "concept_message_passing", "type": "V_concept", "name": "Message Passing", "properties": {"description": "A programming model where programs communicate by sending and receiving messages through a network.", "keywords": ["message", "passing", "programming", "network"], "source_lectures": ["lecture_106103359_w2_l8"]}}
{"id": "concept_shared_memory", "type": "V_concept", "name": "Shared Memory", "properties": {"description": "A programming model where programs communicate by reading and writing to a common memory location.", "keywords": ["shared", "memory", "programming", "communication"], "source_lectures": ["lecture_106103359_w2_l8"]}}
{"id": "concept_generic_parallel_architecture", "type": "V_concept", "name": "Generic Parallel Architecture", "properties": {"description": "A parallel architecture that can run any programming model, providing a generic communication mechanism.", "keywords": ["generic", "parallel", "architecture", "programming"], "source_lectures": ["lecture_106103359_w2_l8"]}}
{"id": "concept_coordination_mechanism", "type": "V_concept", "name": "Coordination Mechanism", "properties": {"description": "A mechanism that allows programs to coordinate their activities, including communication, load balancing, and synchronization.", "keywords": ["coordination", "mechanism", "communication", "synchronization"], "source_lectures": ["lecture_106103359_w2_l8"]}}
{"id": "concept_shared_memory_paradigm", "type": "V_concept", "name": "Shared Memory Paradigm", "properties": {"description": "A parallel computing model where multiple processes or threads communicate by reading and writing to a common memory space.", "keywords": ["shared memory", "parallel computing", "memory sharing", "threads", "processes"], "source_lectures": ["lecture_106103359_w2_l9"]}}
{"id": "concept_virtual_address_space", "type": "V_concept", "name": "Virtual Address Space", "properties": {"description": "The set of virtual memory addresses available to a process, which may include both private and shared regions mapped to physical memory.", "keywords": ["memory mapping", "address space", "process", "virtual", "virtual address", "space", "ram", "translation", "address"], "source_lectures": ["lecture_106103359_w2_l9", "lecture_106103359_w3_l18"]}}
{"id": "concept_physical_memory_mapping", "type": "V_concept", "name": "Physical Memory Mapping", "properties": {"description": "The mechanism by which virtual addresses from different processes are translated to the same physical memory locations to enable shared data access.", "keywords": ["physical memory", "virtual to physical", "memory mapping", "shared region", "translation"], "source_lectures": ["lecture_106103359_w2_l9"]}}
{"id": "concept_shared_data_variables", "type": "V_concept", "name": "Shared Data Variables", "properties": {"description": "Memory locations accessible by multiple processes or threads for communication and coordination in a shared memory system.", "keywords": ["shared data", "shared variables", "memory sharing", "concurrency", "data access"], "source_lectures": ["lecture_106103359_w2_l9"]}}
{"id": "concept_private_data_variables", "type": "V_concept", "name": "Private Data Variables", "properties": {"description": "Memory locations allocated exclusively to a single process or thread and not accessible by other processes in a shared memory system.", "keywords": ["private data", "private variables", "memory isolation", "process local", "data privacy"], "source_lectures": ["lecture_106103359_w2_l9"]}}
{"id": "concept_atomic_operations", "type": "V_concept", "name": "Atomic Operations", "properties": {"description": "Memory read or write operations that complete indivisibly, ensuring no race conditions when multiple threads access shared data simultaneously.", "keywords": ["atomic", "read-modify-write", "race condition", "synchronization", "memory operation"], "source_lectures": ["lecture_106103359_w2_l9"]}}
{"id": "concept_synchronization_mechanisms", "type": "V_concept", "name": "Synchronization Mechanisms", "properties": {"description": "Techniques such as locks, semaphores, or barriers used to coordinate access to shared memory and prevent race conditions.", "keywords": ["synchronization", "locks", "semaphores", "barriers", "race condition prevention"], "source_lectures": ["lecture_106103359_w2_l9"]}}
{"id": "concept_interconnect_network", "type": "V_concept", "name": "Interconnect Network", "properties": {"description": "The communication infrastructure that connects processors and memory modules in a parallel system to enable data transfer and shared memory access.", "keywords": ["bus", "architecture", "multiprocessor", "communication fabric", "parallel architecture", "parallel", "network", "processor-memory link", "communication", "interconnect"], "source_lectures": ["lecture_106103359_w2_l9", "lecture_106103359_w9_l62", "lecture_106103359_w10_l69"]}}
{"id": "concept_bus_interconnect", "type": "V_concept", "name": "Bus Interconnect", "properties": {"description": "A single shared communication channel connecting all processors and memory modules, offering simple but non-scalable access with fixed bandwidth.", "keywords": ["bus", "shared bus", "centralized interconnect", "symmetric multiprocessing", "bandwidth sharing"], "source_lectures": ["lecture_106103359_w2_l9"]}}
{"id": "concept_crossbar_interconnect", "type": "V_concept", "name": "Crossbar Interconnect", "properties": {"description": "A non-blocking interconnect topology where each processor can directly connect to any memory module via dedicated switches, but scales poorly with size.", "keywords": ["crossbar", "switch matrix", "direct connection", "non-blocking", "scalability"], "source_lectures": ["lecture_106103359_w2_l9"]}}
{"id": "concept_multistage_interconnect", "type": "V_concept", "name": "Multistage Interconnect", "properties": {"description": "An interconnect composed of multiple levels of switching nodes that provide multiple paths between processors and memory, improving scalability at the cost of increased latency.", "keywords": ["multistage", "network switch", "multiple paths", "latency", "scalability"], "source_lectures": ["lecture_106103359_w2_l9"]}}
{"id": "concept_uniform_memory_access_uma", "type": "V_concept", "name": "Uniform Memory Access (UMA)", "properties": {"description": "A shared memory architecture where all processors have equal access latency to all memory modules, typically using a centralized memory and shared interconnect.", "keywords": ["uma", "uniform memory access", "centralized memory", "symmetric multiprocessing", "equal latency"], "source_lectures": ["lecture_106103359_w2_l9"]}}
{"id": "concept_non_uniform_memory_access_numa", "type": "V_concept", "name": "Non-Uniform Memory Access (NUMA)", "properties": {"description": "A shared memory architecture where memory access latency depends on the location of the memory relative to the processor, with local memory faster than remote memory.", "keywords": ["numa", "non-uniform memory access", "distributed memory", "local memory", "remote memory"], "source_lectures": ["lecture_106103359_w2_l9"]}}
{"id": "concept_memory_bank", "type": "V_concept", "name": "Memory Bank", "properties": {"description": "An independent unit of memory that can be accessed in parallel with other banks to increase overall memory bandwidth.", "keywords": ["memory bank", "banked memory", "parallel access", "memory module", "bandwidth"], "source_lectures": ["lecture_106103359_w2_l9"]}}
{"id": "concept_address_interleaving", "type": "V_concept", "name": "Address Interleaving", "properties": {"description": "A technique that distributes consecutive memory addresses across multiple memory banks to enable parallel access and improve bandwidth utilization.", "keywords": ["address interleaving", "memory interleaving", "bank access", "parallel memory", "bandwidth optimization"], "source_lectures": ["lecture_106103359_w2_l9"]}}
{"id": "concept_data_migration", "type": "V_concept", "name": "Data Migration", "properties": {"description": "The movement of data from remote memory to local memory in a NUMA system to reduce access latency and improve performance.", "keywords": ["data migration", "numa", "local memory", "remote memory", "performance optimization"], "source_lectures": ["lecture_106103359_w2_l9"]}}
{"id": "concept_data_replication", "type": "V_concept", "name": "Data Replication", "properties": {"description": "The duplication of shared data across multiple local memory banks to reduce remote access and improve concurrency in distributed shared memory systems.", "keywords": ["data replication", "shared data", "local copy", "numa", "concurrency"], "source_lectures": ["lecture_106103359_w2_l9"]}}
{"id": "concept_symmetric_multiprocessing_smp", "type": "V_concept", "name": "Symmetric Multiprocessing (SMP)", "properties": {"description": "A multiprocessing architecture where multiple identical processors share a single main memory and are controlled by a single operating system.", "keywords": ["smp", "symmetric multiprocessing", "shared memory", "multi-core", "centralized memory"], "source_lectures": ["lecture_106103359_w2_l9"]}}
{"id": "concept_system_throughput", "type": "V_concept", "name": "System Throughput", "properties": {"description": "The total amount of work completed by a parallel system per unit time, influenced by processor speed, memory bandwidth, and interconnect efficiency.", "keywords": ["system throughput", "parallel performance", "work rate", "efficiency", "bandwidth"], "source_lectures": ["lecture_106103359_w2_l9"]}}
{"id": "concept_access_latency", "type": "V_concept", "name": "Access Latency", "properties": {"description": "The time delay between a processor's request for data and the delivery of that data from memory, a key factor in system performance.", "keywords": ["access latency", "memory latency", "delay", "response time", "performance"], "source_lectures": ["lecture_106103359_w2_l9"]}}
{"id": "concept_address_translation_unit", "type": "V_concept", "name": "Address Translation Unit", "properties": {"description": "Hardware component that maps virtual addresses to physical addresses and enforces memory protection between private and shared regions.", "keywords": ["address translation", "mmu", "memory management unit", "virtual to physical", "memory protection"], "source_lectures": ["lecture_106103359_w2_l9"]}}
{"id": "concept_granularity_of_data_transfer", "type": "V_concept", "name": "Granularity of Data Transfer", "properties": {"description": "The size of data units (bytes, words, cache lines) moved between processes or memory locations in a shared memory system.", "keywords": ["granularity", "data transfer size", "cache line", "word size", "memory access unit"], "source_lectures": ["lecture_106103359_w2_l9"]}}
{"id": "concept_remote_memory_access", "type": "V_concept", "name": "Remote Memory Access", "properties": {"description": "Accessing memory located on a different node or processor in a distributed shared memory system, typically with higher latency than local access.", "keywords": ["remote memory", "numa", "cross-node access", "latency", "shared memory"], "source_lectures": ["lecture_106103359_w2_l9"]}}
{"id": "concept_local_memory", "type": "V_concept", "name": "Local Memory", "properties": {"description": "Memory physically attached to or closest to a specific processor node in a NUMA architecture, offering lower access latency.", "keywords": ["local memory", "numa", "node-local", "fast access", "private data"], "source_lectures": ["lecture_106103359_w2_l9"]}}
{"id": "concept_interconnect_scalability", "type": "V_concept", "name": "Interconnect Scalability", "properties": {"description": "The ability of a communication network to maintain performance and efficiency as the number of processors or memory modules increases.", "keywords": ["scalability", "interconnect", "network growth", "performance scaling", "cost vs performance"], "source_lectures": ["lecture_106103359_w2_l9"]}}
{"id": "concept_cost_of_interconnect", "type": "V_concept", "name": "Cost of Interconnect", "properties": {"description": "The hardware and design complexity required to implement a communication network, often increasing with the number of connections in topologies like crossbar.", "keywords": ["interconnect cost", "hardware cost", "scalability cost", "switch complexity", "network expense"], "source_lectures": ["lecture_106103359_w2_l9"]}}
{"id": "concept_message_passing_paradigm", "type": "V_concept", "name": "Message Passing Paradigm", "properties": {"description": "A communication model where processes exchange data by sending and receiving messages", "keywords": ["message", "passing", "communication", "processes"], "source_lectures": ["lecture_106103359_w2_l10"]}}
{"id": "concept_inter_process_communication", "type": "V_concept", "name": "Inter-Process Communication", "properties": {"description": "The exchange of data between processes, which can be achieved through shared memory or message passing", "keywords": ["inter-process", "communication", "shared", "memory"], "source_lectures": ["lecture_106103359_w2_l10"]}}
{"id": "concept_send_system_call", "type": "V_concept", "name": "Send System Call", "properties": {"description": "A system call that sends data from a local buffer to a destination process", "keywords": ["send", "system", "call", "data"], "source_lectures": ["lecture_106103359_w2_l10"]}}
{"id": "concept_receive_system_call", "type": "V_concept", "name": "Receive System Call", "properties": {"description": "A system call that receives data from a sender process and stores it in a local buffer", "keywords": ["receive", "system", "call", "data"], "source_lectures": ["lecture_106103359_w2_l10"]}}
{"id": "concept_fifo_implementation", "type": "V_concept", "name": "FIFO Implementation", "properties": {"description": "A method of implementing message passing using a First-In-First-Out buffer", "keywords": ["fifo", "implementation", "buffer"], "source_lectures": ["lecture_106103359_w2_l10"]}}
{"id": "concept_dma_controller", "type": "V_concept", "name": "DMA Controller", "properties": {"description": "A device that enables direct memory access and non-blocking communication between processes", "keywords": ["dma", "controller", "non-blocking"], "source_lectures": ["lecture_106103359_w2_l10"]}}
{"id": "concept_store_and_forward_communication", "type": "V_concept", "name": "Store and Forward Communication", "properties": {"description": "A method of communication where intermediate nodes store and forward data to the destination node", "keywords": ["store", "forward", "communication"], "source_lectures": ["lecture_106103359_w2_l10"]}}
{"id": "concept_network_interface", "type": "V_concept", "name": "Network Interface", "properties": {"description": "A device that connects a node to the interconnect and enables communication between nodes", "keywords": ["network", "node", "interface", "interconnect", "processing"], "source_lectures": ["lecture_106103359_w2_l10", "lecture_106103359_w9_l62"]}}
{"id": "concept_message_passing_architecture", "type": "V_concept", "name": "Message Passing Architecture", "properties": {"description": "An architecture where processes communicate by sending and receiving messages", "keywords": ["passing", "architecture", "message passing", "mpi", "parallel architecture", "message", "communication", "distributed memory"], "source_lectures": ["lecture_106103359_w2_l10", "lecture_106103359_w10_l69"]}}
{"id": "concept_block_placement", "type": "V_concept", "name": "Block Placement", "properties": {"description": "The process of determining where to place a block of data in a cache memory.", "keywords": ["block", "placement", "cache", "memory"], "source_lectures": ["lecture_106103359_w2_l13"]}}
{"id": "concept_direct_map_cache", "type": "V_concept", "name": "Direct Map Cache", "properties": {"description": "A type of cache where each block of data is mapped to a specific location in the cache.", "keywords": ["memory", "one-to-one", "map", "direct", "cache"], "source_lectures": ["lecture_106103359_w2_l13", "lecture_106103359_w5_l34"]}}
{"id": "concept_cache_index", "type": "V_concept", "name": "Cache Index", "properties": {"description": "A portion of an address that is used to identify the location of a block of data in a cache.", "keywords": ["cache", "index", "address", "location"], "source_lectures": ["lecture_106103359_w2_l13"]}}
{"id": "concept_cache_offset", "type": "V_concept", "name": "Cache Offset", "properties": {"description": "A portion of an address that is used to identify the location of a word or byte within a block of data in a cache.", "keywords": ["cache", "offset", "address", "word"], "source_lectures": ["lecture_106103359_w2_l13"]}}
{"id": "concept_cache_hit", "type": "V_concept", "name": "Cache Hit", "properties": {"description": "When the requested data is found in the cache.", "keywords": ["event", "hit", "found", "data", "cache"], "source_lectures": ["lecture_106103359_w2_l13", "lecture_106103359_w4_l24"]}}
{"id": "concept_associativity", "type": "V_concept", "name": "Associativity", "properties": {"description": "The number of ways a block of data can be mapped to a cache.", "keywords": ["associativity", "cache", "mapping", "ways"], "source_lectures": ["lecture_106103359_w2_l13"]}}
{"id": "concept_cache_comparison", "type": "V_concept", "name": "Cache Comparison", "properties": {"description": "The process of comparing the tags of multiple cache entries to determine which one matches the requested address.", "keywords": ["cache", "comparison", "tags", "address"], "source_lectures": ["lecture_106103359_w2_l13"]}}
{"id": "concept_parallel_comparison", "type": "V_concept", "name": "Parallel Comparison", "properties": {"description": "A technique used in set associative caches to compare multiple tags in parallel.", "keywords": ["parallel", "comparison", "tags", "set associative"], "source_lectures": ["lecture_106103359_w2_l13"]}}
{"id": "concept_multiplexer", "type": "V_concept", "name": "Multiplexer", "properties": {"description": "A digital circuit that selects one of several input signals to be sent to a single output.", "keywords": ["multiplexer", "digital", "circuit", "selection"], "source_lectures": ["lecture_106103359_w2_l13"]}}
{"id": "concept_average_memory_access_time_amat", "type": "V_concept", "name": "Average Memory Access Time (AMAT)", "properties": {"description": "The average time required to access data from the memory hierarchy, calculated as hit time plus miss rate multiplied by miss penalty.", "keywords": ["amat", "average memory access time", "hit time", "miss rate", "miss penalty"], "source_lectures": ["lecture_106103359_w3_l15"]}}
{"id": "concept_hit_time", "type": "V_concept", "name": "Hit Time", "properties": {"description": "The time taken to access data from the cache when the requested data is found (a cache hit).", "keywords": ["hit time", "cache hit", "access time", "cache access", "latency"], "source_lectures": ["lecture_106103359_w3_l15"]}}
{"id": "concept_miss_rate", "type": "V_concept", "name": "Miss Rate", "properties": {"description": "The fraction of memory accesses that result in a cache miss, calculated as the number of misses divided by total accesses.", "keywords": ["miss rate", "cache miss", "miss percentage", "access failure", "cache efficiency"], "source_lectures": ["lecture_106103359_w3_l15"]}}
{"id": "concept_miss_penalty", "type": "V_concept", "name": "Miss Penalty", "properties": {"description": "The additional time required to fetch data from a lower memory level when a cache miss occurs.", "keywords": ["miss penalty", "cache miss penalty", "latency penalty", "memory latency", "fetch delay"], "source_lectures": ["lecture_106103359_w3_l15"]}}
{"id": "concept_3cs_model_of_cache_misses", "type": "V_concept", "name": "3C's Model of Cache Misses", "properties": {"description": "A classification of cache misses into three types: compulsory, capacity, and conflict misses, each caused by different factors.", "keywords": ["3c's model", "cache misses", "compulsory miss", "capacity miss", "conflict miss"], "source_lectures": ["lecture_106103359_w3_l15"]}}
{"id": "concept_compulsory_miss", "type": "V_concept", "name": "Compulsory Miss", "properties": {"description": "A cache miss that occurs on the first access to a block, regardless of cache size or organization, because the data is not yet loaded.", "keywords": ["compulsory miss", "first access miss", "cold miss", "initial access", "cache initialization"], "source_lectures": ["lecture_106103359_w3_l15"]}}
{"id": "concept_block_size_optimization", "type": "V_concept", "name": "Block Size Optimization", "properties": {"description": "Increasing the size of cache blocks to exploit spatial locality and reduce miss rate, at the cost of increased miss penalty and potential conflict misses.", "keywords": ["block size", "cache block", "spatial locality", "miss rate optimization", "miss penalty tradeoff"], "source_lectures": ["lecture_106103359_w3_l15"]}}
{"id": "concept_cache_size_increase", "type": "V_concept", "name": "Cache Size Increase", "properties": {"description": "Expanding the physical size of the cache to reduce capacity misses, at the cost of increased hit time, power consumption, and cost.", "keywords": ["cache size", "larger cache", "capacity miss reduction", "cache cost", "hit time increase"], "source_lectures": ["lecture_106103359_w3_l15"]}}
{"id": "concept_cache_associativity", "type": "V_concept", "name": "Cache Associativity", "properties": {"description": "The number of cache lines per set in a set-associative cache, which affects the likelihood of conflict misses and search time.", "keywords": ["associativity", "set associative", "cache way", "conflict miss", "direct mapped"], "source_lectures": ["lecture_106103359_w3_l15"]}}
{"id": "concept_eight_way_set_associative_cache", "type": "V_concept", "name": "Eight-Way Set Associative Cache", "properties": {"description": "A cache organization where each set contains eight lines, offering performance nearly equivalent to fully associative caches with lower hardware complexity.", "keywords": ["eight-way", "set associative", "cache associativity", "fully associative alternative", "cache design"], "source_lectures": ["lecture_106103359_w3_l15"]}}
{"id": "concept_21_cache_rule_of_thumb", "type": "V_concept", "name": "2:1 Cache Rule of Thumb", "properties": {"description": "A heuristic stating that a direct-mapped cache of size N has a similar miss rate as a two-way set-associative cache of size N/2.", "keywords": ["2:1 rule", "cache size equivalence", "direct mapped vs set associative", "miss rate comparison", "cache optimization"], "source_lectures": ["lecture_106103359_w3_l15"]}}
{"id": "concept_bandwidth_latency_tradeoff_in_memory_hierarchy", "type": "V_concept", "name": "Bandwidth-Latency Tradeoff in Memory Hierarchy", "properties": {"description": "The design consideration that high bandwidth at the memory interface favors larger block transfers, while high latency favors smaller blocks.", "keywords": ["bandwidth", "latency", "memory hierarchy", "block transfer", "cache optimization"], "source_lectures": ["lecture_106103359_w3_l15"]}}
{"id": "concept_cache_replacement_policy", "type": "V_concept", "name": "Cache Replacement Policy", "properties": {"description": "The algorithm used to select which cache line to evict when a new block must be loaded and all lines in the set are occupied.", "keywords": ["replacement policy", "cache eviction", "lru", "fifo", "cache management"], "source_lectures": ["lecture_106103359_w3_l15"]}}
{"id": "concept_address_translation_overhead", "type": "V_concept", "name": "Address Translation Overhead", "properties": {"description": "The time delay introduced by translating virtual addresses to physical addresses before accessing the cache.", "keywords": ["address translation", "virtual to physical", "tlb", "cache indexing", "translation delay"], "source_lectures": ["lecture_106103359_w3_l15"]}}
{"id": "concept_read_priority_in_cache", "type": "V_concept", "name": "Read Priority in Cache", "properties": {"description": "A design technique that prioritizes read requests over write requests during cache misses to reduce effective miss penalty.", "keywords": ["read priority", "cache priority", "miss handling", "write buffer", "cache optimization"], "source_lectures": ["lecture_106103359_w3_l15"]}}
{"id": "concept_amat_optimization_tradeoff", "type": "V_concept", "name": "AMAT Optimization Tradeoff", "properties": {"description": "The need to balance reductions in miss rate, hit time, and miss penalty to achieve the lowest possible average memory access time.", "keywords": ["amat optimization", "tradeoff", "cache optimization", "hit time", "miss penalty"], "source_lectures": ["lecture_106103359_w3_l15"]}}
{"id": "concept_working_set_size", "type": "V_concept", "name": "Working Set Size", "properties": {"description": "The set of memory blocks actively used by a program during a specific time period, which determines capacity miss behavior.", "keywords": ["working set", "cache working set", "memory footprint", "capacity miss", "program behavior"], "source_lectures": ["lecture_106103359_w3_l15"]}}
{"id": "concept_tag_comparison", "type": "V_concept", "name": "Tag Comparison", "properties": {"description": "The process of comparing the tag portion of a memory address with the tag stored in a cache line to determine a hit or miss.", "keywords": ["tag comparison", "cache tag", "hit detection", "cache lookup", "address matching"], "source_lectures": ["lecture_106103359_w3_l15"]}}
{"id": "concept_mux_delay_in_cache", "type": "V_concept", "name": "Mux Delay in Cache", "properties": {"description": "The time delay introduced by multiplexers used to select the correct data word from a set-associative cache line.", "keywords": ["mux delay", "multiplexer", "set associative", "cache delay", "data selection"], "source_lectures": ["lecture_106103359_w3_l15"]}}
{"id": "concept_cache_allocation_on_miss", "type": "V_concept", "name": "Cache Allocation on Miss", "properties": {"description": "The process of loading a cache block from a lower memory level into the cache upon a miss, including possible eviction.", "keywords": ["cache allocation", "miss handling", "block loading", "cache fill", "eviction"], "source_lectures": ["lecture_106103359_w3_l15"]}}
{"id": "concept_page_fault", "type": "V_concept", "name": "Page Fault", "properties": {"description": "An event that occurs when a page of memory is not found in the RAM and needs to be retrieved from the main memory or disk.", "keywords": ["page", "fault", "memory", "ram", "disk"], "source_lectures": ["lecture_106103359_w3_l18"]}}
{"id": "concept_swap_space", "type": "V_concept", "name": "Swap Space", "properties": {"description": "A region of the disk used to store pages that cannot fit in the RAM.", "keywords": ["swap", "space", "disk", "ram", "page"], "source_lectures": ["lecture_106103359_w3_l18"]}}
{"id": "concept_valid_bit", "type": "V_concept", "name": "Valid Bit", "properties": {"description": "A bit used to indicate whether a page is present in the RAM or not.", "keywords": ["valid", "bit", "page", "ram", "presence"], "source_lectures": ["lecture_106103359_w3_l18"]}}
{"id": "concept_access_permission_bits", "type": "V_concept", "name": "Access Permission Bits", "properties": {"description": "Bits used to control access to a page, including read and write permissions.", "keywords": ["access", "permission", "bits", "page", "security"], "source_lectures": ["lecture_106103359_w3_l18"]}}
{"id": "concept_process_identifier", "type": "V_concept", "name": "Process Identifier", "properties": {"description": "A unique identifier assigned to each process, used to manage resources and access control.", "keywords": ["process", "identifier", "pid", "resource", "access"], "source_lectures": ["lecture_106103359_w3_l18"]}}
{"id": "concept_context_switch", "type": "V_concept", "name": "Context Switch", "properties": {"description": "The process of switching the CPU's context from one process to another.", "keywords": ["context", "switch", "cpu", "process", " scheduling"], "source_lectures": ["lecture_106103359_w3_l18"]}}
{"id": "concept_page_table_scalability", "type": "V_concept", "name": "Page Table Scalability", "properties": {"description": "The ability of a page table to efficiently manage a large number of pages.", "keywords": ["page", "table", "scalability", "efficiency", "management"], "source_lectures": ["lecture_106103359_w3_l18"]}}
{"id": "concept_physical_page_number", "type": "V_concept", "name": "Physical Page Number", "properties": {"description": "The actual address of a page in the RAM.", "keywords": ["physical", "page", "number", "ram", "address"], "source_lectures": ["lecture_106103359_w3_l18"]}}
{"id": "concept_virtual_page_number", "type": "V_concept", "name": "Virtual Page Number", "properties": {"description": "The address of a page in the virtual address space.", "keywords": ["virtual", "page", "number", "address", "space"], "source_lectures": ["lecture_106103359_w3_l18"]}}
{"id": "concept_program_order", "type": "V_concept", "name": "Program Order", "properties": {"description": "The sequence of instructions executed by a processor, defining the order of memory operations.", "keywords": ["specification", "memory", "instructions", "accesses", "program", "sequence", "order"], "source_lectures": ["lecture_106103359_w3_l20", "lecture_106103359_w8_l56"]}}
{"id": "concept_memory_operation", "type": "V_concept", "name": "Memory Operation", "properties": {"description": "An action performed by a processor on memory, such as a read or write operation.", "keywords": ["memory", "operation", "read", "write", "processor"], "source_lectures": ["lecture_106103359_w3_l20"]}}
{"id": "concept_multiprocessor_system", "type": "V_concept", "name": "Multiprocessor System", "properties": {"description": "A system consisting of multiple processors that share a common memory.", "keywords": ["multiprocessor", "system", "processors", "memory", "shared"], "source_lectures": ["lecture_106103359_w3_l20"]}}
{"id": "concept_coherence_protocol", "type": "V_concept", "name": "Coherence Protocol", "properties": {"description": "A set of rules that ensure cache coherence in a multiprocessor system.", "keywords": ["coherence", "protocol", "cache", "multiprocessor", "system"], "source_lectures": ["lecture_106103359_w3_l20"]}}
{"id": "concept_serial_order", "type": "V_concept", "name": "Serial Order", "properties": {"description": "A hypothetical order of memory operations that is consistent with the results of execution.", "keywords": ["serial", "order", "memory", "operations", "hypothetical"], "source_lectures": ["lecture_106103359_w3_l20"]}}
{"id": "concept_bus_transaction", "type": "V_concept", "name": "Bus Transaction", "properties": {"description": "A sequence of events that occurs when a device sends a request to access a shared bus", "keywords": ["bus", "main", "memory", "transaction", "request", "events", "sequence", "cache"], "source_lectures": ["lecture_106103359_w4_l22", "lecture_106103359_w4_l24"]}}
{"id": "concept_broadcast_medium", "type": "V_concept", "name": "Broadcast Medium", "properties": {"description": "A communication channel that allows multiple devices to receive the same message simultaneously", "keywords": ["broadcast", "medium", "communication", "channel", "message"], "source_lectures": ["lecture_106103359_w4_l22"]}}
{"id": "concept_distributed_finite_state_machine", "type": "V_concept", "name": "Distributed Finite State Machine", "properties": {"description": "A system that consists of multiple finite state machines that coordinate with each other to maintain consistency", "keywords": ["distributed", "finite", "state", "machine", "fsm", "coordination"], "source_lectures": ["lecture_106103359_w4_l22"]}}
{"id": "concept_write_invalidate_protocol", "type": "V_concept", "name": "Write Invalidate Protocol", "properties": {"description": "A cache coherence protocol that invalidates all copies of a data item when one cache writes to it.", "keywords": ["multiprocessor", "coherence", "write", "write invalidate", "protocol", "shared data", "cache invalidation", "invalidate", "cache", "coherence protocol"], "source_lectures": ["lecture_106103359_w4_l23", "lecture_106103359_w10_l69"]}}
{"id": "concept_write_propagation", "type": "V_concept", "name": "Write Propagation", "properties": {"description": "The property of a cache coherence protocol that ensures all writes are visible to all caches.", "keywords": ["coherence", "write", "cache", "propagation"], "source_lectures": ["lecture_106103359_w4_l23", "lecture_106103359_w4_l25"]}}
{"id": "concept_vi_protocol", "type": "V_concept", "name": "VI Protocol", "properties": {"description": "A two-state cache coherence protocol that uses invalidation to maintain data consistency.", "keywords": ["vi", "protocol", "cache", "coherence", "invalidation"], "source_lectures": ["lecture_106103359_w4_l24"]}}
{"id": "concept_write_no_allocate_cache", "type": "V_concept", "name": "Write No-Allocate Cache", "properties": {"description": "A type of cache that does not allocate space for a block when a write operation is performed.", "keywords": ["write", "no-allocate", "cache", "block", "operation"], "source_lectures": ["lecture_106103359_w4_l24"]}}
{"id": "concept_total_order", "type": "V_concept", "name": "Total Order", "properties": {"description": "A ordering of events that ensures consistency and coherence in a parallel system.", "keywords": ["total", "order", "events", "consistency", "coherence"], "source_lectures": ["lecture_106103359_w4_l24"]}}
{"id": "concept_bus_write_back_transaction", "type": "V_concept", "name": "Bus Write Back Transaction", "properties": {"description": "A transaction sent by a cache to write back a modified cache block to main memory", "keywords": ["buswriteback", "transaction", "cache", "writeback"], "source_lectures": ["lecture_106103359_w4_l25"]}}
{"id": "concept_busrd_signal", "type": "V_concept", "name": "BusRd Signal", "properties": {"description": "A signal sent by a processor to read data from the bus.", "keywords": ["busrd", "signal", "processor", "read"], "source_lectures": ["lecture_106103359_w4_l26"]}}
{"id": "concept_busrdx_signal", "type": "V_concept", "name": "BusRdX Signal", "properties": {"description": "A signal sent by a processor to write data to the bus and invalidate other caches.", "keywords": ["busrdx", "signal", "processor", "write", "invalidate"], "source_lectures": ["lecture_106103359_w4_l26"]}}
{"id": "concept_flush_signal", "type": "V_concept", "name": "Flush Signal", "properties": {"description": "A signal sent by a cache to write back dirty data to the main memory.", "keywords": ["flush", "signal", "cache", "write", "back"], "source_lectures": ["lecture_106103359_w4_l26"]}}
{"id": "concept_mesi_states", "type": "V_concept", "name": "Mesi States", "properties": {"description": "The four states of the MESI protocol: Modified, Exclusive, Shared, and Invalid.", "keywords": ["mesi", "states", "modified", "exclusive", "shared", "invalid"], "source_lectures": ["lecture_106103359_w4_l26"]}}
{"id": "concept_invalid_state", "type": "V_concept", "name": "Invalid State", "properties": {"description": "A state in the MESI protocol where the cache does not have a valid copy of the data.", "keywords": ["invalid", "state", "mesi", "cache"], "source_lectures": ["lecture_106103359_w4_l26"]}}
{"id": "concept_cache_to_cache_sharing", "type": "V_concept", "name": "Cache To Cache Sharing", "properties": {"description": "A technique used in some cache coherence protocols where one cache can supply data to another cache.", "keywords": ["cache", "to", "cache", "sharing"], "source_lectures": ["lecture_106103359_w4_l26"]}}
{"id": "concept_owned_state", "type": "V_concept", "name": "Owned State", "properties": {"description": "A state in the MOESI protocol where a cache has the most up-to-date copy of the data and is responsible for providing it to other caches.", "keywords": ["owned", "state", "moesi", "cache"], "source_lectures": ["lecture_106103359_w4_l26"]}}
{"id": "concept_bus_snooping", "type": "V_concept", "name": "Bus Snooping", "properties": {"description": "A technique used to maintain cache coherence by monitoring bus transactions.", "keywords": ["bus", "snooping", "cache", "coherence"], "source_lectures": ["lecture_106103359_w5_l34"]}}
{"id": "concept_inclusion_bit", "type": "V_concept", "name": "Inclusion Bit", "properties": {"description": "A bit used to indicate whether a block is present in a lower-level cache.", "keywords": ["inclusion", "bit", "cache", "memory"], "source_lectures": ["lecture_106103359_w5_l34"]}}
{"id": "concept_commit_protocol", "type": "V_concept", "name": "Commit Protocol", "properties": {"description": "A protocol used to optimize cache coherence by allowing a cache to commit to an operation before it is complete.", "keywords": ["commit", "protocol", "cache", "coherence"], "source_lectures": ["lecture_106103359_w5_l34"]}}
{"id": "concept_exclusion_property", "type": "V_concept", "name": "Exclusion Property", "properties": {"description": "A property of cache hierarchies where a block is not present in more than one cache.", "keywords": ["exclusion", "cache", "hierarchy", "property"], "source_lectures": ["lecture_106103359_w5_l34"]}}
{"id": "concept_multi_level_cache_hierarchy", "type": "V_concept", "name": "Multi-Level Cache Hierarchy", "properties": {"description": "A cache hierarchy with multiple levels of caches, each with its own characteristics and optimizations.", "keywords": ["multi-level", "cache", "hierarchy", "memory"], "source_lectures": ["lecture_106103359_w5_l34"]}}
{"id": "concept_sequent_numa_q_architecture", "type": "V_concept", "name": "Sequent NUMA-Q Architecture", "properties": {"description": "A parallel computer architecture that uses a combination of symmetric multiprocessors and a directory-based coherence protocol to maintain coherence among nodes.", "keywords": ["sequent", "numa-q", "architecture", "parallel", "coherence"], "source_lectures": ["lecture_106103359_w8_l50"]}}
{"id": "concept_cache_based_directory_protocol", "type": "V_concept", "name": "Cache-Based Directory Protocol", "properties": {"description": "A type of directory coherence protocol that uses a cache to store information about the location of shared data.", "keywords": ["coherence", "protocol", "distributed", "cache-based", "directory", "cache"], "source_lectures": ["lecture_106103359_w8_l50", "lecture_106103359_w8_l51"]}}
{"id": "concept_linked_list_directory_structure", "type": "V_concept", "name": "Linked List Directory Structure", "properties": {"description": "A data structure used to implement a directory coherence protocol, where each node in the list represents a sharer of a block of data.", "keywords": ["linked", "list", "directory", "structure", "coherence"], "source_lectures": ["lecture_106103359_w8_l50"]}}
{"id": "concept_remote_access_cache", "type": "V_concept", "name": "Remote Access Cache", "properties": {"description": "A cache used to store data that is accessed from remote nodes in a parallel computer system.", "keywords": ["memory", "remote", "parallel", "access", "system", "distributed", "cache"], "source_lectures": ["lecture_106103359_w8_l50", "lecture_106103359_w8_l51", "lecture_106103359_w8_l52"]}}
{"id": "concept_directory_state", "type": "V_concept", "name": "Directory State", "properties": {"description": "The state of a block of data in a directory coherence protocol, which can be one of several states such as home, fresh, or dirty.", "keywords": ["directory", "state", "coherence", "protocol", "block"], "source_lectures": ["lecture_106103359_w8_l50"]}}
{"id": "concept_iq_link_board", "type": "V_concept", "name": "IQ-Link Board", "properties": {"description": "A customized board used in the Sequent NUMA-Q architecture to implement the directory coherence protocol and connect nodes to the SCI ring.", "keywords": ["board", "link", "sequent", "iq-link", "coherence", "iq", "numa-q", "sci", "numazu"], "source_lectures": ["lecture_106103359_w8_l50", "lecture_106103359_w11_l71"]}}
{"id": "concept_distributed_linked_list", "type": "V_concept", "name": "Distributed Linked List", "properties": {"description": "A data structure used to implement a cache based directory protocol.", "keywords": ["distributed", "linked", "list", "data", "structure"], "source_lectures": ["lecture_106103359_w8_l51"]}}
{"id": "concept_list_construction_operation", "type": "V_concept", "name": "List Construction Operation", "properties": {"description": "An operation used to add a new node to a distributed linked list.", "keywords": ["list", "construction", "operation", "distributed", "linked"], "source_lectures": ["lecture_106103359_w8_l51"]}}
{"id": "concept_roll_out_operation", "type": "V_concept", "name": "Roll Out Operation", "properties": {"description": "An operation used to remove a node from a distributed linked list.", "keywords": ["roll", "out", "operation", "linked", "list", "distributed"], "source_lectures": ["lecture_106103359_w8_l51", "lecture_106103359_w8_l52"]}}
{"id": "concept_purge_operation", "type": "V_concept", "name": "Purge Operation", "properties": {"description": "An operation used to delete all nodes in a distributed linked list.", "keywords": ["purge", "coherence", "operation", "linked", "list", "distributed"], "source_lectures": ["lecture_106103359_w8_l51", "lecture_106103359_w8_l52"]}}
{"id": "concept_numa_q_system", "type": "V_concept", "name": "NUMA-Q System", "properties": {"description": "A type of distributed shared memory system that uses a cache based directory protocol.", "keywords": ["numa-q", "system", "distributed", "shared", "memory"], "source_lectures": ["lecture_106103359_w8_l51"]}}
{"id": "concept_pending_state", "type": "V_concept", "name": "Pending State", "properties": {"description": "A state where a node is waiting for a operation to complete.", "keywords": ["pending", "operation", "state", "complete", "system", "node", "distributed"], "source_lectures": ["lecture_106103359_w8_l51", "lecture_106103359_w8_l52"]}}
{"id": "concept_true_head", "type": "V_concept", "name": "True Head", "properties": {"description": "The actual head of a distributed linked list.", "keywords": ["true", "head", "distributed", "linked", "list"], "source_lectures": ["lecture_106103359_w8_l51"]}}
{"id": "concept_pending_head", "type": "V_concept", "name": "Pending Head", "properties": {"description": "A node that is waiting to become the head of a distributed linked list.", "keywords": ["pending", "head", "distributed", "linked", "list"], "source_lectures": ["lecture_106103359_w8_l51"]}}
{"id": "concept_head_node", "type": "V_concept", "name": "Head Node", "properties": {"description": "The primary node in a distributed linked list, responsible for managing the list and ensuring data consistency.", "keywords": ["head", "node", "distributed", "list", "management"], "source_lectures": ["lecture_106103359_w8_l52"]}}
{"id": "concept_invalidation_request", "type": "V_concept", "name": "Invalidation Request", "properties": {"description": "A request sent to a node to remove itself from a distributed linked list, ensuring data consistency and coherence.", "keywords": ["invalidation", "request", "node", "distributed", "list"], "source_lectures": ["lecture_106103359_w8_l52"]}}
{"id": "concept_replacement_policy", "type": "V_concept", "name": "Replacement Policy", "properties": {"description": "A policy used to determine which blocks to replace in a cache, ensuring efficient use of cache space.", "keywords": ["replacement", "policy", "cache", "block", "management"], "source_lectures": ["lecture_106103359_w8_l52"]}}
{"id": "concept_sci_directory_protocol", "type": "V_concept", "name": "SCI Directory Protocol", "properties": {"description": "A specific directory protocol used in distributed systems, ensuring coherence and consistency among nodes.", "keywords": ["sci", "directory", "protocol", "distributed", "system"], "source_lectures": ["lecture_106103359_w8_l52"]}}
{"id": "concept_node_state", "type": "V_concept", "name": "Node State", "properties": {"description": "The current status of a node in a distributed system, indicating its role and responsibilities.", "keywords": ["node", "state", "distributed", "system", "status"], "source_lectures": ["lecture_106103359_w8_l52"]}}
{"id": "concept_relaxed_consistency_models", "type": "V_concept", "name": "Relaxed Consistency Models", "properties": {"description": "Memory consistency models that allow reordering of memory accesses to improve performance while still preserving program semantics", "keywords": ["models", "memory", "relaxed", "computing", "semantics", "parallel", "reordering", "performance", "consistency"], "source_lectures": ["lecture_106103359_w8_l56", "lecture_106103359_w9_l57", "lecture_106103359_w11_l71"]}}
{"id": "concept_read_own_write_early", "type": "V_concept", "name": "Read Own Write Early", "properties": {"description": "The ability of a processor to read its own write before it is visible to other processors in the system", "keywords": ["read", "write", "early", "visibility", "processors"], "source_lectures": ["lecture_106103359_w8_l56"]}}
{"id": "concept_read_others_write_early", "type": "V_concept", "name": "Read Others Write Early", "properties": {"description": "The ability of a processor to read a write from another processor before it is visible to all processors in the system", "keywords": ["read", "write", "early", "visibility", "processors"], "source_lectures": ["lecture_106103359_w8_l56"]}}
{"id": "concept_safety_net", "type": "V_concept", "name": "Safety Net", "properties": {"description": "A mechanism that allows programmers to specify strict orderings between memory accesses in a relaxed consistency model", "keywords": ["safety", "net", "mechanism", "programmers", "orderings"], "source_lectures": ["lecture_106103359_w8_l56"]}}
{"id": "concept_ibm_370_model", "type": "V_concept", "name": "IBM 370 Model", "properties": {"description": "A relaxed consistency model that does not permit read own write early or read others write early", "keywords": ["model", "ibm", "relaxed", "consistency", "370"], "source_lectures": ["lecture_106103359_w8_l56", "lecture_106103359_w9_l57"]}}
{"id": "concept_total_store_order_tso_model", "type": "V_concept", "name": "Total Store Order (TSO) Model", "properties": {"description": "A relaxed consistency model that permits read own write early but not read others write early", "keywords": ["tso", "model", "consistency", "relaxed", "store"], "source_lectures": ["lecture_106103359_w8_l56"]}}
{"id": "concept_processor_consistency_pc_model", "type": "V_concept", "name": "Processor Consistency (PC) Model", "properties": {"description": "A relaxed consistency model that permits both read own write early and read others write early", "keywords": ["pc", "model", "consistency", "relaxed", "processor"], "source_lectures": ["lecture_106103359_w8_l56"]}}
{"id": "concept_tso_model", "type": "V_concept", "name": "TSO Model", "properties": {"description": "A relaxed consistency model that allows for reordering of write and read operations, with a read-modify-write instruction as a safety net.", "keywords": ["tso", "model", "relaxed", "consistency", "read-modify-write"], "source_lectures": ["lecture_106103359_w9_l57"]}}
{"id": "concept_pc_model", "type": "V_concept", "name": "PC Model", "properties": {"description": "A relaxed consistency model that allows for reordering of write and read operations, with a read-modify-write instruction as a safety net, but requires cooperation between processes.", "keywords": ["pc", "model", "relaxed", "consistency", "read-modify-write"], "source_lectures": ["lecture_106103359_w9_l57"]}}
{"id": "concept_read_modify_write_instruction", "type": "V_concept", "name": "Read-Modify-Write Instruction", "properties": {"description": "An instruction that atomically reads, modifies, and writes a memory location.", "keywords": ["location", "concurrency", "memory", "read", "instruction", "modify", "write", "read-modify-write", "synchronization", "atomic", "atomic instruction"], "source_lectures": ["lecture_106103359_w9_l57", "lecture_106103359_w9_l58", "lecture_106103359_w9_l59"]}}
{"id": "concept_memory_barrier_instruction", "type": "V_concept", "name": "Memory Barrier Instruction", "properties": {"description": "An instruction that ensures all memory accesses before it are completed before any memory accesses after it.", "keywords": ["memory", "barrier", "instruction", "synchronization"], "source_lectures": ["lecture_106103359_w9_l57"]}}
{"id": "concept_stbar_instruction", "type": "V_concept", "name": "STBAR Instruction", "properties": {"description": "A store barrier instruction that ensures all store operations before it are completed before any store operations after it.", "keywords": ["stbar", "instruction", "store", "barrier", "synchronization"], "source_lectures": ["lecture_106103359_w9_l57"]}}
{"id": "concept_write_buffer_merging", "type": "V_concept", "name": "Write Buffer Merging", "properties": {"description": "A technique that allows multiple write operations to be merged into a single write operation, improving performance.", "keywords": ["write", "buffer", "merging", "technique", "performance"], "source_lectures": ["lecture_106103359_w9_l57"]}}
{"id": "concept_fifo_queue", "type": "V_concept", "name": "FIFO Queue", "properties": {"description": "A first-in-first-out queue data structure used to implement store barrier instructions.", "keywords": ["fifo", "queue", "data", "structure", "store", "barrier"], "source_lectures": ["lecture_106103359_w9_l57"]}}
{"id": "concept_weak_ordering", "type": "V_concept", "name": "Weak Ordering", "properties": {"description": "A memory consistency model that allows reordering of memory operations while maintaining program order between synchronization points.", "keywords": ["weak", "ordering", "memory", "consistency", "synchronization"], "source_lectures": ["lecture_106103359_w9_l58"]}}
{"id": "concept_release_consistency", "type": "V_concept", "name": "Release Consistency", "properties": {"description": "A memory consistency model that extends weak ordering by distinguishing between acquire and release operations.", "keywords": ["release", "consistency", "acquire", "memory", "model"], "source_lectures": ["lecture_106103359_w9_l58"]}}
{"id": "concept_memory_barrier", "type": "V_concept", "name": "Memory Barrier", "properties": {"description": "A synchronization instruction that ensures all previous memory accesses are completed before proceeding.", "keywords": ["memory", "barrier", "synchronization", "instruction", "access"], "source_lectures": ["lecture_106103359_w9_l58"]}}
{"id": "concept_synchronization_operation", "type": "V_concept", "name": "Synchronization Operation", "properties": {"description": "An operation that ensures program order is maintained between two points in a program.", "keywords": ["synchronization", "operation", "program", "order", "maintenance"], "source_lectures": ["lecture_106103359_w9_l58"]}}
{"id": "concept_data_dependence", "type": "V_concept", "name": "Data Dependence", "properties": {"description": "A relationship between two operations where the result of one operation is used as input to another operation.", "keywords": ["data", "dependence", "relationship", "operation", "input"], "source_lectures": ["lecture_106103359_w9_l58"]}}
{"id": "concept_compiler_optimization", "type": "V_concept", "name": "Compiler Optimization", "properties": {"description": "A technique used by compilers to improve the performance of a program by reordering or eliminating instructions.", "keywords": ["compiler", "optimization", "performance", "reordering", "elimination"], "source_lectures": ["lecture_106103359_w9_l58"]}}
{"id": "concept_mutual_exclusion", "type": "V_concept", "name": "Mutual Exclusion", "properties": {"description": "A concept in synchronization where only one process can access a shared resource at a time.", "keywords": ["concurrency", "mutual exclusion", "resource", "synchronization", "exclusion", "lock", "shared", "mutual"], "source_lectures": ["lecture_106103359_w9_l59", "lecture_106103359_w9_l61"]}}
{"id": "concept_atomic_instruction", "type": "V_concept", "name": "Atomic Instruction", "properties": {"description": "An instruction that executes as a single, uninterruptible unit, ensuring data consistency in multi-process environments.", "keywords": ["atomic instruction", "uninterruptible", "synchronization", "concurrency"], "source_lectures": ["lecture_106103359_w9_l59"]}}
{"id": "concept_test_and_set_instruction", "type": "V_concept", "name": "Test And Set Instruction", "properties": {"description": "A type of atomic instruction that tests a value and sets it to a new value in a single operation.", "keywords": ["test and set", "concurrency", "instruction", "synchronization", "lock", "atomic instruction", "variable", "test", "set"], "source_lectures": ["lecture_106103359_w9_l59", "lecture_106103359_w9_l60"]}}
{"id": "concept_fetch_and_increment_instruction", "type": "V_concept", "name": "Fetch And Increment Instruction", "properties": {"description": "A type of atomic instruction that fetches a value, increments it, and writes it back in a single operation.", "keywords": ["fetch and increment", "atomic instruction", "synchronization", "concurrency"], "source_lectures": ["lecture_106103359_w9_l59"]}}
{"id": "concept_load_linked_instruction", "type": "V_concept", "name": "Load Linked Instruction", "properties": {"description": "An instruction that loads a value from memory and establishes a link to the memory location.", "keywords": ["concurrency", "memory", "instruction", "load linked", "synchronization", "linked", "load", "flag", "atomic instruction"], "source_lectures": ["lecture_106103359_w9_l59", "lecture_106103359_w9_l60"]}}
{"id": "concept_store_conditional_instruction", "type": "V_concept", "name": "Store Conditional Instruction", "properties": {"description": "An instruction that stores a value in memory only if the memory location has not been modified since the last load linked instruction.", "keywords": ["concurrency", "memory", "instruction", "synchronization", "conditional", "flag", "atomic instruction", "store conditional", "store"], "source_lectures": ["lecture_106103359_w9_l59", "lecture_106103359_w9_l60"]}}
{"id": "concept_spin_lock", "type": "V_concept", "name": "Spin Lock", "properties": {"description": "A synchronization technique where a process repeatedly checks a lock variable until it becomes available.", "keywords": ["spin lock", "synchronization", "concurrency", "lock"], "source_lectures": ["lecture_106103359_w9_l59"]}}
{"id": "concept_lock_variable", "type": "V_concept", "name": "Lock Variable", "properties": {"description": "A variable used to indicate whether a shared resource is available or not.", "keywords": ["concurrency", "resource", "synchronization", "lock variable", "lock", "shared", "variable"], "source_lectures": ["lecture_106103359_w9_l59", "lecture_106103359_w9_l61"]}}
{"id": "concept_fetch_and_op_instruction", "type": "V_concept", "name": "Fetch And Op Instruction", "properties": {"description": "An instruction that fetches data, performs an operation on it, and then writes the data back.", "keywords": ["fetch", "op", "instruction", "data", "operation"], "source_lectures": ["lecture_106103359_w9_l60"]}}
{"id": "concept_compare_and_swap_instruction", "type": "V_concept", "name": "Compare And Swap Instruction", "properties": {"description": "An instruction that compares a memory location with a register and swaps the register with the memory location if they are equal.", "keywords": ["compare", "swap", "instruction", "memory", "register"], "source_lectures": ["lecture_106103359_w9_l60"]}}
{"id": "concept_bus_based_system", "type": "V_concept", "name": "Bus-Based System", "properties": {"description": "A system in which multiple processors share a common bus to access memory.", "keywords": ["bus", "system", "processors", "memory", "access"], "source_lectures": ["lecture_106103359_w9_l60"]}}
{"id": "concept_point_to_point_synchronization", "type": "V_concept", "name": "Point To Point Synchronization", "properties": {"description": "A method of synchronization where two processes communicate with each other to coordinate their actions.", "keywords": ["synchronization", "point", "process", "communication"], "source_lectures": ["lecture_106103359_w9_l61"]}}
{"id": "concept_busy_waiting", "type": "V_concept", "name": "Busy Waiting", "properties": {"description": "A technique where a process continuously checks a condition until it is met, consuming CPU cycles.", "keywords": ["busy", "waiting", "process", "cpu"], "source_lectures": ["lecture_106103359_w9_l61"]}}
{"id": "concept_semaphore", "type": "V_concept", "name": "Semaphore", "properties": {"description": "A variable or data structure that provides a simple way to control access to a shared resource.", "keywords": ["semaphore", "variable", "shared", "resource"], "source_lectures": ["lecture_106103359_w9_l61"]}}
{"id": "concept_barrier_synchronization", "type": "V_concept", "name": "Barrier Synchronization", "properties": {"description": "A method of synchronization where multiple processes wait for each other to reach a certain point before proceeding.", "keywords": ["coordination", "wait", "map-reduce barrier", "process", "synchronization", "phase completion", "barrier"], "source_lectures": ["lecture_106103359_w9_l61", "lecture_106104182_w3_l19"]}}
{"id": "concept_critical_section", "type": "V_concept", "name": "Critical Section", "properties": {"description": "A section of code that accesses shared resources and must be executed atomically to prevent conflicts.", "keywords": ["concurrency", "section", "resource", "shared resource", "shared", "critical", "critical section", "atomic access", "race condition"], "source_lectures": ["lecture_106103359_w9_l61", "lecture_106104182_w2_l12"]}}
{"id": "concept_flag_variable", "type": "V_concept", "name": "Flag Variable", "properties": {"description": "A variable used to signal the status of a process or resource, often used in synchronization.", "keywords": ["flag", "variable", "status", "synchronization"], "source_lectures": ["lecture_106103359_w9_l61"]}}
{"id": "concept_full_empty_bit", "type": "V_concept", "name": "Full Empty Bit", "properties": {"description": "A bit used to indicate whether a variable or resource is available or not, often used in point-to-point synchronization.", "keywords": ["full", "empty", "bit", "synchronization"], "source_lectures": ["lecture_106103359_w9_l61"]}}
{"id": "concept_uninterruptible_instruction", "type": "V_concept", "name": "Uninterruptible Instruction", "properties": {"description": "An instruction that cannot be interrupted by other processes or events, often used in synchronization.", "keywords": ["uninterruptible", "instruction", "synchronization"], "source_lectures": ["lecture_106103359_w9_l61"]}}
{"id": "concept_link_level_protocol", "type": "V_concept", "name": "Link Level Protocol", "properties": {"description": "A protocol that governs the transfer of data over a link", "keywords": ["link", "level", "protocol", "data", "transfer"], "source_lectures": ["lecture_106103359_w9_l62"]}}
{"id": "concept_packet_switching", "type": "V_concept", "name": "Packet Switching", "properties": {"description": "A technique where data is broken into small packets and transmitted independently", "keywords": ["switching", "independent", "packet", "network", "transmission", "data"], "source_lectures": ["lecture_106103359_w9_l62", "lecture_106103359_w10_l65"]}}
{"id": "concept_circuit_switching", "type": "V_concept", "name": "Circuit Switching", "properties": {"description": "A technique where a dedicated path is established for data transmission", "keywords": ["switching", "path", "reservation", "transmission", "circuit", "data", "dedicated"], "source_lectures": ["lecture_106103359_w9_l62", "lecture_106103359_w10_l65"]}}
{"id": "concept_network_topology", "type": "V_concept", "name": "Network Topology", "properties": {"description": "The physical and logical arrangement of devices in a network", "keywords": ["network", "topology", "arrangement", "devices"], "source_lectures": ["lecture_106103359_w9_l62"]}}
{"id": "concept_routing_algorithm", "type": "V_concept", "name": "Routing Algorithm", "properties": {"description": "A method used to determine the path that data takes through a network", "keywords": ["packet", "path", "network", "algorithm", "routing", "data"], "source_lectures": ["lecture_106103359_w9_l62", "lecture_106103359_w10_l64"]}}
{"id": "concept_bisection_width", "type": "V_concept", "name": "Bisection Width", "properties": {"description": "The minimum number of links that must be removed to divide a network into two equal parts", "keywords": ["bisection", "width", "network", "links"], "source_lectures": ["lecture_106103359_w9_l62"]}}
{"id": "concept_diameter", "type": "V_concept", "name": "Diameter", "properties": {"description": "The maximum length of the shortest path between any two nodes in a network", "keywords": ["diameter", "network", "path", "nodes"], "source_lectures": ["lecture_106103359_w9_l62"]}}
{"id": "concept_degree", "type": "V_concept", "name": "Degree", "properties": {"description": "The number of links connected to a node in a network", "keywords": ["degree", "node", "links", "network"], "source_lectures": ["lecture_106103359_w9_l62"]}}
{"id": "concept_packet_format", "type": "V_concept", "name": "Packet Format", "properties": {"description": "The structure of a packet, including header, payload, and trailer", "keywords": ["packet", "format", "header", "payload", "trailer"], "source_lectures": ["lecture_106103359_w9_l62"]}}
{"id": "concept_bandwidth", "type": "V_concept", "name": "Bandwidth", "properties": {"description": "The amount of data that can be transmitted over a network in a given time", "keywords": ["bandwidth", "data", "transmission", "network"], "source_lectures": ["lecture_106103359_w9_l62"]}}
{"id": "concept_arithmetic_routing", "type": "V_concept", "name": "Arithmetic Routing", "properties": {"description": "A routing method that uses simple mathematical calculations to determine the path a packet takes.", "keywords": ["arithmetic", "routing", "math", "packet", "path"], "source_lectures": ["lecture_106103359_w10_l64"]}}
{"id": "concept_dimension_order_routing", "type": "V_concept", "name": "Dimension Order Routing", "properties": {"description": "A routing method that follows a specific order of dimensions, such as x and y, to determine the path a packet takes.", "keywords": ["dimension", "order", "routing", "x", "y"], "source_lectures": ["lecture_106103359_w10_l64"]}}
{"id": "concept_source_based_routing", "type": "V_concept", "name": "Source Based Routing", "properties": {"description": "A routing method that uses a complete path, written in the packet header, to determine the path a packet takes.", "keywords": ["source", "based", "routing", "path", "header"], "source_lectures": ["lecture_106103359_w10_l64"]}}
{"id": "concept_table_driven_routing", "type": "V_concept", "name": "Table Driven Routing", "properties": {"description": "A routing method that uses a table, maintained by each switch, to determine the path a packet takes.", "keywords": ["table", "driven", "routing", "switch", "path"], "source_lectures": ["lecture_106103359_w10_l64"]}}
{"id": "concept_turn_model", "type": "V_concept", "name": "Turn Model", "properties": {"description": "A method used to avoid deadlocks by restricting certain turns in a network.", "keywords": ["turn", "model", "deadlock", "network", "restriction"], "source_lectures": ["lecture_106103359_w10_l64"]}}
{"id": "concept_virtual_channels", "type": "V_concept", "name": "Virtual Channels", "properties": {"description": "A method used to avoid deadlocks and protocol-level deadlocks by multiplexing multiple channels on the same physical channel.", "keywords": ["virtual", "channels", "deadlock", "protocol", "multiplexing"], "source_lectures": ["lecture_106103359_w10_l64"]}}
{"id": "concept_up_star_down_star_routing", "type": "V_concept", "name": "Up Star Down Star Routing", "properties": {"description": "A routing method that uses a tree-like structure to determine the path a packet takes, by going up the tree and then down the tree.", "keywords": ["up", "star", "down", "star", "routing", "tree"], "source_lectures": ["lecture_106103359_w10_l64"]}}
{"id": "concept_adaptive_routing", "type": "V_concept", "name": "Adaptive Routing", "properties": {"description": "A routing method that dynamically adjusts the path a packet takes based on the current network conditions.", "keywords": ["adaptive", "routing", "dynamic", "network", "conditions"], "source_lectures": ["lecture_106103359_w10_l64"]}}
{"id": "concept_minimal_routing_algorithm", "type": "V_concept", "name": "Minimal Routing Algorithm", "properties": {"description": "A routing algorithm that always chooses the shortest path to the destination.", "keywords": ["minimal", "routing", "algorithm", "shortest", "path"], "source_lectures": ["lecture_106103359_w10_l64"]}}
{"id": "concept_non_minimal_routing_algorithm", "type": "V_concept", "name": "Non-Minimal Routing Algorithm", "properties": {"description": "A routing algorithm that does not always choose the shortest path to the destination.", "keywords": ["non-minimal", "routing", "algorithm", "path"], "source_lectures": ["lecture_106103359_w10_l64"]}}
{"id": "concept_store_and_forward", "type": "V_concept", "name": "Store And Forward", "properties": {"description": "A packet switching method where the entire packet is stored at each node before being forwarded to the next node.", "keywords": ["store", "forward", "packet", "node", "buffering"], "source_lectures": ["lecture_106103359_w10_l65"]}}
{"id": "concept_virtual_cut_through", "type": "V_concept", "name": "Virtual Cut Through", "properties": {"description": "A packet switching method where the packet is forwarded to the next node as soon as the header is received, without waiting for the entire packet to arrive.", "keywords": ["virtual", "cut", "through", "packet", "header"], "source_lectures": ["lecture_106103359_w10_l65"]}}
{"id": "concept_wormhole_routing", "type": "V_concept", "name": "Wormhole Routing", "properties": {"description": "A type of flow control where data is divided into flits, and each flit is transmitted through the network in a pipelined fashion.", "keywords": ["wormhole", "routing", "flit", "pipelined", "network"], "source_lectures": ["lecture_106103359_w10_l65"]}}
{"id": "concept_head_of_line_blocking", "type": "V_concept", "name": "Head Of Line Blocking", "properties": {"description": "A problem in wormhole routing where a blocked packet prevents other packets from being transmitted, even if there are available resources.", "keywords": ["head", "line", "blocking", "packet", "resource"], "source_lectures": ["lecture_106103359_w10_l65"]}}
{"id": "concept_virtual_channel", "type": "V_concept", "name": "Virtual Channel", "properties": {"description": "A technique to divide a physical channel into multiple logical channels, allowing for more efficient use of resources and improved flow control.", "keywords": ["virtual", "channel", "physical", "logical", "resource"], "source_lectures": ["lecture_106103359_w10_l65"]}}
{"id": "concept_credit_based_flow_control", "type": "V_concept", "name": "Credit Based Flow Control", "properties": {"description": "A method of flow control where the sender maintains a count of available buffers at the receiver, and adjusts its transmission rate accordingly.", "keywords": ["credit", "based", "flow", "control", "buffer"], "source_lectures": ["lecture_106103359_w10_l65"]}}
{"id": "concept_on_off_signaling", "type": "V_concept", "name": "On-Off Signaling", "properties": {"description": "A method of flow control where the receiver sends a signal to the sender indicating whether it is ready to receive data or not.", "keywords": ["on", "off", "signaling", "receiver", "sender"], "source_lectures": ["lecture_106103359_w10_l65"]}}
{"id": "concept_ack_nack_flow_control", "type": "V_concept", "name": "Ack-Nack Flow Control", "properties": {"description": "A method of flow control where the receiver sends an acknowledgement or negative acknowledgement to the sender, indicating whether the data was received successfully or not.", "keywords": ["ack", "nack", "flow", "control", "receiver"], "source_lectures": ["lecture_106103359_w10_l65"]}}
{"id": "concept_true_sharing", "type": "V_concept", "name": "True Sharing", "properties": {"description": "A situation where a block is shared by multiple processors and one of them modifies the data.", "keywords": ["true", "multiprocessor", "coherence", "modify", "sharing", "data", "cache"], "source_lectures": ["lecture_106103359_w10_l67", "lecture_106103359_w10_l70"]}}
{"id": "concept_flat_directory", "type": "V_concept", "name": "Flat Directory", "properties": {"description": "A directory organization that uses a bit vector to keep track of cache accesses.", "keywords": ["flat", "directory", "bit", "vector"], "source_lectures": ["lecture_106103359_w10_l67"]}}
{"id": "concept_hierarchical_directory", "type": "V_concept", "name": "Hierarchical Directory", "properties": {"description": "A directory organization that uses a hierarchical structure to keep track of cache accesses.", "keywords": ["hierarchical", "directory", "cache", "coherence"], "source_lectures": ["lecture_106103359_w10_l67"]}}
{"id": "concept_cache_inclusion", "type": "V_concept", "name": "Cache Inclusion", "properties": {"description": "The property that a larger cache contains all the blocks of a smaller cache.", "keywords": ["cache", "inclusion", "property"], "source_lectures": ["lecture_106103359_w10_l67"]}}
{"id": "concept_bus_update", "type": "V_concept", "name": "Bus Update", "properties": {"description": "A signal sent on the bus to update the cache with new data.", "keywords": ["bus", "update", "cache", "coherence"], "source_lectures": ["lecture_106103359_w10_l67"]}}
{"id": "concept_compulsory_cache_miss", "type": "V_concept", "name": "Compulsory Cache Miss", "properties": {"description": "A cache miss that occurs the first time a block is accessed, because it has never been loaded into the cache before.", "keywords": ["compulsory miss", "cold miss", "cache miss", "first access", "initial load"], "source_lectures": ["lecture_106103359_w10_l69"]}}
{"id": "concept_conflict_cache_miss", "type": "V_concept", "name": "Conflict Cache Miss", "properties": {"description": "A cache miss that occurs when multiple memory blocks map to the same cache set and evict each other due to limited associativity.", "keywords": ["conflict miss", "cache conflict", "set associative", "cache eviction", "associativity"], "source_lectures": ["lecture_106103359_w10_l69"]}}
{"id": "concept_capacity_cache_miss", "type": "V_concept", "name": "Capacity Cache Miss", "properties": {"description": "A cache miss that occurs when the cache is too small to hold all the data needed by the program, forcing eviction of useful blocks.", "keywords": ["capacity miss", "cache capacity", "cache size", "eviction", "working set"], "source_lectures": ["lecture_106103359_w10_l69"]}}
{"id": "concept_memory_prefetching", "type": "V_concept", "name": "Memory Prefetching", "properties": {"description": "A technique where data is loaded into the cache before it is explicitly requested by the processor, to hide memory latency.", "keywords": ["prefetching", "memory prefetch", "latency hiding", "cache", "memory hierarchy"], "source_lectures": ["lecture_106103359_w10_l69"]}}
{"id": "concept_memory_bank_interleaving", "type": "V_concept", "name": "Memory Bank Interleaving", "properties": {"description": "A method of organizing memory into multiple independent banks to allow parallel access and increase memory bandwidth.", "keywords": ["memory bank", "interleaving", "parallel memory", "bandwidth", "memory module"], "source_lectures": ["lecture_106103359_w10_l69"]}}
{"id": "concept_multi_threading", "type": "V_concept", "name": "Multi-threading", "properties": {"description": "A programming model that allows a single process to execute multiple threads concurrently, enabling parallelism within a single program.", "keywords": ["multi-threading", "thread", "concurrency", "parallel execution", "shared memory"], "source_lectures": ["lecture_106103359_w10_l69"]}}
{"id": "concept_multi_programming", "type": "V_concept", "name": "Multi-programming", "properties": {"description": "A technique where multiple programs are loaded into memory and executed concurrently by the processor, improving CPU utilization.", "keywords": ["multi-programming", "concurrent programs", "cpu utilization", "process", "task switching"], "source_lectures": ["lecture_106103359_w10_l69"]}}
{"id": "concept_scalar_processor", "type": "V_concept", "name": "Scalar Processor", "properties": {"description": "A processor that executes one instruction per clock cycle on a single data element, as opposed to vector or parallel processors.", "keywords": ["scalar processor", "single instruction", "single data", "sequential execution", "classic pipeline"], "source_lectures": ["lecture_106103359_w10_l69"]}}
{"id": "concept_instruction_fetch", "type": "V_concept", "name": "Instruction Fetch", "properties": {"description": "The first stage in a processor pipeline where the next instruction is retrieved from memory or cache.", "keywords": ["instruction fetch", "fetch", "pipeline stage", "memory access", "instruction"], "source_lectures": ["lecture_106103359_w10_l69"]}}
{"id": "concept_instruction_decode", "type": "V_concept", "name": "Instruction Decode", "properties": {"description": "The pipeline stage where the fetched instruction is interpreted to determine the operation and operands.", "keywords": ["instruction decode", "decode", "pipeline stage", "opcode", "operand"], "source_lectures": ["lecture_106103359_w10_l69"]}}
{"id": "concept_alu_operation", "type": "V_concept", "name": "ALU Operation", "properties": {"description": "An arithmetic or logical operation performed by the Arithmetic Logic Unit in a processor, such as addition or bitwise AND.", "keywords": ["alu", "arithmetic logic unit", "operation", "compute", "integer"], "source_lectures": ["lecture_106103359_w10_l69"]}}
{"id": "concept_memory_access_latency", "type": "V_concept", "name": "Memory Access Latency", "properties": {"description": "The time delay between requesting data from memory and receiving it, often a bottleneck in processor performance.", "keywords": ["memory latency", "access latency", "cache miss", "memory hierarchy", "delay"], "source_lectures": ["lecture_106103359_w10_l69"]}}
{"id": "concept_bus_read_signal", "type": "V_concept", "name": "Bus Read Signal", "properties": {"description": "A signal sent by a processor to indicate that it wants to read data from the main memory or another cache.", "keywords": ["bus", "read", "signal", "processor", "memory"], "source_lectures": ["lecture_106103359_w10_l70"]}}
{"id": "concept_bus_update_signal", "type": "V_concept", "name": "Bus Update Signal", "properties": {"description": "A signal sent by a processor to update the data in other caches when it modifies the data.", "keywords": ["bus", "update", "signal", "processor", "cache"], "source_lectures": ["lecture_106103359_w10_l70"]}}
{"id": "concept_sgi_origin_protocol", "type": "V_concept", "name": "SGI Origin Protocol", "properties": {"description": "A directory-based cache coherence protocol used in parallel computer architectures.", "keywords": ["sgi", "origin", "protocol", "cache", "coherence"], "source_lectures": ["lecture_106103359_w11_l71"]}}
{"id": "concept_directory_governance", "type": "V_concept", "name": "Directory Governance", "properties": {"description": "A method of managing cache coherence in a parallel system using a directory to track cache state.", "keywords": ["directory", "governance", "cache", "coherence", "management"], "source_lectures": ["lecture_106103359_w11_l71"]}}
{"id": "concept_sci_ring", "type": "V_concept", "name": "SCI Ring", "properties": {"description": "A type of interconnect topology used in parallel computer architectures.", "keywords": ["sci", "ring", "interconnect", "topology", "parallel"], "source_lectures": ["lecture_106103359_w11_l71"]}}
{"id": "concept_cache_based_directory_structure", "type": "V_concept", "name": "Cache-Based Directory Structure", "properties": {"description": "A data structure used to manage cache coherence in a parallel system.", "keywords": ["cache", "based", "directory", "structure", "coherence"], "source_lectures": ["lecture_106103359_w11_l71"]}}
{"id": "concept_load_linked_store_conditional", "type": "V_concept", "name": "Load Linked Store Conditional", "properties": {"description": "A pair of instructions used to implement synchronization in parallel systems.", "keywords": ["load", "linked", "store", "conditional", "synchronization"], "source_lectures": ["lecture_106103359_w11_l71"]}}
{"id": "concept_interconnect_topology", "type": "V_concept", "name": "Interconnect Topology", "properties": {"description": "The physical or logical arrangement of nodes and links in an interconnect network.", "keywords": ["interconnect", "topology", "network", "nodes", "links"], "source_lectures": ["lecture_106103359_w11_l71"]}}
{"id": "concept_rooting_algorithms", "type": "V_concept", "name": "Rooting Algorithms", "properties": {"description": "Algorithms used to determine the path that data will take through an interconnect network.", "keywords": ["rooting", "algorithms", "interconnect", "network", "path"], "source_lectures": ["lecture_106103359_w11_l71"]}}
{"id": "concept_deadlock_control", "type": "V_concept", "name": "Deadlock Control", "properties": {"description": "Mechanisms used to prevent or recover from deadlocks in an interconnect network.", "keywords": ["deadlock", "control", "interconnect", "network", "recovery"], "source_lectures": ["lecture_106103359_w11_l71"]}}
{"id": "concept_empirical_research", "type": "V_concept", "name": "Empirical Research", "properties": {"description": "A research approach that involves collecting and analyzing data through observation and experimentation to test hypotheses and answer research questions.", "keywords": ["observation", "data", "analysis", "experimentation", "research", "empirical"], "source_lectures": ["lecture_106103220_w4_l26", "lecture_106103220_w4_l28", "lecture_106103220_w5_l31"]}}
{"id": "concept_testable_research_question", "type": "V_concept", "name": "Testable Research Question", "properties": {"description": "A research question that is specific, measurable, and can be answered through empirical data collection and analysis.", "keywords": ["testable", "research", "question", "specific", "measurable"], "source_lectures": ["lecture_106103220_w4_l26"]}}
{"id": "concept_non_testable_research_question", "type": "V_concept", "name": "Non-Testable Research Question", "properties": {"description": "A research question that is too broad, vague, or ambiguous to be answered through empirical data collection and analysis.", "keywords": ["non-testable", "research", "question", "broad", "vague"], "source_lectures": ["lecture_106103220_w4_l26"]}}
{"id": "concept_internal_validity", "type": "V_concept", "name": "Internal Validity", "properties": {"description": "The extent to which a research study's results are due to the manipulation of the independent variable and not to other factors.", "keywords": ["internal", "validity", "research", "study", "manipulation"], "source_lectures": ["lecture_106103220_w4_l26"]}}
{"id": "concept_external_validity", "type": "V_concept", "name": "External Validity", "properties": {"description": "The extent to which a research study's results can be generalized to other populations, settings, and contexts.", "keywords": ["external", "validity", "research", "study", "generalizability"], "source_lectures": ["lecture_106103220_w4_l26"]}}
{"id": "concept_research_hypothesis", "type": "V_concept", "name": "Research Hypothesis", "properties": {"description": "A statement that predicts the outcome of a study and is tested through empirical data collection and analysis.", "keywords": ["research", "hypothesis", "prediction", "outcome", "study"], "source_lectures": ["lecture_106103220_w4_l26"]}}
{"id": "concept_null_hypothesis", "type": "V_concept", "name": "Null Hypothesis", "properties": {"description": "A statement that predicts no effect or no difference between groups, and is used as a basis for comparison with the alternative hypothesis.", "keywords": ["no", "statistical", "hypothesis", "effect", "testing", "null", "difference"], "source_lectures": ["lecture_106103220_w4_l26", "lecture_106103220_w4_l28"]}}
{"id": "concept_alternative_hypothesis", "type": "V_concept", "name": "Alternative Hypothesis", "properties": {"description": "A statement that predicts an effect or a difference between groups, and is used as a basis for comparison with the null hypothesis.", "keywords": ["statistical", "hypothesis", "alternative", "effect", "testing", "groups", "difference"], "source_lectures": ["lecture_106103220_w4_l26", "lecture_106103220_w4_l28"]}}
{"id": "concept_empirical_data", "type": "V_concept", "name": "Empirical Data", "properties": {"description": "Data collected through observation, experimentation, or other empirical methods to test hypotheses and answer research questions.", "keywords": ["empirical", "data", "observation", "experimentation", "research"], "source_lectures": ["lecture_106103220_w4_l26"]}}
{"id": "concept_stages_of_empirical_research", "type": "V_concept", "name": "Stages of Empirical Research", "properties": {"description": "The steps involved in conducting empirical research, including formulation of research questions, determination of variables, design of experiment, data analysis, and interpretation of results.", "keywords": ["stages", "empirical", "research", "formulation", "determination"], "source_lectures": ["lecture_106103220_w4_l26"]}}
{"id": "concept_independent_variable", "type": "V_concept", "name": "Independent Variable", "properties": {"description": "A variable that is intentionally changed by the researcher to observe its effect on the dependent variable.", "keywords": ["independent", "variable", "research", "experiment"], "source_lectures": ["lecture_106103220_w4_l27"]}}
{"id": "concept_dependent_variable", "type": "V_concept", "name": "Dependent Variable", "properties": {"description": "A variable that is being measured or observed in response to changes made to the independent variable.", "keywords": ["dependent", "variable", "measurement", "observation"], "source_lectures": ["lecture_106103220_w4_l27"]}}
{"id": "concept_control_variable", "type": "V_concept", "name": "Control Variable", "properties": {"description": "A variable that is held constant or controlled to prevent its influence on the dependent variable.", "keywords": ["control", "variable", "constant", "influence"], "source_lectures": ["lecture_106103220_w4_l27"]}}
{"id": "concept_confounding_variable", "type": "V_concept", "name": "Confounding Variable", "properties": {"description": "A variable that affects the dependent variable but is not accounted for in the experiment.", "keywords": ["confounding", "variable", "effect", "experiment"], "source_lectures": ["lecture_106103220_w4_l27"]}}
{"id": "concept_nominal_scale", "type": "V_concept", "name": "Nominal Scale", "properties": {"description": "A scale of measurement that assigns labels or categories to data without any quantitative value.", "keywords": ["nominal", "scale", "measurement", "category"], "source_lectures": ["lecture_106103220_w4_l27"]}}
{"id": "concept_ordinal_scale", "type": "V_concept", "name": "Ordinal Scale", "properties": {"description": "A scale of measurement that assigns a rank or order to data but does not establish the degree of difference between them.", "keywords": ["ordinal", "scale", "measurement", "rank"], "source_lectures": ["lecture_106103220_w4_l27"]}}
{"id": "concept_interval_scale", "type": "V_concept", "name": "Interval Scale", "properties": {"description": "A scale of measurement that assigns equal intervals between consecutive levels of measurement.", "keywords": ["interval", "scale", "measurement", "equal"], "source_lectures": ["lecture_106103220_w4_l27"]}}
{"id": "concept_ratio_scale", "type": "V_concept", "name": "Ratio Scale", "properties": {"description": "A scale of measurement that has a true zero point and allows for the calculation of meaningful ratios between measurements.", "keywords": ["ratio", "scale", "measurement", "zero"], "source_lectures": ["lecture_106103220_w4_l27"]}}
{"id": "concept_within_subject_design", "type": "V_concept", "name": "Within Subject Design", "properties": {"description": "An experimental design where each participant is exposed to all levels of the independent variable.", "keywords": ["within", "subject", "design", "experiment"], "source_lectures": ["lecture_106103220_w4_l27"]}}
{"id": "concept_between_subject_design", "type": "V_concept", "name": "Between Subject Design", "properties": {"description": "An experimental design where each participant is exposed to only one level of the independent variable.", "keywords": ["between", "subject", "design", "experiment"], "source_lectures": ["lecture_106103220_w4_l27"]}}
{"id": "concept_latin_square_method", "type": "V_concept", "name": "Latin Square Method", "properties": {"description": "A statistical technique used to counterbalance the order of tasks in an experiment to minimize practice effects.", "keywords": ["latin", "square", "method", "counterbalance"], "source_lectures": ["lecture_106103220_w4_l27"]}}
{"id": "concept_practice_effect", "type": "V_concept", "name": "Practice Effect", "properties": {"description": "A type of bias that occurs when participants' performance improves or changes due to repeated exposure to a task or stimulus.", "keywords": ["practice", "effect", "bias", "performance"], "source_lectures": ["lecture_106103220_w4_l27"]}}
{"id": "concept_user_profile", "type": "V_concept", "name": "User Profile", "properties": {"description": "A set of characteristics that define a user's background, experience, and preferences.", "keywords": ["user", "profile", "characteristics", "background"], "source_lectures": ["lecture_106103220_w4_l27"]}}
{"id": "concept_representative_task", "type": "V_concept", "name": "Representative Task", "properties": {"description": "A task that is representative of the real-world scenario or situation being studied.", "keywords": ["representative", "task", "real-world", "scenario"], "source_lectures": ["lecture_106103220_w4_l27"]}}
{"id": "concept_research_question", "type": "V_concept", "name": "Research Question", "properties": {"description": "A specific question that guides the research study and is used to collect and analyze data.", "keywords": ["research", "question", "study", "data"], "source_lectures": ["lecture_106103220_w4_l28"]}}
{"id": "concept_statistical_significance_test", "type": "V_concept", "name": "Statistical Significance Test", "properties": {"description": "A procedure used to determine whether the results of a study are due to chance or if they reflect a real effect.", "keywords": ["statistical", "significance", "test", "chance"], "source_lectures": ["lecture_106103220_w4_l28"]}}
{"id": "concept_p_value", "type": "V_concept", "name": "P-Value", "properties": {"description": "A measure of the probability that the results of a study are due to chance, used to determine statistical significance.", "keywords": ["p-value", "probability", "chance", "significance"], "source_lectures": ["lecture_106103220_w4_l28"]}}
{"id": "concept_type_i_error", "type": "V_concept", "name": "Type I Error", "properties": {"description": "The error of rejecting a true null hypothesis, also known as a false positive error.", "keywords": ["type i error", "false positive", "null hypothesis"], "source_lectures": ["lecture_106103220_w4_l28"]}}
{"id": "concept_type_ii_error", "type": "V_concept", "name": "Type II Error", "properties": {"description": "The error of failing to reject a false null hypothesis, also known as a false negative error.", "keywords": ["type ii error", "false negative", "null hypothesis"], "source_lectures": ["lecture_106103220_w4_l28"]}}
{"id": "concept_parametric_test", "type": "V_concept", "name": "Parametric Test", "properties": {"description": "A statistical test that assumes a specific distribution of the data, such as a normal distribution.", "keywords": ["parametric", "test", "distribution", "normal"], "source_lectures": ["lecture_106103220_w4_l28"]}}
{"id": "concept_non_parametric_test", "type": "V_concept", "name": "Non-Parametric Test", "properties": {"description": "A statistical test that does not assume a specific distribution of the data.", "keywords": ["non-parametric", "test", "distribution"], "source_lectures": ["lecture_106103220_w4_l28"]}}
{"id": "concept_r_squared", "type": "V_concept", "name": "R-Squared", "properties": {"description": "A measure of the goodness of fit of a regression model, indicating the proportion of variance in the dependent variable that is explained by the independent variable.", "keywords": ["r-squared", "goodness of fit", "regression", "model"], "source_lectures": ["lecture_106103220_w4_l28"]}}
{"id": "concept_interactive_systems", "type": "V_concept", "name": "Interactive Systems", "properties": {"description": "Systems that allow users to interact with them through various means such as input devices, voice commands, or gestures.", "keywords": ["interactive", "systems", "user", "interface", "design"], "source_lectures": ["lecture_106103220_w5_l31"]}}
{"id": "concept_computational_framework", "type": "V_concept", "name": "Computational Framework", "properties": {"description": "A structured approach to designing and evaluating interactive systems using computational models and methods.", "keywords": ["computational", "framework", "design", "evaluation", "interactive"], "source_lectures": ["lecture_106103220_w5_l31"]}}
{"id": "concept_user_models", "type": "V_concept", "name": "User Models", "properties": {"description": "Representations of the user's behavior, goals, and characteristics used to design and evaluate interactive systems.", "keywords": ["user", "models", "behavior", "goals", "characteristics"], "source_lectures": ["lecture_106103220_w5_l31"]}}
{"id": "concept_statistical_significance_testing", "type": "V_concept", "name": "Statistical Significance Testing", "properties": {"description": "A method used to determine whether the results of an experiment or study are statistically significant and reliable.", "keywords": ["statistical", "significance", "testing", "experiment", "reliability"], "source_lectures": ["lecture_106103220_w5_l31"]}}
{"id": "concept_conference_proceedings", "type": "V_concept", "name": "Conference Proceedings", "properties": {"description": "Published records of the papers and presentations given at a conference, often used to disseminate research findings and stay up-to-date with the latest developments in a field.", "keywords": ["conference", "proceedings", "research", "publications", "dissemination"], "source_lectures": ["lecture_106103220_w5_l31"]}}
{"id": "concept_journal_publications", "type": "V_concept", "name": "Journal Publications", "properties": {"description": "Periodical publications that contain research articles, reviews, and other scholarly content, often used to disseminate research findings and stay up-to-date with the latest developments in a field.", "keywords": ["journal", "publications", "research", "articles", "reviews"], "source_lectures": ["lecture_106103220_w5_l31"]}}
{"id": "concept_chi_conference", "type": "V_concept", "name": "CHI Conference", "properties": {"description": "A premier international conference on human-computer interaction, organized by the Special Interest Group on Computer-Human Interaction (SIGCHI).", "keywords": ["chi", "conference", "human", "computer", "interaction"], "source_lectures": ["lecture_106103220_w5_l31"]}}
{"id": "concept_core_ranking", "type": "V_concept", "name": "CORE Ranking", "properties": {"description": "A ranking system used to evaluate the quality of conferences and journals in the field of computer science, based on factors such as impact, reputation, and citation counts.", "keywords": ["core", "ranking", "conferences", "journals", "quality"], "source_lectures": ["lecture_106103220_w5_l31"]}}
{"id": "concept_design_thinking", "type": "V_concept", "name": "Design Thinking", "properties": {"description": "A problem-solving approach that involves empathizing with users, ideating solutions, and prototyping and testing.", "keywords": ["design", "thinking", "problem", "solving", "empathy"], "source_lectures": ["lecture_106103220_w6_l37"]}}
{"id": "concept_software_development_life_cycle", "type": "V_concept", "name": "Software Development Life Cycle", "properties": {"description": "A process used to plan, design, develop, test, and deliver software systems.", "keywords": ["software", "development", "life", "cycle", "process"], "source_lectures": ["lecture_106103220_w6_l37"]}}
{"id": "concept_agile_method", "type": "V_concept", "name": "Agile Method", "properties": {"description": "A software development approach that emphasizes flexibility, collaboration, and rapid delivery.", "keywords": ["agile", "method", "software", "development", "flexibility"], "source_lectures": ["lecture_106103220_w6_l37"]}}
{"id": "concept_iterative_life_cycle", "type": "V_concept", "name": "Iterative Life Cycle", "properties": {"description": "A software development approach that involves repeating cycles of design, development, and testing.", "keywords": ["iterative", "life", "cycle", "software", "development"], "source_lectures": ["lecture_106103220_w6_l37"]}}
{"id": "concept_incremental_life_cycle", "type": "V_concept", "name": "Incremental Life Cycle", "properties": {"description": "A software development approach that involves building a system in small increments, with each increment adding new functionality.", "keywords": ["incremental", "life", "cycle", "software", "development"], "source_lectures": ["lecture_106103220_w6_l37"]}}
{"id": "concept_user_experience_design", "type": "V_concept", "name": "User Experience Design", "properties": {"description": "A process used to create systems that are intuitive, easy to use, and provide a positive experience for users.", "keywords": ["user", "experience", "design", "intuitive", "easy"], "source_lectures": ["lecture_106103220_w6_l37"]}}
{"id": "concept_affective_computing", "type": "V_concept", "name": "Affective Computing", "properties": {"description": "A field of study that involves using computers to recognize and respond to human emotions.", "keywords": ["affective", "computing", "field", "study", "emotions"], "source_lectures": ["lecture_106103220_w6_l37"]}}
{"id": "concept_schneidermans_eight_golden_rules", "type": "V_concept", "name": "Schneiderman's Eight Golden Rules", "properties": {"description": "A set of principles for designing user interfaces that are intuitive and easy to use.", "keywords": ["schneiderman", "golden", "rules", "design", "interface"], "source_lectures": ["lecture_106103220_w6_l37"]}}
{"id": "concept_normans_seven_principles", "type": "V_concept", "name": "Norman's Seven Principles", "properties": {"description": "A set of principles for designing user interfaces that are intuitive and easy to use.", "keywords": ["norman", "principles", "design", "interface", "intuitive"], "source_lectures": ["lecture_106103220_w6_l37"]}}
{"id": "concept_ux_design_principles", "type": "V_concept", "name": "Ux Design Principles", "properties": {"description": "Guidelines for designing user interfaces and interactions that are intuitive and user-friendly", "keywords": ["ux", "design", "principles", "interface", "interaction"], "source_lectures": ["lecture_106103220_w6_l40"]}}
{"id": "concept_large_language_models", "type": "V_concept", "name": "Large Language Models", "properties": {"description": "A type of artificial intelligence model that is trained on large amounts of text data and can generate human-like language", "keywords": ["large", "language", "models", "ai", "nlp"], "source_lectures": ["lecture_106103220_w6_l40"]}}
{"id": "concept_gestural_interaction", "type": "V_concept", "name": "Gestural Interaction", "properties": {"description": "A type of interaction that uses hand or body gestures to control a system or device", "keywords": ["gestural", "interaction", "gesture", "interface", "input"], "source_lectures": ["lecture_106103220_w6_l40"]}}
{"id": "concept_halting_problem", "type": "V_concept", "name": "Halting Problem", "properties": {"description": "A problem that determines whether a given program will halt or run forever.", "keywords": ["input", "program", "problem", "turing", "computation", "halting", "decision", "machine"], "source_lectures": ["lecture_106104357_w1_l1", "lecture_106104357_w1_l2", "lecture_106104357_w1_l5"]}}
{"id": "concept_computability", "type": "V_concept", "name": "Computability", "properties": {"description": "The ability of a problem to be solved by a computational machine.", "keywords": ["computability", "problem", "machine", "computation"], "source_lectures": ["lecture_106104357_w1_l1"]}}
{"id": "concept_satisfiability", "type": "V_concept", "name": "Satisfiability", "properties": {"description": "A problem that determines whether a given Boolean formula is satisfiable.", "keywords": ["satisfiability", "boolean", "formula", "computation"], "source_lectures": ["lecture_106104357_w1_l1"]}}
{"id": "concept_quantified_boolean_formula", "type": "V_concept", "name": "Quantified Boolean Formula", "properties": {"description": "A Boolean formula with quantifiers that range over the variables.", "keywords": ["variables", "boolean", "computation", "quantified", "formula", "qbf"], "source_lectures": ["lecture_106104357_w1_l1", "lecture_106104357_w3_l19", "lecture_106104357_w4_l23", "lecture_106104357_w4_l24"]}}
{"id": "concept_p_vs_np", "type": "V_concept", "name": "P vs NP", "properties": {"description": "A problem that determines whether every problem with a known efficient algorithm can also be verified efficiently.", "keywords": ["p", "np", "computation", "complexity"], "source_lectures": ["lecture_106104357_w1_l1"]}}
{"id": "concept_p_versus_np_problem", "type": "V_concept", "name": "P Versus NP Problem", "properties": {"description": "A fundamental problem in computer science that deals with the relationship between computational complexity theory and cryptography.", "keywords": ["p", "np", "problem", "complexity", "cryptography"], "source_lectures": ["lecture_106104357_w1_l2"]}}
{"id": "concept_formula_optimization", "type": "V_concept", "name": "Formula Optimization", "properties": {"description": "A problem that involves finding the smallest possible formula that represents a given Boolean function.", "keywords": ["formula", "optimization", "boolean", "function"], "source_lectures": ["lecture_106104357_w1_l2"]}}
{"id": "concept_identity_testing", "type": "V_concept", "name": "Identity Testing", "properties": {"description": "A problem that involves determining whether a given polynomial is identically zero.", "keywords": ["identity", "testing", "polynomial", "zero"], "source_lectures": ["lecture_106104357_w1_l2"]}}
{"id": "concept_bpp_complexity_class", "type": "V_concept", "name": "BPP Complexity Class", "properties": {"description": "A complexity class that represents problems that can be solved in polynomial time using randomness.", "keywords": ["probabilistic", "polynomial", "class", "complexity", "bpp", "randomness"], "source_lectures": ["lecture_106104357_w1_l2", "lecture_106104357_w6_l37"]}}
{"id": "concept_graph_reachability", "type": "V_concept", "name": "Graph Reachability", "properties": {"description": "A problem that involves determining whether there is a path between two given vertices in a graph.", "keywords": ["graph", "reachability", "path", "vertices"], "source_lectures": ["lecture_106104357_w1_l2"]}}
{"id": "concept_l_complexity_class", "type": "V_concept", "name": "L Complexity Class", "properties": {"description": "A complexity class that represents problems that can be solved in logarithmic space.", "keywords": ["l", "complexity", "class", "logarithmic", "space"], "source_lectures": ["lecture_106104357_w1_l2"]}}
{"id": "concept_rl_complexity_class", "type": "V_concept", "name": "RL Complexity Class", "properties": {"description": "A complexity class that represents problems that can be solved in logarithmic space using randomness.", "keywords": ["rl", "complexity", "class", "logarithmic", "space", "randomness"], "source_lectures": ["lecture_106104357_w1_l2"]}}
{"id": "concept_sharp_p_complexity_class", "type": "V_concept", "name": "Sharp P Complexity Class", "properties": {"description": "A complexity class that represents problems that involve counting the number of solutions to a given problem.", "keywords": ["complexity class", "sharp", "class", "complexity", "computational complexity", "sharp p", "counting", "p"], "source_lectures": ["lecture_106104357_w1_l2", "lecture_106104357_w4_l28"]}}
{"id": "concept_graph_isomorphism", "type": "V_concept", "name": "Graph Isomorphism", "properties": {"description": "A problem that involves determining whether two given graphs are isomorphic.", "keywords": ["graph", "isomorphic", "structure", "problem", "isomorphism", "vertices"], "source_lectures": ["lecture_106104357_w1_l2", "lecture_106104357_w6_l42"]}}
{"id": "concept_ip_complexity_class", "type": "V_concept", "name": "IP Complexity Class", "properties": {"description": "A complexity class that represents problems that can be solved using interactive proofs.", "keywords": ["ip", "complexity", "class", "interactive", "proofs"], "source_lectures": ["lecture_106104357_w1_l2"]}}
{"id": "concept_pspace_complexity_class", "type": "V_concept", "name": "PSPACE Complexity Class", "properties": {"description": "A complexity class that represents problems that can be solved in polynomial space.", "keywords": ["pspace", "complexity", "class", "polynomial", "space"], "source_lectures": ["lecture_106104357_w1_l2"]}}
{"id": "concept_oracle", "type": "V_concept", "name": "Oracle", "properties": {"description": "A hypothetical machine that can solve a given problem in a single step.", "keywords": ["oracle", "machine", "problem", "solution"], "source_lectures": ["lecture_106104357_w1_l2"]}}
{"id": "concept_decision_problem", "type": "V_concept", "name": "Decision Problem", "properties": {"description": "A problem that can be answered with a simple yes or no, often by evaluating a Boolean function.", "keywords": ["decision", "problem", "boolean", "computing"], "source_lectures": ["lecture_106104357_w1_l3"]}}
{"id": "concept_language_recognition", "type": "V_concept", "name": "Language Recognition", "properties": {"description": "The process of determining whether a given string belongs to a specific language, often using a Turing machine.", "keywords": ["language", "recognition", "turing", "machine"], "source_lectures": ["lecture_106104357_w1_l3"]}}
{"id": "concept_transition_function", "type": "V_concept", "name": "Transition Function", "properties": {"description": "A function that determines the next state of a Turing machine based on its current state and input.", "keywords": ["transition", "state", "turing", "function", "computation", "machine"], "source_lectures": ["lecture_106104357_w1_l3", "lecture_106104357_w1_l4", "lecture_106104357_w2_l10"]}}
{"id": "concept_parity_computation", "type": "V_concept", "name": "Parity Computation", "properties": {"description": "The process of determining whether the sum of a set of bits is odd or even.", "keywords": ["sum", "string", "bits", "algorithm", "computation", "binary", "parity"], "source_lectures": ["lecture_106104357_w1_l3", "lecture_106104357_w1_l4"]}}
{"id": "concept_boolean_string", "type": "V_concept", "name": "Boolean String", "properties": {"description": "A sequence of binary digits (0s and 1s) that can be used to represent information.", "keywords": ["boolean", "string", "binary", "digits"], "source_lectures": ["lecture_106104357_w1_l3"]}}
{"id": "concept_state_diagram", "type": "V_concept", "name": "State Diagram", "properties": {"description": "A graphical representation of a Turing machine's states and transitions.", "keywords": ["state", "diagram", "turing", "machine", "graph"], "source_lectures": ["lecture_106104357_w1_l4"]}}
{"id": "concept_theta_notation", "type": "V_concept", "name": "Theta Notation", "properties": {"description": "A notation used to describe the exact bound of an algorithm's time or space complexity.", "keywords": ["theta", "notation", "complexity", "algorithm", "efficiency"], "source_lectures": ["lecture_106104357_w1_l4"]}}
{"id": "concept_small_o_notation", "type": "V_concept", "name": "Small O Notation", "properties": {"description": "A mathematical notation that describes the upper bound of an algorithm's time or space complexity, but not necessarily tight.", "keywords": ["small o", "notation", "complexity", "algorithm", "upper bound"], "source_lectures": ["lecture_106104357_w1_l5"]}}
{"id": "concept_church_turing_thesis", "type": "V_concept", "name": "Church-Turing Thesis", "properties": {"description": "A hypothesis that states any effectively calculable function can be computed by a Turing machine.", "keywords": ["church", "turing", "thesis", "computability", "turing machine"], "source_lectures": ["lecture_106104357_w1_l5"]}}
{"id": "concept_universal_turing_machine", "type": "V_concept", "name": "Universal Turing Machine", "properties": {"description": "A Turing machine that can simulate any other Turing machine on a given input.", "keywords": ["input", "universal", "turing", "universal turing machine", "utm", "turing machine", "simulation", "computation", "machine"], "source_lectures": ["lecture_106104357_w1_l5", "lecture_106104357_w2_l14"]}}
{"id": "concept_polynomial_time_complexity", "type": "V_concept", "name": "Polynomial Time Complexity", "properties": {"description": "A time complexity that is bounded by a polynomial function of the input size.", "keywords": ["polynomial", "time", "complexity", "input size", "bounded"], "source_lectures": ["lecture_106104357_w1_l5"]}}
{"id": "concept_efficient_computation", "type": "V_concept", "name": "Efficient Computation", "properties": {"description": "A computation that can be performed in polynomial time.", "keywords": ["efficient", "computation", "polynomial", "time", "complexity"], "source_lectures": ["lecture_106104357_w1_l5"]}}
{"id": "concept_np_complexity_class", "type": "V_concept", "name": "Np Complexity Class", "properties": {"description": "A class of decision problems that can be verified in polynomial time by a deterministic Turing machine.", "keywords": ["time", "polynomial", "class", "complexity", "turing", "nondeterministic", "np", "machine"], "source_lectures": ["lecture_106104357_w2_l8", "lecture_106104357_w3_l17"]}}
{"id": "concept_verifier", "type": "V_concept", "name": "Verifier", "properties": {"description": "A Turing machine that checks whether a given certificate is correct for a particular input.", "keywords": ["input", "certificate", "np", "turing", "verifier", "correctness", "algorithm", "solution", "machine"], "source_lectures": ["lecture_106104357_w2_l8", "lecture_106104357_w2_l10"]}}
{"id": "concept_certificate", "type": "V_concept", "name": "Certificate", "properties": {"description": "A string that serves as proof of a solution to a decision problem.", "keywords": ["certificate", "string", "membership", "proof", "solution", "np", "decision"], "source_lectures": ["lecture_106104357_w2_l8", "lecture_106104357_w2_l10"]}}
{"id": "concept_p_complexity_class", "type": "V_concept", "name": "P Complexity Class", "properties": {"description": "A class of decision problems that can be solved in polynomial time by a deterministic Turing machine.", "keywords": ["time", "polynomial", "class", "complexity", "turing", "p", "machine"], "source_lectures": ["lecture_106104357_w2_l8", "lecture_106104357_w3_l17"]}}
{"id": "concept_transition_relation", "type": "V_concept", "name": "Transition Relation", "properties": {"description": "A relation that defines the possible next states of a non-deterministic Turing machine.", "keywords": ["transition", "relation", "non-deterministic", "turing", "machine"], "source_lectures": ["lecture_106104357_w2_l8"]}}
{"id": "concept_brute_force_algorithm", "type": "V_concept", "name": "Brute Force Algorithm", "properties": {"description": "A type of algorithm that tries all possible solutions to a problem.", "keywords": ["brute", "force", "algorithm", "solution", "problem"], "source_lectures": ["lecture_106104357_w2_l8"]}}
{"id": "concept_boolean_formula", "type": "V_concept", "name": "Boolean Formula", "properties": {"description": "A logical statement that combines variables and constants using logical operators to produce a true or false result.", "keywords": ["variables", "operators", "boolean", "logic", "formula"], "source_lectures": ["lecture_106104357_w2_l10", "lecture_106104357_w2_l11"]}}
{"id": "concept_cnf_formula", "type": "V_concept", "name": "CNF Formula", "properties": {"description": "A Boolean formula that is expressed as a conjunction of clauses, where each clause is a disjunction of literals.", "keywords": ["disjunction", "conjunction", "boolean", "literals", "cnf", "formula"], "source_lectures": ["lecture_106104357_w2_l10", "lecture_106104357_w2_l11"]}}
{"id": "concept_oblivious_turing_machine", "type": "V_concept", "name": "Oblivious Turing Machine", "properties": {"description": "A Turing machine where the head positions only depend on the size of the input and the current step, not on the input itself.", "keywords": ["oblivious", "turing", "machine", "head", "positions"], "source_lectures": ["lecture_106104357_w2_l10"]}}
{"id": "concept_reduction", "type": "V_concept", "name": "Reduction", "properties": {"description": "A process of transforming one problem into another problem, often to prove that the second problem is at least as hard as the first.", "keywords": ["reduction", "problem", "transformation", "hardness"], "source_lectures": ["lecture_106104357_w2_l10"]}}
{"id": "concept_satisfiability_problem", "type": "V_concept", "name": "Satisfiability Problem", "properties": {"description": "A problem of determining whether a given Boolean formula can be satisfied by an assignment of values to its variables.", "keywords": ["satisfiability", "boolean", "formula", "assignment", "values"], "source_lectures": ["lecture_106104357_w2_l11"]}}
{"id": "concept_3_sat", "type": "V_concept", "name": "3-SAT", "properties": {"description": "A problem of determining whether a given Boolean formula in conjunctive normal form with three literals per clause is satisfiable.", "keywords": ["3-sat", "boolean", "formula", "satisfiability", "cnf"], "source_lectures": ["lecture_106104357_w2_l11"]}}
{"id": "concept_arithmetization", "type": "V_concept", "name": "Arithmetization", "properties": {"description": "A process of converting a combinatorial problem into an algebraic or arithmetic problem.", "keywords": ["arithmetization", "combinatorial", "algebraic", "arithmetic", "problem"], "source_lectures": ["lecture_106104357_w2_l11"]}}
{"id": "concept_integer_programming", "type": "V_concept", "name": "Integer Programming", "properties": {"description": "A problem of finding the optimal solution to a system of linear equations and inequalities with integer variables.", "keywords": ["integer", "programming", "linear", "equations", "inequalities"], "source_lectures": ["lecture_106104357_w2_l11"]}}
{"id": "concept_space_hierarchy_theorem", "type": "V_concept", "name": "Space Hierarchy Theorem", "properties": {"description": "States that given more space, a Turing machine can solve more problems, specifically that DSPACE(f(n)) is a proper subset of DSPACE(g(n)) if g(n) grows asymptotically faster than f(n).", "keywords": ["space hierarchy", "dspaces", "complexity classes", "turing machine", "space bounds"], "source_lectures": ["lecture_106104357_w2_l14"]}}
{"id": "concept_simulation_overhead", "type": "V_concept", "name": "Simulation Overhead", "properties": {"description": "The additional time or space required by a universal Turing machine to simulate another Turing machine, typically bounded by a logarithmic factor in time but negligible in space.", "keywords": ["simulation", "overhead", "time complexity", "space complexity", "universal turing machine"], "source_lectures": ["lecture_106104357_w2_l14"]}}
{"id": "concept_diagonalization_argument", "type": "V_concept", "name": "Diagonalization Argument", "properties": {"description": "A proof technique used to construct a problem that differs from every problem in a given class, often used to show separations between complexity classes.", "keywords": ["argument", "diagonalization", "technique", "proof technique", "complexity", "contradiction", "proof", "complexity separation", "halting problem"], "source_lectures": ["lecture_106104357_w2_l14", "lecture_106104357_w3_l16"]}}
{"id": "concept_lazy_diagonalization", "type": "V_concept", "name": "Lazy Diagonalization", "properties": {"description": "A refined diagonalization technique that constructs a problem differing from others on only very sparse inputs, used to handle non-deterministic time hierarchies.", "keywords": ["lazy diagonalization", "non-deterministic", "sparse differences", "diagonalization", "complexity hierarchy"], "source_lectures": ["lecture_106104357_w2_l14"]}}
{"id": "concept_non_deterministic_time_hierarchy_theorem", "type": "V_concept", "name": "Non-Deterministic Time Hierarchy Theorem", "properties": {"description": "States that for time-constructible functions, if g(n) grows faster than f(n), then NTIME(f(n)) is a proper subset of NTIME(g(n)), even when the gap is small.", "keywords": ["non-deterministic time hierarchy", "ntime", "complexity classes", "cook-zach theorem", "diagonalization"], "source_lectures": ["lecture_106104357_w2_l14"]}}
{"id": "concept_co_class", "type": "V_concept", "name": "Co-Class", "properties": {"description": "The class of problems whose complements are in a given complexity class, often relevant when negating non-deterministic computations.", "keywords": ["co-class", "complement", "complexity class", "negation", "non-determinism"], "source_lectures": ["lecture_106104357_w2_l14"]}}
{"id": "concept_time_constructible_function", "type": "V_concept", "name": "Time-Constructible Function", "properties": {"description": "A function f(n) for which there exists a Turing machine that, given input of length n, can compute f(n) in O(f(n)) time.", "keywords": ["time-constructible", "function", "complexity", "turing machine", "computable"], "source_lectures": ["lecture_106104357_w2_l14"]}}
{"id": "concept_space_constructible_function", "type": "V_concept", "name": "Space-Constructible Function", "properties": {"description": "A function f(n) for which there exists a Turing machine that, given input of length n, can compute f(n) using O(f(n)) space.", "keywords": ["space-constructible", "function", "complexity", "turing machine", "computable"], "source_lectures": ["lecture_106104357_w2_l14"]}}
{"id": "concept_blowup_in_simulation", "type": "V_concept", "name": "Blowup in Simulation", "properties": {"description": "The increase in resource usage (time or space) when simulating one Turing machine on another, such as the log-factor time blowup in universal simulation.", "keywords": ["blowup", "simulation", "time complexity", "space complexity", "overhead"], "source_lectures": ["lecture_106104357_w2_l14"]}}
{"id": "concept_ntime_vs_dtime", "type": "V_concept", "name": "NTIME vs DTIME", "properties": {"description": "The distinction between non-deterministic and deterministic time complexity classes, where NTIME may capture more problems than DTIME for the same time bound.", "keywords": ["ntime", "dtimes", "non-determinism", "determinism", "complexity classes"], "source_lectures": ["lecture_106104357_w2_l14"]}}
{"id": "concept_exponential_blowup_in_non_deterministic_negation", "type": "V_concept", "name": "Exponential Blowup in Non-Deterministic Negation", "properties": {"description": "The phenomenon where negating a non-deterministic computation may require exponential time due to the need to check all computation paths.", "keywords": ["exponential blowup", "non-determinism", "negation", "complement", "computation path"], "source_lectures": ["lecture_106104357_w2_l14"]}}
{"id": "concept_proper_subset_in_complexity_classes", "type": "V_concept", "name": "Proper Subset in Complexity Classes", "properties": {"description": "A relationship between two complexity classes where one is entirely contained within the other but not equal, indicating a strict separation.", "keywords": ["proper subset", "complexity class", "separation", "inclusion", "hierarchy"], "source_lectures": ["lecture_106104357_w2_l14"]}}
{"id": "concept_asymptotic_growth_comparison", "type": "V_concept", "name": "Asymptotic Growth Comparison", "properties": {"description": "The comparison of functions using asymptotic notation (e.g., little omega) to determine whether one grows strictly faster than another.", "keywords": ["asymptotic", "growth", "little omega", "big o", "function comparison"], "source_lectures": ["lecture_106104357_w2_l14"]}}
{"id": "concept_configuration_tracking", "type": "V_concept", "name": "Configuration Tracking", "properties": {"description": "The process of recording the state, tape contents, and head positions of a Turing machine during simulation to accurately reproduce its behavior.", "keywords": ["configuration", "tracking", "simulation", "turing machine", "tape"], "source_lectures": ["lecture_106104357_w2_l14"]}}
{"id": "concept_halting_problem_connection", "type": "V_concept", "name": "Halting Problem Connection", "properties": {"description": "The use of diagonalization techniques from the halting problem proof to construct undecidable or hierarchy-separating languages in complexity theory.", "keywords": ["halting problem", "diagonalization", "undecidable", "complexity", "proof technique"], "source_lectures": ["lecture_106104357_w2_l14"]}}
{"id": "concept_deterministic_time_complexity", "type": "V_concept", "name": "Deterministic Time Complexity", "properties": {"description": "The amount of time a deterministic Turing machine requires to solve a problem as a function of input size, denoted DTIME(f(n)).", "keywords": ["deterministic", "time complexity", "dtimes", "turing machine", "computational complexity"], "source_lectures": ["lecture_106104357_w2_l14"]}}
{"id": "concept_non_deterministic_time_complexity", "type": "V_concept", "name": "Non-Deterministic Time Complexity", "properties": {"description": "The amount of time a non-deterministic Turing machine requires to solve a problem as a function of input size, denoted NTIME(f(n)).", "keywords": ["non-deterministic", "time complexity", "ntime", "turing machine", "computational complexity"], "source_lectures": ["lecture_106104357_w2_l14"]}}
{"id": "concept_polynomial_space_pspace", "type": "V_concept", "name": "Polynomial Space (PSPACE)", "properties": {"description": "The complexity class of decision problems solvable by a deterministic Turing machine using a polynomial amount of space.", "keywords": ["pspace", "polynomial space", "complexity class", "space complexity", "deterministic"], "source_lectures": ["lecture_106104357_w2_l14"]}}
{"id": "concept_open_problem_time_hierarchy_without_log_factor", "type": "V_concept", "name": "Open Problem: Time Hierarchy Without Log Factor", "properties": {"description": "The unresolved question of whether DTIME(f(n)) is strictly contained in DTIME(f(n) * log(f(n))) or if the log factor is necessary in the time hierarchy theorem.", "keywords": ["open problem", "time hierarchy", "log factor", "dtimes", "complexity theory"], "source_lectures": ["lecture_106104357_w2_l14"]}}
{"id": "concept_lazy_diagonalization_timing", "type": "V_concept", "name": "Lazy Diagonalization Timing", "properties": {"description": "A technique where the constructed Turing machine differs from others only on inputs of exponentially increasing lengths, such as 2^1, 2^2, 2^3, etc.", "keywords": ["lazy diagonalization", "timing", "exponential spacing", "sparse inputs", "non-determinism"], "source_lectures": ["lecture_106104357_w2_l14"]}}
{"id": "concept_cook_zach_theorem", "type": "V_concept", "name": "Cook-Zach Theorem", "properties": {"description": "The theorem establishing the non-deterministic time hierarchy, showing that NTIME(f(n)) is strictly contained in NTIME(g(n)) for g(n) growing faster than f(n).", "keywords": ["cook-zach", "non-deterministic time hierarchy", "ntime", "complexity theorem", "proof"], "source_lectures": ["lecture_106104357_w2_l14"]}}
{"id": "concept_complement_problem_in_non_determinism", "type": "V_concept", "name": "Complement Problem in Non-Determinism", "properties": {"description": "The challenge of constructing a machine that accepts the complement of a language decided by a non-deterministic Turing machine without exponential overhead.", "keywords": ["complement", "non-determinism", "negation", "co-class", "complexity"], "source_lectures": ["lecture_106104357_w2_l14"]}}
{"id": "concept_rapidly_growing_function", "type": "V_concept", "name": "Rapidly Growing Function", "properties": {"description": "A function that increases extremely quickly, such as s(i+1) > 2^g(s(i)), used in lazy diagonalization to space out differences in computation.", "keywords": ["rapidly growing", "function", "diagonalization", "exponential growth", "complexity"], "source_lectures": ["lecture_106104357_w2_l14"]}}
{"id": "concept_input_encoding_in_diagonalization", "type": "V_concept", "name": "Input Encoding in Diagonalization", "properties": {"description": "The process of treating the description of a Turing machine as input to another machine to construct a diagonalizing language.", "keywords": ["input encoding", "diagonalization", "turing machine description", "self-reference", "complexity"], "source_lectures": ["lecture_106104357_w2_l14"]}}
{"id": "concept_deterministic_vs_non_deterministic_hierarchy_optimality", "type": "V_concept", "name": "Deterministic vs Non-Deterministic Hierarchy Optimality", "properties": {"description": "The observation that the non-deterministic time hierarchy theorem has an optimal gap condition (g(n) > f(n)), unlike the deterministic version which requires g(n) > f(n) * log(f(n)).", "keywords": ["deterministic", "non-deterministic", "hierarchy", "optimality", "gap condition"], "source_lectures": ["lecture_106104357_w2_l14"]}}
{"id": "concept_simulation_in_same_space", "type": "V_concept", "name": "Simulation in Same Space", "properties": {"description": "The property that a universal Turing machine can simulate another Turing machine using space asymptotically equivalent to the original machine\u2019s space usage.", "keywords": ["simulation", "space efficiency", "universal turing machine", "space complexity", "same space"], "source_lectures": ["lecture_106104357_w2_l14"]}}
{"id": "concept_ladners_theorem", "type": "V_concept", "name": "Ladner's Theorem", "properties": {"description": "A theorem in computational complexity theory that states there are problems in NP that are not in P and not NP-complete.", "keywords": ["ladner", "np", "p", "complexity", "theorem"], "source_lectures": ["lecture_106104357_w3_l16"]}}
{"id": "concept_padded_set", "type": "V_concept", "name": "Padded Set", "properties": {"description": "A set that is constructed by padding a given set with additional elements to make it harder to solve.", "keywords": ["padded", "set", "complexity", "reduction", "np"], "source_lectures": ["lecture_106104357_w3_l16"]}}
{"id": "concept_oracle_turing_machine", "type": "V_concept", "name": "Oracle Turing Machine", "properties": {"description": "A Turing machine that has access to an oracle, which is a device that can solve a specific problem in a single step.", "keywords": ["model", "oracle", "complexity", "turing", "problem", "computation", "decision", "machine"], "source_lectures": ["lecture_106104357_w3_l16", "lecture_106104357_w3_l17", "lecture_106104357_w3_l18", "lecture_106104357_w4_l23", "lecture_106104357_w4_l26"]}}
{"id": "concept_relativizing_proof", "type": "V_concept", "name": "Relativizing Proof", "properties": {"description": "A proof technique used in computational complexity theory to show that a certain result holds relative to an oracle.", "keywords": ["relativizing", "oracle", "technique", "complexity", "proof", "computation"], "source_lectures": ["lecture_106104357_w3_l16", "lecture_106104357_w3_l17"]}}
{"id": "concept_complexity_class", "type": "V_concept", "name": "Complexity Class", "properties": {"description": "A set of problems that have a certain level of computational complexity, such as P or NP.", "keywords": ["complexity", "class", "problem", "computation", "theory"], "source_lectures": ["lecture_106104357_w3_l16"]}}
{"id": "concept_diagonalization", "type": "V_concept", "name": "Diagonalization", "properties": {"description": "A technique used to prove that two complexity classes are not equal.", "keywords": ["diagonalization", "proof", "complexity", "classes"], "source_lectures": ["lecture_106104357_w3_l17"]}}
{"id": "concept_oracle_based_complexity_classes", "type": "V_concept", "name": "Oracle-Based Complexity Classes", "properties": {"description": "Complexity classes defined using oracles, such as P^O and NP^O.", "keywords": ["oracle", "complexity", "classes", "p", "np"], "source_lectures": ["lecture_106104357_w3_l17"]}}
{"id": "concept_exponential_computation", "type": "V_concept", "name": "Exponential Computation", "properties": {"description": "A computation that takes exponential time.", "keywords": ["exponential", "computation", "time"], "source_lectures": ["lecture_106104357_w3_l17"]}}
{"id": "concept_non_relativizing_proof", "type": "V_concept", "name": "Non-Relativizing Proof", "properties": {"description": "A proof that does not remain valid under any oracle.", "keywords": ["non-relativizing", "proof", "oracle", "computation"], "source_lectures": ["lecture_106104357_w3_l17"]}}
{"id": "concept_baker_gill_solovay_theorem", "type": "V_concept", "name": "Baker-Gill-Solovay Theorem", "properties": {"description": "A theorem that shows that P!=NP requires a non-relativizing proof.", "keywords": ["baker", "solovay", "gill", "p", "np", "theorem"], "source_lectures": ["lecture_106104357_w3_l17", "lecture_106104357_w3_l18"]}}
{"id": "concept_unary_language", "type": "V_concept", "name": "Unary Language", "properties": {"description": "A language that consists of strings of a single symbol.", "keywords": ["unary", "language", "symbol"], "source_lectures": ["lecture_106104357_w3_l17"]}}
{"id": "concept_p_space", "type": "V_concept", "name": "P Space", "properties": {"description": "A complexity class that represents the set of decision problems that can be solved by a deterministic Turing machine in polynomial space.", "keywords": ["space", "complexity", "turing", "problem", "p", "decision", "machine"], "source_lectures": ["lecture_106104357_w3_l18", "lecture_106104357_w4_l26"]}}
{"id": "concept_np_space", "type": "V_concept", "name": "Np Space", "properties": {"description": "A complexity class that represents the set of decision problems that can be solved by a non-deterministic Turing machine in polynomial space.", "keywords": ["space", "complexity", "turing", "nondeterministic", "np", "machine"], "source_lectures": ["lecture_106104357_w3_l18", "lecture_106104357_w3_l19"]}}
{"id": "concept_p_not_equal_to_np", "type": "V_concept", "name": "P Not Equal To Np", "properties": {"description": "A conjecture that states that the complexity classes P and NP are not equal, which implies that there are problems that are not solvable in polynomial time.", "keywords": ["p", "np", "complexity", "conjecture"], "source_lectures": ["lecture_106104357_w3_l18"]}}
{"id": "concept_non_deterministic_space", "type": "V_concept", "name": "Non-Deterministic Space", "properties": {"description": "A measure of the amount of memory used by a non-deterministic Turing machine, which is an important consideration in the study of computational complexity.", "keywords": ["non-deterministic", "space", "complexity", "turing", "machine"], "source_lectures": ["lecture_106104357_w3_l18"]}}
{"id": "concept_polynomial_space", "type": "V_concept", "name": "Polynomial Space", "properties": {"description": "A complexity class that represents the set of decision problems that can be solved by a deterministic Turing machine in polynomial space.", "keywords": ["memory", "polynomial", "space", "complexity", "turing", "machine"], "source_lectures": ["lecture_106104357_w3_l18", "lecture_106104357_w3_l19"]}}
{"id": "concept_log_space", "type": "V_concept", "name": "Log Space", "properties": {"description": "A complexity class that represents the set of decision problems that can be solved by a deterministic Turing machine in logarithmic space.", "keywords": ["memory", "space", "complexity", "turing", "log", "machine"], "source_lectures": ["lecture_106104357_w3_l18", "lecture_106104357_w3_l19"]}}
{"id": "concept_tqbf", "type": "V_concept", "name": "Tqbf", "properties": {"description": "A problem that involves determining whether a quantified Boolean formula is true, which is a P-space complete problem.", "keywords": ["tqbf", "boolean", "p-space", "quantified", "formula"], "source_lectures": ["lecture_106104357_w3_l18", "lecture_106104357_w3_l19"]}}
{"id": "concept_pspace_completeness", "type": "V_concept", "name": "Pspace Completeness", "properties": {"description": "A concept in computational complexity theory that describes a problem that is complete for the complexity class PSPACE.", "keywords": ["pspace", "completeness", "computational", "complexity"], "source_lectures": ["lecture_106104357_w3_l19"]}}
{"id": "concept_pspace_reduction", "type": "V_concept", "name": "Pspace Reduction", "properties": {"description": "A reduction from one problem to another that can be computed in polynomial space.", "keywords": ["pspace", "reduction", "polynomial", "space"], "source_lectures": ["lecture_106104357_w3_l19"]}}
{"id": "concept_cook_levin_reduction", "type": "V_concept", "name": "Cook-Levin Reduction", "properties": {"description": "A reduction from a problem to a quantified Boolean formula that can be used to show that the problem is NP-complete.", "keywords": ["cook", "levin", "reduction", "np-complete"], "source_lectures": ["lecture_106104357_w3_l19"]}}
{"id": "concept_quantifier", "type": "V_concept", "name": "Quantifier", "properties": {"description": "A logical operator that ranges over the possible assignments of values to the variables in a Boolean formula.", "keywords": ["values", "quantifier", "logical", "boolean", "operator"], "source_lectures": ["lecture_106104357_w3_l19", "lecture_106104357_w7_l46"]}}
{"id": "concept_savitchs_theorem", "type": "V_concept", "name": "Savitch's Theorem", "properties": {"description": "States that any problem solvable in non-deterministic space S can be solved in deterministic space S\u00b2, implying NSPACE(S) \u2286 DSPACE(S\u00b2).", "keywords": ["savitch", "theorem", "space", "deterministic", "non-deterministic"], "source_lectures": ["lecture_106104357_w3_l21"]}}
{"id": "concept_nl_nondeterministic_logarithmic_space", "type": "V_concept", "name": "NL (Nondeterministic Logarithmic Space)", "properties": {"description": "The complexity class of decision problems solvable by a non-deterministic Turing machine using O(log n) space.", "keywords": ["nl", "nondeterministic", "logspace", "complexity", "class"], "source_lectures": ["lecture_106104357_w3_l21"]}}
{"id": "concept_l_deterministic_logarithmic_space", "type": "V_concept", "name": "L (Deterministic Logarithmic Space)", "properties": {"description": "The complexity class of decision problems solvable by a deterministic Turing machine using O(log n) space.", "keywords": ["l", "deterministic", "logspace", "complexity", "class"], "source_lectures": ["lecture_106104357_w3_l21"]}}
{"id": "concept_configuration_graph", "type": "V_concept", "name": "Configuration Graph", "properties": {"description": "A directed graph where each vertex represents a configuration of a Turing machine on a given input, and edges represent valid single-step transitions.", "keywords": ["configuration", "graph", "turing", "machine", "transition"], "source_lectures": ["lecture_106104357_w3_l21"]}}
{"id": "concept_reachability_in_directed_graphs", "type": "V_concept", "name": "Reachability in Directed Graphs", "properties": {"description": "The problem of determining whether there exists a directed path from a source vertex to a target vertex in a directed graph.", "keywords": ["reachability", "directed", "graph", "path", "source", "target"], "source_lectures": ["lecture_106104357_w3_l21"]}}
{"id": "concept_nl_completeness", "type": "V_concept", "name": "NL-Completeness", "properties": {"description": "A problem is NL-complete if it is in NL and every problem in NL can be reduced to it via logarithmic-space reductions.", "keywords": ["completeness", "reducibility", "complexity", "nl", "logspace", "reduction", "nl-complete"], "source_lectures": ["lecture_106104357_w3_l21", "lecture_106104357_w4_l23"]}}
{"id": "concept_logarithmic_space_reduction", "type": "V_concept", "name": "Logarithmic-Space Reduction", "properties": {"description": "A reduction between two problems where the transformation function can be computed using only O(log n) space.", "keywords": ["logspace", "reduction", "complexity", "transformation", "space"], "source_lectures": ["lecture_106104357_w3_l21"]}}
{"id": "concept_implicitly_l_computable_function", "type": "V_concept", "name": "Implicitly L-Computable Function", "properties": {"description": "A function where each bit of the output can be computed in logarithmic space, given access to the input and the bit index.", "keywords": ["implicitly", "l-computable", "logspace", "function", "bit"], "source_lectures": ["lecture_106104357_w3_l21"]}}
{"id": "concept_path_problem_directed_reachability", "type": "V_concept", "name": "Path Problem (Directed Reachability)", "properties": {"description": "The problem of deciding whether there is a directed path from a source vertex to a target vertex in a directed graph, used as a canonical NL-complete problem.", "keywords": ["path", "directed", "reachability", "nl-complete", "graph"], "source_lectures": ["lecture_106104357_w3_l21"]}}
{"id": "concept_space_time_tradeoff", "type": "V_concept", "name": "Space-Time Tradeoff", "properties": {"description": "The relationship between the amount of memory (space) used and the time required to solve a computational problem, where increasing space can reduce time.", "keywords": ["space", "time", "tradeoff", "complexity", "resource"], "source_lectures": ["lecture_106104357_w3_l21"]}}
{"id": "concept_nl_p", "type": "V_concept", "name": "NL \u2286 P", "properties": {"description": "The inclusion relationship stating that every problem solvable in non-deterministic logarithmic space can also be solved in polynomial time.", "keywords": ["nl", "p", "inclusion", "complexity", "time"], "source_lectures": ["lecture_106104357_w3_l21"]}}
{"id": "concept_l_nl", "type": "V_concept", "name": "L \u2286 NL", "properties": {"description": "The inclusion relationship stating that every problem solvable in deterministic logarithmic space is also solvable in non-deterministic logarithmic space.", "keywords": ["l", "nl", "inclusion", "complexity", "space"], "source_lectures": ["lecture_106104357_w3_l21"]}}
{"id": "concept_configuration_space", "type": "V_concept", "name": "Configuration Space", "properties": {"description": "The total number of distinct states a Turing machine can be in during computation, determined by its state, tape content, and head positions.", "keywords": ["configuration", "space", "turing", "machine", "state"], "source_lectures": ["lecture_106104357_w3_l21"]}}
{"id": "concept_composition_of_log_space_functions", "type": "V_concept", "name": "Composition of Log-Space Functions", "properties": {"description": "The property that the composition of two implicitly log-space computable functions is also implicitly log-space computable.", "keywords": ["composition", "logspace", "function", "computable", "reduction"], "source_lectures": ["lecture_106104357_w3_l21"]}}
{"id": "concept_deterministic_vs_non_deterministic_space", "type": "V_concept", "name": "Deterministic vs Non-Deterministic Space", "properties": {"description": "The comparison between the power of deterministic and non-deterministic Turing machines when restricted to logarithmic space, central to the L vs NL question.", "keywords": ["deterministic", "non-deterministic", "space", "l", "nl"], "source_lectures": ["lecture_106104357_w3_l21"]}}
{"id": "concept_l_nl_question", "type": "V_concept", "name": "L = NL Question", "properties": {"description": "The open problem in complexity theory asking whether deterministic logarithmic space is as powerful as non-deterministic logarithmic space.", "keywords": ["l", "nl", "equality", "open", "problem"], "source_lectures": ["lecture_106104357_w3_l21"]}}
{"id": "concept_reduction_transitivity", "type": "V_concept", "name": "Reduction Transitivity", "properties": {"description": "The property that if problem A reduces to B and B reduces to C via log-space reductions, then A reduces to C via log-space reduction.", "keywords": ["reduction", "transitivity", "logspace", "complexity", "composition"], "source_lectures": ["lecture_106104357_w3_l21"]}}
{"id": "concept_log_space_verifiability", "type": "V_concept", "name": "Log-Space Verifiability", "properties": {"description": "The ability to verify a solution or transition in logarithmic space without storing the entire input or intermediate state.", "keywords": ["logspace", "verification", "space", "efficient", "check"], "source_lectures": ["lecture_106104357_w3_l21"]}}
{"id": "concept_polynomial_time_hierarchy_relation", "type": "V_concept", "name": "Polynomial-Time Hierarchy Relation", "properties": {"description": "The relationship that any space-bounded class like NL is contained within P due to the exponential time overhead of simulating space-bounded computation.", "keywords": ["polynomial", "time", "space", "hierarchy", "nl"], "source_lectures": ["lecture_106104357_w3_l21"]}}
{"id": "concept_conl", "type": "V_concept", "name": "CoNL", "properties": {"description": "The complement of the complexity class NL, containing problems that are at least as hard as the unreachability problem in directed graphs.", "keywords": ["conl", "complement", "nl", "unreachability"], "source_lectures": ["lecture_106104357_w4_l23"]}}
{"id": "concept_nspace", "type": "V_concept", "name": "NSpace", "properties": {"description": "A complexity class that contains problems that can be solved in nondeterministic space, where the space used is bounded by a function of the input size.", "keywords": ["nspace", "nondeterministic", "space", "complexity"], "source_lectures": ["lecture_106104357_w4_l23"]}}
{"id": "concept_conspace", "type": "V_concept", "name": "CoNSpace", "properties": {"description": "The complement of the complexity class NSpace, containing problems that are at least as hard as the complement of problems in NSpace.", "keywords": ["conspac", "complement", "nspace", "complexity"], "source_lectures": ["lecture_106104357_w4_l23"]}}
{"id": "concept_mindnf", "type": "V_concept", "name": "MinDNF", "properties": {"description": "A problem that involves finding the minimum DNF formula that is equivalent to a given Boolean formula.", "keywords": ["mindnf", "dnf", "boolean", "formula"], "source_lectures": ["lecture_106104357_w4_l23"]}}
{"id": "concept_sigma2p", "type": "V_concept", "name": "Sigma2P", "properties": {"description": "A complexity class that contains problems that can be solved in polynomial time with two quantifiers, where the first quantifier is existential and the second is universal.", "keywords": ["sigma2p", "complexity", "quantifiers", "polynomial"], "source_lectures": ["lecture_106104357_w4_l23"]}}
{"id": "concept_pi2p", "type": "V_concept", "name": "Pi2P", "properties": {"description": "A complexity class that contains problems that can be solved in polynomial time with two quantifiers, where the first quantifier is universal and the second is existential.", "keywords": ["pi2p", "complexity", "quantifiers", "polynomial"], "source_lectures": ["lecture_106104357_w4_l23"]}}
{"id": "concept_polynomial_time_verifier", "type": "V_concept", "name": "Polynomial Time Verifier", "properties": {"description": "A Turing machine that can verify a solution to a problem in polynomial time.", "keywords": ["polynomial", "time", "verifier", "turing"], "source_lectures": ["lecture_106104357_w4_l23"]}}
{"id": "concept_sigma_i", "type": "V_concept", "name": "Sigma I", "properties": {"description": "A complexity class that represents the set of decision problems that can be solved by a nondeterministic Turing machine in polynomial time with I quantifier alternations", "keywords": ["sigma", "complexity", "nondeterministic", "turing", "quantifier"], "source_lectures": ["lecture_106104357_w4_l24"]}}
{"id": "concept_pi_i", "type": "V_concept", "name": "Pi I", "properties": {"description": "A complexity class that represents the set of decision problems that can be solved by a nondeterministic Turing machine in polynomial time with I quantifier alternations, starting with a universal quantifier", "keywords": ["pi", "complexity", "nondeterministic", "turing", "quantifier"], "source_lectures": ["lecture_106104357_w4_l24"]}}
{"id": "concept_ph_conjecture", "type": "V_concept", "name": "PH Conjecture", "properties": {"description": "A conjecture that states that the polynomial hierarchy does not collapse, meaning that each level of the hierarchy is strictly contained in the next level", "keywords": ["ph", "conjecture", "polynomial", "hierarchy", "collapse"], "source_lectures": ["lecture_106104357_w4_l24"]}}
{"id": "concept_pspace", "type": "V_concept", "name": "PSPACE", "properties": {"description": "A complexity class that represents the set of decision problems that can be solved by a deterministic Turing machine in polynomial space", "keywords": ["pspace", "complexity", "deterministic", "turing", "polynomial"], "source_lectures": ["lecture_106104357_w4_l24"]}}
{"id": "concept_collapse_of_the_hierarchy", "type": "V_concept", "name": "Collapse of the Hierarchy", "properties": {"description": "A phenomenon where the polynomial hierarchy collapses to a single level, meaning that all levels of the hierarchy are equal", "keywords": ["collapse", "hierarchy", "polynomial", "ph"], "source_lectures": ["lecture_106104357_w4_l24"]}}
{"id": "concept_np", "type": "V_concept", "name": "NP", "properties": {"description": "A complexity class that represents the set of decision problems that can be solved by a nondeterministic Turing machine in polynomial time", "keywords": ["np", "complexity", "nondeterministic", "turing", "polynomial"], "source_lectures": ["lecture_106104357_w4_l24"]}}
{"id": "concept_co_np", "type": "V_concept", "name": "Co-NP", "properties": {"description": "A complexity class that represents the set of decision problems that can be solved by a nondeterministic Turing machine in polynomial time, where the machine accepts if and only if the input is not in the language", "keywords": ["co", "polynomial", "conp", "complexity", "turing", "nondeterministic", "np", "complement"], "source_lectures": ["lecture_106104357_w4_l24", "lecture_106104357_w6_l42"]}}
{"id": "concept_quantifier_alternation", "type": "V_concept", "name": "Quantifier Alternation", "properties": {"description": "A property of a formula where the quantifiers alternate between existential and universal quantifiers", "keywords": ["quantifier", "alternation", "existential", "universal"], "source_lectures": ["lecture_106104357_w4_l24"]}}
{"id": "concept_sigma_2", "type": "V_concept", "name": "Sigma 2", "properties": {"description": "A class of decision problems that can be solved by a nondeterministic Turing machine with an oracle for NP", "keywords": ["sigma", "2", "oracle", "turing", "nondeterministic", "problems", "decision", "machine"], "source_lectures": ["lecture_106104357_w4_l26", "lecture_106104357_w7_l46"]}}
{"id": "concept_np_to_the_sat", "type": "V_concept", "name": "NP To The SAT", "properties": {"description": "A decision problem that involves finding a satisfying assignment for a Boolean formula", "keywords": ["np", "sat", "boolean", "formula", "satisfying"], "source_lectures": ["lecture_106104357_w4_l26"]}}
{"id": "concept_sharp_p", "type": "V_concept", "name": "Sharp P", "properties": {"description": "A class of functions that count the number of accepting paths of a nondeterministic Turing machine", "keywords": ["sharp", "p", "function", "nondeterministic", "turing"], "source_lectures": ["lecture_106104357_w4_l26"]}}
{"id": "concept_sharp_sat", "type": "V_concept", "name": "Sharp SAT", "properties": {"description": "A function that counts the number of satisfying assignments for a Boolean formula", "keywords": ["sharp", "sat", "function", "boolean", "formula"], "source_lectures": ["lecture_106104357_w4_l26"]}}
{"id": "concept_fp", "type": "V_concept", "name": "FP", "properties": {"description": "A class of functions that can be computed in polynomial time by a deterministic Turing machine", "keywords": ["fp", "function", "polynomial", "time", "turing"], "source_lectures": ["lecture_106104357_w4_l26"]}}
{"id": "concept_permanent_of_a_matrix", "type": "V_concept", "name": "Permanent Of A Matrix", "properties": {"description": "A value calculated from a matrix, representing the sum of products of elements corresponding to permutations of rows and columns.", "keywords": ["cycle cover", "permutation", "permanent", "linear algebra", "combinatorics", "matrix"], "source_lectures": ["lecture_106104357_w4_l28", "lecture_106104357_w5_l29"]}}
{"id": "concept_symmetric_group", "type": "V_concept", "name": "Symmetric Group", "properties": {"description": "A group of permutations of a set of elements, with a size equal to the number of elements factorial.", "keywords": ["symmetric group", "permutation", "group theory"], "source_lectures": ["lecture_106104357_w4_l28"]}}
{"id": "concept_permutation_parity", "type": "V_concept", "name": "Permutation Parity", "properties": {"description": "A property of a permutation, either even or odd, used to determine the sign of the permutation in calculations such as the determinant.", "keywords": ["permutation parity", "even permutation", "odd permutation"], "source_lectures": ["lecture_106104357_w4_l28"]}}
{"id": "concept_cycle_cover_of_a_graph", "type": "V_concept", "name": "Cycle Cover Of A Graph", "properties": {"description": "A subgraph of a directed graph, consisting of disjoint cycles that cover all vertices, used to interpret the permanent of a matrix.", "keywords": ["cycle cover", "graph theory", "directed graph"], "source_lectures": ["lecture_106104357_w4_l28"]}}
{"id": "concept_weight_of_a_cycle_cover", "type": "V_concept", "name": "Weight Of A Cycle Cover", "properties": {"description": "The product of the weights of the edges in a cycle cover of a graph, used to calculate the permanent of a matrix.", "keywords": ["weight of cycle cover", "graph theory", "matrix permanent"], "source_lectures": ["lecture_106104357_w4_l28"]}}
{"id": "concept_adjacency_matrix", "type": "V_concept", "name": "Adjacency Matrix", "properties": {"description": "A matrix representing the edges and weights of a graph, used to calculate the permanent of a matrix.", "keywords": ["adjacency matrix", "graph theory", "matrix representation"], "source_lectures": ["lecture_106104357_w4_l28"]}}
{"id": "concept_directed_graph", "type": "V_concept", "name": "Directed Graph", "properties": {"description": "A graph with directed edges, used to represent the adjacency matrix of a graph and calculate the permanent of a matrix.", "keywords": ["directed graph", "graph theory", "adjacency matrix"], "source_lectures": ["lecture_106104357_w4_l28"]}}
{"id": "concept_p_complete", "type": "V_concept", "name": "#P-Complete", "properties": {"description": "A class of counting problems that are at least as hard as the hardest problems in #P, meaning every #P problem reduces to them.", "keywords": ["#p-complete", "counting complexity", "#p", "hardness", "reduction"], "source_lectures": ["lecture_106104357_w5_l29"]}}
{"id": "concept_3_cnf_formula", "type": "V_concept", "name": "3-CNF Formula", "properties": {"description": "A Boolean formula in conjunctive normal form where each clause contains exactly three literals.", "keywords": ["3-cnf", "cnf", "boolean formula", "clause", "literal"], "source_lectures": ["lecture_106104357_w5_l29"]}}
{"id": "concept_sharp_3sat", "type": "V_concept", "name": "Sharp-3SAT", "properties": {"description": "The counting problem of determining the number of satisfying assignments for a 3-CNF Boolean formula.", "keywords": ["sharp-3sat", "#3sat", "satisfying assignments", "counting", "boolean satisfiability"], "source_lectures": ["lecture_106104357_w5_l29"]}}
{"id": "concept_variable_gadget", "type": "V_concept", "name": "Variable Gadget", "properties": {"description": "A subgraph representing a Boolean variable, designed to encode truth assignments via cycle cover choices between true and false paths.", "keywords": ["variable gadget", "truth assignment", "cycle cover", "boolean variable", "graph gadget"], "source_lectures": ["lecture_106104357_w5_l29"]}}
{"id": "concept_clause_gadget", "type": "V_concept", "name": "Clause Gadget", "properties": {"description": "A subgraph representing a 3-literal clause, designed so that a cycle cover exists if and only if at least one literal is true.", "keywords": ["clause gadget", "3-literal clause", "cycle cover", "satisfiability", "graph gadget"], "source_lectures": ["lecture_106104357_w5_l29"]}}
{"id": "concept_connecting_gadget_zor_gadget", "type": "V_concept", "name": "Connecting Gadget (Zor Gadget)", "properties": {"description": "A specialized subgraph that links a variable gadget to a clause gadget, enforcing consistency between variable truth values and clause satisfaction.", "keywords": ["zor gadget", "connecting gadget", "variable-clause link", "cycle cover constraint", "graph gadget"], "source_lectures": ["lecture_106104357_w5_l29"]}}
{"id": "concept_weighted_graph_for_permanent", "type": "V_concept", "name": "Weighted Graph for Permanent", "properties": {"description": "A directed graph with weighted edges constructed so that the sum of weighted cycle covers equals the permanent of its adjacency matrix.", "keywords": ["weighted graph", "permanent", "cycle cover", "adjacency matrix", "graph construction"], "source_lectures": ["lecture_106104357_w5_l29"]}}
{"id": "concept_reduction_from_3sat_to_permanent", "type": "V_concept", "name": "Reduction from #3SAT to Permanent", "properties": {"description": "A polynomial-time transformation that encodes the number of satisfying assignments of a 3-CNF formula as the permanent of a constructed 0-1 matrix.", "keywords": ["reduction", "#3sat", "permanent", "counting reduction", "complexity"], "source_lectures": ["lecture_106104357_w5_l29"]}}
{"id": "concept_negative_edge_weight", "type": "V_concept", "name": "Negative Edge Weight", "properties": {"description": "An edge in a graph with a negative numerical weight, used to cancel out unwanted contributions in cycle cover sums.", "keywords": ["negative weight", "edge weight", "cycle cover cancellation", "graph weight", "permanent"], "source_lectures": ["lecture_106104357_w5_l29"]}}
{"id": "concept_literal_in_3_cnf", "type": "V_concept", "name": "Literal in 3-CNF", "properties": {"description": "A Boolean variable or its negation appearing in a clause of a 3-CNF formula.", "keywords": ["literal", "boolean variable", "negation", "clause", "3-cnf"], "source_lectures": ["lecture_106104357_w5_l29"]}}
{"id": "concept_truth_assignment", "type": "V_concept", "name": "Truth Assignment", "properties": {"description": "An assignment of true or false values to all variables in a Boolean formula.", "keywords": ["truth assignment", "boolean assignment", "variable value", "satisfiability", "assignment"], "source_lectures": ["lecture_106104357_w5_l29"]}}
{"id": "concept_adjacency_matrix_representation", "type": "V_concept", "name": "Adjacency Matrix Representation", "properties": {"description": "A matrix where entries indicate the presence and weight of edges between vertices in a directed graph.", "keywords": ["adjacency matrix", "graph representation", "edge weight", "directed graph", "matrix"], "source_lectures": ["lecture_106104357_w5_l29"]}}
{"id": "concept_gadget_in_computational_complexity", "type": "V_concept", "name": "Gadget in Computational Complexity", "properties": {"description": "A small, carefully designed subgraph used to simulate logical components (variables, clauses, connections) in complexity reductions.", "keywords": ["gadget", "complexity reduction", "graph construction", "logic simulation", "computational gadget"], "source_lectures": ["lecture_106104357_w5_l29"]}}
{"id": "concept_sum_of_weights_of_cycle_covers", "type": "V_concept", "name": "Sum of Weights of Cycle Covers", "properties": {"description": "The total weight computed by summing the products of edge weights over all possible cycle covers in a weighted directed graph.", "keywords": ["sum of weights", "cycle cover", "weighted graph", "permanent", "combinatorial sum"], "source_lectures": ["lecture_106104357_w5_l29"]}}
{"id": "concept_zero_contribution_gadget", "type": "V_concept", "name": "Zero Contribution Gadget", "properties": {"description": "A subgraph designed so that the sum of weights of all its cycle covers equals zero, used to eliminate unwanted computational paths.", "keywords": ["zero contribution", "gadget", "cycle cover", "cancellation", "permanent"], "source_lectures": ["lecture_106104357_w5_l29"]}}
{"id": "concept_self_loop_in_graph", "type": "V_concept", "name": "Self-Loop in Graph", "properties": {"description": "An edge that connects a vertex to itself, often used in graph gadgets to represent inactive or default states.", "keywords": ["self-loop", "vertex loop", "graph edge", "default state", "cycle cover"], "source_lectures": ["lecture_106104357_w5_l29"]}}
{"id": "concept_external_edge_in_gadget", "type": "V_concept", "name": "External Edge in Gadget", "properties": {"description": "An edge in a graph gadget that connects to other gadgets, enabling communication of truth values or constraints between components.", "keywords": ["external edge", "gadget connection", "inter-gadget link", "cycle cover interface", "graph gadget"], "source_lectures": ["lecture_106104357_w5_l29"]}}
{"id": "concept_graph_reduction_for_p_hardness", "type": "V_concept", "name": "Graph Reduction for #P-Hardness", "properties": {"description": "A method of constructing a graph whose combinatorial properties (e.g., permanent) encode the solution count of a known #P-hard problem.", "keywords": ["graph reduction", "#p-hardness", "permanent", "complexity reduction", "counting problem"], "source_lectures": ["lecture_106104357_w5_l29"]}}
{"id": "concept_literal_variable_consistency", "type": "V_concept", "name": "Literal-Variable Consistency", "properties": {"description": "The requirement that the truth value assigned to a variable must match the truth value implied by its occurrence (positive or negative) in clauses.", "keywords": ["literal consistency", "variable truth", "clause satisfaction", "boolean logic", "gadget connection"], "source_lectures": ["lecture_106104357_w5_l29"]}}
{"id": "concept_cycle_cover_weight_product", "type": "V_concept", "name": "Cycle Cover Weight Product", "properties": {"description": "The product of the weights of all edges in a single cycle cover, used as a term in the sum defining the permanent.", "keywords": ["cycle cover weight", "weight product", "permanent term", "edge product", "combinatorial weight"], "source_lectures": ["lecture_106104357_w5_l29"]}}
{"id": "concept_permanent_as_counting_function", "type": "V_concept", "name": "Permanent as Counting Function", "properties": {"description": "The interpretation of the matrix permanent as counting the number of weighted cycle covers in a directed graph.", "keywords": ["permanent", "counting function", "cycle cover", "graph enumeration", "combinatorics"], "source_lectures": ["lecture_106104357_w5_l29"]}}
{"id": "concept_unmarked_edge_weight_convention", "type": "V_concept", "name": "Unmarked Edge Weight Convention", "properties": {"description": "The assumption in graph gadgets that edges without explicitly labeled weights have a weight of one.", "keywords": ["unmarked edge", "weight convention", "graph gadget", "default weight", "edge weight"], "source_lectures": ["lecture_106104357_w5_l29"]}}
{"id": "concept_clause_satisfaction_via_cycle_cover", "type": "V_concept", "name": "Clause Satisfaction via Cycle Cover", "properties": {"description": "The property that a clause gadget admits a cycle cover if and only if at least one of its literals is set to true.", "keywords": ["clause satisfaction", "cycle cover", "gadget", "literal true", "boolean logic"], "source_lectures": ["lecture_106104357_w5_l29"]}}
{"id": "concept_variable_gadget_truth_encoding", "type": "V_concept", "name": "Variable Gadget Truth Encoding", "properties": {"description": "The mechanism by which a variable gadget\u2019s cycle cover selects either the 'true' or 'false' path to represent the variable\u2019s assignment.", "keywords": ["variable encoding", "truth encoding", "gadget", "cycle cover", "boolean variable"], "source_lectures": ["lecture_106104357_w5_l29"]}}
{"id": "concept_zor_gadget_zero_sum_property", "type": "V_concept", "name": "Zor Gadget Zero-Sum Property", "properties": {"description": "The design feature of the Zor gadget such that the total weight of all its cycle covers equals zero, ensuring no extraneous contribution to the permanent.", "keywords": ["zor gadget", "zero-sum", "cycle cover", "gadget property", "permanent cancellation"], "source_lectures": ["lecture_106104357_w5_l29"]}}
{"id": "concept_graph_gadget_composition", "type": "V_concept", "name": "Graph Gadget Composition", "properties": {"description": "The process of assembling variable, clause, and connecting gadgets into a single graph to model a logical formula\u2019s structure.", "keywords": ["gadget composition", "graph assembly", "complexity reduction", "gadget network", "formula encoding"], "source_lectures": ["lecture_106104357_w5_l29"]}}
{"id": "concept_permanent_of_0_1_matrix", "type": "V_concept", "name": "Permanent of 0-1 Matrix", "properties": {"description": "The permanent of a matrix whose entries are only 0 or 1, which counts the number of cycle covers in the corresponding directed graph.", "keywords": ["permanent", "0-1 matrix", "binary matrix", "cycle cover count", "combinatorics"], "source_lectures": ["lecture_106104357_w5_l29"]}}
{"id": "concept_reduction_in_computational_complexity", "type": "V_concept", "name": "Reduction in Computational Complexity", "properties": {"description": "A transformation from one computational problem to another, preserving solution structure to prove hardness or equivalence.", "keywords": ["reduction", "complexity", "hardness", "problem transformation", "polynomial-time"], "source_lectures": ["lecture_106104357_w5_l29"]}}
{"id": "concept_parity_sat", "type": "V_concept", "name": "Parity-SAT", "properties": {"description": "A computational problem where the goal is to determine whether the number of satisfying assignments to a Boolean formula is odd.", "keywords": ["parity-sat", "satisfiability", "odd count", "boolean formula", "counting"], "source_lectures": ["lecture_106104357_w5_l32"]}}
{"id": "concept_unique_sat", "type": "V_concept", "name": "Unique-SAT", "properties": {"description": "The decision problem of determining whether a Boolean formula has exactly one satisfying assignment.", "keywords": ["unique-sat", "satisfiability", "one solution", "boolean formula", "counting"], "source_lectures": ["lecture_106104357_w5_l32"]}}
{"id": "concept_hash_function_bucketing", "type": "V_concept", "name": "Hash Function Bucketing", "properties": {"description": "The process of mapping input values to discrete buckets using a hash function, often used to partition solution spaces in randomized algorithms.", "keywords": ["hash function", "bucketing", "partition", "mapping", "randomized"], "source_lectures": ["lecture_106104357_w5_l32"]}}
{"id": "concept_parity_quantifier", "type": "V_concept", "name": "Parity Quantifier", "properties": {"description": "A quantifier in logic that asserts the number of assignments satisfying a formula is odd, denoted as 'parity x \u03c6(x)'.", "keywords": ["parity quantifier", "quantifier", "odd count", "boolean logic", "alternation"], "source_lectures": ["lecture_106104357_w5_l32"]}}
{"id": "concept_probability_of_singleton_bucket", "type": "V_concept", "name": "Probability of Singleton Bucket", "properties": {"description": "The probability that exactly one element from a set maps to a specific bucket under a random universal hash function, a key component in Valiant-Vazirani reduction.", "keywords": ["singleton bucket", "hash probability", "universal hashing", "valiant-vazirani", "randomized"], "source_lectures": ["lecture_106104357_w5_l32"]}}
{"id": "concept_satisfying_assignment_count", "type": "V_concept", "name": "Satisfying Assignment Count", "properties": {"description": "The total number of variable assignments that make a Boolean formula evaluate to true.", "keywords": ["satisfying assignment", "count", "boolean formula", "sat", "solution"], "source_lectures": ["lecture_106104357_w5_l32"]}}
{"id": "concept_modulo_2_linear_equation", "type": "V_concept", "name": "Modulo-2 Linear Equation", "properties": {"description": "A Boolean equation formed by XORing variables with coefficients in {0,1}, equivalent to a linear equation over GF(2).", "keywords": ["modulo-2", "linear equation", "gf(2)", "xor", "boolean algebra"], "source_lectures": ["lecture_106104357_w5_l32"]}}
{"id": "concept_alternating_quantifiers", "type": "V_concept", "name": "Alternating Quantifiers", "properties": {"description": "A sequence of existential and universal quantifiers in a logical formula that define the structure of problems in the polynomial hierarchy.", "keywords": ["alternating quantifiers", "quantifier alternation", "ph", "logic", "complexity"], "source_lectures": ["lecture_106104357_w5_l32"]}}
{"id": "concept_polynomial_time_randomized_algorithm", "type": "V_concept", "name": "Polynomial-Time Randomized Algorithm", "properties": {"description": "An algorithm that runs in polynomial time and uses randomness to achieve a correct output with high probability.", "keywords": ["randomized algorithm", "polynomial time", "probabilistic", "complexity", "bpp"], "source_lectures": ["lecture_106104357_w5_l32"]}}
{"id": "concept_lower_bound_on_probability", "type": "V_concept", "name": "Lower Bound on Probability", "properties": {"description": "A mathematical guarantee that the probability of an event is at least a certain value, often derived using inequalities or combinatorial bounds.", "keywords": ["lower bound", "probability", "inequality", "bound", "analysis"], "source_lectures": ["lecture_106104357_w5_l32"]}}
{"id": "concept_function_x_x\u00b2_increasing_on_0_05", "type": "V_concept", "name": "Function x - x\u00b2 Increasing on [0, 0.5]", "properties": {"description": "The mathematical property that the function f(x) = x - x\u00b2 is strictly increasing for x in the interval [0, 0.5], used to derive probability bounds.", "keywords": ["x - x\u00b2", "increasing function", "probability bound", "inequality", "calculus"], "source_lectures": ["lecture_106104357_w5_l32"]}}
{"id": "concept_probability_of_collision_under_hashing", "type": "V_concept", "name": "Probability of Collision Under Hashing", "properties": {"description": "The probability that two distinct inputs are mapped to the same output by a randomly chosen hash function from a universal family.", "keywords": ["hash collision", "probability", "universal hashing", "collision", "randomized"], "source_lectures": ["lecture_106104357_w5_l32"]}}
{"id": "concept_random_variable_for_count_of_satisfying_assignments", "type": "V_concept", "name": "Random Variable for Count of Satisfying Assignments", "properties": {"description": "A random variable defined as the number of inputs satisfying a Boolean formula under a randomly chosen hash function.", "keywords": ["random variable", "satisfying assignment", "count", "hashing", "probability"], "source_lectures": ["lecture_106104357_w5_l32"]}}
{"id": "concept_np_to_parity_sat_reduction", "type": "V_concept", "name": "NP to Parity-SAT Reduction", "properties": {"description": "A randomized polynomial-time reduction showing that SAT can be transformed into Parity-SAT, implying NP \u2286 RP^Parity-SAT.", "keywords": ["np to parity-sat", "reduction", "complexity", "randomized", "parity"], "source_lectures": ["lecture_106104357_w5_l32"]}}
{"id": "concept_parity_of_satisfying_assignments", "type": "V_concept", "name": "Parity of Satisfying Assignments", "properties": {"description": "The property of a Boolean formula indicating whether the total number of satisfying assignments is odd or even.", "keywords": ["parity", "satisfying assignments", "odd", "even", "boolean"], "source_lectures": ["lecture_106104357_w5_l32"]}}
{"id": "concept_rp_complexity_class", "type": "V_concept", "name": "RP Complexity Class", "properties": {"description": "A complexity class that represents problems solvable by a probabilistic Turing machine in polynomial time with one-sided error.", "keywords": ["rp", "complexity", "class", "probabilistic", "polynomial"], "source_lectures": ["lecture_106104357_w6_l37"]}}
{"id": "concept_co_rp_complexity_class", "type": "V_concept", "name": "Co-RP Complexity Class", "properties": {"description": "A complexity class that represents problems whose complement is solvable by a probabilistic Turing machine in polynomial time with one-sided error.", "keywords": ["co-rp", "complexity", "class", "probabilistic", "polynomial"], "source_lectures": ["lecture_106104357_w6_l37"]}}
{"id": "concept_zpp_complexity_class", "type": "V_concept", "name": "ZPP Complexity Class", "properties": {"description": "A complexity class that represents problems solvable by a probabilistic Turing machine in expected polynomial time with zero error.", "keywords": ["zpp", "complexity", "class", "probabilistic", "expected"], "source_lectures": ["lecture_106104357_w6_l37"]}}
{"id": "concept_las_vegas_algorithm", "type": "V_concept", "name": "Las Vegas Algorithm", "properties": {"description": "A type of randomized algorithm that always produces the correct result, but may have variable running time.", "keywords": ["las", "vegas", "algorithm", "randomized", "variable"], "source_lectures": ["lecture_106104357_w6_l37"]}}
{"id": "concept_monte_carlo_algorithm", "type": "V_concept", "name": "Monte Carlo Algorithm", "properties": {"description": "A type of randomized algorithm that may produce incorrect results, but always has a bounded running time.", "keywords": ["monte", "carlo", "algorithm", "randomized", "bounded"], "source_lectures": ["lecture_106104357_w6_l37"]}}
{"id": "concept_polynomial_identity_testing", "type": "V_concept", "name": "Polynomial Identity Testing", "properties": {"description": "The problem of determining whether a given polynomial is identically zero.", "keywords": ["polynomial", "identity", "testing", "problem", "zero"], "source_lectures": ["lecture_106104357_w6_l37"]}}
{"id": "concept_np_hard", "type": "V_concept", "name": "NP-hard", "properties": {"description": "A class of problems that are at least as hard as the hardest problems in NP, meaning they cannot be solved in polynomial time.", "keywords": ["np", "hard", "complexity", "polynomial"], "source_lectures": ["lecture_106104357_w6_l42"]}}
{"id": "concept_bp_dot_np", "type": "V_concept", "name": "BP Dot NP", "properties": {"description": "A complexity class that represents the set of decision problems solvable by a probabilistic Turing machine in polynomial time with access to an NP oracle.", "keywords": ["bp", "np", "complexity", "probabilistic"], "source_lectures": ["lecture_106104357_w6_l42"]}}
{"id": "concept_chernov_bound", "type": "V_concept", "name": "Chernov Bound", "properties": {"description": "A mathematical bound used to estimate the probability of a random variable deviating from its expected value.", "keywords": ["chernov", "bound", "probability", "random"], "source_lectures": ["lecture_106104357_w6_l42"]}}
{"id": "concept_randomized_poly_time_reduction", "type": "V_concept", "name": "Randomized Poly Time Reduction", "properties": {"description": "A reduction from one problem to another that uses randomness and runs in polynomial time.", "keywords": ["randomized", "poly", "time", "reduction"], "source_lectures": ["lecture_106104357_w6_l42"]}}
{"id": "concept_sigma_2_sat", "type": "V_concept", "name": "Sigma 2 Sat", "properties": {"description": "A class of decision problems that can be expressed as a Boolean satisfiability problem with two alternating quantifiers.", "keywords": ["sigma", "sat", "quantifier", "boolean"], "source_lectures": ["lecture_106104357_w6_l42"]}}
{"id": "concept_pi_2_sat", "type": "V_concept", "name": "Pi 2 Sat", "properties": {"description": "A class of decision problems that can be expressed as a Boolean satisfiability problem with two alternating quantifiers, starting with a universal quantifier.", "keywords": ["pi", "sat", "quantifier", "boolean"], "source_lectures": ["lecture_106104357_w6_l42"]}}
{"id": "concept_bpp", "type": "V_concept", "name": "BPP", "properties": {"description": "A complexity class that represents the set of decision problems solvable by a probabilistic Turing machine in polynomial time.", "keywords": ["bpp", "complexity", "probabilistic", "polynomial"], "source_lectures": ["lecture_106104357_w6_l42"]}}
{"id": "concept_graph_non_isomorphism", "type": "V_concept", "name": "Graph Non-isomorphism", "properties": {"description": "A problem of determining whether two given graphs are not isomorphic, meaning they do not have the same structure and vertices.", "keywords": ["graph", "non-isomorphism", "structure", "vertices"], "source_lectures": ["lecture_106104357_w6_l42"]}}
{"id": "concept_polynomial_size_circuits", "type": "V_concept", "name": "Polynomial Size Circuits", "properties": {"description": "Circuits with a size that grows polynomially with the input size.", "keywords": ["polynomial", "size", "circuits", "input"], "source_lectures": ["lecture_106104357_w7_l46"]}}
{"id": "concept_exptime", "type": "V_concept", "name": "EXPTIME", "properties": {"description": "The class of decision problems that can be solved in exponential time by a deterministic Turing machine.", "keywords": ["exptime", "decision", "problems", "turing"], "source_lectures": ["lecture_106104357_w7_l46"]}}
{"id": "concept_karp_reduction", "type": "V_concept", "name": "Karp Reduction", "properties": {"description": "A reduction from one problem to another that preserves the solution.", "keywords": ["karp", "reduction", "problem", "solution"], "source_lectures": ["lecture_106104357_w7_l46"]}}
{"id": "concept_parallel_computation", "type": "V_concept", "name": "Parallel Computation", "properties": {"description": "A model of computation that uses multiple processors to solve a problem simultaneously.", "keywords": ["parallel", "computation", "processors", "problem"], "source_lectures": ["lecture_106104357_w7_l46"]}}
{"id": "concept_polylog_time", "type": "V_concept", "name": "Polylog Time", "properties": {"description": "A time complexity that grows polynomially with the logarithm of the input size.", "keywords": ["polylog", "time", "complexity", "input"], "source_lectures": ["lecture_106104357_w7_l46"]}}
{"id": "concept_ph_collapse", "type": "V_concept", "name": "PH Collapse", "properties": {"description": "The phenomenon where the polynomial hierarchy collapses to a lower level.", "keywords": ["ph", "collapse", "polynomial", "hierarchy"], "source_lectures": ["lecture_106104357_w7_l46"]}}
{"id": "concept_binomial_random_variable", "type": "V_concept", "name": "Binomial Random Variable", "properties": {"description": "A discrete random variable that represents the number of successes in a fixed number of independent trials, each with a constant probability of success.", "keywords": ["binomial", "random", "variable", "trials", "success"], "source_lectures": ["lecture_106104233_w2_l11"]}}
{"id": "concept_geometric_random_variable", "type": "V_concept", "name": "Geometric Random Variable", "properties": {"description": "A discrete random variable that represents the number of trials until the first success, often used to model the number of coin tosses until the first head.", "keywords": ["geometric", "random", "variable", "trials", "success"], "source_lectures": ["lecture_106104233_w2_l11"]}}
{"id": "concept_negative_binomial_random_variable", "type": "V_concept", "name": "Negative Binomial Random Variable", "properties": {"description": "A discrete random variable that represents the number of trials until a specified number of successes, often used to model the number of coin tosses until a certain number of heads.", "keywords": ["negative", "binomial", "random", "variable", "trials"], "source_lectures": ["lecture_106104233_w2_l11"]}}
{"id": "concept_expectation_of_a_random_variable", "type": "V_concept", "name": "Expectation Of A Random Variable", "properties": {"description": "A measure of the central tendency of a random variable, often denoted as E(X) or \u03bc.", "keywords": ["expectation", "random", "variable", "central", "tendency"], "source_lectures": ["lecture_106104233_w2_l11"]}}
{"id": "concept_buffons_needle_problem", "type": "V_concept", "name": "Buffon's Needle Problem", "properties": {"description": "A problem in geometric probability that involves dropping a needle on a floor with parallel lines to determine the probability of intersection.", "keywords": ["buffon", "needle", "probability", "geometric", "intersection"], "source_lectures": ["lecture_106104233_w2_l13"]}}
{"id": "concept_equality_checking_protocol", "type": "V_concept", "name": "Equality Checking Protocol", "properties": {"description": "A protocol used to determine whether two files are identical without transmitting the entire files.", "keywords": ["equality", "checking", "protocol", "file", "transmission"], "source_lectures": ["lecture_106104233_w2_l13"]}}
{"id": "concept_prime_number_theorem", "type": "V_concept", "name": "Prime Number Theorem", "properties": {"description": "A theorem that describes the distribution of prime numbers among the positive integers.", "keywords": ["prime", "number", "theorem", "distribution", "integer"], "source_lectures": ["lecture_106104233_w2_l13"]}}
{"id": "concept_poisson_random_variable", "type": "V_concept", "name": "Poisson Random Variable", "properties": {"description": "A discrete random variable that models the number of events occurring in a fixed interval of time or space.", "keywords": ["poisson", "random", "variable", "discrete", "event"], "source_lectures": ["lecture_106104233_w2_l13"]}}
{"id": "concept_poisson_distribution", "type": "V_concept", "name": "Poisson Distribution", "properties": {"description": "A probability distribution that models the number of events occurring in a fixed interval of time or space.", "keywords": ["poisson", "distribution", "probability", "event", "interval"], "source_lectures": ["lecture_106104233_w2_l13"]}}
{"id": "concept_bernoulli_trial", "type": "V_concept", "name": "Bernoulli Trial", "properties": {"description": "A random experiment with two possible outcomes, often used to model binary events.", "keywords": ["bernoulli", "trial", "random", "experiment", "binary"], "source_lectures": ["lecture_106104233_w2_l13"]}}
{"id": "concept_chebyshev_inequality", "type": "V_concept", "name": "Chebyshev Inequality", "properties": {"description": "A mathematical statement that describes the probability of a random variable deviating from its mean by more than a certain amount.", "keywords": ["inequality", "random variable", "chebyshev", "random", "probability", "variable"], "source_lectures": ["lecture_106104233_w3_l15", "lecture_106104233_w5_l32"]}}
{"id": "concept_markov_inequality", "type": "V_concept", "name": "Markov Inequality", "properties": {"description": "A mathematical statement that provides an upper bound on the probability of a random variable exceeding a certain threshold.", "keywords": ["inequality", "markov", "random variable", "random", "variable", "probability"], "source_lectures": ["lecture_106104233_w3_l15", "lecture_106104233_w5_l32"]}}
{"id": "concept_weak_linearity_of_expectation", "type": "V_concept", "name": "Weak Linearity of Expectation", "properties": {"description": "A property of expectation that states the expectation of the sum of random variables is the sum of their individual expectations, under certain conditions.", "keywords": ["weak linearity", "expectation", "random variables"], "source_lectures": ["lecture_106104233_w3_l15"]}}
{"id": "concept_weak_law_of_large_numbers", "type": "V_concept", "name": "Weak Law of Large Numbers", "properties": {"description": "A theorem that states the average of a large number of independent and identically distributed random variables will be close to the population mean with high probability.", "keywords": ["weak law of large numbers", "random variables", "population mean"], "source_lectures": ["lecture_106104233_w3_l15"]}}
{"id": "concept_chernoff_inequality", "type": "V_concept", "name": "Chernoff Inequality", "properties": {"description": "A mathematical statement that provides an upper bound on the probability of a sum of random variables deviating from its mean by more than a certain amount.", "keywords": ["chernoff inequality", "random variables", "probability"], "source_lectures": ["lecture_106104233_w3_l15"]}}
{"id": "concept_mutual_independence", "type": "V_concept", "name": "Mutual Independence", "properties": {"description": "A property of random variables that states any subset of the variables is independent of any other subset.", "keywords": ["mutual independence", "random variables", "independence"], "source_lectures": ["lecture_106104233_w3_l15"]}}
{"id": "concept_chernoff_bound", "type": "V_concept", "name": "Chernoff Bound", "properties": {"description": "A concentration inequality that provides exponentially decaying bounds on the probability that the sum of independent random variables deviates from its expected value.", "keywords": ["chernoff", "bound", "concentration", "inequality", "exponential decay"], "source_lectures": ["lecture_106104233_w3_l17"]}}
{"id": "concept_probability_boosting", "type": "V_concept", "name": "Probability Boosting", "properties": {"description": "A technique to reduce the error probability of a randomized algorithm by repeating it independently and taking a majority vote.", "keywords": ["probability", "boosting", "error reduction", "majority vote", "repetition"], "source_lectures": ["lecture_106104233_w3_l17"]}}
{"id": "concept_majority_vote_algorithm", "type": "V_concept", "name": "Majority Vote Algorithm", "properties": {"description": "A decision rule that outputs the most frequent result among multiple independent trials of a randomized algorithm.", "keywords": ["majority vote", "decision rule", "randomized algorithm", "repetition", "error reduction"], "source_lectures": ["lecture_106104233_w3_l17"]}}
{"id": "concept_stirlings_approximation", "type": "V_concept", "name": "Stirling's Approximation", "properties": {"description": "An asymptotic formula for estimating factorials, given by n! \u2248 \u221a(2\u03c0n) (n/e)^n.", "keywords": ["stirling", "approximation", "factorial", "asymptotic", "n!"], "source_lectures": ["lecture_106104233_w3_l17"]}}
{"id": "concept_max_load_in_hashing", "type": "V_concept", "name": "Max Load in Hashing", "properties": {"description": "The maximum number of clients or items assigned to any single server in a random assignment model.", "keywords": ["max load", "hashing", "server load", "random assignment", "balancing"], "source_lectures": ["lecture_106104233_w3_l17"]}}
{"id": "concept_stochastic_process", "type": "V_concept", "name": "Stochastic Process", "properties": {"description": "A collection of random variables indexed by time or another parameter, modeling sequences of dependent experiments.", "keywords": ["stochastic process", "random variables", "time index", "dependence", "sequence"], "source_lectures": ["lecture_106104233_w3_l17"]}}
{"id": "concept_state_space", "type": "V_concept", "name": "State Space", "properties": {"description": "The set of all possible values that a random variable in a stochastic process can take.", "keywords": ["values", "state", "space", "range", "markov", "chain", "state space", "random variable", "stochastic process"], "source_lectures": ["lecture_106104233_w3_l17", "lecture_106104233_w3_l18"]}}
{"id": "concept_conditional_probability_in_stochastic_processes", "type": "V_concept", "name": "Conditional Probability in Stochastic Processes", "properties": {"description": "The probability of a future state in a stochastic process given the history of previous states, reflecting temporal dependence.", "keywords": ["conditional probability", "stochastic process", "dependence", "history", "time"], "source_lectures": ["lecture_106104233_w3_l17"]}}
{"id": "concept_load_balancing_via_randomization", "type": "V_concept", "name": "Load Balancing via Randomization", "properties": {"description": "A strategy to distribute workload evenly across servers by assigning clients randomly, reducing maximum load significantly.", "keywords": ["load balancing", "randomization", "server distribution", "random assignment", "max load"], "source_lectures": ["lecture_106104233_w3_l17"]}}
{"id": "concept_binomial_probability_estimation", "type": "V_concept", "name": "Binomial Probability Estimation", "properties": {"description": "The calculation of the probability that a binomial random variable takes a specific value, often bounded using combinatorial estimates.", "keywords": ["binomial", "probability", "estimation", "n choose k", "combinatorial bound"], "source_lectures": ["lecture_106104233_w3_l17"]}}
{"id": "concept_exponential_decay_of_error_probability", "type": "V_concept", "name": "Exponential Decay of Error Probability", "properties": {"description": "The phenomenon where the error probability of an algorithm decreases exponentially with the number of independent repetitions.", "keywords": ["exponential decay", "error probability", "repetition", "concentration", "randomized algorithm"], "source_lectures": ["lecture_106104233_w3_l17"]}}
{"id": "concept_index_set_in_stochastic_processes", "type": "V_concept", "name": "Index Set in Stochastic Processes", "properties": {"description": "The set of indices (often representing time) that parameterize the sequence of random variables in a stochastic process.", "keywords": ["index set", "stochastic process", "time index", "parameter", "sequence"], "source_lectures": ["lecture_106104233_w3_l17"]}}
{"id": "concept_chebyshevs_inequality", "type": "V_concept", "name": "Chebyshev's Inequality", "properties": {"description": "An inequality that bounds the probability that a random variable deviates from its mean by more than a specified amount, using variance.", "keywords": ["chebyshev", "inequality", "variance", "deviation", "mean"], "source_lectures": ["lecture_106104233_w3_l17"]}}
{"id": "concept_independent_trials", "type": "V_concept", "name": "Independent Trials", "properties": {"description": "A sequence of random experiments where the outcome of one does not affect the outcomes of others.", "keywords": ["independent trials", "independence", "random experiments", "repetition", "no dependence"], "source_lectures": ["lecture_106104233_w3_l17"]}}
{"id": "concept_expected_load", "type": "V_concept", "name": "Expected Load", "properties": {"description": "The average number of clients assigned to a server under a random assignment model.", "keywords": ["expected load", "server load", "average", "random assignment", "expectation"], "source_lectures": ["lecture_106104233_w3_l17"]}}
{"id": "concept_logarithmic_load_bound", "type": "V_concept", "name": "Logarithmic Load Bound", "properties": {"description": "A bound on the maximum server load in a random assignment model that grows logarithmically with the number of clients.", "keywords": ["logarithmic load", "max load", "random assignment", "log n", "server balancing"], "source_lectures": ["lecture_106104233_w3_l17"]}}
{"id": "concept_sample_space_in_probability", "type": "V_concept", "name": "Sample Space in Probability", "properties": {"description": "The set of all possible outcomes of a random experiment.", "keywords": ["sample space", "outcome", "probability", "event space", "universe"], "source_lectures": ["lecture_106104233_w3_l17"]}}
{"id": "concept_partition_formula_in_probability", "type": "V_concept", "name": "Partition Formula in Probability", "properties": {"description": "A method to compute the probability of an event by summing probabilities of mutually exclusive and exhaustive sub-events.", "keywords": ["partition formula", "probability", "mutually exclusive", "exhaustive", "sum"], "source_lectures": ["lecture_106104233_w3_l17"]}}
{"id": "concept_concentration_inequality", "type": "V_concept", "name": "Concentration Inequality", "properties": {"description": "An inequality that quantifies how a random variable concentrates around its mean, such as Markov, Chebyshev, or Chernoff bounds.", "keywords": ["inequality", "deviation", "concentration", "bound", "random variable", "mean", "probability", "concentration inequality", "random", "variable"], "source_lectures": ["lecture_106104233_w3_l17", "lecture_106104233_w5_l31", "lecture_106104233_w5_l32"]}}
{"id": "concept_server_client_load_model", "type": "V_concept", "name": "Server-Client Load Model", "properties": {"description": "A probabilistic model where n clients randomly assign themselves to n servers to study distribution and maximum load.", "keywords": ["server-client", "load model", "random assignment", "distribution", "max load"], "source_lectures": ["lecture_106104233_w3_l17"]}}
{"id": "concept_factorial_growth_estimation", "type": "V_concept", "name": "Factorial Growth Estimation", "properties": {"description": "The analysis of how rapidly factorial functions grow, often approximated using Stirling\u2019s formula for asymptotic bounds.", "keywords": ["factorial growth", "stirling", "asymptotic", "combinatorics", "estimation"], "source_lectures": ["lecture_106104233_w3_l17"]}}
{"id": "concept_high_probability_bound", "type": "V_concept", "name": "High Probability Bound", "properties": {"description": "A probabilistic guarantee that an event occurs with probability at least 1 - 1/poly(n), often used in algorithm analysis.", "keywords": ["high probability", "bound", "poly(n)", "probabilistic guarantee", "negligible error"], "source_lectures": ["lecture_106104233_w3_l17"]}}
{"id": "concept_continuous_stochastic_process", "type": "V_concept", "name": "Continuous Stochastic Process", "properties": {"description": "A stochastic process where the state space is continuous, such as stock prices evolving over time.", "keywords": ["continuous", "stochastic process", "state space", "time evolution", "stock price"], "source_lectures": ["lecture_106104233_w3_l17"]}}
{"id": "concept_discrete_stochastic_process", "type": "V_concept", "name": "Discrete Stochastic Process", "properties": {"description": "A stochastic process where the state space is discrete, such as coin tosses repeated over time.", "keywords": ["discrete", "stochastic process", "state space", "coin toss", "time series"], "source_lectures": ["lecture_106104233_w3_l17"]}}
{"id": "concept_markov_chain", "type": "V_concept", "name": "Markov Chain", "properties": {"description": "A mathematical system that undergoes transitions from one state to another according to certain probabilistic rules.", "keywords": ["transition", "process", "state", "markov", "stochastic", "chain", "probability"], "source_lectures": ["lecture_106104233_w3_l18", "lecture_106104233_w3_l19", "lecture_106104233_w4_l22"]}}
{"id": "concept_independence", "type": "V_concept", "name": "Independence", "properties": {"description": "A property of random variables where the occurrence of one event does not affect the probability of another event.", "keywords": ["independence", "variables", "random", "probability"], "source_lectures": ["lecture_106104233_w3_l18", "lecture_106104233_w5_l29"]}}
{"id": "concept_homogeneous_markov_chain", "type": "V_concept", "name": "Homogeneous Markov Chain", "properties": {"description": "A Markov chain where the transition probabilities do not depend on time.", "keywords": ["transition", "homogeneous", "markov", "stochastic", "chain"], "source_lectures": ["lecture_106104233_w3_l18", "lecture_106104233_w3_l19"]}}
{"id": "concept_transition_matrix", "type": "V_concept", "name": "Transition Matrix", "properties": {"description": "A matrix that represents the transition probabilities of a Markov chain.", "keywords": ["transition", "markov", "chain", "probability", "matrix"], "source_lectures": ["lecture_106104233_w3_l18", "lecture_106104233_w3_l19", "lecture_106104233_w4_l22"]}}
{"id": "concept_stochastic_matrix", "type": "V_concept", "name": "Stochastic Matrix", "properties": {"description": "A square matrix with non-negative entries where each row sums to one.", "keywords": ["non-negative", "row", "markov", "stochastic", "chain", "probability", "matrix"], "source_lectures": ["lecture_106104233_w3_l18", "lecture_106104233_w3_l19", "lecture_106104233_w4_l22"]}}
{"id": "concept_initial_distribution", "type": "V_concept", "name": "Initial Distribution", "properties": {"description": "A probability distribution that specifies the starting state of a Markov chain.", "keywords": ["distribution", "initial", "chain", "markov"], "source_lectures": ["lecture_106104233_w3_l18", "lecture_106104233_w3_l19"]}}
{"id": "concept_independent_identically_distributed", "type": "V_concept", "name": "Independent Identically Distributed", "properties": {"description": "A property of random variables where each variable is independent and has the same probability distribution.", "keywords": ["independent", "identically", "distributed", "random"], "source_lectures": ["lecture_106104233_w3_l18"]}}
{"id": "concept_drunkards_walk", "type": "V_concept", "name": "Drunkard's Walk", "properties": {"description": "A random walk model where an individual moves randomly in one or more dimensions, often used to illustrate Markov chain concepts.", "keywords": ["drunkard", "walk", "random", "markov"], "source_lectures": ["lecture_106104233_w3_l19"]}}
{"id": "concept_random_walk", "type": "V_concept", "name": "Random Walk", "properties": {"description": "A mathematical model where an individual moves randomly in a sequence of steps, often used to model stochastic processes.", "keywords": ["graph", "lattice", "process", "stochastic", "random", "walk"], "source_lectures": ["lecture_106104233_w3_l19", "lecture_106104233_w4_l22"]}}
{"id": "concept_stationary_distribution", "type": "V_concept", "name": "Stationary Distribution", "properties": {"description": "A probability distribution that does not change over time in a Markov chain, often representing the long-term behavior of the chain.", "keywords": ["distribution", "markov", "chain", "probability", "stationary"], "source_lectures": ["lecture_106104233_w3_l19", "lecture_106104233_w4_l22"]}}
{"id": "concept_limit_of_a_markov_chain", "type": "V_concept", "name": "Limit of a Markov Chain", "properties": {"description": "The behavior of a Markov chain as the number of steps approaches infinity, often representing the long-term behavior of the chain.", "keywords": ["limit", "markov", "chain", "long-term"], "source_lectures": ["lecture_106104233_w3_l19"]}}
{"id": "concept_page_rank_algorithm", "type": "V_concept", "name": "Page Rank Algorithm", "properties": {"description": "A link analysis algorithm used to rank web pages in order of importance, based on the probability of a random surfer visiting a page.", "keywords": ["page", "rank", "algorithm", "web", "importance"], "source_lectures": ["lecture_106104233_w4_l22"]}}
{"id": "concept_ergodic_markov_chain", "type": "V_concept", "name": "Ergodic Markov Chain", "properties": {"description": "A Markov chain that has a stationary distribution, and for which the probability of transitioning from any state to any other state is positive after some number of steps.", "keywords": ["ergodic", "markov", "chain", "stationary", "distribution"], "source_lectures": ["lecture_106104233_w4_l22"]}}
{"id": "concept_regular_markov_chain", "type": "V_concept", "name": "Regular Markov Chain", "properties": {"description": "A Markov chain where all entries of the transition matrix are positive after some number of steps, ensuring the existence of a unique stationary distribution.", "keywords": ["regular", "markov", "chain", "transition", "matrix"], "source_lectures": ["lecture_106104233_w4_l22"]}}
{"id": "concept_eigenvalue", "type": "V_concept", "name": "Eigenvalue", "properties": {"description": "A scalar value that represents how much a linear transformation changes a vector, used in the study of Markov chains and page rank algorithms.", "keywords": ["eigenvalue", "linear", "transformation", "vector", "markov"], "source_lectures": ["lecture_106104233_w4_l22"]}}
{"id": "concept_eigenspace", "type": "V_concept", "name": "Eigenspace", "properties": {"description": "The set of all vectors that, when transformed by a linear transformation, result in a scaled version of themselves, used in the study of Markov chains and page rank algorithms.", "keywords": ["eigenspace", "linear", "transformation", "vector", "markov"], "source_lectures": ["lecture_106104233_w4_l22"]}}
{"id": "concept_geometric_distribution", "type": "V_concept", "name": "Geometric Distribution", "properties": {"description": "A discrete probability distribution that models the number of trials until the first success.", "keywords": ["geometric", "distribution", "probability", "trials"], "source_lectures": ["lecture_106104233_w4_l25"]}}
{"id": "concept_uniform_sampling", "type": "V_concept", "name": "Uniform Sampling", "properties": {"description": "A method of selecting samples from a population such that every sample has an equal chance of being chosen.", "keywords": ["uniform", "sampling", "probability", "population"], "source_lectures": ["lecture_106104233_w4_l25"]}}
{"id": "concept_biased_coin_toss", "type": "V_concept", "name": "Biased Coin Toss", "properties": {"description": "A coin toss with a probability of heads that is not equal to 0.5.", "keywords": ["biased", "coin", "toss", "probability"], "source_lectures": ["lecture_106104233_w4_l25"]}}
{"id": "concept_pairwise_independent_hashing", "type": "V_concept", "name": "Pairwise Independent Hashing", "properties": {"description": "A type of hashing where the outputs of two different inputs are independent and uniformly distributed.", "keywords": ["distribution", "uniform", "independent", "hashing", "pairwise"], "source_lectures": ["lecture_106104233_w4_l25", "lecture_106104233_w4_l26"]}}
{"id": "concept_harmonic_series", "type": "V_concept", "name": "Harmonic Series", "properties": {"description": "A series of numbers in which each term is the reciprocal of a positive integer, often used in mathematical analysis.", "keywords": ["harmonic", "series", "reciprocal", "integer"], "source_lectures": ["lecture_106104233_w4_l25"]}}
{"id": "concept_random_permutation", "type": "V_concept", "name": "Random Permutation", "properties": {"description": "A permutation of a set of elements that is chosen randomly and uniformly.", "keywords": ["random", "permutation", "uniform", "set"], "source_lectures": ["lecture_106104233_w4_l25"]}}
{"id": "concept_geometric_distribution_expectation", "type": "V_concept", "name": "Geometric Distribution Expectation", "properties": {"description": "The expected value of a geometric distribution, which is equal to 1/p, where p is the probability of success.", "keywords": ["geometric", "distribution", "expectation", "probability"], "source_lectures": ["lecture_106104233_w4_l25"]}}
{"id": "concept_linear_transformation", "type": "V_concept", "name": "Linear Transformation", "properties": {"description": "A mathematical function that preserves the operations of vector addition and scalar multiplication.", "keywords": ["linear", "transformation", "vector", "space", "matrix"], "source_lectures": ["lecture_106104233_w4_l26"]}}
{"id": "concept_vector_space", "type": "V_concept", "name": "Vector Space", "properties": {"description": "A mathematical structure that consists of a set of vectors and operations that can be performed on them.", "keywords": ["vector", "space", "mathematics", "linear", "algebra"], "source_lectures": ["lecture_106104233_w4_l26"]}}
{"id": "concept_ramsey_theory", "type": "V_concept", "name": "Ramsey Theory", "properties": {"description": "A branch of mathematics that studies the conditions under which order must appear in a system.", "keywords": ["ramsey", "theory", "mathematics", "order", "system"], "source_lectures": ["lecture_106104233_w4_l26"]}}
{"id": "concept_graph_coloring", "type": "V_concept", "name": "Graph Coloring", "properties": {"description": "A mathematical technique that assigns colors to the vertices or edges of a graph such that certain conditions are met.", "keywords": ["graph", "coloring", "mathematics", "vertices", "edges"], "source_lectures": ["lecture_106104233_w4_l26"]}}
{"id": "concept_ramsey_number", "type": "V_concept", "name": "Ramsey Number", "properties": {"description": "The smallest number of vertices in a complete graph such that any coloring of the edges with two colors will result in a monochromatic complete subgraph of a certain size.", "keywords": ["graph", "coloring", "ramsey", "subgraph", "number", "monochromatic"], "source_lectures": ["lecture_106104233_w4_l27", "lecture_106104233_w5_l29"]}}
{"id": "concept_monochromatic_subgraph", "type": "V_concept", "name": "Monochromatic Subgraph", "properties": {"description": "A subgraph of a graph where all edges have the same color.", "keywords": ["monochromatic", "subgraph", "graph", "coloring"], "source_lectures": ["lecture_106104233_w4_l27"]}}
{"id": "concept_max_cut_problem", "type": "V_concept", "name": "Max Cut Problem", "properties": {"description": "A problem in computer science that involves finding the largest possible cut in a graph.", "keywords": ["max", "cut", "problem", "graph", "optimization"], "source_lectures": ["lecture_106104233_w4_l27"]}}
{"id": "concept_cut_size", "type": "V_concept", "name": "Cut Size", "properties": {"description": "The number of edges in a cut of a graph.", "keywords": ["cut", "size", "graph", "edges"], "source_lectures": ["lecture_106104233_w4_l27"]}}
{"id": "concept_indicator_variable", "type": "V_concept", "name": "Indicator Variable", "properties": {"description": "A random variable that takes on the value 1 if a certain event occurs and 0 otherwise.", "keywords": ["indicator", "variable", "random", "event"], "source_lectures": ["lecture_106104233_w4_l27"]}}
{"id": "concept_sum_free_subset", "type": "V_concept", "name": "Sum Free Subset", "properties": {"description": "A subset of integers where no element is the sum of two other elements in the subset.", "keywords": ["sum", "free", "subset", "integers", "combinatorics"], "source_lectures": ["lecture_106104233_w4_l28"]}}
{"id": "concept_indicator_random_variable", "type": "V_concept", "name": "Indicator Random Variable", "properties": {"description": "A random variable that takes on the value 1 if a certain event occurs and 0 otherwise.", "keywords": ["indicator", "random", "variable", "probability", "statistics"], "source_lectures": ["lecture_106104233_w4_l28"]}}
{"id": "concept_discrepancy_theorem", "type": "V_concept", "name": "Discrepancy Theorem", "properties": {"description": "A theorem that states the existence of a signed linear combination of unit vectors with a small norm.", "keywords": ["discrepancy", "theorem", "linear", "combination", "unit vectors"], "source_lectures": ["lecture_106104233_w4_l28"]}}
{"id": "concept_bit_string", "type": "V_concept", "name": "Bit String", "properties": {"description": "A sequence of binary digits, often used to represent a binary number or a sequence of choices.", "keywords": ["bit", "string", "binary", "digit", "sequence"], "source_lectures": ["lecture_106104233_w4_l28"]}}
{"id": "concept_signed_linear_combination", "type": "V_concept", "name": "Signed Linear Combination", "properties": {"description": "A linear combination of vectors where each vector is multiplied by a scalar that can be positive or negative.", "keywords": ["signed", "linear", "combination", "vectors", "scalars"], "source_lectures": ["lecture_106104233_w4_l28"]}}
{"id": "concept_monochromatic_complete_subgraph", "type": "V_concept", "name": "Monochromatic Complete Subgraph", "properties": {"description": "A complete subgraph in which all edges have the same color.", "keywords": ["monochromatic", "complete", "subgraph", "graph"], "source_lectures": ["lecture_106104233_w5_l29"]}}
{"id": "concept_independent_set", "type": "V_concept", "name": "Independent Set", "properties": {"description": "A set of vertices in a graph, no two of which are adjacent.", "keywords": ["independent", "set", "graph", "vertices"], "source_lectures": ["lecture_106104233_w5_l29"]}}
{"id": "concept_discrepancy", "type": "V_concept", "name": "Discrepancy", "properties": {"description": "A measure of how far a set of vectors is from being evenly distributed.", "keywords": ["discrepancy", "vectors", "distribution"], "source_lectures": ["lecture_106104233_w5_l29"]}}
{"id": "concept_signed_sum", "type": "V_concept", "name": "Signed Sum", "properties": {"description": "A sum of vectors where each vector is multiplied by a scalar of +1 or -1.", "keywords": ["signed", "sum", "vectors", "scalar"], "source_lectures": ["lecture_106104233_w5_l29"]}}
{"id": "concept_norm", "type": "V_concept", "name": "Norm", "properties": {"description": "A measure of the magnitude of a vector.", "keywords": ["norm", "magnitude", "vector"], "source_lectures": ["lecture_106104233_w5_l29"]}}
{"id": "concept_kale_system", "type": "V_concept", "name": "Kale System", "properties": {"description": "A family of set pairs with certain properties, including disjointness and overlap.", "keywords": ["kale", "system", "set", "pairs"], "source_lectures": ["lecture_106104233_w5_l29"]}}
{"id": "concept_extremal_set_families", "type": "V_concept", "name": "Extremal Set Families", "properties": {"description": "A family of sets with certain properties, including maximum or minimum size.", "keywords": ["extremal", "set", "families", "properties"], "source_lectures": ["lecture_106104233_w5_l29"]}}
{"id": "concept_super_concentrator", "type": "V_concept", "name": "Super Concentrator", "properties": {"description": "A directed acyclic graph with high connectivity between input and output nodes.", "keywords": ["graph", "network", "recursive", "concentrator", "connectivity", "super"], "source_lectures": ["lecture_106104233_w5_l29", "lecture_106104233_w5_l30", "lecture_106104233_w5_l31"]}}
{"id": "concept_disjoint_paths", "type": "V_concept", "name": "Disjoint Paths", "properties": {"description": "Paths in a graph that do not share any edges or vertices.", "keywords": ["graph", "edges", "disjoint", "paths", "connectivity"], "source_lectures": ["lecture_106104233_w5_l29", "lecture_106104233_w5_l30"]}}
{"id": "concept_concentrator", "type": "V_concept", "name": "Concentrator", "properties": {"description": "A bipartite graph with input and output nodes, where for all subsets of input nodes, there exists a subset of output nodes connected by disjoint paths.", "keywords": ["concentrator", "bipartite", "graph", "disjoint", "paths"], "source_lectures": ["lecture_106104233_w5_l30"]}}
{"id": "concept_bipartite_graph", "type": "V_concept", "name": "Bipartite Graph", "properties": {"description": "A graph whose vertices can be divided into two disjoint sets, where edges only connect vertices between the two sets.", "keywords": ["bipartite", "graph", "disjoint", "sets"], "source_lectures": ["lecture_106104233_w5_l30"]}}
{"id": "concept_halls_theorem", "type": "V_concept", "name": "Hall's Theorem", "properties": {"description": "A theorem about bipartite graphs, stating that a matching exists if and only if for all subsets of input nodes, the neighborhood has at least the same size.", "keywords": ["hall", "theorem", "bipartite", "graph", "matching"], "source_lectures": ["lecture_106104233_w5_l30"]}}
{"id": "concept_adjacency_list_representation", "type": "V_concept", "name": "Adjacency List Representation", "properties": {"description": "A way to represent a graph, where each vertex is associated with a list of its neighboring vertices.", "keywords": ["adjacency", "list", "representation", "graph"], "source_lectures": ["lecture_106104233_w5_l30"]}}
{"id": "concept_graph_connectivity", "type": "V_concept", "name": "Graph Connectivity", "properties": {"description": "A property of a graph, where there exists a path between every pair of vertices.", "keywords": ["graph", "connectivity", "path", "vertices"], "source_lectures": ["lecture_106104233_w5_l30"]}}
{"id": "concept_pairwise_independent_hash_function", "type": "V_concept", "name": "Pairwise Independent Hash Function", "properties": {"description": "A hash function that maps a set of inputs to a set of outputs in a way that is pairwise independent.", "keywords": ["hash", "function", "pairwise", "independent"], "source_lectures": ["lecture_106104233_w5_l31"]}}
{"id": "concept_valuation_map", "type": "V_concept", "name": "Valuation Map", "properties": {"description": "A function that maps a number to the highest power of two that divides it.", "keywords": ["valuation", "map", "power", "two"], "source_lectures": ["lecture_106104233_w5_l31"]}}
{"id": "concept_data_stream_model", "type": "V_concept", "name": "Data Stream Model", "properties": {"description": "A model of computation where data is processed in a streaming fashion, with limited memory and processing power.", "keywords": ["data", "stream", "model", "computation"], "source_lectures": ["lecture_106104233_w5_l31"]}}
{"id": "concept_streaming_algorithm", "type": "V_concept", "name": "Streaming Algorithm", "properties": {"description": "An algorithm that processes data in a streaming fashion, with limited memory and processing power.", "keywords": ["streaming", "algorithm", "data", "processing"], "source_lectures": ["lecture_106104233_w5_l31"]}}
{"id": "concept_distinct_elements_problem", "type": "V_concept", "name": "Distinct Elements Problem", "properties": {"description": "The problem of estimating the number of distinct elements in a large dataset.", "keywords": ["streaming", "estimation", "problem", "distinct", "elements", "data"], "source_lectures": ["lecture_106104233_w5_l31", "lecture_106104233_w5_l32"]}}
{"id": "concept_four_wise_independence", "type": "V_concept", "name": "Four-Wise Independence", "properties": {"description": "A property of a set of random variables where each set of four variables is independent.", "keywords": ["four-wise", "independence", "random", "variables"], "source_lectures": ["lecture_106104233_w5_l32"]}}
{"id": "concept_data_streaming_algorithm", "type": "V_concept", "name": "Data Streaming Algorithm", "properties": {"description": "An algorithm designed to process and analyze large amounts of data in real-time, often with limited memory and processing power.", "keywords": ["data", "streaming", "algorithm", "real-time", "processing"], "source_lectures": ["lecture_106104233_w5_l32"]}}
{"id": "concept_heavy_hitter_detection", "type": "V_concept", "name": "Heavy Hitter Detection", "properties": {"description": "A problem in data streaming where the goal is to identify elements that appear frequently in a large dataset.", "keywords": ["heavy", "hitter", "detection", "data", "streaming"], "source_lectures": ["lecture_106104233_w5_l32"]}}
{"id": "concept_alon_matias_szegedy_algorithm", "type": "V_concept", "name": "Alon-Matias-Szegedy Algorithm", "properties": {"description": "An algorithm for estimating the second moment of a dataset in a data streaming setting.", "keywords": ["alon", "matias", "szegedy", "algorithm", "data", "streaming"], "source_lectures": ["lecture_106104233_w5_l32"]}}
{"id": "concept_boosting_trick", "type": "V_concept", "name": "Boosting Trick", "properties": {"description": "A technique used to improve the accuracy of an algorithm by running multiple instances of the algorithm and combining the results.", "keywords": ["boosting", "trick", "algorithm", "accuracy", "improvement"], "source_lectures": ["lecture_106104233_w5_l32"]}}
{"id": "concept_gilders_law", "type": "V_concept", "name": "Gilder's Law", "properties": {"description": "A principle that states that the bandwidth of communication networks doubles approximately every year", "keywords": ["gilder", "law", "bandwidth", "network"], "source_lectures": ["lecture_106104182_w1_l1"]}}
{"id": "concept_utility_computing", "type": "V_concept", "name": "Utility Computing", "properties": {"description": "A model of computing where computing resources are provided as a service, similar to a utility like electricity or water", "keywords": ["utility", "computing", "service", "on-demand"], "source_lectures": ["lecture_106104182_w1_l1"]}}
{"id": "concept_cloud_service_models", "type": "V_concept", "name": "Cloud Service Models", "properties": {"description": "A classification of cloud services into Infrastructure as a Service (IaaS), Platform as a Service (PaaS), and Software as a Service (SaaS)", "keywords": ["cloud", "service", "models", "iaas", "paas", "saas"], "source_lectures": ["lecture_106104182_w1_l1"]}}
{"id": "concept_mapreduce", "type": "V_concept", "name": "MapReduce", "properties": {"description": "A programming paradigm for processing large data sets in parallel across a cluster of computers", "keywords": ["programming", "large datasets", "hadoop", "parallel", "mapreduce", "parallel processing", "programming model", "data", "processing"], "source_lectures": ["lecture_106104182_w1_l1", "lecture_106104182_w3_l20", "lecture_106104182_w4_l22"]}}
{"id": "concept_nosql", "type": "V_concept", "name": "NoSQL", "properties": {"description": "A type of database that does not use the traditional structured query language (SQL) to manage data", "keywords": ["nosql", "database", "sql", "unstructured"], "source_lectures": ["lecture_106104182_w1_l1"]}}
{"id": "concept_public_cloud", "type": "V_concept", "name": "Public Cloud", "properties": {"description": "A cloud computing environment that is open to the general public and provides services over the internet", "keywords": ["public", "cloud", "internet", "service"], "source_lectures": ["lecture_106104182_w1_l1"]}}
{"id": "concept_private_cloud", "type": "V_concept", "name": "Private Cloud", "properties": {"description": "A cloud computing environment that is restricted to a single organization and provides services over a private network", "keywords": ["private", "cloud", "network", "organization"], "source_lectures": ["lecture_106104182_w1_l1"]}}
{"id": "concept_data_intensive_computing", "type": "V_concept", "name": "Data Intensive Computing", "properties": {"description": "A type of computing that focuses on processing large amounts of data, often using parallel processing techniques", "keywords": ["data", "intensive", "computing", "parallel"], "source_lectures": ["lecture_106104182_w1_l1"]}}
{"id": "concept_on_demand_access", "type": "V_concept", "name": "On-Demand Access", "properties": {"description": "A feature of cloud computing that allows users to access computing resources as needed, without having to purchase or maintain them", "keywords": ["cloud", "pay-as-you-go", "resource", "computing", "on-demand", "access", "provisioning"], "source_lectures": ["lecture_106104182_w1_l1", "lecture_106104182_w4_l23"]}}
{"id": "concept_massive_scale", "type": "V_concept", "name": "Massive Scale", "properties": {"description": "A feature of cloud computing that allows for the processing of large amounts of data and the handling of a large number of users", "keywords": ["cloud", "data center", "servers", "scale", "computing", "capacity", "massive"], "source_lectures": ["lecture_106104182_w1_l1", "lecture_106104182_w4_l23"]}}
{"id": "concept_bare_metal_hypervisor", "type": "V_concept", "name": "Bare Metal Hypervisor", "properties": {"description": "A type of hypervisor that runs directly on the host machine's hardware, without requiring a host operating system.", "keywords": ["bare metal", "hypervisor", "hardware", "native"], "source_lectures": ["lecture_106104182_w1_l2"]}}
{"id": "concept_hosted_hypervisor", "type": "V_concept", "name": "Hosted Hypervisor", "properties": {"description": "A type of hypervisor that runs on top of a host operating system, which manages the hardware resources.", "keywords": ["hosted", "hypervisor", "operating system", "hardware"], "source_lectures": ["lecture_106104182_w1_l2"]}}
{"id": "concept_para_virtualization", "type": "V_concept", "name": "Para Virtualization", "properties": {"description": "A virtualization technique where the guest operating system is modified to communicate with the hypervisor, improving performance.", "keywords": ["para virtualization", "hypervisor", "performance"], "source_lectures": ["lecture_106104182_w1_l2"]}}
{"id": "concept_binary_translation", "type": "V_concept", "name": "Binary Translation", "properties": {"description": "A technique used in full virtualization to translate privileged instructions, allowing the guest operating system to run without modification.", "keywords": ["binary translation", "full virtualization", "privileged instructions"], "source_lectures": ["lecture_106104182_w1_l2"]}}
{"id": "concept_shadow_page_table", "type": "V_concept", "name": "Shadow Page Table", "properties": {"description": "A data structure used by the hypervisor to map guest physical memory to machine memory, improving memory virtualization efficiency.", "keywords": ["shadow page table", "hypervisor", "memory virtualization"], "source_lectures": ["lecture_106104182_w1_l2"]}}
{"id": "concept_device_virtualization", "type": "V_concept", "name": "Device Virtualization", "properties": {"description": "A technique that allows multiple virtual machines to share physical devices, improving resource utilization.", "keywords": ["device virtualization", "virtual machine", "sharing"], "source_lectures": ["lecture_106104182_w1_l2"]}}
{"id": "concept_pass_through_model", "type": "V_concept", "name": "Pass Through Model", "properties": {"description": "A device virtualization technique where the hypervisor configures devices and grants exclusive access to virtual machines.", "keywords": ["pass through model", "device virtualization", "hypervisor"], "source_lectures": ["lecture_106104182_w1_l2"]}}
{"id": "concept_hypervisor_direct_model", "type": "V_concept", "name": "Hypervisor Direct Model", "properties": {"description": "A device virtualization technique where the hypervisor intercepts device accesses and emulates device operations.", "keywords": ["hypervisor direct model", "device virtualization", "emulation"], "source_lectures": ["lecture_106104182_w1_l2"]}}
{"id": "concept_split_device_driver_model", "type": "V_concept", "name": "Split Device Driver Model", "properties": {"description": "A device virtualization technique that splits device access control between the front-end driver and back-end driver.", "keywords": ["split device driver model", "device virtualization", "driver"], "source_lectures": ["lecture_106104182_w1_l2"]}}
{"id": "concept_xen", "type": "V_concept", "name": "Xen", "properties": {"description": "An open-source hypervisor that supports para-virtualization and full virtualization.", "keywords": ["xen", "hypervisor", "para-virtualization"], "source_lectures": ["lecture_106104182_w1_l2"]}}
{"id": "concept_kvm", "type": "V_concept", "name": "KVM", "properties": {"description": "A kernel-based virtual machine that supports full virtualization and para-virtualization.", "keywords": ["kvm", "virtual machine", "full virtualization"], "source_lectures": ["lecture_106104182_w1_l2"]}}
{"id": "concept_vmware", "type": "V_concept", "name": "VMware", "properties": {"description": "A commercial hypervisor that supports full virtualization and para-virtualization.", "keywords": ["vmware", "hypervisor", "full virtualization"], "source_lectures": ["lecture_106104182_w1_l2"]}}
{"id": "concept_docker", "type": "V_concept", "name": "Docker", "properties": {"description": "A containerization platform that allows applications to be packaged and run in isolated environments.", "keywords": ["container", "runtime", "linux", "docker", "container platform", "virtualization", "containerization", "image building"], "source_lectures": ["lecture_106104182_w1_l4", "lecture_106104449_w1_l6"]}}
{"id": "concept_linux_container", "type": "V_concept", "name": "Linux Container", "properties": {"description": "A lightweight virtualization technology that runs applications in isolated environments, sharing the host operating system.", "keywords": ["linux", "container", "virtualization", "docker"], "source_lectures": ["lecture_106104182_w1_l4"]}}
{"id": "concept_sr_iov", "type": "V_concept", "name": "SR-IOV", "properties": {"description": "A hardware-based virtualization technology that allows multiple virtual machines to share a single physical network interface card.", "keywords": ["sr-iov", "hardware", "virtualization", "nic"], "source_lectures": ["lecture_106104182_w1_l4"]}}
{"id": "concept_open_vswitch", "type": "V_concept", "name": "Open vSwitch", "properties": {"description": "A software-based virtualization technology that provides flexible and fast packet forwarding for virtual machines.", "keywords": ["openvswitch", "software", "virtualization", "packet", "forwarding"], "source_lectures": ["lecture_106104182_w1_l4"]}}
{"id": "concept_virtual_network_interface_card", "type": "V_concept", "name": "Virtual Network Interface Card", "properties": {"description": "A virtualized network interface card that allows virtual machines to communicate with each other and the physical network.", "keywords": ["vnic", "virtual", "network", "interface", "card"], "source_lectures": ["lecture_106104182_w1_l4"]}}
{"id": "concept_mininet", "type": "V_concept", "name": "Mininet", "properties": {"description": "A network emulator that allows users to create and test virtual network topologies.", "keywords": ["mininet", "network", "emulator", "virtual", "topology"], "source_lectures": ["lecture_106104182_w1_l4"]}}
{"id": "concept_live_vm_migration", "type": "V_concept", "name": "Live VM Migration", "properties": {"description": "The process of moving a virtual machine from one physical server to another without disrupting its operation.", "keywords": ["live", "vm", "migration", "virtual", "machine"], "source_lectures": ["lecture_106104182_w1_l4"]}}
{"id": "concept_software_defined_network", "type": "V_concept", "name": "Software Defined Network", "properties": {"description": "A network architecture that allows for the creation of a virtual network by separating the control plane from the data plane", "keywords": ["software", "defined", "network", "virtualization", "sdn"], "source_lectures": ["lecture_106104182_w1_l5"]}}
{"id": "concept_multi_tenancy", "type": "V_concept", "name": "Multi-tenancy", "properties": {"description": "The ability of a single network or system to support multiple tenants or users, while maintaining isolation and security between them", "keywords": ["multi-tenancy", "tenants", "users", "isolation", "security"], "source_lectures": ["lecture_106104182_w1_l5"]}}
{"id": "concept_network_abstraction", "type": "V_concept", "name": "Network Abstraction", "properties": {"description": "A layer of software that provides a simplified interface to a complex network, making it easier to manage and program", "keywords": ["network", "abstraction", "software", "interface", "management"], "source_lectures": ["lecture_106104182_w1_l5"]}}
{"id": "concept_geo_distributed_cloud_data_centers", "type": "V_concept", "name": "Geo Distributed Cloud Data Centers", "properties": {"description": "A network of data centers located in different geographical locations, connected through the internet to provide services to users.", "keywords": ["cloud", "data", "centers", "geodistributed", "network"], "source_lectures": ["lecture_106104182_w1_l6"]}}
{"id": "concept_inter_data_center_networking", "type": "V_concept", "name": "Inter Data Center Networking", "properties": {"description": "The process of connecting multiple data centers together to enable communication and data exchange between them.", "keywords": ["inter", "data", "center", "networking", "communication"], "source_lectures": ["lecture_106104182_w1_l6"]}}
{"id": "concept_wide_area_network", "type": "V_concept", "name": "Wide Area Network", "properties": {"description": "A computer network that covers a large geographical area, such as a city or country, and is used to connect multiple data centers.", "keywords": ["wide", "area", "network", "geographical", "connection"], "source_lectures": ["lecture_106104182_w1_l6"]}}
{"id": "concept_mpls", "type": "V_concept", "name": "MPLS", "properties": {"description": "A routing technique used in wide area networks to efficiently route traffic between multiple data centers.", "keywords": ["mpls", "routing", "technique", "wide", "area"], "source_lectures": ["lecture_106104182_w1_l6"]}}
{"id": "concept_software_defined_networking", "type": "V_concept", "name": "Software Defined Networking", "properties": {"description": "A network architecture that allows for the creation of virtual networks and the management of network traffic through software.", "keywords": ["software", "defined", "networking", "virtual", "management"], "source_lectures": ["lecture_106104182_w1_l6"]}}
{"id": "concept_google_b4", "type": "V_concept", "name": "Google B4", "properties": {"description": "A software-defined networking system used by Google to manage traffic between its data centers.", "keywords": ["google", "b4", "software", "defined", "networking"], "source_lectures": ["lecture_106104182_w1_l6"]}}
{"id": "concept_bandwidth_utilization", "type": "V_concept", "name": "Bandwidth Utilization", "properties": {"description": "The process of optimizing the use of available bandwidth in a network to ensure efficient data transfer.", "keywords": ["bandwidth", "utilization", "optimization", "network", "efficiency"], "source_lectures": ["lecture_106104182_w1_l6"]}}
{"id": "concept_network_congestion", "type": "V_concept", "name": "Network Congestion", "properties": {"description": "A state of network overload where the amount of data being transmitted exceeds the available bandwidth, causing delays and packet loss.", "keywords": ["network", "congestion", "overload", "bandwidth", "delays"], "source_lectures": ["lecture_106104182_w1_l6"]}}
{"id": "concept_leader_election", "type": "V_concept", "name": "Leader Election", "properties": {"description": "A process in distributed systems where a leader is elected among a group of processes to coordinate their actions.", "keywords": ["kafka", "systems", "coordination", "election", "fault-tolerance", "leader", "system", "distributed"], "source_lectures": ["lecture_106104182_w2_l8", "lecture_106104182_w2_l9", "lecture_106104182_w3_l21"]}}
{"id": "concept_ring_leader_election", "type": "V_concept", "name": "Ring Leader Election", "properties": {"description": "A leader election algorithm where processes are organized in a logical ring and messages are sent in a clockwise direction.", "keywords": ["ring", "leader", "election", "distributed", "algorithm"], "source_lectures": ["lecture_106104182_w2_l8"]}}
{"id": "concept_bully_leader_election", "type": "V_concept", "name": "Bully Leader Election", "properties": {"description": "A leader election algorithm where the process with the highest id is elected as the leader and sends a coordinator message to all other processes.", "keywords": ["bully", "leader", "election", "distributed", "algorithm"], "source_lectures": ["lecture_106104182_w2_l8"]}}
{"id": "concept_safety_property", "type": "V_concept", "name": "Safety Property", "properties": {"description": "A property of leader election algorithms that ensures nothing bad happens, such as electing a leader that is not the highest id process.", "keywords": ["safety", "property", "leader", "election", "distributed"], "source_lectures": ["lecture_106104182_w2_l8"]}}
{"id": "concept_liveness_property", "type": "V_concept", "name": "Liveness Property", "properties": {"description": "A property of leader election algorithms that ensures something good happens, such as eventually electing a leader.", "keywords": ["fairness", "mutual exclusion", "property", "election", "leader", "starvation", "liveness", "distributed", "progress"], "source_lectures": ["lecture_106104182_w2_l8", "lecture_106104182_w2_l12"]}}
{"id": "concept_paxos_protocol", "type": "V_concept", "name": "Paxos Protocol", "properties": {"description": "A consensus protocol used in distributed systems for leader election and other purposes.", "keywords": ["systems", "distributed systems", "failures", "paxos", "protocol", "paxos protocol", "distributed", "consensus", "fault tolerance", "consensus protocol", "locking"], "source_lectures": ["lecture_106104182_w2_l8", "lecture_106104182_w2_l12", "lecture_106104182_w4_l22"]}}
{"id": "concept_failure_detector", "type": "V_concept", "name": "Failure Detector", "properties": {"description": "A mechanism used to detect failures in distributed systems, such as the failure of a leader process.", "keywords": ["failure", "detector", "distributed", "systems", "leader"], "source_lectures": ["lecture_106104182_w2_l8"]}}
{"id": "concept_zab_protocol", "type": "V_concept", "name": "Zab Protocol", "properties": {"description": "A variant of the Paxos protocol used in Apache Zookeeper for leader election and atomic broadcast.", "keywords": ["zab", "protocol", "paxos", "zookeeper", "leader", "election"], "source_lectures": ["lecture_106104182_w2_l8"]}}
{"id": "concept_consensus_problem", "type": "V_concept", "name": "Consensus Problem", "properties": {"description": "A problem in distributed systems where multiple processes must agree on a single value or decision.", "keywords": ["consensus", "problem", "distributed", "systems", "agreement"], "source_lectures": ["lecture_106104182_w2_l8"]}}
{"id": "concept_zookeeper", "type": "V_concept", "name": "Zookeeper", "properties": {"description": "A highly reliable distributed coordination kernel that provides a centralized service for maintaining configuration information, naming, and providing distributed synchronization and group services.", "keywords": ["kafka", "apache", "coordination", "coordination service", "distributed systems", "distributed lock", "paxos", "nodes", "cluster", "system", "distributed", "hbase", "kernel", "zookeeper"], "source_lectures": ["lecture_106104182_w2_l9", "lecture_106104182_w2_l12", "lecture_106104182_w3_l17", "lecture_106104182_w3_l21", "lecture_106104182_w4_l22"]}}
{"id": "concept_fault_tolerance", "type": "V_concept", "name": "Fault Tolerance", "properties": {"description": "The ability of a system to continue functioning even when one or more of its components fail.", "keywords": ["system", "fault", "tolerance", "reliability"], "source_lectures": ["lecture_106104182_w2_l9", "lecture_106104182_w3_l20"]}}
{"id": "concept_majority_quorum", "type": "V_concept", "name": "Majority Quorum", "properties": {"description": "A minimum number of nodes required to achieve consensus in a distributed system, which ensures that the system can continue to function even in the presence of failures.", "keywords": ["majority", "quorum", "distributed", "system"], "source_lectures": ["lecture_106104182_w2_l9"]}}
{"id": "concept_distributed_locking", "type": "V_concept", "name": "Distributed Locking", "properties": {"description": "A mechanism that allows multiple nodes in a distributed system to coordinate access to shared resources, preventing conflicts and ensuring consistency.", "keywords": ["distributed", "locking", "coordination", "resources"], "source_lectures": ["lecture_106104182_w2_l9"]}}
{"id": "concept_configuration_management", "type": "V_concept", "name": "Configuration Management", "properties": {"description": "The process of managing and maintaining the configuration of a distributed system, including the management of metadata and the coordination of nodes.", "keywords": ["configuration", "management", "distributed", "system"], "source_lectures": ["lecture_106104182_w2_l9"]}}
{"id": "concept_group_membership", "type": "V_concept", "name": "Group Membership", "properties": {"description": "The process of managing the membership of nodes in a distributed system, including the addition and removal of nodes.", "keywords": ["group", "membership", "distributed", "system"], "source_lectures": ["lecture_106104182_w2_l9"]}}
{"id": "concept_two_phase_commit_protocol", "type": "V_concept", "name": "Two-Phase Commit Protocol", "properties": {"description": "A protocol used to ensure atomicity and consistency in distributed transactions, which involves two phases: prepare and commit.", "keywords": ["two-phase", "commit", "protocol", "distributed"], "source_lectures": ["lecture_106104182_w2_l9"]}}
{"id": "concept_paxos_algorithm", "type": "V_concept", "name": "Paxos Algorithm", "properties": {"description": "A consensus algorithm used in distributed systems to achieve agreement among nodes, which is based on a voting mechanism.", "keywords": ["paxos", "algorithm", "consensus", "distributed"], "source_lectures": ["lecture_106104182_w2_l9"]}}
{"id": "concept_znode", "type": "V_concept", "name": "ZNode", "properties": {"description": "A node in the Zookeeper data model, which represents a piece of data or a directory.", "keywords": ["znode", "zookeeper", "data", "model"], "source_lectures": ["lecture_106104182_w2_l9"]}}
{"id": "concept_christians_algorithm", "type": "V_concept", "name": "Christian's Algorithm", "properties": {"description": "A clock synchronization algorithm that measures round-trip time to estimate the clock offset.", "keywords": ["christian", "algorithm", "clock", "synchronization"], "source_lectures": ["lecture_106104182_w2_l10"]}}
{"id": "concept_network_time_protocol_ntp", "type": "V_concept", "name": "Network Time Protocol (NTP)", "properties": {"description": "A protocol for synchronizing clocks over the internet using a hierarchical system of time servers.", "keywords": ["ntp", "network", "time", "protocol"], "source_lectures": ["lecture_106104182_w2_l10"]}}
{"id": "concept_berkeleys_algorithm", "type": "V_concept", "name": "Berkeley's Algorithm", "properties": {"description": "A clock synchronization algorithm that uses a master-slave approach to synchronize clocks in a distributed system.", "keywords": ["berkeley", "algorithm", "clock", "synchronization"], "source_lectures": ["lecture_106104182_w2_l10"]}}
{"id": "concept_data_center_time_protocol_dtp", "type": "V_concept", "name": "Data Center Time Protocol (DTP)", "properties": {"description": "A clock synchronization protocol designed for data centers that uses a decentralized approach to achieve high precision.", "keywords": ["dtp", "data", "center", "time", "protocol"], "source_lectures": ["lecture_106104182_w2_l10"]}}
{"id": "concept_lamport_clock", "type": "V_concept", "name": "Lamport Clock", "properties": {"description": "A logical clock that assigns timestamps to events in a distributed system based on causal relationships.", "keywords": ["lamport", "clock", "logical", "distributed", "system"], "source_lectures": ["lecture_106104182_w2_l10"]}}
{"id": "concept_vector_clock", "type": "V_concept", "name": "Vector Clock", "properties": {"description": "A data structure used to track causal relationships between events in a distributed system.", "keywords": ["vector", "clock", "causal", "relationships", "distributed"], "source_lectures": ["lecture_106104182_w2_l10"]}}
{"id": "concept_external_synchronization", "type": "V_concept", "name": "External Synchronization", "properties": {"description": "The process of synchronizing clocks in a distributed system with an external reference clock.", "keywords": ["external", "synchronization", "distributed", "system"], "source_lectures": ["lecture_106104182_w2_l10"]}}
{"id": "concept_internal_synchronization", "type": "V_concept", "name": "Internal Synchronization", "properties": {"description": "The process of synchronizing clocks within a distributed system without an external reference clock.", "keywords": ["internal", "synchronization", "distributed", "system"], "source_lectures": ["lecture_106104182_w2_l10"]}}
{"id": "concept_distributed_mutual_exclusion", "type": "V_concept", "name": "Distributed Mutual Exclusion", "properties": {"description": "A mechanism to ensure that only one process at a time can access a shared resource in a distributed system, preventing race conditions.", "keywords": ["distributed", "mutual exclusion", "race condition", "shared resource", "concurrency"], "source_lectures": ["lecture_106104182_w2_l12"]}}
{"id": "concept_safety_property_mutual_exclusion", "type": "V_concept", "name": "Safety Property (Mutual Exclusion)", "properties": {"description": "A guarantee that no two processes are ever in the critical section at the same time, ensuring exclusive access to shared resources.", "keywords": ["safety", "mutual exclusion", "exclusive access", "critical section", "concurrency control"], "source_lectures": ["lecture_106104182_w2_l12"]}}
{"id": "concept_fairness_property", "type": "V_concept", "name": "Fairness Property", "properties": {"description": "A guarantee that requests to enter the critical section are granted in the order they are made, ensuring first-in-first-out processing.", "keywords": ["fairness", "first-in-first-out", "ordering", "request queue", "mutual exclusion"], "source_lectures": ["lecture_106104182_w2_l12"]}}
{"id": "concept_token_based_mutual_exclusion", "type": "V_concept", "name": "Token-Based Mutual Exclusion", "properties": {"description": "A method where a special token is passed among processes; only the process holding the token may enter the critical section.", "keywords": ["token", "mutual exclusion", "distributed system", "token passing", "access control"], "source_lectures": ["lecture_106104182_w2_l12"]}}
{"id": "concept_centralized_algorithm_token_based", "type": "V_concept", "name": "Centralized Algorithm (Token-Based)", "properties": {"description": "A mutual exclusion algorithm where a central server manages a single token and grants access to the critical section in request order.", "keywords": ["centralized", "token", "master server", "request queue", "mutual exclusion"], "source_lectures": ["lecture_106104182_w2_l12"]}}
{"id": "concept_ring_based_mutual_exclusion", "type": "V_concept", "name": "Ring-Based Mutual Exclusion", "properties": {"description": "A distributed mutual exclusion algorithm where processes are arranged in a logical ring, and a token circulates among them to grant access.", "keywords": ["ring", "token", "logical ring", "distributed", "mutual exclusion"], "source_lectures": ["lecture_106104182_w2_l12"]}}
{"id": "concept_lamports_algorithm", "type": "V_concept", "name": "Lamport's Algorithm", "properties": {"description": "A distributed mutual exclusion algorithm that uses logical clocks and timestamped messages to order requests and ensure mutual exclusion.", "keywords": ["lamport", "logical clock", "timestamp", "distributed", "mutual exclusion"], "source_lectures": ["lecture_106104182_w2_l12"]}}
{"id": "concept_logical_clock", "type": "V_concept", "name": "Logical Clock", "properties": {"description": "A mechanism for ordering events in a distributed system using counters incremented on message sends and receives.", "keywords": ["logical clock", "lamport clock", "event ordering", "distributed system", "timestamp"], "source_lectures": ["lecture_106104182_w2_l12"]}}
{"id": "concept_request_reply_release_protocol", "type": "V_concept", "name": "Request-Reply-Release Protocol", "properties": {"description": "A message pattern in distributed mutual exclusion where a process sends a request, receives replies from others, and releases access after use.", "keywords": ["request", "reply", "release", "message protocol", "mutual exclusion"], "source_lectures": ["lecture_106104182_w2_l12"]}}
{"id": "concept_quorum_based_mutual_exclusion", "type": "V_concept", "name": "Quorum-Based Mutual Exclusion", "properties": {"description": "A mutual exclusion technique where a process must obtain permission from a subset (quorum) of processes, not all, to enter the critical section.", "keywords": ["quorum", "subset", "distributed", "mutual exclusion", "permission"], "source_lectures": ["lecture_106104182_w2_l12"]}}
{"id": "concept_quorum_intersection_property", "type": "V_concept", "name": "Quorum Intersection Property", "properties": {"description": "A requirement that any two quorums in a system must have at least one process in common, ensuring mutual exclusion.", "keywords": ["quorum", "intersection", "mutual exclusion", "distributed system", "consensus"], "source_lectures": ["lecture_106104182_w2_l12"]}}
{"id": "concept_makawas_algorithm", "type": "V_concept", "name": "Makawa's Algorithm", "properties": {"description": "A quorum-based mutual exclusion algorithm where each process has a predefined quorum set, and access is granted only after receiving replies from all members.", "keywords": ["mukawa", "quorum", "distributed", "mutual exclusion", "request-reply"], "source_lectures": ["lecture_106104182_w2_l12"]}}
{"id": "concept_deadlock_in_distributed_systems", "type": "V_concept", "name": "Deadlock in Distributed Systems", "properties": {"description": "A situation where two or more processes are waiting indefinitely for each other to release resources, creating a circular wait.", "keywords": ["deadlock", "circular wait", "distributed system", "resource waiting", "mutual exclusion"], "source_lectures": ["lecture_106104182_w2_l12"]}}
{"id": "concept_deadlock_resolution_via_timestamps", "type": "V_concept", "name": "Deadlock Resolution via Timestamps", "properties": {"description": "A technique to break deadlocks by allowing higher-priority requests (based on timestamps) to override lower-priority ones and reclaim locks.", "keywords": ["deadlock", "timestamp", "priority", "lock", "resolution"], "source_lectures": ["lecture_106104182_w2_l12"]}}
{"id": "concept_inquiry_message", "type": "V_concept", "name": "Inquiry Message", "properties": {"description": "A message sent in deadlock resolution protocols to check whether a process holding a lock has successfully acquired all required permissions.", "keywords": ["inquiry", "deadlock", "lock", "check", "distributed"], "source_lectures": ["lecture_106104182_w2_l12"]}}
{"id": "concept_yield_message", "type": "V_concept", "name": "Yield Message", "properties": {"description": "A message sent to release a lock held by a lower-priority process, allowing a higher-priority process to proceed in deadlock resolution.", "keywords": ["yield", "lock", "priority", "deadlock", "release"], "source_lectures": ["lecture_106104182_w2_l12"]}}
{"id": "concept_failed_message", "type": "V_concept", "name": "Failed Message", "properties": {"description": "A message sent to reject a mutual exclusion request because a higher-priority request is already being processed.", "keywords": ["failed", "reject", "priority", "request", "mutual exclusion"], "source_lectures": ["lecture_106104182_w2_l12"]}}
{"id": "concept_advisory_lock", "type": "V_concept", "name": "Advisory Lock", "properties": {"description": "A lock mechanism where compliance is voluntary; mutual exclusion is enforced only if all clients cooperate by acquiring the lock before access.", "keywords": ["advisory lock", "voluntary", "cooperative", "lock", "mutual exclusion"], "source_lectures": ["lecture_106104182_w2_l12"]}}
{"id": "concept_chubby_lock_service", "type": "V_concept", "name": "Chubby Lock Service", "properties": {"description": "A distributed locking service developed by Google that uses Paxos to provide reliable, fault-tolerant locking for distributed systems.", "keywords": ["chubby", "google", "distributed lock", "paxos", "fault tolerance"], "source_lectures": ["lecture_106104182_w2_l12"]}}
{"id": "concept_bandwidth_efficiency_mutual_exclusion", "type": "V_concept", "name": "Bandwidth Efficiency (Mutual Exclusion)", "properties": {"description": "A performance metric measuring the total number of messages exchanged per critical section entry and exit in a mutual exclusion algorithm.", "keywords": ["bandwidth", "messages", "efficiency", "performance", "mutual exclusion"], "source_lectures": ["lecture_106104182_w2_l12"]}}
{"id": "concept_client_delay_mutual_exclusion", "type": "V_concept", "name": "Client Delay (Mutual Exclusion)", "properties": {"description": "The time a client waits to enter the critical section, measured from sending a request to receiving permission.", "keywords": ["client delay", "latency", "request", "response", "mutual exclusion"], "source_lectures": ["lecture_106104182_w2_l12"]}}
{"id": "concept_synchronization_delay", "type": "V_concept", "name": "Synchronization Delay", "properties": {"description": "The time interval between a process exiting the critical section and the next process entering it, including message transmission delays.", "keywords": ["synchronization delay", "latency", "transition", "critical section", "mutual exclusion"], "source_lectures": ["lecture_106104182_w2_l12"]}}
{"id": "concept_distributed_file_system", "type": "V_concept", "name": "Distributed File System", "properties": {"description": "A file system that allows multiple clients to access files stored across multiple servers, requiring mutual exclusion for concurrent access.", "keywords": ["distributed file system", "concurrent access", "file locking", "shared storage", "mutual exclusion"], "source_lectures": ["lecture_106104182_w2_l12"]}}
{"id": "concept_server_coordination", "type": "V_concept", "name": "Server Coordination", "properties": {"description": "The process of synchronizing actions among multiple servers in a distributed system, often using mutual exclusion for logging or state updates.", "keywords": ["server coordination", "distributed system", "synchronization", "logging", "mutual exclusion"], "source_lectures": ["lecture_106104182_w2_l12"]}}
{"id": "concept_logical_ordering_of_events", "type": "V_concept", "name": "Logical Ordering of Events", "properties": {"description": "The partial ordering of events in a distributed system based on causality, often implemented using logical clocks.", "keywords": ["logical ordering", "causality", "event ordering", "distributed system", "lamport clock"], "source_lectures": ["lecture_106104182_w2_l12"]}}
{"id": "concept_byzantine_agreement", "type": "V_concept", "name": "Byzantine Agreement", "properties": {"description": "A problem in distributed systems where a group of processes must agree on a single value, despite some processes being faulty or malicious.", "keywords": ["byzantine", "agreement", "distributed", "systems", "faulty"], "source_lectures": ["lecture_106104182_w2_l14"]}}
{"id": "concept_byzantine_fault_model", "type": "V_concept", "name": "Byzantine Fault Model", "properties": {"description": "A fault model that assumes a process can exhibit arbitrary behavior, including sending incorrect or misleading messages.", "keywords": ["byzantine", "fault", "model", "arbitrary", "behavior"], "source_lectures": ["lecture_106104182_w2_l14"]}}
{"id": "concept_fail_stop_fault_model", "type": "V_concept", "name": "Fail-Stop Fault Model", "properties": {"description": "A fault model that assumes a process fails by stopping its execution and other processes can detect the failure.", "keywords": ["fail-stop", "fault", "model", "execution", "detection"], "source_lectures": ["lecture_106104182_w2_l14"]}}
{"id": "concept_omission_fault_model", "type": "V_concept", "name": "Omission Fault Model", "properties": {"description": "A fault model that assumes a process fails by omitting some steps or messages.", "keywords": ["omission", "fault", "model", "steps", "messages"], "source_lectures": ["lecture_106104182_w2_l14"]}}
{"id": "concept_crash_fault_model", "type": "V_concept", "name": "Crash Fault Model", "properties": {"description": "A fault model that assumes a process fails by stopping its execution, but other processes cannot detect the failure.", "keywords": ["crash", "fault", "model", "execution", "undetection"], "source_lectures": ["lecture_106104182_w2_l14"]}}
{"id": "concept_synchronous_computation", "type": "V_concept", "name": "Synchronous Computation", "properties": {"description": "A model of computation where processes run in a lock-step manner, receiving and sending messages in a coordinated way.", "keywords": ["synchronous", "computation", "lock-step", "coordination"], "source_lectures": ["lecture_106104182_w2_l14"]}}
{"id": "concept_asynchronous_computation", "type": "V_concept", "name": "Asynchronous Computation", "properties": {"description": "A model of computation where processes run independently, sending and receiving messages at any time.", "keywords": ["asynchronous", "computation", "independent", "messages"], "source_lectures": ["lecture_106104182_w2_l14"]}}
{"id": "concept_network_connectivity", "type": "V_concept", "name": "Network Connectivity", "properties": {"description": "The ability of processes to communicate with each other through a network.", "keywords": ["network", "connectivity", "communication", "processes"], "source_lectures": ["lecture_106104182_w2_l14"]}}
{"id": "concept_sender_identification", "type": "V_concept", "name": "Sender Identification", "properties": {"description": "The ability of a process to identify the sender of a message.", "keywords": ["sender", "identification", "process", "message"], "source_lectures": ["lecture_106104182_w2_l14"]}}
{"id": "concept_channel_reliability", "type": "V_concept", "name": "Channel Reliability", "properties": {"description": "The assumption that communication channels are reliable and do not introduce errors or losses.", "keywords": ["channel", "reliability", "communication", "errors"], "source_lectures": ["lecture_106104182_w2_l14"]}}
{"id": "concept_authenticated_messages", "type": "V_concept", "name": "Authenticated Messages", "properties": {"description": "Messages that are verified to come from the claimed sender, using techniques such as digital signatures.", "keywords": ["authenticated", "messages", "verification", "digital", "signatures"], "source_lectures": ["lecture_106104182_w2_l14"]}}
{"id": "concept_unauthenticated_messages", "type": "V_concept", "name": "Unauthenticated Messages", "properties": {"description": "Messages that are not verified to come from the claimed sender, and may be forged or tampered with.", "keywords": ["unauthenticated", "messages", "forgery", "tampering"], "source_lectures": ["lecture_106104182_w2_l14"]}}
{"id": "concept_agreement_variable", "type": "V_concept", "name": "Agreement Variable", "properties": {"description": "A variable that is agreed upon by all processes in a distributed system.", "keywords": ["agreement", "variable", "distributed", "system"], "source_lectures": ["lecture_106104182_w2_l14"]}}
{"id": "concept_byzantine_general_problem", "type": "V_concept", "name": "Byzantine General Problem", "properties": {"description": "A problem where a group of generals must agree on a common battle plan, despite some generals being traitors.", "keywords": ["byzantine", "general", "problem", "traitors", "battle"], "source_lectures": ["lecture_106104182_w2_l14"]}}
{"id": "concept_lamport_shostak_pease_algorithm", "type": "V_concept", "name": "Lamport-Shostak-Pease Algorithm", "properties": {"description": "An algorithm for solving the Byzantine Agreement problem in a synchronous system.", "keywords": ["lamport", "shostak", "pease", "algorithm", "byzantine"], "source_lectures": ["lecture_106104182_w2_l14"]}}
{"id": "concept_terminating_reliable_broadcast", "type": "V_concept", "name": "Terminating Reliable Broadcast", "properties": {"description": "A problem where a process broadcasts a message to all other processes, and all correct processes must deliver the message.", "keywords": ["terminating", "reliable", "broadcast", "message", "delivery"], "source_lectures": ["lecture_106104182_w2_l14"]}}
{"id": "concept_reliable_broadcast", "type": "V_concept", "name": "Reliable Broadcast", "properties": {"description": "A problem where a process broadcasts a message to all other processes, and all correct processes must eventually deliver the message.", "keywords": ["reliable", "broadcast", "message", "delivery", "eventual"], "source_lectures": ["lecture_106104182_w2_l14"]}}
{"id": "concept_flp_impossibility_result", "type": "V_concept", "name": "FLP Impossibility Result", "properties": {"description": "A result that shows it is impossible to solve the consensus problem in an asynchronous system, even with a single faulty process.", "keywords": ["flp", "impossibility", "result", "consensus", "asynchronous"], "source_lectures": ["lecture_106104182_w2_l14"]}}
{"id": "concept_forward_recovery_method", "type": "V_concept", "name": "Forward Recovery Method", "properties": {"description": "A method of recovering from a failure by repairing the erroneous part of a system state to reach a valid state.", "keywords": ["forward", "recovery", "failure", "system", "state"], "source_lectures": ["lecture_106104182_w3_l15"]}}
{"id": "concept_backward_recovery_method", "type": "V_concept", "name": "Backward Recovery Method", "properties": {"description": "A method of recovering from a failure by restoring the system state to a previous error-free state.", "keywords": ["backward", "recovery", "failure", "system", "state"], "source_lectures": ["lecture_106104182_w3_l15"]}}
{"id": "concept_rollback_recovery", "type": "V_concept", "name": "Rollback Recovery", "properties": {"description": "A technique of recovering from a failure by rolling back the system state to a previous consistent state.", "keywords": ["rollback", "recovery", "failure", "system", "state"], "source_lectures": ["lecture_106104182_w3_l15"]}}
{"id": "concept_domino_effect", "type": "V_concept", "name": "Domino Effect", "properties": {"description": "A phenomenon where the rollback of one process causes a cascade of rollbacks in other processes.", "keywords": ["domino", "effect", "rollback", "process", "failure"], "source_lectures": ["lecture_106104182_w3_l15"]}}
{"id": "concept_livelock_problem", "type": "V_concept", "name": "Livelock Problem", "properties": {"description": "A situation where a single failure can cause an infinite number of rollbacks.", "keywords": ["livelock", "problem", "failure", "rollback", "infinite"], "source_lectures": ["lecture_106104182_w3_l15"]}}
{"id": "concept_orphan_message", "type": "V_concept", "name": "Orphan Message", "properties": {"description": "A message that is received by a process but its send is not recorded in the checkpoint.", "keywords": ["orphan", "message", "process", "checkpoint", "send"], "source_lectures": ["lecture_106104182_w3_l15"]}}
{"id": "concept_coordinated_checkpointing", "type": "V_concept", "name": "Coordinated Checkpointing", "properties": {"description": "A technique of coordinating the checkpointing of multiple processes to ensure a consistent global state.", "keywords": ["coordinated", "checkpointing", "process", "consistent", "global"], "source_lectures": ["lecture_106104182_w3_l15"]}}
{"id": "concept_uncoordinated_checkpointing", "type": "V_concept", "name": "Uncoordinated Checkpointing", "properties": {"description": "A technique of checkpointing where each process takes its checkpoints independently.", "keywords": ["uncoordinated", "checkpointing", "process", "independent"], "source_lectures": ["lecture_106104182_w3_l15"]}}
{"id": "concept_communication_induced_checkpointing", "type": "V_concept", "name": "Communication-Induced Checkpointing", "properties": {"description": "A technique of checkpointing that forces each process to take checkpoints based on information piggybacked on application messages.", "keywords": ["communication", "induced", "checkpointing", "process", "message"], "source_lectures": ["lecture_106104182_w3_l15"]}}
{"id": "concept_log_based_rollback_recovery", "type": "V_concept", "name": "Log-Based Rollback Recovery", "properties": {"description": "A technique of recovering from failures by combining checkpointing with logging of non-deterministic events.", "keywords": ["log", "based", "rollback", "recovery", "non-deterministic"], "source_lectures": ["lecture_106104182_w3_l15"]}}
{"id": "concept_pessimistic_logging", "type": "V_concept", "name": "Pessimistic Logging", "properties": {"description": "A logging protocol that assumes a failure can occur after any non-deterministic event and blocks the application until the determinant is stored on stable storage.", "keywords": ["pessimistic", "logging", "failure", "non-deterministic", "block"], "source_lectures": ["lecture_106104182_w3_l15"]}}
{"id": "concept_optimistic_logging", "type": "V_concept", "name": "Optimistic Logging", "properties": {"description": "A logging protocol that assumes a failure will not occur before the determinant is stored on stable storage and does not block the application.", "keywords": ["optimistic", "logging", "failure", "non-deterministic", "async"], "source_lectures": ["lecture_106104182_w3_l15"]}}
{"id": "concept_casual_logging", "type": "V_concept", "name": "Casual Logging", "properties": {"description": "A logging protocol that combines the advantages of pessimistic and optimistic logging by striking a balance between failure-free overhead and recovery complexity.", "keywords": ["casual", "logging", "failure", "non-deterministic", "balance"], "source_lectures": ["lecture_106104182_w3_l15"]}}
{"id": "concept_koo_toueg_coordinated_checkpointing_algorithm", "type": "V_concept", "name": "Koo-Toueg Coordinated Checkpointing Algorithm", "properties": {"description": "An algorithm for coordinated checkpointing and rollback recovery that takes a constant number of checkpoints and avoids the domino effect and livelock problem.", "keywords": ["koo", "toueg", "coordinated", "checkpointing", "algorithm"], "source_lectures": ["lecture_106104182_w3_l15"]}}
{"id": "concept_cassandra", "type": "V_concept", "name": "Cassandra", "properties": {"description": "A distributed NoSQL database that is designed to handle large amounts of data across many commodity servers.", "keywords": ["cassandra", "nosql", "database", "distributed", "storage"], "source_lectures": ["lecture_106104182_w3_l16"]}}
{"id": "concept_distributed_hash_table", "type": "V_concept", "name": "Distributed Hash Table", "properties": {"description": "A data structure that allows for efficient storage and retrieval of data in a distributed system.", "keywords": ["distributed", "hash", "table", "storage", "retrieval"], "source_lectures": ["lecture_106104182_w3_l16"]}}
{"id": "concept_partition_tolerance", "type": "V_concept", "name": "Partition Tolerance", "properties": {"description": "The ability of a distributed system to continue functioning even when there are network partitions or failures.", "keywords": ["partition", "tolerance", "distributed", "systems", "fault"], "source_lectures": ["lecture_106104182_w3_l16"]}}
{"id": "concept_availability", "type": "V_concept", "name": "Availability", "properties": {"description": "The ability of a system to be accessible and usable at all times.", "keywords": ["availability", "system", "accessibility", "usability"], "source_lectures": ["lecture_106104182_w3_l16"]}}
{"id": "concept_bloom_filter", "type": "V_concept", "name": "Bloom Filter", "properties": {"description": "A space-efficient probabilistic data structure that is used to test whether an element is a member of a set.", "keywords": ["hbase", "probabilistic", "structure", "filter", "bloom", "data"], "source_lectures": ["lecture_106104182_w3_l16", "lecture_106104182_w3_l17"]}}
{"id": "concept_compaction", "type": "V_concept", "name": "Compaction", "properties": {"description": "The process of merging multiple files or data structures into a single, more efficient file or data structure.", "keywords": ["compaction", "merging", "files", "data", "structure"], "source_lectures": ["lecture_106104182_w3_l16"]}}
{"id": "concept_read_repair", "type": "V_concept", "name": "Read Repair", "properties": {"description": "A mechanism used in distributed systems to ensure that data is consistent across all nodes.", "keywords": ["read", "repair", "distributed", "systems", "consistency"], "source_lectures": ["lecture_106104182_w3_l16"]}}
{"id": "concept_linearizability", "type": "V_concept", "name": "Linearizability", "properties": {"description": "A consistency model that guarantees that all operations are visible to all nodes in the system in a linearizable order.", "keywords": ["linearizability", "consistency", "model", "distributed", "systems"], "source_lectures": ["lecture_106104182_w3_l16"]}}
{"id": "concept_base_model", "type": "V_concept", "name": "BASE Model", "properties": {"description": "A set of properties that guarantee the availability and consistency of database transactions, including basic availability, soft-state, and eventual consistency.", "keywords": ["base", "model", "database", "transactions", "availability"], "source_lectures": ["lecture_106104182_w3_l16"]}}
{"id": "concept_hbase", "type": "V_concept", "name": "HBase", "properties": {"description": "An open source NoSQL database that is a distributed column-oriented data store", "keywords": ["hbase", "nosql", "database", "distributed", "column-oriented"], "source_lectures": ["lecture_106104182_w3_l17"]}}
{"id": "concept_horizontal_scaling", "type": "V_concept", "name": "Horizontal Scaling", "properties": {"description": "A method of scaling a system by adding more servers to handle increased load", "keywords": ["horizontal", "scaling", "distributed", "system", "load"], "source_lectures": ["lecture_106104182_w3_l17"]}}
{"id": "concept_column_family", "type": "V_concept", "name": "Column Family", "properties": {"description": "A group of columns in a HBase table that are stored together", "keywords": ["column", "family", "hbase", "table", "storage"], "source_lectures": ["lecture_106104182_w3_l17"]}}
{"id": "concept_hfile", "type": "V_concept", "name": "HFile", "properties": {"description": "A file format used by HBase to store data in HDFS", "keywords": ["hfile", "hbase", "hdfs", "storage", "file"], "source_lectures": ["lecture_106104182_w3_l17"]}}
{"id": "concept_hbase_architecture", "type": "V_concept", "name": "HBase Architecture", "properties": {"description": "The overall design and structure of the HBase system", "keywords": ["hbase", "architecture", "design", "structure", "system"], "source_lectures": ["lecture_106104182_w3_l17"]}}
{"id": "concept_region_server", "type": "V_concept", "name": "Region Server", "properties": {"description": "A server in HBase that manages a set of regions", "keywords": ["region", "server", "hbase", "management", "distributed"], "source_lectures": ["lecture_106104182_w3_l17"]}}
{"id": "concept_row_key", "type": "V_concept", "name": "Row Key", "properties": {"description": "A unique identifier for a row in a HBase table", "keywords": ["row", "key", "hbase", "table", "identifier"], "source_lectures": ["lecture_106104182_w3_l17"]}}
{"id": "concept_cell", "type": "V_concept", "name": "Cell", "properties": {"description": "The basic unit of storage in HBase, consisting of a row key, column family, column qualifier, and value", "keywords": ["cell", "hbase", "storage", "row", "column"], "source_lectures": ["lecture_106104182_w3_l17"]}}
{"id": "concept_cross_datacentre_replication", "type": "V_concept", "name": "Cross-Datacentre Replication", "properties": {"description": "A feature of HBase that allows data to be replicated across multiple data centers", "keywords": ["cross-datacentre", "replication", "hbase", "data", "center"], "source_lectures": ["lecture_106104182_w3_l17"]}}
{"id": "concept_auto_sharding", "type": "V_concept", "name": "Auto Sharding", "properties": {"description": "A feature of HBase that allows data to be automatically split into smaller regions", "keywords": ["auto", "sharding", "hbase", "data", "region"], "source_lectures": ["lecture_106104182_w3_l17"]}}
{"id": "concept_hlog", "type": "V_concept", "name": "HLog", "properties": {"description": "A write-ahead log used by HBase to ensure data consistency and durability", "keywords": ["hlog", "write-ahead", "log", "hbase", "consistency"], "source_lectures": ["lecture_106104182_w3_l17"]}}
{"id": "concept_memstore", "type": "V_concept", "name": "MemStore", "properties": {"description": "An in-memory store used by HBase to cache data before it is written to disk", "keywords": ["memstore", "in-memory", "store", "hbase", "cache"], "source_lectures": ["lecture_106104182_w3_l17"]}}
{"id": "concept_storefile", "type": "V_concept", "name": "StoreFile", "properties": {"description": "A file format used by HBase to store data on disk", "keywords": ["storefile", "file", "format", "hbase", "disk"], "source_lectures": ["lecture_106104182_w3_l17"]}}
{"id": "concept_mapreduce_programming_model", "type": "V_concept", "name": "MapReduce Programming Model", "properties": {"description": "A programming model for processing and generating large data sets using two functions: map and reduce, designed for parallel execution on distributed systems.", "keywords": ["mapreduce", "programming model", "map", "reduce", "distributed processing"], "source_lectures": ["lecture_106104182_w3_l19"]}}
{"id": "concept_reduce_function", "type": "V_concept", "name": "Reduce Function", "properties": {"description": "A user-defined function in MapReduce that merges intermediate values associated with the same key to produce final output key-value pairs.", "keywords": ["reduce", "function", "merge", "intermediate values", "aggregation"], "source_lectures": ["lecture_106104182_w3_l19"]}}
{"id": "concept_data_splitting", "type": "V_concept", "name": "Data Splitting", "properties": {"description": "The process of dividing large input files into fixed-size chunks (typically 16\u201364 MB) for parallel processing by multiple map tasks.", "keywords": ["splitting", "data split", "chunk", "input partitioning", "file splitting"], "source_lectures": ["lecture_106104182_w3_l19"]}}
{"id": "concept_shuffle_and_sort", "type": "V_concept", "name": "Shuffle and Sort", "properties": {"description": "The internal phase in MapReduce where intermediate key-value pairs are partitioned, sorted, and transferred from map tasks to reduce tasks based on keys.", "keywords": ["shuffle", "sort", "partitioning", "intermediate data", "data transfer"], "source_lectures": ["lecture_106104182_w3_l19"]}}
{"id": "concept_hash_partitioning", "type": "V_concept", "name": "Hash Partitioning", "properties": {"description": "A method used in MapReduce to assign intermediate keys to reduce tasks by applying a hash function to the key and taking modulo of the number of reducers.", "keywords": ["hash partitioning", "partition", "reduce task", "load balancing", "hash"], "source_lectures": ["lecture_106104182_w3_l19"]}}
{"id": "concept_speculative_execution", "type": "V_concept", "name": "Speculative Execution", "properties": {"description": "A fault tolerance technique in MapReduce where slow-running tasks (stragglers) are redundantly executed on other nodes to avoid job delays.", "keywords": ["speculative execution", "straggler", "fault tolerance", "redundant task", "performance optimization"], "source_lectures": ["lecture_106104182_w3_l19"]}}
{"id": "concept_hdfs_hadoop_distributed_file_system", "type": "V_concept", "name": "HDFS (Hadoop Distributed File System)", "properties": {"description": "A distributed file system designed to store large data sets across multiple machines with replication for fault tolerance and high throughput.", "keywords": ["hdfs", "distributed file system", "hadoop", "chunk server", "name node"], "source_lectures": ["lecture_106104182_w3_l19"]}}
{"id": "concept_replication_in_hdfs", "type": "V_concept", "name": "Replication in HDFS", "properties": {"description": "The default practice in HDFS of storing three copies of each data chunk across different racks to ensure rack-aware fault tolerance.", "keywords": ["replication", "hdfs replication", "fault tolerance", "rack awareness", "data redundancy"], "source_lectures": ["lecture_106104182_w3_l19"]}}
{"id": "concept_yarn_yet_another_resource_negotiator", "type": "V_concept", "name": "YARN (Yet Another Resource Negotiator)", "properties": {"description": "A resource management layer in Hadoop 2.0+ that schedules and manages computing resources across clusters using resource managers, node managers, and application masters.", "keywords": ["yarn", "resource manager", "node manager", "application master", "cluster scheduling"], "source_lectures": ["lecture_106104182_w3_l19"]}}
{"id": "concept_container_in_yarn", "type": "V_concept", "name": "Container in YARN", "properties": {"description": "A resource allocation unit in YARN representing a fixed amount of CPU and memory on a node, used to execute map or reduce tasks.", "keywords": ["container", "yarn container", "resource unit", "cpu memory", "task execution"], "source_lectures": ["lecture_106104182_w3_l19"]}}
{"id": "concept_word_count_example", "type": "V_concept", "name": "Word Count Example", "properties": {"description": "A canonical MapReduce application that counts occurrences of each word in a large text corpus by emitting (word, 1) in map and summing values in reduce.", "keywords": ["word count", "mapreduce example", "counting", "text processing", "aggregation"], "source_lectures": ["lecture_106104182_w3_l19"]}}
{"id": "concept_reverse_web_link_graph", "type": "V_concept", "name": "Reverse Web Link Graph", "properties": {"description": "A MapReduce application that identifies all pages linking to a given page by reversing source-target pairs from a web graph.", "keywords": ["reverse link graph", "web graph", "link analysis", "page ranking", "mapreduce application"], "source_lectures": ["lecture_106104182_w3_l19"]}}
{"id": "concept_distributed_sort", "type": "V_concept", "name": "Distributed Sort", "properties": {"description": "A MapReduce application that sorts large datasets by using range-based partitioning to preserve sorted order across map and reduce phases.", "keywords": ["distributed sort", "sorting", "range partitioning", "sorted output", "mapreduce sorting"], "source_lectures": ["lecture_106104182_w3_l19"]}}
{"id": "concept_url_access_frequency_count", "type": "V_concept", "name": "URL Access Frequency Count", "properties": {"description": "A two-phase MapReduce application that first counts total URL accesses and then computes the percentage of each URL\u2019s access relative to the total.", "keywords": ["url access", "frequency count", "two-phase mapreduce", "percentage calculation", "cascaded jobs"], "source_lectures": ["lecture_106104182_w3_l19"]}}
{"id": "concept_term_vector_per_host", "type": "V_concept", "name": "Term Vector Per Host", "properties": {"description": "A MapReduce application that summarizes the most frequent words in documents per host, producing a word-frequency list for each host.", "keywords": ["term vector", "word frequency", "host-based analysis", "text summarization", "mapreduce application"], "source_lectures": ["lecture_106104182_w3_l19"]}}
{"id": "concept_common_friends_detection", "type": "V_concept", "name": "Common Friends Detection", "properties": {"description": "A MapReduce application that finds mutual friends between pairs of users by emitting friend pairs and computing intersections in the reduce phase.", "keywords": ["common friends", "social network", "intersection", "friendship graph", "mapreduce application"], "source_lectures": ["lecture_106104182_w3_l19"]}}
{"id": "concept_straggler_task", "type": "V_concept", "name": "Straggler Task", "properties": {"description": "A map or reduce task that runs significantly slower than others, potentially delaying the entire MapReduce job due to barrier synchronization.", "keywords": ["straggler", "slow task", "job delay", "performance bottleneck", "mapreduce fault"], "source_lectures": ["lecture_106104182_w3_l19"]}}
{"id": "concept_locality_awareness", "type": "V_concept", "name": "Locality Awareness", "properties": {"description": "A scheduling optimization in MapReduce that assigns tasks to nodes physically close to the data to minimize network transfer latency.", "keywords": ["locality", "data locality", "rack awareness", "network latency", "scheduling optimization"], "source_lectures": ["lecture_106104182_w3_l19"]}}
{"id": "concept_master_node_in_hdfs", "type": "V_concept", "name": "Master Node in HDFS", "properties": {"description": "The central node in HDFS that manages metadata, including file system namespace and access permissions, and tracks chunk locations.", "keywords": ["name node", "hdfs master", "metadata", "file system namespace", "chunk location"], "source_lectures": ["lecture_106104182_w3_l19"]}}
{"id": "concept_chunk_server_in_hdfs", "type": "V_concept", "name": "Chunk Server in HDFS", "properties": {"description": "A data node in HDFS that stores actual data chunks (16\u201364 MB) and serves read/write requests from clients.", "keywords": ["chunk server", "data node", "hdfs storage", "data chunk", "block storage"], "source_lectures": ["lecture_106104182_w3_l19"]}}
{"id": "concept_cascaded_mapreduce_jobs", "type": "V_concept", "name": "Cascaded MapReduce Jobs", "properties": {"description": "A technique where the output of one MapReduce job is used as the input to another, enabling complex multi-stage data processing.", "keywords": ["cascaded jobs", "multi-stage mapreduce", "job chaining", "complex processing", "pipeline"], "source_lectures": ["lecture_106104182_w3_l19"]}}
{"id": "concept_input_split", "type": "V_concept", "name": "Input Split", "properties": {"description": "A logical division of input data in MapReduce, typically 16\u201364 MB in size, assigned to a single map task for processing.", "keywords": ["input split", "split", "map task input", "data chunk", "file partition"], "source_lectures": ["lecture_106104182_w3_l19"]}}
{"id": "concept_intermediate_key_value_pairs", "type": "V_concept", "name": "Intermediate Key-Value Pairs", "properties": {"description": "The output generated by map tasks, consisting of keys and associated values that are grouped and passed to reduce tasks.", "keywords": ["intermediate key-value", "map output", "shuffled data", "temporary data", "reduce input"], "source_lectures": ["lecture_106104182_w3_l19"]}}
{"id": "concept_output_file_in_mapreduce", "type": "V_concept", "name": "Output File in MapReduce", "properties": {"description": "The final result of a MapReduce job, stored in a distributed file system, with one file per reduce task.", "keywords": ["output file", "final result", "reduce output", "distributed storage", "mapreduce result"], "source_lectures": ["lecture_106104182_w3_l19"]}}
{"id": "concept_application_master_in_yarn", "type": "V_concept", "name": "Application Master in YARN", "properties": {"description": "A per-job component in YARN that negotiates resources from the Resource Manager and coordinates task execution and failure recovery.", "keywords": ["application master", "yarn application", "job coordinator", "task management", "failure recovery"], "source_lectures": ["lecture_106104182_w3_l19"]}}
{"id": "concept_node_manager_in_yarn", "type": "V_concept", "name": "Node Manager in YARN", "properties": {"description": "A per-node daemon in YARN that manages local resources, launches containers, and reports status to the Resource Manager.", "keywords": ["node manager", "yarn node", "resource monitoring", "container management", "node status"], "source_lectures": ["lecture_106104182_w3_l19"]}}
{"id": "concept_resource_manager_in_yarn", "type": "V_concept", "name": "Resource Manager in YARN", "properties": {"description": "The central authority in YARN that arbitrates resources among all applications and schedules containers across the cluster.", "keywords": ["resource manager", "yarn scheduler", "cluster resource", "scheduling", "allocation"], "source_lectures": ["lecture_106104182_w3_l19"]}}
{"id": "concept_apache_spark", "type": "V_concept", "name": "Apache Spark", "properties": {"description": "An open-source big data analytics framework for large-scale data processing", "keywords": ["spark", "bigdata", "analytics", "framework"], "source_lectures": ["lecture_106104182_w3_l20"]}}
{"id": "concept_resilient_distributed_datasets", "type": "V_concept", "name": "Resilient Distributed Datasets", "properties": {"description": "A fundamental data structure in Apache Spark that represents a collection of elements that can be split across nodes in the cluster", "keywords": ["rdd", "spark", "distributed", "dataset"], "source_lectures": ["lecture_106104182_w3_l20"]}}
{"id": "concept_pagerank_algorithm", "type": "V_concept", "name": "PageRank Algorithm", "properties": {"description": "A link analysis algorithm used to rank web pages in order of importance", "keywords": ["pagerank", "algorithm", "link", "analysis"], "source_lectures": ["lecture_106104182_w3_l20"]}}
{"id": "concept_graphx", "type": "V_concept", "name": "GraphX", "properties": {"description": "A library for graph processing in Apache Spark", "keywords": ["graphx", "spark", "graph", "processing"], "source_lectures": ["lecture_106104182_w3_l20"]}}
{"id": "concept_lineage", "type": "V_concept", "name": "Lineage", "properties": {"description": "A mechanism in Apache Spark for tracking the lineage of Resilient Distributed Datasets (RDDs) to enable efficient fault tolerance", "keywords": ["lineage", "spark", "rdd", "fault"], "source_lectures": ["lecture_106104182_w3_l20"]}}
{"id": "concept_coarse_grained_operations", "type": "V_concept", "name": "Coarse-Grained Operations", "properties": {"description": "Operations that involve large chunks of data and are typically used in parallel processing", "keywords": ["coarse", "grained", "operations", "parallel"], "source_lectures": ["lecture_106104182_w3_l20"]}}
{"id": "concept_hash_based_partitioning", "type": "V_concept", "name": "Hash-Based Partitioning", "properties": {"description": "A technique for partitioning data across nodes in a cluster using hash functions", "keywords": ["hash", "partitioning", "data", "cluster"], "source_lectures": ["lecture_106104182_w3_l20"]}}
{"id": "concept_gather_apply_scatter", "type": "V_concept", "name": "Gather Apply Scatter", "properties": {"description": "A programming model for graph processing that involves gathering data, applying operations, and scattering results", "keywords": ["gather", "apply", "scatter", "graph"], "source_lectures": ["lecture_106104182_w3_l20"]}}
{"id": "concept_triplets", "type": "V_concept", "name": "Triplets", "properties": {"description": "A data structure used in GraphX to represent graph data as a collection of triples", "keywords": ["triplets", "graphx", "graph", "data"], "source_lectures": ["lecture_106104182_w3_l20"]}}
{"id": "concept_vertex_table", "type": "V_concept", "name": "Vertex Table", "properties": {"description": "A table in GraphX that stores vertex data", "keywords": ["vertex", "table", "graphx", "data"], "source_lectures": ["lecture_106104182_w3_l20"]}}
{"id": "concept_edge_table", "type": "V_concept", "name": "Edge Table", "properties": {"description": "A table in GraphX that stores edge data", "keywords": ["edge", "table", "graphx", "data"], "source_lectures": ["lecture_106104182_w3_l20"]}}
{"id": "concept_forward_recovery", "type": "V_concept", "name": "Forward Recovery", "properties": {"description": "A method of recovering from failures by repairing the erroneous part of the system state", "keywords": ["forward", "recovery", "failure", "system"], "source_lectures": ["lecture_106104182_w3_l20"]}}
{"id": "concept_backward_recovery", "type": "V_concept", "name": "Backward Recovery", "properties": {"description": "A method of recovering from failures by restoring the system state to a previous error-free state", "keywords": ["backward", "recovery", "failure", "system"], "source_lectures": ["lecture_106104182_w3_l20"]}}
{"id": "concept_apache_kafka", "type": "V_concept", "name": "Apache Kafka", "properties": {"description": "An open-source, distributed streaming platform for handling high-throughput and provides low-latency, fault-tolerant, and scalable data processing.", "keywords": ["kafka", "streaming", "distributed", "scalable"], "source_lectures": ["lecture_106104182_w3_l21"]}}
{"id": "concept_streaming_data", "type": "V_concept", "name": "Streaming Data", "properties": {"description": "A continuous flow of data that is generated and processed in real-time, often from various sources such as sensors, applications, or social media.", "keywords": ["streaming", "data", "real-time", "continuous"], "source_lectures": ["lecture_106104182_w3_l21"]}}
{"id": "concept_publish_subscribe_messaging_system", "type": "V_concept", "name": "Publish-Subscribe Messaging System", "properties": {"description": "A messaging paradigm where publishers send messages to a topic, and subscribers receive messages from that topic without knowing the identity of the publishers.", "keywords": ["publish-subscribe", "messaging", "system", "topic"], "source_lectures": ["lecture_106104182_w3_l21"]}}
{"id": "concept_queue_based_messaging_system", "type": "V_concept", "name": "Queue-Based Messaging System", "properties": {"description": "A messaging paradigm where messages are stored in a queue, and consumers retrieve messages from the queue, often used for point-to-point communication.", "keywords": ["queue-based", "messaging", "system", "point-to-point"], "source_lectures": ["lecture_106104182_w3_l21"]}}
{"id": "concept_kafka_broker", "type": "V_concept", "name": "Kafka Broker", "properties": {"description": "A server that runs in a Kafka cluster, responsible for maintaining a subset of the overall data and handling client requests.", "keywords": ["kafka", "broker", "server", "cluster"], "source_lectures": ["lecture_106104182_w3_l21"]}}
{"id": "concept_kafka_topic", "type": "V_concept", "name": "Kafka Topic", "properties": {"description": "A named stream of related data in Kafka, which is divided into partitions and replicated across multiple brokers for fault tolerance.", "keywords": ["kafka", "topic", "stream", "partitions"], "source_lectures": ["lecture_106104182_w3_l21"]}}
{"id": "concept_replication_factor", "type": "V_concept", "name": "Replication Factor", "properties": {"description": "The number of copies of a partition that are maintained in a Kafka cluster, which determines the level of fault tolerance and data durability.", "keywords": ["replication", "factor", "kafka", "fault-tolerance"], "source_lectures": ["lecture_106104182_w3_l21"]}}
{"id": "concept_distributed_system", "type": "V_concept", "name": "Distributed System", "properties": {"description": "A system in which components are located on different computers or nodes, which communicate with each other to achieve a common goal.", "keywords": ["distributed", "system", "nodes", "communication"], "source_lectures": ["lecture_106104182_w4_l22"]}}
{"id": "concept_microservices_architecture", "type": "V_concept", "name": "Microservices Architecture", "properties": {"description": "A software architecture style that structures an application as a collection of small, independent services.", "keywords": ["microservices", "architecture", "independent", "services", "modular architecture", "independent deployment", "service boundary", "service-oriented"], "source_lectures": ["lecture_106104182_w4_l22", "lecture_106104449_w1_l6"]}}
{"id": "concept_big_data", "type": "V_concept", "name": "Big Data", "properties": {"description": "A term used to describe large, complex datasets that are difficult to process using traditional data processing tools.", "keywords": ["big data", "large", "complex", "datasets"], "source_lectures": ["lecture_106104182_w4_l22"]}}
{"id": "concept_lamport_timestamps", "type": "V_concept", "name": "Lamport Timestamps", "properties": {"description": "A method for assigning timestamps to events in a distributed system, based on the concept of causal ordering.", "keywords": ["lamport", "timestamps", "distributed system", "causal ordering"], "source_lectures": ["lecture_106104182_w4_l22"]}}
{"id": "concept_elastic_mapreduce", "type": "V_concept", "name": "Elastic MapReduce", "properties": {"description": "A service offered by cloud providers that allows users to run MapReduce jobs on a scalable, on-demand basis.", "keywords": ["elastic mapreduce", "mapreduce", "cloud providers", "scalable"], "source_lectures": ["lecture_106104182_w4_l22"]}}
{"id": "concept_cloud_computing_specialization", "type": "V_concept", "name": "Cloud Computing Specialization", "properties": {"description": "A structured series of courses covering foundational to advanced cloud computing concepts, virtualization, and cloud networking.", "keywords": ["cloud", "specialization", "courses", "curriculum"], "source_lectures": ["lecture_106104182_w4_l23"]}}
{"id": "concept_data_center_architecture", "type": "V_concept", "name": "Data Center Architecture", "properties": {"description": "A hierarchical structure comprising racks of servers interconnected in large-scale facilities housing cloud infrastructure.", "keywords": ["data center", "servers", "racks", "hierarchy"], "source_lectures": ["lecture_106104182_w4_l23"]}}
{"id": "concept_data_intensive_computation", "type": "V_concept", "name": "Data Intensive Computation", "properties": {"description": "Processing paradigms optimized for large datasets where computation occurs near data sources to minimize movement.", "keywords": ["data-intensive", "big data", "computation", "storage"], "source_lectures": ["lecture_106104182_w4_l23"]}}
{"id": "concept_cloud_programming_paradigm", "type": "V_concept", "name": "Cloud Programming Paradigm", "properties": {"description": "Specialized programming models like MapReduce and Spark designed for distributed big data processing in the cloud.", "keywords": ["mapreduce", "spark", "distributed", "programming"], "source_lectures": ["lecture_106104182_w4_l23"]}}
{"id": "concept_nosql_databases", "type": "V_concept", "name": "NoSQL Databases", "properties": {"description": "Non-relational databases such as Cassandra and MongoDB that store data as key-value pairs for scalability.", "keywords": ["nosql", "cassandra", "mongodb", "database"], "source_lectures": ["lecture_106104182_w4_l23"]}}
{"id": "concept_cloud_security_policies", "type": "V_concept", "name": "Cloud Security Policies", "properties": {"description": "Controls and protocols including encryption and access management to protect data and resources in cloud environments.", "keywords": ["security", "encryption", "access control", "policies"], "source_lectures": ["lecture_106104182_w4_l23"]}}
{"id": "concept_disaster_recovery", "type": "V_concept", "name": "Disaster Recovery", "properties": {"description": "Strategies for automatic system restoration and data replication during failures in cloud infrastructures.", "keywords": ["disaster", "recovery", "replication", "fault tolerance"], "source_lectures": ["lecture_106104182_w4_l23"]}}
{"id": "concept_leader_election_problem", "type": "V_concept", "name": "Leader Election Problem", "properties": {"description": "A distributed systems challenge for selecting a coordinator node dynamically in the presence of failures.", "keywords": ["leader", "election", "distributed", "coordinator"], "source_lectures": ["lecture_106104182_w4_l23"]}}
{"id": "concept_zookeeper_service", "type": "V_concept", "name": "ZooKeeper Service", "properties": {"description": "A coordination service using Paxos protocol for reliable leader election and failure management in distributed systems.", "keywords": ["zookeeper", "paxos", "coordination", "failure"], "source_lectures": ["lecture_106104182_w4_l23"]}}
{"id": "concept_virtual_machine_migration", "type": "V_concept", "name": "Virtual Machine Migration", "properties": {"description": "The process of relocating virtual machines between physical servers while maintaining operational continuity.", "keywords": ["vm", "migration", "live migration", "server"], "source_lectures": ["lecture_106104182_w4_l23"]}}
{"id": "concept_virtual_machine_vm", "type": "V_concept", "name": "Virtual Machine (VM)", "properties": {"description": "A full virtualized computing environment that emulates a physical computer, including its own guest operating system and hardware abstraction layer.", "keywords": ["virtual machine", "vm", "hypervisor", "guest os", "hardware virtualization"], "source_lectures": ["lecture_106104449_w1_l6"]}}
{"id": "concept_container_vs_virtual_machine", "type": "V_concept", "name": "Container vs Virtual Machine", "properties": {"description": "A comparison highlighting that containers share the host OS kernel and are lightweight, while virtual machines include a full guest OS and require more resources.", "keywords": ["container vs vm", "virtualization comparison", "resource efficiency", "isolation level", "boot time"], "source_lectures": ["lecture_106104449_w1_l6"]}}
{"id": "concept_docker_image", "type": "V_concept", "name": "Docker Image", "properties": {"description": "A lightweight, standalone, executable package that includes code, runtime, libraries, and configuration needed to run an application, serving as a template for containers.", "keywords": ["docker image", "image", "container template", "dockerfile", "layered filesystem"], "source_lectures": ["lecture_106104449_w1_l6"]}}
{"id": "concept_dockerfile", "type": "V_concept", "name": "Dockerfile", "properties": {"description": "A text script containing instructions to build a Docker image, specifying base images, dependencies, environment setup, and execution commands.", "keywords": ["dockerfile", "image build", "container build", "instructions", "docker build"], "source_lectures": ["lecture_106104449_w1_l6"]}}
{"id": "concept_container_runtime", "type": "V_concept", "name": "Container Runtime", "properties": {"description": "The software component responsible for executing and managing containers, leveraging OS features like namespaces and cgroups for isolation and resource control.", "keywords": ["container runtime", "runc", "containerd", "isolation", "cgroups"], "source_lectures": ["lecture_106104449_w1_l6"]}}
{"id": "concept_namespaces", "type": "V_concept", "name": "Namespaces", "properties": {"description": "Linux kernel features that isolate processes, networks, file systems, and other resources to provide separate views for each container, enabling process isolation.", "keywords": ["namespaces", "linux namespaces", "isolation", "pid namespace", "network namespace"], "source_lectures": ["lecture_106104449_w1_l6"]}}
{"id": "concept_control_groups_cgroups", "type": "V_concept", "name": "Control Groups (cgroups)", "properties": {"description": "Linux kernel functionality that limits, accounts for, and isolates the resource usage (CPU, memory, disk I/O) of a collection of processes, commonly used for container resource management.", "keywords": ["cgroups", "resource control", "linux cgroups", "cpu limit", "memory limit"], "source_lectures": ["lecture_106104449_w1_l6"]}}
{"id": "concept_container_as_a_service_caas", "type": "V_concept", "name": "Container as a Service (CaaS)", "properties": {"description": "A cloud computing service model that provides platforms for deploying, managing, and scaling containerized applications without managing underlying infrastructure.", "keywords": ["caas", "container as a service", "cloud container", "orchestration", "managed containers"], "source_lectures": ["lecture_106104449_w1_l6"]}}
{"id": "concept_kubernetes", "type": "V_concept", "name": "Kubernetes", "properties": {"description": "An open-source container orchestration platform that automates deployment, scaling, and management of containerized applications across clusters of hosts.", "keywords": ["container", "deployment", "kubernetes", "container orchestration", "scaling", "orchestration", "k8s", "pod"], "source_lectures": ["lecture_106104449_w1_l6", "lecture_106104449_w1_l7"]}}
{"id": "concept_12_factor_app_methodology", "type": "V_concept", "name": "12-Factor App Methodology", "properties": {"description": "A set of best practices for building software-as-a-service applications that emphasize portability, scalability, and resilience through statelessness and configuration management.", "keywords": ["12-factor", "app methodology", "cloud native", "stateless", "config management"], "source_lectures": ["lecture_106104449_w1_l6"]}}
{"id": "concept_docker_volumes", "type": "V_concept", "name": "Docker Volumes", "properties": {"description": "Persistent storage mechanisms in Docker that allow data to be shared between containers and the host system, surviving container restarts or deletions.", "keywords": ["docker volumes", "persistent storage", "data persistence", "volume mount", "host storage"], "source_lectures": ["lecture_106104449_w1_l6"]}}
{"id": "concept_docker_network_bridge", "type": "V_concept", "name": "Docker Network Bridge", "properties": {"description": "A default Docker network mode that enables communication between containers on the same host using a virtual Ethernet bridge.", "keywords": ["bridge network", "docker network", "container communication", "virtual bridge", "local networking"], "source_lectures": ["lecture_106104449_w1_l6"]}}
{"id": "concept_overlay_network", "type": "V_concept", "name": "Overlay Network", "properties": {"description": "A Docker network type that enables communication between containers running on different hosts, essential for distributed applications in orchestration platforms.", "keywords": ["overlay network", "multi-host networking", "docker swarm", "kubernetes networking", "cross-host communication"], "source_lectures": ["lecture_106104449_w1_l6"]}}
{"id": "concept_docker_registry", "type": "V_concept", "name": "Docker Registry", "properties": {"description": "A storage and distribution system for Docker images, allowing teams to push, pull, and version container images for deployment across environments.", "keywords": ["docker registry", "image registry", "docker hub", "container registry", "image repository"], "source_lectures": ["lecture_106104449_w1_l6"]}}
{"id": "concept_docker_daemon_dockerd", "type": "V_concept", "name": "Docker Daemon (dockerd)", "properties": {"description": "The background service running on the host machine that manages Docker objects such as images, containers, networks, and volumes, responding to API requests.", "keywords": ["docker daemon", "dockerd", "container management", "docker api", "host service"], "source_lectures": ["lecture_106104449_w1_l6"]}}
{"id": "concept_docker_cli", "type": "V_concept", "name": "Docker CLI", "properties": {"description": "The command-line interface used by users and developers to interact with the Docker daemon to build, run, and manage containers and images.", "keywords": ["docker cli", "command line", "docker commands", "docker run", "docker build"], "source_lectures": ["lecture_106104449_w1_l6"]}}
{"id": "concept_container_orchestration", "type": "V_concept", "name": "Container Orchestration", "properties": {"description": "The automated management of containerized applications, including deployment, scaling, networking, and lifecycle management across multiple hosts.", "keywords": ["container", "swarm", "kubernetes", "container orchestration", "production", "orchestration", "lifecycle", "management", "auto scaling"], "source_lectures": ["lecture_106104449_w1_l6", "lecture_106104449_w1_l7"]}}
{"id": "concept_portability_in_containers", "type": "V_concept", "name": "Portability in Containers", "properties": {"description": "The ability of containerized applications to run consistently across different environments (development, testing, production) due to encapsulated dependencies.", "keywords": ["portability", "consistent environment", "container portability", "cross-platform", "dependency encapsulation"], "source_lectures": ["lecture_106104449_w1_l6"]}}
{"id": "concept_isolation_in_containers", "type": "V_concept", "name": "Isolation in Containers", "properties": {"description": "The separation of application processes and resources within containers using OS-level mechanisms like namespaces and cgroups to prevent interference.", "keywords": ["isolation", "container isolation", "process isolation", "security boundary", "namespaces"], "source_lectures": ["lecture_106104449_w1_l6"]}}
{"id": "concept_resource_efficiency_in_containers", "type": "V_concept", "name": "Resource Efficiency in Containers", "properties": {"description": "The ability of containers to use fewer system resources than virtual machines by sharing the host OS kernel and avoiding redundant OS layers.", "keywords": ["resource efficiency", "lightweight", "low overhead", "memory usage", "cpu efficiency"], "source_lectures": ["lecture_106104449_w1_l6"]}}
{"id": "concept_fast_container_startup", "type": "V_concept", "name": "Fast Container Startup", "properties": {"description": "The ability of containers to start in seconds due to the absence of a guest OS boot process and direct use of the host kernel.", "keywords": ["fast startup", "container boot time", "instantiation", "rapid deployment", "lightweight startup"], "source_lectures": ["lecture_106104449_w1_l6"]}}
{"id": "concept_open_container_initiative_oci", "type": "V_concept", "name": "Open Container Initiative (OCI)", "properties": {"description": "An industry-standard organization that defines open standards for container formats and runtimes to ensure interoperability across platforms.", "keywords": ["oci", "open container initiative", "container standard", "runtime spec", "image spec"], "source_lectures": ["lecture_106104449_w1_l6"]}}
{"id": "concept_docker_containerd", "type": "V_concept", "name": "Docker Containerd", "properties": {"description": "A standalone container runtime donated by Docker to the Cloud Native Computing Foundation, serving as the core component for executing containers.", "keywords": ["containerd", "docker containerd", "container runtime", "cnf", "cncf"], "source_lectures": ["lecture_106104449_w1_l6"]}}
{"id": "concept_devops_integration_with_containers", "type": "V_concept", "name": "DevOps Integration with Containers", "properties": {"description": "The alignment of containerization with DevOps practices to enable continuous integration and continuous deployment (CI/CD) pipelines.", "keywords": ["devops", "ci/cd", "continuous deployment", "container ci/cd", "automation"], "source_lectures": ["lecture_106104449_w1_l6"]}}
{"id": "concept_pay_as_you_go_model_for_caas", "type": "V_concept", "name": "Pay-as-you-go Model for CaaS", "properties": {"description": "A pricing model in Container as a Service where users pay only for the compute, storage, and network resources consumed by their containerized applications.", "keywords": ["pay as you go", "caas pricing", "cloud billing", "usage-based pricing", "cost efficiency"], "source_lectures": ["lecture_106104449_w1_l6"]}}
{"id": "concept_microservice_architecture", "type": "V_concept", "name": "Microservice Architecture", "properties": {"description": "A software development technique that structures an application as a collection of small, independent services.", "keywords": ["microservice", "architecture", "software", "development", "independent"], "source_lectures": ["lecture_106104449_w1_l7"]}}
{"id": "concept_kubernetes_control_plane", "type": "V_concept", "name": "Kubernetes Control Plane", "properties": {"description": "The central management component of a Kubernetes cluster, responsible for maintaining the cluster's state and making decisions about node assignments.", "keywords": ["kubernetes", "control", "plane", "management", "cluster"], "source_lectures": ["lecture_106104449_w1_l7"]}}
{"id": "concept_pod", "type": "V_concept", "name": "Pod", "properties": {"description": "The smallest deployable unit in Kubernetes, representing a logical host for one or more containers.", "keywords": ["pod", "deployable", "unit", "kubernetes", "container"], "source_lectures": ["lecture_106104449_w1_l7"]}}
{"id": "concept_replica_set", "type": "V_concept", "name": "Replica Set", "properties": {"description": "A Kubernetes component that ensures a specified number of replicas of a pod are running at all times.", "keywords": ["replica", "set", "kubernetes", "pod", "replication"], "source_lectures": ["lecture_106104449_w1_l7"]}}
{"id": "concept_deployment", "type": "V_concept", "name": "Deployment", "properties": {"description": "A Kubernetes object that manages the rollout of new versions of an application, including rolling updates and rollbacks.", "keywords": ["deployment", "kubernetes", "rollout", "update", "rollback"], "source_lectures": ["lecture_106104449_w1_l7"]}}
{"id": "concept_service", "type": "V_concept", "name": "Service", "properties": {"description": "A Kubernetes object that provides a stable network identity and load balancing for accessing a group of pods.", "keywords": ["service", "kubernetes", "network", "identity", "load", "balancing"], "source_lectures": ["lecture_106104449_w1_l7"]}}
{"id": "concept_persistent_volume", "type": "V_concept", "name": "Persistent Volume", "properties": {"description": "A Kubernetes resource that provides persistent storage for data, allowing it to be preserved even if a pod is deleted or recreated.", "keywords": ["persistent", "volume", "kubernetes", "storage", "data"], "source_lectures": ["lecture_106104449_w1_l7"]}}
{"id": "concept_config_map", "type": "V_concept", "name": "Config Map", "properties": {"description": "A Kubernetes object that stores configuration data as key-value pairs, allowing it to be decoupled from container images.", "keywords": ["config", "map", "kubernetes", "configuration", "data"], "source_lectures": ["lecture_106104449_w1_l7"]}}
{"id": "concept_secret", "type": "V_concept", "name": "Secret", "properties": {"description": "A Kubernetes object that stores sensitive data, such as passwords or API keys, and makes it available to pods.", "keywords": ["secret", "kubernetes", "sensitive", "data", "password"], "source_lectures": ["lecture_106104449_w1_l7"]}}
{"id": "concept_self_healing_system", "type": "V_concept", "name": "Self-Healing System", "properties": {"description": "A system that can automatically detect and recover from failures, such as node failures or application crashes.", "keywords": ["self-healing", "system", "failure", "recovery", "automatic"], "source_lectures": ["lecture_106104449_w1_l7"]}}
{"id": "concept_autoscaling", "type": "V_concept", "name": "Autoscaling", "properties": {"description": "The ability of a system to automatically adjust its resources, such as the number of replicas, in response to changes in load or demand.", "keywords": ["autoscaling", "system", "resource", "adjustment", "load"], "source_lectures": ["lecture_106104449_w1_l7"]}}
{"id": "concept_high_availability", "type": "V_concept", "name": "High Availability", "properties": {"description": "The ability of a system to maintain its functionality and responsiveness even in the event of failures or outages.", "keywords": ["high", "availability", "system", "functionality", "responsiveness"], "source_lectures": ["lecture_106104449_w1_l7"]}}
{"id": "concept_edge_intelligence", "type": "V_concept", "name": "Edge Intelligence", "properties": {"description": "A framework for deploying and running AI models directly on edge devices to enable distributed, low-latency intelligent services.", "keywords": ["edge", "ai", "inference", "distributed", "latency"], "source_lectures": ["lecture_106104449_w2_l9"]}}
{"id": "concept_intelligent_edge", "type": "V_concept", "name": "Intelligent Edge", "properties": {"description": "The integration of artificial intelligence into edge infrastructure to optimize maintenance, management, and decision-making processes.", "keywords": ["edge", "ai", "optimization", "management", "adaptive"], "source_lectures": ["lecture_106104449_w2_l9"]}}
{"id": "concept_iot_gateway", "type": "V_concept", "name": "IoT Gateway", "properties": {"description": "An intermediary device facilitating communication between IoT devices and the cloud by translating protocols and preprocessing data.", "keywords": ["iot", "gateway", "protocol", "preprocessing", "communication"], "source_lectures": ["lecture_106104449_w2_l9"]}}
{"id": "concept_azure_iot_hub", "type": "V_concept", "name": "Azure IoT Hub", "properties": {"description": "A managed cloud service enabling bidirectional communication, device management, and security for IoT ecosystems.", "keywords": ["azure", "iot", "hub", "communication", "management"], "source_lectures": ["lecture_106104449_w2_l9"]}}
{"id": "concept_azure_iot_edge", "type": "V_concept", "name": "Azure IoT Edge", "properties": {"description": "A hybrid service deploying containerized workloads to edge devices for local data processing and analytics.", "keywords": ["azure", "iot", "edge", "container", "deployment"], "source_lectures": ["lecture_106104449_w2_l9"]}}
{"id": "concept_iot_edge_runtime", "type": "V_concept", "name": "IoT Edge Runtime", "properties": {"description": "Software managing module deployment, security, and communication on edge devices within Azure IoT Edge.", "keywords": ["iot", "edge", "runtime", "modules", "management"], "source_lectures": ["lecture_106104449_w2_l9"]}}
{"id": "concept_digital_twin", "type": "V_concept", "name": "Digital Twin", "properties": {"description": "A virtual representation of a physical entity that simulates real-time behavior using data from IoT devices and business systems.", "keywords": ["digital", "twin", "simulation", "virtual", "realtime"], "source_lectures": ["lecture_106104449_w2_l9"]}}
{"id": "concept_module_twins", "type": "V_concept", "name": "Module Twins", "properties": {"description": "JSON documents storing configuration and state information for modules in Azure IoT Edge deployments.", "keywords": ["module", "twins", "configuration", "json", "state"], "source_lectures": ["lecture_106104449_w2_l9"]}}
{"id": "concept_hot_path_processing", "type": "V_concept", "name": "Hot Path Processing", "properties": {"description": "Real-time data analysis with minimal latency, typically using stream processing engines for immediate insights.", "keywords": ["hot", "path", "realtime", "stream", "latency"], "source_lectures": ["lecture_106104449_w2_l9"]}}
{"id": "concept_cold_path_processing", "type": "V_concept", "name": "Cold Path Processing", "properties": {"description": "Batch-oriented data analysis performed at intervals over large stored datasets, prioritizing volume over speed.", "keywords": ["cold", "path", "batch", "storage", "analysis"], "source_lectures": ["lecture_106104449_w2_l9"]}}
{"id": "concept_machine_learning_model_life_cycle", "type": "V_concept", "name": "Machine Learning Model Life Cycle", "properties": {"description": "The iterative process encompassing data preparation, model training, deployment, and monitoring for AI systems.", "keywords": ["machine", "learning", "lifecycle", "training", "deployment"], "source_lectures": ["lecture_106104449_w2_l9"]}}
{"id": "concept_edge_computing_low_latency", "type": "V_concept", "name": "Edge Computing Low Latency", "properties": {"description": "The principle that processing data near its source reduces delay, enabling real-time decision-making.", "keywords": ["edge", "latency", "realtime", "processing", "response"], "source_lectures": ["lecture_106104449_w2_l9"]}}
{"id": "concept_data_reduction_principle", "type": "V_concept", "name": "Data Reduction Principle", "properties": {"description": "The concept that edge computing minimizes data transfer to the cloud by filtering and aggregating information locally.", "keywords": ["data", "reduction", "bandwidth", "filtering", "edge"], "source_lectures": ["lecture_106104449_w2_l9"]}}
{"id": "concept_iot_device_registry", "type": "V_concept", "name": "IoT Device Registry", "properties": {"description": "A cloud-based repository storing identities, authentication details, and metadata for all connected IoT devices.", "keywords": ["iot", "registry", "devices", "metadata", "authentication"], "source_lectures": ["lecture_106104449_w2_l9"]}}
{"id": "concept_containerized_workloads", "type": "V_concept", "name": "Containerized Workloads", "properties": {"description": "Applications packaged as Docker containers for consistent deployment across edge and cloud environments.", "keywords": ["container", "docker", "workloads", "deployment", "edge"], "source_lectures": ["lecture_106104449_w2_l9"]}}
{"id": "concept_protocol_translation", "type": "V_concept", "name": "Protocol Translation", "properties": {"description": "The technique of converting communication protocols between disparate IoT devices to enable interoperability.", "keywords": ["protocol", "translation", "communication", "iot", "interoperability"], "source_lectures": ["lecture_106104449_w2_l9"]}}
{"id": "concept_offline_edge_functionality", "type": "V_concept", "name": "Offline Edge Functionality", "properties": {"description": "The capability of edge devices to operate and process data without continuous cloud connectivity.", "keywords": ["offline", "edge", "reliability", "operation", "autonomous"], "source_lectures": ["lecture_106104449_w2_l9"]}}
